---
layout: page
title: "Developing Web Applications with Haskell and Yesod"
prev: OEBPS/pt01.html
next: OEBPS/ch01s02.html
book_path: books/michael-snoyman-developing-web-applications-with-haskell-and-yesod-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="calibre8"></div><div class="book" title="Chapter 1. Introduction"><div class="book"><div class="book"><div class="book"><div class="calibre8"></div><h1 class="title1"><a id="I_chapter1_d1e308" class="calibre1"></a>Chapter 1. Introduction</h1></div></div></div><p class="calibre7">Since web programming began, people have been trying to make the development process a more
    pleasant one. As a community, we have continually pushed new techniques to try and solve some of
    the lingering difficulties of security threats, the stateless nature of HTTP, the multiple
    languages (HTML, CSS, JavaScript) necessary to create a powerful web application, and
    more.</p><p class="calibre7">Yesod attempts to ease the web development process by playing to the strengths of the
    Haskell programming language. Haskell’s strong compile-time guarantees of correctness not
    only encompass types; referential transparency ensures that we don’t have any unintended
    side effects. Pattern matching on algebraic data types can help guarantee we’ve accounted
    for every possible case. By building upon Haskell, entire classes of bugs disappear.</p><p class="calibre7">Unfortunately, using Haskell isn’t enough. The Web, by its very nature, is
      <span class="firstname"><em class="calibre4">not</em></span> type safe. Even the simplest case of distinguishing between an
    integer and string is impossible: all data on the Web is transferred as raw bytes, evading our
    best efforts at type safety. Every app writer is left with the task of validating all input. I
    call this problem <em class="calibre4">the boundary issue</em>: as much as your application is type
    safe on the inside, every boundary with the outside world still needs to be sanitized.</p><div class="book" title="Type Safety"><div class="book"><div class="book"><div class="book"><h1 class="title2"><a id="I_sect11_d1e325" class="calibre1"></a>Type Safety</h1></div></div></div><p class="calibre7">This is where Yesod comes in. By using high-level declarative techniques, you can specify the exact input types you are expecting. And the process works the other way as well: using a process of type-safe URLs, you can make sure that the data you send out is also guaranteed to be well formed.</p><p class="calibre7">The boundary issue is not just a problem when dealing with the client: the same problem exists when persisting and loading data. Once again, Yesod saves you on the boundary by performing the marshaling of data for you. You can specify your entities in a high-level definition and remain blissfully ignorant of the details.</p></div></div></div>

{% endraw %}

