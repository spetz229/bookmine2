---
layout: page
title: "Developing Web Applications with Haskell and Yesod"
prev: OEBPS/ch03s07.html
next: OEBPS/ch03s09.html
book_path: books/michael-snoyman-developing-web-applications-with-haskell-and-yesod-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<div class="book" title="Development Server"><div class="book"><div class="book"><div class="book"><h1 class="title2"><a id="I_sect13_d1e1158" class="calibre1"></a>Development Server</h1></div></div></div><p class="calibre7">One of the advantages interpreted languages have over compiled languages is fast
            prototyping: you save changes to a file and hit refresh. If we want to make any changes
            to our Yesod apps above, we’ll need to call <em class="calibre4">runhaskell</em> from scratch, which can be a bit tedious.</p><p class="calibre7">Fortunately, there’s a solution to this: <code class="literal">yesod devel</code>
            automatically rebuilds and reloads your code for you. This can be a great way to develop
            your Yesod projects, and when you’re ready to move to production, you still get to
            compile down to incredibly efficient code. The Yesod scaffolding automatically sets
            things up for you. This gives you the best of both worlds: rapid prototyping <span class="bold"><strong class="bold">and</strong></span> fast production code.</p><p class="calibre7">It’s a little bit more involved to set up your code to be used by <em class="calibre4">yesod devel</em>, so our examples will just use <code class="literal">warpDebug</code>. But when you’re ready to make your real world information, <em class="calibre4">yesod devel</em> will be waiting for you.</p></div></div>

{% endraw %}

