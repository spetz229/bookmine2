---
layout: page
title: "Clojure Programming"
prev: None
next: None
book_path: books/clojure-programming-chas-emerick_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<p id="filepos109" class="calibre1"><span class="calibre2"><span class="bold">Clojure Programming</span></span></p><p class="calibre3"><span class="calibre4"><span class="bold"><span class="calibre5">Chas Emerick</span></span></span></p><p class="calibre3"><span class="calibre4"><span class="bold"><span class="calibre5">Brian Carper</span></span></span></p><p class="calibre3"><span class="calibre4"><span class="bold"><span class="calibre5">Christophe Grand</span></span></span></p><p class="calibre6"><span class="bold"><span class="calibre7">Editor</span></span></p><p class="calibre8">Mike Loukides</p><p class="calibre6"><span class="bold"><span class="calibre7">Editor</span></span></p><p class="calibre8">Julie Steele</p><p class="calibre6">Copyright © 2012 Chas Emerick, Brian Carper and Christophe Grand, Chas Emerick and Dave Fayram</p><p class="calibre6"></p><p class="calibre9"><span class="calibre10">O’Reilly books may be purchased for educational, business, or sales promotional use. Online editions are also available for most titles (</span><a href="http://my.safaribooksonline.com/?portal=oreilly"><span class="calibre10"><span class="calibre5">http://my.safaribooksonline.com</span></span></a><span class="calibre10">). For more information, contact our corporate/institutional sales department: (800) 998-9938 or </span><a href="mailto:corporate@oreilly.com"><span class="calibre10"><span class="calibre5">corporate@oreilly.com</span></span></a><span class="calibre10">.</span></p><p class="calibre9"></p><p class="calibre9"><span class="calibre10">Nutshell Handbook, the Nutshell Handbook logo, and the O’Reilly logo are registered trademarks of O’Reilly Media, Inc. </span><span class="calibre10"><span class="italic">Clojure Programming</span></span><span class="calibre10">, the image of a painted snipe, and related trade dress are trademarks of O’Reilly Media, Inc.</span></p><p class="calibre9"><span class="calibre10">Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks. Where those designations appear in this book, and O’Reilly Media, Inc., was aware of a trademark claim, the designations have been printed in caps or initial caps.</span></p><p class="calibre9"></p><p class="calibre9"><span class="calibre10">While every precaution has been taken in the preparation of this book, the publisher and authors assume no responsibility for errors or omissions, or for damages resulting from the use of the information contained herein.</span></p><p class="calibre9"></p><p class="calibre9"></p><p class="calibre9"><img src="images/00009.jpg" class="calibre11"/></p><p class="calibre9">O'Reilly Media</p><hr class="calibre12"/><div class="mbppagebreak"></div><p id="filepos2808" class="calibre6"><span class="calibre2"><span class="bold">Preface</span></span></p><p class="calibre13">Clojure is a dynamically and strongly typed programming language hosted on the Java Virtual Machine (JVM), now in its fifth year. It has seen enthusiastic adoption by programmers from a variety of backgrounds, working in essentially all problem domains. Clojure offers a compelling mix of features and characteristics applicable to solving modern programming challenges:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Functional programming foundations, including a suite of persistent data structures with performance characteristics approaching typical mutable data structures</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">A mature, efficient runtime environment, as provided by the host JVM</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">JVM/Java interoperability capabilities suited for a wide variety of architectural and operational requirements</blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17">A set of mechanisms providing reliable concurrency and parallelism semantics</blockquote></li><li value="5" class="calibre16"><blockquote class="calibre17">A Lisp pedigree, thereby providing remarkably flexible and powerful metaprogramming facilities</blockquote></li></ul><p class="calibre18">Clojure offers a compelling practical alternative to many who strain against the limitations of typical programming languages and environments. We aim to demonstrate this by showing Clojure seamlessly interoperating with existing technologies, libraries, and services that many working programmers already use on a day-to-day basis. Throughout, we’ll provide a solid grounding in Clojure fundamentals, starting from places of common expertise and familiarity rather than from (often foreign) computer science first principles.</p><div class="mbppagebreak"></div><p id="filepos4892" class="calibre6"><span class="calibre4"><span class="bold">Who Is This Book For?</span></span></p><p class="calibre18">We wrote this book with a couple of audiences in mind. Hopefully, you consider yourself a part of one of them.</p><p class="calibre18">Clojure matches and often exceeds your current favorite language’s expressivity, concision, and flexibility while allowing you to effortlessly leverage the performance, libraries, community, and operational stability of the JVM. This makes it a natural next step for Java developers (and even JVM developers using interpreted or otherwise not particularly fast non-Java languages), who simply will not accept a performance hit or who do not want to give up their JVM platform investment. Clojure is also a natural step for Ruby and Python developers who refuse to compromise on language expressivity, but wish they had a more reliable, efficient execution platform and a larger selection of quality libraries.</p><p id="filepos5859" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Engaged Java Developers</span></span></span></p><p class="calibre18">There are millions of Java developers in the world, but some fewer number are working in demanding environments solving nontrivial, often domain-specific problems. If this describes you, you’re probably always on the hunt for better tools, techniques, and practices that will boost your productivity and value to your team, organization, and community. In addition, you’re probably at least somewhat frustrated with the constraints of Java compared to other languages, but you continue to find the JVM ecosystem compelling: its process maturity, massive third-party library selection, vendor support, and large skilled workforce is hard to walk away from, no matter how shiny and appealing alternative languages are.</p><p class="calibre18">You’ll find Clojure to be a welcome relief. It runs on the JVM with excellent performance characteristics, interoperates with all of your existing libraries, tools, and applications, and is <span class="italic">simpler</span> than Java, yet is demonstrably more expressive and less verbose.</p><p id="filepos7027" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Ruby, Python, and Other Developers</span></span></span></p><p class="calibre18">Ruby and Python are not new languages by any means, but they have garnered significant (dare we say, “mainstream”?) traction over recent years. It’s not hard to see why: both are expressive, dynamic languages that, along with their thriving communities, encourage maximal developer productivity in many domains.</p><p class="calibre18">Clojure is a natural next step for you. As a Ruby or Python programmer, you’re probably unwilling to compromise on their strengths, but you may wish for a more capable execution platform, better runtime performance, and a larger selection of libraries. The fact that Clojure is efficiently hosted on the JVM fulfills those desires—and it matches or exceeds the degrees of language sophistication and developer productivity that you’ve come to expect.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">We will frequently compare and contrast Clojure with Java, Ruby, and Python to help you translate your existing expertise to Clojure. In such comparisons, we will always refer to the canonical implementations of these other languages:</span></blockquote><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17"><span class="calibre10">Ruby MRI (also called CRuby)</span></blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17"><span class="calibre10">CPython</span></blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17"><span class="calibre10">Java 6/7</span></blockquote></li></ul><div class="mbppagebreak"></div><p id="filepos8871" class="calibre6"><span class="calibre4"><span class="bold">How to Read This Book</span></span></p><p class="calibre18">In formulating our approach to this book, we wanted to provide a fair bit of concrete detail and practical examples that you could relate to, but stay clear of what we thought were generally unsuccessful approaches for doing so. In particular, we’ve been frustrated in the past by books that attempted to thread the implementation of a single program or application through their pages. Such approaches seem to result in a disjointed narrative, as well as the dominance of a tortured “practical” example that may or may not apply or appeal to readers.</p><p class="calibre18">With that in mind, we split the book in two, starting with foundational, instructional narrative that occupies roughly two-thirds of the book, followed in <a href="#filepos1527345"><span class="calibre5">Part IV</span></a> by a number of discrete, practical examples from real-world domains. This clear segmentation of content with decidedly distinct objectives may qualify this book as a “duplex book.” (This term may have been coined by Martin Fowler in <a href="http://martinfowler.com/bliki/DuplexBook.html"><span class="calibre5">http://martinfowler.com/bliki/DuplexBook.html</span></a>.) In any case, we can conceive of two obvious approaches to reading it.</p><p id="filepos10236" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Start with Practical Applications of Clojure</span></span></span></p><p class="calibre18">Often the best way to learn is to dig straight into the nitty-gritty of how a language is used in the real world. If that sounds appealing, the hope is that you will find that at least a couple of the practicums resonate with what you do on a day-to-day basis, so that you can readily draw parallels between how you solve certain categories of problems in your current language(s) and how they may be solved using Clojure. You’re going to bump into a lot of potentially foreign concepts and language constructs in those chapters—when you do, use that context within the domain in question as your entry point for understanding those concepts using the relevant instructional material in the first part of the book.</p><p id="filepos11120" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Start from the Ground Up with Clojure’s Foundational Concepts</span></span></span></p><p class="calibre18">Sometimes the only way to truly understand something is to learn it inside-out, starting with the fundamentals. If you prefer that approach, then you will likely find that digesting this book starting from the first page of <a href="#filepos28661"><span class="calibre5">Chapter 1</span></a> will be best. We have attempted to provide a comprehensive treatment of all of Clojure’s foundational principles and constructs in a narrative that progresses such that it will be <span class="italic">very</span> rare for you to need to look ahead in the book to understand concepts in earlier sections. As you begin to get a handle on Clojure’s fundamentals, feel free to jump ahead into the practicums you find most interesting and relevant to your work.</p><div class="mbppagebreak"></div><p id="filepos12050" class="calibre6"><span class="calibre4"><span class="bold">Who’s “We”?</span></span></p><p class="calibre18">We are three software developers who have each taken different paths in coming to use and appreciate Clojure. In writing this book, we have attempted to distill all that we’ve learned about why and how you should use Clojure so that you can be successful in your use of it as well.</p><p id="filepos12443" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Chas Emerick</span></span></span></p><p class="calibre18">Chas has been a consistent presence in the Clojure community since early 2008. He has made contributions to the core language, been involved in dozens of Clojure open source projects, and frequently writes and speaks about Clojure and software development generally.</p><p class="calibre18">Chas maintains the Clojure Atlas (<a href="http://clojureatlas.com"><span class="calibre5">http://clojureatlas.com</span></a>), an interactive visualization of and learning aid for the Clojure language and its standard libraries.</p><p class="calibre18">The founder of Snowtide (<a href="http://snowtide.com"><span class="calibre5">http://snowtide.com</span></a>), a small software company in Western Massachusetts, Chas’s primary domain is unstructured data extraction, with a particular specialty around PDF documents. He writes about Clojure, software development, entrepreneurship, and other passions at <a href="http://cemerick.com"><span class="calibre5">http://cemerick.com</span></a>.</p><p id="filepos13573" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Brian Carper</span></span></span></p><p class="calibre18">Brian is a Ruby programmer turned Clojure devotee. He’s been programming Clojure since 2008, using it at home and at work for everything from web development to data analysis to GUI apps.</p><p class="calibre18">Brian is the author of Gaka (<a href="https://github.com/briancarper/gaka"><span class="calibre5">https://github.com/briancarper/gaka</span></a>), a Clojure-to-CSS compiler, and Oyako (<a href="https://github.com/briancarper/oyako"><span class="calibre5">https://github.com/briancarper/oyako</span></a>), an Object-Relational Mapping library. He writes about Clojure and other topics at <a href="http://briancarper.net"><span class="calibre5">http://briancarper.net</span></a>.</p><p id="filepos14402" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Christophe Grand</span></span></span></p><p class="calibre18">Christophe was a long-time enthusiast of functional programming lost in Java-land when he encountered Clojure in early 2008, and it was love at first sight! He authored Enlive (<a href="http://github.com/cgrand/enlive"><span class="calibre5">http://github.com/cgrand/enlive</span></a>), an HTML/XML transformation, extraction, and templating library; Parsley (<a href="http://github.com/cgrand/parsley"><span class="calibre5">http://github.com/cgrand/parsley</span></a>), an incremental parser generator; and Moustache (<a href="http://github.com/cgrand/moustache"><span class="calibre5">http://github.com/cgrand/moustache</span></a>), a routing and middleware application DSL for Ring.</p><p class="calibre18">As an independent consultant, he develops, coaches, and offers training in Clojure. He also writes about Clojure at <a href="http://clj-me.cgrand.net"><span class="calibre5">http://clj-me.cgrand.net</span></a>.</p><div class="mbppagebreak"></div><p id="filepos15480" class="calibre6"><span class="calibre4"><span class="bold">Acknowledgments</span></span></p><p class="calibre18">Like any sizable piece of work, this book would not exist without the tireless efforts of dozens, probably hundreds of people.</p><p class="calibre18">First, Rich Hickey, the creator of Clojure. In just a few short years, he has designed, implemented, and shepherded a new programming language into the world that, for so many, has been not just another tool, but a reinvigoration of our love of programming. Beyond that, he’s personally taught us a great deal—certainly about programming, but also about patience, humility, and perspective. Thanks, Rich.</p><p class="calibre18">Dave Fayram and Mike Loukides were essential in helping to formulate the initial concept and approach of the book. Of course, you likely wouldn’t be reading this book right now if it weren’t for Julie Steele, our editor, and all of the fine people at O’Reilly who took care of the logistics and minutiae that go along with publishing.</p><p class="calibre18">The quality of this book would be far less than it is were it not for the efforts of our technical reviewers, including Sam Aaron, Antoni Batchelli, Tom Faulhaber, Chris Granger, Anthony Grimes, Phil Hagelberg, Tom Hicks, Alex Miller, William Morgan, Laurent Petit, and Dean Wampler. We’d also like to thank all of those who provided feedback and comments on the early releases and Rough Cuts of the book, both on the O’Reilly forums and via email, Twitter, and so on.</p><p class="calibre18">Michael Fogus and Chris Houser have inspired us in many ways large and small. One of the smaller ways was the style and presentation of the REPL interactions in their Clojure book, <span class="italic">The Joy of Clojure</span>, which we shamelessly copied and iterated.</p><p class="calibre18">If we’ve neglected to mention anyone, please accept our implicit thanks and our apologies; at the end of this endeavor, we are quite lucky to be upright and coherent at all!</p><p id="filepos17518" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">And Last, but Certainly Far from Least</span></span></span></p><p class="calibre18">The Clojure community has been my home away from home for a number of years. The hospitality and positive, helpful energy I see anywhere Clojure programmers congregate continues to be an inspiration and example to me. In particular, many of the regular denizens of <tt class="calibre22">#clojure</tt> on Freenode IRC—in addition to becoming good friends—have guided me toward learning things I never would have otherwise.</p><p class="calibre18">To my coauthors, Christophe and Brian: working with you has been a great honor for me. There is absolutely no way that I would have been able to complete this work without you.</p><p class="calibre18">To my parents, Charley and Darleen: my compulsive curiosity about how things work, my love of language and rhetoric, and my interest in business—all of these can be traced back over the years to your consistent influence. Without it, I am certain I would not have found my unique path, started a software company, or written this book, each done against all odds.</p><p class="calibre18">Finally, to my wife, Krissy: the sacrifices you’ve made to enable me to chase my ambitions are legion. It is likely that I’ll never be able to thank you sufficiently. So, I’ll just say: I love you.</p><p class="calibre18"><span class="italic">—Chas Emerick, February 2012</span></p><p class="calibre18">To everyone in the community who helped create Clojure: thank you for your tireless hard work, for making my professional and personal coding life so much more enjoyable, and for opening my eyes to what’s possible.</p><p class="calibre18">To my coauthors, Christophe and Chas: I’ve never worked with a smarter group of people. It’s been an honor and a privilege.</p><p class="calibre18">To my wife Nicole: sorry I kept you awake all night with my typing.</p><p class="calibre18"><span class="italic">—Brian Carper, February 2012</span></p><p class="calibre18">To Rich Hickey for creating Clojure and fostering such a friendly community.</p><p class="calibre18">To this community for having brought me to higher standards.</p><p class="calibre18">To my coauthors, Brian and Chas: it has been a great honor to work with you.</p><p class="calibre18">A mon professeur Daniel Goffinet, et à ses exercices improbables, qui a radicalement changé mon approche de la programmation et de l’informatique—sur ces sujets je lui suis plus redevable qu’à nul autre.</p><p class="calibre18">(To Pr. Daniel Goffinet, and his meta mind twisters, who radically altered the way I think about programming and computing—on those subjects there is no one I’m more indebted to.)</p><p class="calibre18">A mes parents pour votre amour bien sûr mais aussi pour tout le temps à s’inquiéter que je passais trop de temps sur l’Amstrad.</p><p class="calibre18">(To my parents: for your love obviously and for buying me that 8-bit computer you worried I was spending too much time on.)</p><p class="calibre18">A ma compagne Emilie, et mon fils Gaël, merci d’être là et de m’avoir supporté pendant l’écriture de ce livre.</p><p class="calibre18">(To my wife Emilie and to my son Gaël: thank you for being there and having supported me throughout the writing of this book.)</p><p class="calibre18"><span class="italic">—Christophe Grand, February 2012</span></p><div class="mbppagebreak"></div><p id="filepos21058" class="calibre6"><span class="calibre4"><span class="bold">Conventions Used in This Book</span></span></p><p class="calibre18">The following typographical conventions are used in this book:</p><p class="calibre23"><span class="italic">Italic</span></p><blockquote class="calibre17">Indicates new terms, URLs, email addresses, filenames, and file extensions.</blockquote><p class="calibre23"><tt class="calibre22">Constant width</tt></p><blockquote class="calibre17">Used for program listings, as well as within paragraphs to refer to program elements such as variable or function names, databases, data types, environment variables, statements, and keywords.</blockquote><p class="calibre23"><tt class="calibre22">; listing lines prefixed with a semicolon</tt></p><blockquote class="calibre17">Used to indicate content <span class="italic">printed</span> (i.e., to standard out/err) by code evaluated in the REPL.</blockquote><p class="calibre23"><tt class="calibre22">;= listing lines prefixed with a semicolon + equal sign</tt></p><blockquote class="calibre17">Used to indicate the <span class="italic">result/return value</span> of a REPL evaluation.</blockquote><p class="calibre23"><tt class="calibre22"><span class="bold">Constant width bold</span></tt></p><blockquote class="calibre17">Shows commands or other text that should be typed literally by the user.</blockquote><p class="calibre23"><tt class="calibre22"><span class="italic">Constant width italic</span></tt></p><blockquote class="calibre17">Shows text that should be replaced with user-supplied values or by values determined by context.</blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">This icon signifies a tip, suggestion, or general note.</span></blockquote><blockquote class="calibre24"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">This icon indicates a warning or caution.</span></blockquote><div class="mbppagebreak"></div><p id="filepos23066" class="calibre6"><span class="calibre4"><span class="bold">Using Code Examples</span></span></p><p class="calibre18">This book is here to help you get your job done. In general, you may use the code in this book in your programs and documentation. You do not need to contact us for permission unless you’re reproducing a significant portion of the code. For example, writing a program that uses several chunks of code from this book does not require permission. Selling or distributing a CD-ROM of examples from O’Reilly books does require permission. Answering a question by citing this book and quoting example code does not require permission. Incorporating a significant amount of example code from this book into your product’s documentation does require permission.</p><p class="calibre18">We appreciate, but do not require, attribution. An attribution usually includes the title, author, publisher, and ISBN. For example: “<span class="italic">Clojure Programming</span> by Chas Emerick, Brian Carper, and Christophe Grand (O’Reilly). Copyright 2012 Chas Emerick, Brian Carper, and Christophe Grand, 978-1-449-39470-7.”</p><p class="calibre18">If you feel your use of code examples falls outside fair use or the permission given above, feel free to contact us at <a href="mailto:permissions@oreilly.com"><span class="calibre5">permissions@oreilly.com</span></a>.</p><div class="mbppagebreak"></div><p id="filepos24450" class="calibre6"><span class="calibre4"><span class="bold">Safari® Books Online</span></span></p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Safari Books Online is an on-demand digital library that lets you easily search over 7,500 technology and creative reference books and videos to find the answers you need quickly.</span></blockquote><p class="calibre25">With a subscription, you can read any page and watch any video from our library online. Read books on your cell phone and mobile devices. Access new titles before they are available for print, and get exclusive access to manuscripts in development and post feedback for the authors. Copy and paste code samples, organize your favorites, download chapters, bookmark key sections, create notes, print out pages, and benefit from tons of other time-saving features.</p><p class="calibre18">O’Reilly Media has uploaded this book to the Safari Books Online service. To have full digital access to this book and others on similar topics from O’Reilly and other publishers, sign up for free at <a href="http://my.safaribooksonline.com/?portal=oreilly"><span class="calibre5">http://my.safaribooksonline.com</span></a>.<a id="filepos25757"></a></p><div class="mbppagebreak"></div><p id="filepos25784" class="calibre6"><span class="calibre4"><span class="bold">How to Contact Us</span></span></p><p class="calibre18">Please address comments and questions concerning this book to the publisher:</p><table border="1" valign="top" class="calibre26"><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre10"> O’Reilly Media, Inc. </span></td></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre10"> 1005 Gravenstein Highway North </span></td></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre10"> Sebastopol, CA 95472 </span></td></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre10"> 800-998-9938 (in the United States or Canada) </span></td></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre10"> 707-829-0515 (international or local) </span></td></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre10"> 707-829-0104 (fax) </span></td></tr></table><p class="calibre23">We have a web page for this book, where we list errata, examples, and any additional information. You can access this page at:</p><table border="1" valign="top" class="calibre26"><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre10"> </span><a href="http://shop.oreilly.com/product/0636920013754.do"><span class="calibre10"><span class="calibre5">http://shop.oreilly.com/product/0636920013754.do </span></span></a></td></tr></table><p class="calibre23">To comment or ask technical questions about this book, send email to:</p><table border="1" valign="top" class="calibre26"><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre10">  </span><a href="mailto:bookquestions@oreilly.com"><span class="calibre10"><span class="calibre5">bookquestions@oreilly.com</span></span></a></td></tr></table><p class="calibre23">For more information about our books, courses, conferences, and news, see our website at <a href="http://www.oreilly.com"><span class="calibre5">http://www.oreilly.com</span></a>.</p><p class="calibre18">Find us on Facebook: <a href="http://facebook.com/oreilly"><span class="calibre5">http://facebook.com/oreilly</span></a></p><p class="calibre18">Follow us on Twitter: <a href="http://twitter.com/oreillymedia"><span class="calibre5">http://twitter.com/oreillymedia</span></a></p><p class="calibre18">Watch us on YouTube: <a href="http://www.youtube.com/oreillymedia"><span class="calibre5">http://www.youtube.com/oreillymedia</span></a></p><div class="mbppagebreak"></div><p id="filepos28661" class="calibre6"><span class="calibre2"><span class="bold">Chapter 1. Down the Rabbit Hole</span></span></p><p id="filepos28755" class="calibre13">If you’re reading this book, you are presumably open to learning new programming languages. On the other hand, we assume that you expect reciprocity for the time and effort you’ll expend to learn a new language, some tangible benefits that can make you more productive, your team more effective, and your organization more flexible.</p><p class="calibre18">We believe that you will find this virtuous cycle in effect as you learn, apply, and leverage Clojure. As we are fond of saying, <span class="italic">Clojure demands that you raise your game, and pays you back for doing so</span>.</p><p class="calibre18">As software developers, we often build up a complex and sometimes very personal relationship with our tools and languages. Deciding which raw materials to use is sometimes dominated by pragmatic and legacy concerns. However, all other things being equal, programmers prefer using whatever maximally enhances their productivity and hopefully enables us to fulfill our potential to build useful, elegant systems. As the old saying goes, we want whatever makes the easy stuff easy, and the hard stuff possible.</p><p id="filepos29903" class="calibre6"><span class="calibre4"><span class="bold">Why Clojure?</span></span></p><p id="filepos29976" class="calibre18">Clojure is a programming language that lives up to that standard. Forged of a unique blend of the best features of a number of different programming languages—including various Lisp implementations, Ruby, Python, Java, Haskell, and others—Clojure provides a set of capabilities suited to address many of the most frustrating problems programmers struggle with today and those we can see barreling toward us over the horizon. And, far from requiring a sea-change to a new or unfamiliar architecture and runtime (typical of many otherwise promising languages over the years), Clojure is hosted on the Java Virtual Machine, a fact that puts to bed many of the most pressing pragmatic and legacy concerns raised when a new language is considered.</p><p class="calibre18">To whet your appetite, let’s enumerate some of Clojure’s marquee features and characteristics:</p><p class="calibre23">Clojure is hosted on the JVM</p><blockquote id="filepos30944" class="calibre17">Clojure code can use any Java library, Clojure libraries can in turn be used from Java, and Clojure applications can be packaged just like any Java application and deployed anywhere other Java applications can be deployed: to web application servers; to desktops with Swing, SWT, or command-line interfaces; and so on. This also means that Clojure’s runtime is Java’s runtime, one of the most efficient and operationally reliable in the world.</blockquote><p class="calibre23">Clojure is a Lisp</p><blockquote id="filepos31490" class="calibre17">Unlike Java, Python, Ruby, C++, and other members of the Algol family of programming languages, Clojure is part of the Lisp family. However, forget everything you know (or might have heard rumored) about Lisps: Clojure retains the best of Lisp heritage, but is unburdened by the shortcomings and sometimes anachronistic aspects of many other Lisp implementations. Also, being a Lisp, Clojure has <span class="italic">macros</span>, an approach to metaprogramming and syntactic extension that has been the benchmark against which other such systems have been measured for decades.</blockquote><p class="calibre23">Clojure is a functional programming language</p><blockquote class="calibre17">Clojure encourages the use of first-class and higher-order functions with values and comes with its own set of efficient immutable data structures. The focus on a strong flavor of functional programming encourages the elimination of common bugs and faults due to the use of unconstrained mutable state and enables Clojure’s solutions for concurrency and parallelization.</blockquote><p class="calibre23">Clojure offers innovative solutions to the challenges inherent in concurrency and parallelization</p><blockquote id="filepos32725" class="calibre17">The realities of multicore, multi-CPU, and distributed computing demand that we use languages and libraries that have been designed with these contexts in mind. Clojure’s <span class="italic">reference types</span><a id="filepos32957"></a> enforce a clean separation of <span class="italic">state</span><a id="filepos33007"></a> and <span class="italic">identity</span><a id="filepos33034"></a>, providing defined concurrency semantics that are to manual locking and threading strategies what garbage collection is to manual memory management.</blockquote><p class="calibre23">Clojure is a dynamic programming language</p><blockquote id="filepos33276" class="calibre17">Clojure is dynamically and strongly typed (and therefore similar to Python and Ruby), yet function calls are compiled down to (fast!) Java method invocations. Clojure is also dynamic in the sense that it deeply supports updating and loading new code at runtime, either locally or remotely. This is particularly useful for enabling interactive development and debugging or even instrumenting and patching remote applications without downtime.</blockquote><p class="calibre18">Of course, we don’t expect you to understand all of that, but we do hope the gestalt sounds compelling. If so, press on. By the end of this chapter, you’ll be able to write simple programs in Clojure, and be well on your way to understanding and leveraging it to help realize your potential.</p><div class="mbppagebreak"></div><p id="filepos34110" class="calibre6"><span class="calibre4"><span class="bold">Obtaining Clojure</span></span></p><p id="filepos34188" class="calibre18">You’ll need two things to work with the code in this chapter and otherwise explore Clojure on your own:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">The Java runtime. You can download the Oracle JVM for free for Windows and Linux (<a href="http://java.com/en/download/"><span class="calibre5">http://java.com/en/download/</span></a>); it is bundled with or automatically installed by all versions of Mac OS X. Clojure requires Java v1.5 or higher; the latest releases of v1.6 or v1.7 are preferable.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Clojure itself, available from clojure.org (<a href="http://clojure.org/downloads"><span class="calibre5">http://clojure.org/downloads</span></a>). <span class="italic">All of the code in this book requires v1.3.0 or higher, and has been tested against v1.4.0 as well.<sup class="calibre30"><small class="calibre31"><span class="calibre32"><span class="italic">[</span></span><a id="filepos35175"></a><a href="#filepos37149"><span class="calibre32"><span class="italic">1</span></span></a><span class="calibre32"><span class="italic">]</span></span></small></sup></span> Within the zip file you download, you’ll find a file named something like <span class="italic">clojure-1.4.0.jar</span>; this is all you’ll need to get started.</blockquote></li></ol><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">There are a number of different Clojure plug-ins for popular development environments like Eclipse and Emacs; see </span><a id="filepos35751"></a><a href="#filepos1458065"><span class="calibre10"><span class="calibre5">Tooling</span></span></a><span class="calibre10"> for an overview of Clojure tooling. While Clojure’s command-line REPL is sufficient for your first few steps in understanding Clojure, we encourage you to use your favorite text editor or IDE if it has quality Clojure support, or to pick up one that does.</span></blockquote><blockquote class="calibre17"><span class="calibre10">If you don’t yet want to commit to a particular editor or IDE for Clojure development, you should at least use Leiningen, the most popular project management tool for Clojure. It will download Clojure for you, give you a better REPL than Clojure’s default, and you’ll likely be using it on a daily basis for your own projects in short order anyway. See </span><a href="#filepos1238499"><span class="calibre10"><span class="calibre5">Leiningen</span></span></a><span class="calibre10"> for an introduction to it.</span></blockquote><blockquote class="calibre17"><span class="calibre10">If you want to avoid downloading anything right now, you can run many of the samples in this book in the online, in-browser Clojure implementation available at </span><a href="http://tryclj.com"><span class="calibre10"><span class="calibre5">http://tryclj.com</span></span></a><span class="calibre10">.</span></blockquote><br class="calibre33"/><hr class="calibre34"/><p class="calibre25"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos37149"></a><a href="#filepos35175"><span class="calibre32">1</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Given Clojure’s history with regard to backwards compatibility, the code and concepts in this book should remain applicable to future versions of Clojure as well.</span></p><div class="mbppagebreak"></div><p id="filepos37449" class="calibre6"><span class="calibre4"><span class="bold">The Clojure REPL</span></span></p><p id="filepos37526" class="calibre18">Many languages have REPLs, often also referred to as interpreters: Ruby has <tt class="calibre22">irb</tt>; Python has its command-line interpreter; Groovy has its console; even Java has something akin to a REPL in BeanShell. The “REPL” acronym is derived from a simple description of what it does:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">Read: code is read as text from some input (often <tt class="calibre22">stdin</tt>, but this varies if you’re using a REPL in an IDE or other nonconsole environment).</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Eval: the code is evaluated, yielding some value.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Print: the value is printed to some output device (often <tt class="calibre22">stdout</tt>, sometimes preceded by other output if the code in question happened to print content itself).</blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17">Loop: control returns to the <span class="italic">read</span> step.</blockquote></li></ol><p class="calibre18">Clojure has a REPL too, but it differs from many other languages’ REPLs in that it is not an interpreter or otherwise using a limited or lightweight subset of Clojure: all code entered into a Clojure REPL is <span class="italic">compiled</span> to JVM bytecode as part of its evaluation, with the same result as when code is loaded from a Clojure source file. In these two scenarios, compilation <a id="filepos39080"></a>is performed entirely at runtime, and requires no separate “compile” step.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos39200"></a><a href="#filepos47339"><span class="calibre32">2</span></a><span class="calibre32">]</span></small></sup> In fact, Clojure is <span class="italic">never</span> interpreted. This has a couple of implications:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">Operations performed in the REPL run at “full speed”; that is to say, there is no runtime penalty or difference in semantics associated with running code in the REPL versus running the same code as part of a “proper” application.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17"><span class="italic">Once you understand how Clojure’s REPL works (in particular, its read and eval phases), you’ll understand how Clojure itself works at the most fundamental level.</span></blockquote></li></ol><p class="calibre18">With this second point in mind, let’s dig into the Clojure REPL and see if we can find bedrock.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">The optimal workflow for programming in Clojure makes much more use of the REPL than is typical in other languages to make the development process as interactive as possible. Taking advantage of this is a significant source of the enhanced productivity—and really, fun!—that Clojure enables. We talk about this extensively in </span><a href="#filepos1437663"><span class="calibre10"><span class="calibre5">Chapter 10</span></span></a><span class="calibre10">.</span></blockquote><p id="filepos40787" class="calibre25"></p><p class="calibre23"><span class="italic">Example 1-1. Starting a Clojure REPL on the command line</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">% java -cp clojure-1.4.0.jar clojure.main<br class="calibre33"/>Clojure 1.4.0<br class="calibre33"/>user=&gt;</tt></span></p><p class="calibre13">This incantation starts a new JVM process, with a <span class="italic">classpath</span><a id="filepos41159"></a> that includes the <span class="italic">clojure.jar</span> file in the current directory, running the <tt class="calibre22">clojure.main</tt> class as its main entry point.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos41334"></a><a href="#filepos47736"><span class="calibre32">3</span></a><span class="calibre32">]</span></small></sup> See <a href="#filepos1168529"><span class="calibre5">A classpath primer</span></a> if you don’t yet know what the classpath is; for now, you can just think of the classpath as the JVM’s analogue to Python’s <tt class="calibre22">PYTHONPATH</tt>, Ruby’s <tt class="calibre22">$:</tt>, and your shell’s <tt class="calibre22">PATH</tt>, the set of files and directories from which the JVM will load classes and resources.</p><p class="calibre18">When you see the <tt class="calibre22">user=&gt;</tt> prompt, the REPL is ready for you to enter some Clojure code. The portion of the Clojure REPL prompt preceding <tt class="calibre22">=&gt;</tt> is the name of the <span class="italic">current namespace</span>. Namespaces are like modules or packages; we discuss them extensively later in this chapter in <a href="#filepos109342"><span class="calibre5">Namespaces</span></a>. Clojure REPL sessions always start in the default <tt class="calibre22">user</tt> namespace.</p><p class="calibre18">Let’s look at some real code, a function that calculates the average <a id="filepos42374"></a>of some numbers in Java, Ruby, and Python:</p><p id="filepos42427" class="calibre23"></p><p class="calibre23"><span class="italic">Example 1-2. Averaging numbers in Java, Ruby, and Python</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">public static double average (double[] numbers) {<br class="calibre33"/>  double sum = 0;<br class="calibre33"/>  for (int i = 0; i &lt; numbers.length; i++) {<br class="calibre33"/>    sum += numbers[i];<br class="calibre33"/>  }<br class="calibre33"/>  return sum / numbers.length;<br class="calibre33"/>}<br class="calibre33"/><br class="calibre33"/>def average (numbers)<br class="calibre33"/>  numbers.inject(:+) / numbers.length<br class="calibre33"/>end<br class="calibre33"/><br class="calibre33"/>def average (numbers):<br class="calibre33"/>    return sum(numbers) / len(numbers)</tt></span></p><p class="calibre13">Here is the Clojure equivalent:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn average                            </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  [numbers]                              </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  (/ (apply + numbers) (count numbers))) </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">defn</tt> defines a new function named <tt class="calibre22">average</tt> in the current namespace.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">The <tt class="calibre22">average</tt> function takes one argument, referred to within its body as <tt class="calibre22">numbers</tt>. Note that there is no type declaration; this function will work equally well when provided with any collection or array of numbers of any type.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">The body of the <tt class="calibre22">average</tt> function, which sums the provided numbers with <tt class="calibre22">(apply + numbers)</tt>,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos44626"></a><a href="#filepos48344"><span class="calibre32">4</span></a><span class="calibre32">]</span></small></sup> divides that sum by the number of numbers provided—obtained with <tt class="calibre22">(count numbers)</tt>—and returns the result of that division operation.</blockquote><p class="calibre18">We can enter that <tt class="calibre22">defn</tt> expression at the REPL, and then call our function with a vector of numbers, which yields the expected result:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">user=&gt; (defn average<br class="calibre33"/>         [numbers]<br class="calibre33"/>         (/ (apply + numbers) (count numbers)))<br class="calibre33"/>#'user/average<br class="calibre33"/>user=&gt; (average [60 80 100 400])<br class="calibre33"/>160</tt></span></blockquote><blockquote class="calibre38"></blockquote><blockquote class="calibre39"><span class="calibre10"><span class="bold">A WORD ABOUT REPL INTERACTION STYLES</span></span></blockquote><blockquote id="filepos45527" class="calibre17"><span class="calibre10">From here on, we will adopt a simple convention for listings that show REPL interactions so you can identify the different types of REPL output. The return value of evaluated expressions will be printed with a </span><span class="calibre10"><tt class="calibre22">;=</tt></span><span class="calibre10"> prefix:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(average [60 80 100 400])<br class="calibre33"/>;= 160</tt></span></blockquote><blockquote class="calibre35"><span class="calibre10">And content that is written to </span><span class="calibre10"><tt class="calibre22">stdout</tt></span><span class="calibre10"> by an expression—aside from what the REPL prints for the expression’s return value—will be shown with a single semicolon prefix:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(println (average [60 80 100 400]))<br class="calibre33"/>; 160<br class="calibre33"/>;= nil</tt></span></blockquote><blockquote class="calibre35"><span class="calibre10">There are the two differently prefixed lines of REPL output because </span><span class="calibre10"><tt class="calibre22">println</tt></span><span class="calibre10"> returns </span><span class="calibre10"><tt class="calibre22">nil</tt></span><span class="calibre10"> after printing the provided value(s) to </span><span class="calibre10"><tt class="calibre22">stdout</tt></span><span class="calibre10">.</span></blockquote><blockquote class="calibre17"><span class="calibre10">Lines prefixed with semicolons are comments in Clojure, so you can copy and paste these interactions into your REPL with relative abandon. We’ll not include the </span><span class="calibre10"><tt class="calibre22">namespace=&gt;</tt></span><span class="calibre10"> prompt in listings, as they are not valid Clojure code and will cause an error if they are accidentally pasted into a REPL.</span><a id="filepos47226"></a></blockquote><br class="calibre33"/><hr class="calibre34"/><p class="calibre25"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos47339"></a><a href="#filepos39200"><span class="calibre32">2</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">If necessary, you can ahead-of-time compile Clojure to Java class files. See </span><a href="#filepos1199448"><span class="calibre10"><span class="calibre5">Ahead-of-Time Compilation</span></span></a><span class="calibre10"> for details.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos47736"></a><a href="#filepos41334"><span class="calibre32">3</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Alternatively, you can use </span><span class="calibre10"><tt class="calibre22">java -jar clojure.jar</tt></span><span class="calibre10">, but the </span><span class="calibre10"><tt class="calibre22">-cp</tt></span><span class="calibre10"> flag and the </span><span class="calibre10"><tt class="calibre22">clojure.main</tt></span><span class="calibre10"> entry point are both important to know about; we talk about both in </span><a href="#filepos1132603"><span class="calibre10"><span class="calibre5">Chapter 8</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos48344"></a><a href="#filepos44626"><span class="calibre32">4</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Note that </span><span class="calibre10"><tt class="calibre22">+</tt></span><span class="calibre10"> here is not a special language operator, as in most other languages. It is a regular function, no different in type than the one we’re defining. </span><span class="calibre10"><tt class="calibre22">apply</tt></span><span class="calibre10"> is also a function, which applies a function it is provided with to a collection of arguments (</span><span class="calibre10"><tt class="calibre22">numbers</tt></span><span class="calibre10"> here); so, </span><span class="calibre10"><tt class="calibre22">(apply + [a b c])</tt></span><span class="calibre10"> will yield the same value as </span><span class="calibre10"><tt class="calibre22">(+ a b c)</tt></span><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos49081" class="calibre6"><span class="calibre4"><span class="bold">No, Parentheses Actually Won’t Make You Go Blind</span></span></p><p id="filepos49192" class="calibre18">Many programmers who don’t already use a Lisp or secretly harbor fond memories of their last usage of Lisp from university blanch at the sight of Lisp syntax. Typical reasons offered for this reaction include:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">The particular usage of parentheses to delimit scope, rather than the more familiar braces <tt class="calibre22">{...}</tt> or <tt class="calibre22">do ... end</tt> blocks</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">The use of prefix notation indicating the operation being performed; e.g., <tt class="calibre22">(+ 1 2)</tt> rather than the familiar infix <tt class="calibre22">1 + 2</tt></blockquote></li></ol><p class="calibre18">These objections are born first out of simple unfamiliarity. The braces that Java (and C and C++ and C# and PHP and…) uses for delimiting scope seem perfectly fine—why bother with what appears to be an ill-conceived animal? Similarly, we’ve all known and used infix notation for mathematics since early childhood—why work to use an unusual notation when what we’ve been using seems to have been so reliable? We are creatures of habit, and outside of building an understanding of why any particular difference may be significant, we understandably prefer the familiar and reliable.</p><p class="calibre18">In both cases, the answer is that Clojure did not import its syntactic foundations from other Lisp implementations on a whim; their adoption carries powerful benefits that are worth a minor shift in perspective:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Prefixed operations used uniformly simplify the language’s syntax significantly and eliminate potential ambiguity from nontrivial expressions.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">The use of parentheses (as a textual representation of lists) is an outgrowth of Clojure being a <span class="italic">homoiconic</span> language. We’ll see what this means in <a href="#filepos69475"><span class="calibre5">Homoiconicity</span></a>, but the ramifications of it are manifold: homoiconicity enables the development and use of metaprogramming and domain-specific language constructs simply unavailable in any programming language that is not homoiconic.</blockquote></li><a id="filepos51620"></a></ul><p class="calibre18">After getting through an initial period of unfamiliarity, you will very likely find that Clojure’s syntax reduces the cognitive load necessary to read and write code. Quick: is <tt class="calibre22">&lt;&lt;</tt> (bit-shift left) in Java executed before or after <tt class="calibre22">&amp;</tt> (bitwise and) in order of operations? Every time a programmer has to pause and think about this (or look it up in a manual), every time a programmer has to go back and add grouping parentheses “just in case,” a mental page fault has occurred. And, every time a programmer forgets to think about this, a potential error has entered his code. Imagine a language with no order of operations to worry about at all; Clojure is that language.</p><p class="calibre18">You might be saying, “But there are so many parentheses!” Actually, there aren’t.</p><p class="calibre18">In places where it makes sense, Clojure has borrowed a lot of syntax from other languages—like Ruby—for its data literals. Where other Lisps you might have seen use parenthesized lists <span class="italic">everywhere</span>, Clojure provides a rich set of literals for data and collections like vectors, maps, sets, and lists, as well as things like records (roughly, Clojure’s corollary to structs).</p><p class="calibre18">If you count and compare the number of delimiting characters and tokens of all kinds (<tt class="calibre22">()</tt>, <tt class="calibre22">[]</tt>, <tt class="calibre22">{}</tt>, Ruby’s <tt class="calibre22">||</tt> and <tt class="calibre22">end</tt>, and so on) in Clojure, Java, Ruby, and Python codebases of similar sizes, you will find that the Clojure code won’t have appreciably more than the others—and will often have many fewer thanks to its concision.</p><div class="mbppagebreak"></div><p id="filepos53327" class="calibre6"><span class="calibre4"><span class="bold">Expressions, Operators, Syntax, and Precedence</span></span></p><p id="filepos53434" class="calibre18">All Clojure code is made up of expressions, each of which evaluates to a single value. This is in contrast to many languages that rely upon valueless statements—such as <tt class="calibre22">if</tt>, <tt class="calibre22">for</tt>, and <tt class="calibre22">continue</tt>—to control program flow imperatively. Clojure’s corollaries to these statements are all expressions that evaluate to a value.</p><p class="calibre18">You’ve already seen a few examples of expressions in Clojure:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">60</tt></blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">[60 80 100 400]</tt></blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">(average [60 80 100 400])</tt></blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">(+ 1 2)</tt></blockquote></li></ul><p class="calibre18">These expressions all evaluate to a single value. The rules for that evaluation are extraordinarily simple compared to other languages:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">Lists (denoted by parentheses) are calls, where the first value in the list is the operator and the rest of the values are parameters. The first element in a list is often referred to as being in <span class="italic">function position</span> (as that’s where one provides the function or symbol naming the function to be called). Call expressions evaluate to the value returned by the call.</blockquote></li><a id="filepos55088"></a><li value="2" class="calibre16"><blockquote class="calibre17">Symbols (such as <tt class="calibre22">average</tt> or <tt class="calibre22">+</tt>) evaluate to the named value in the current scope—which can be a function, a named local like <tt class="calibre22">numbers</tt> in our <tt class="calibre22">average</tt> function, a Java class, a macro, or a special form. We’ll learn about macros and special forms in a little bit; for now, just think of them as functions.</blockquote></li><a id="filepos55529"></a><li value="3" class="calibre16"><blockquote class="calibre17">All other expressions evaluate to the literal values they describe.</blockquote></li></ol><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Lists in Lisps are often called </span><span class="calibre10"><span class="italic">s-expressions</span></span><span class="calibre10"> or </span><span class="calibre10"><span class="italic">sexprs</span></span><span class="calibre10">—short for </span><span class="calibre10"><span class="italic">symbolic expressions</span></span><span class="calibre10"> due to the significance of symbols in identifying the values to be used in calls denoted by such lists. Generally, valid s-expressions that can be successfully evaluated are often referred to as </span><span class="calibre10"><span class="italic">forms</span></span><span class="calibre10">: e.g., </span><span class="calibre10"><tt class="calibre22">(if condition then else)</tt></span><span class="calibre10"> is an </span><span class="calibre10"><tt class="calibre22">if</tt></span><span class="calibre10"> form, </span><span class="calibre10"><tt class="calibre22">[60 80 100 400]</tt></span><span class="calibre10"> is a vector form. Not all s-expressions are forms: </span><span class="calibre10"><tt class="calibre22">(1 2 3)</tt></span><span class="calibre10"> is a valid s-expression—a list of three integers—but evaluating it will produce an error because the first value in the list is an integer, which is not callable.</span></blockquote><p class="calibre25">The second and third points are roughly equivalent to most other languages (although Clojure’s literals are more expressive, as we’ll see shortly). However, an examination of how calls work in other languages quickly reveals the complexity of their syntax.</p><p class="calibre3"></p><p class="calibre1"><span class="italic">Table 1-1. Comparison of call syntax between Clojure, Java, Python, and Ruby</span></p><table border="1" valign="top" class="calibre40"><tr border="1" valign="top" class="calibre27"><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Clojure expression </span></span></span></th><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Java equivalent </span></span></span></th><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Python equivalent </span></span></span></th><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Ruby equivalent </span></span></span></th></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">(not k)</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">!k</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">not k</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">not k</tt></span><span class="calibre21"> or </span><span class="calibre21"><tt class="calibre22">! k</tt></span></p></td></tr><tr border="1" valign="top" class="calibre43"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">(inc a)</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">a++</tt></span><span class="calibre21">, </span><span class="calibre21"><tt class="calibre22">++a</tt></span><span class="calibre21">, </span><span class="calibre21"><tt class="calibre22">a += 1</tt></span><span class="calibre21">, </span><span class="calibre21"><tt class="calibre22">a + 1<sup class="calibre44"><small class="calibre31"><span class="calibre32">[</span><a id="filepos59430"></a><a href="#filepos65274"><span class="calibre32">a</span></a><span class="calibre32">]</span></small></sup></tt></span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">a += 1</tt></span><span class="calibre21">, </span><span class="calibre21"><tt class="calibre22">a + 1</tt></span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">a += 1</tt></span><span class="calibre21">
</span></p></td></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">(/ (+ x y) 2)</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">(x + y) / 2</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">(x + y) / 2</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">(x + y) / 2</tt></span><span class="calibre21">
</span></p></td></tr><tr border="1" valign="top" class="calibre43"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">(instance? java.util.List al)</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">al instanceof java.util.List</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">isinstance(al, list)</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">al.is_a? Array</tt></span><span class="calibre21">
</span></p></td></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">(if (not a) (inc b) (dec b))</tt></span><span class="calibre21">
<sup class="calibre44"><small class="calibre31"><span class="calibre32">[</span><a id="filepos62169"></a><a href="#filepos65909"><span class="calibre32">b</span></a><span class="calibre32">]</span></small></sup></span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">!a ? b + 1 : b - 1</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">b + 1 if not a else b - 1</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">!a ? b + 1 : b - 1</tt></span><span class="calibre21">
</span></p></td></tr><tr border="1" valign="top" class="calibre43"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">(Math/pow 2 10)</tt></span><span class="calibre21">
<sup class="calibre44"><small class="calibre31"><span class="calibre32">[</span><a id="filepos63236"></a><a href="#filepos66732"><span class="calibre32">c</span></a><span class="calibre32">]</span></small></sup></span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">Math.pow(2, 10)</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">pow(2, 10)</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">2 ** 10</tt></span><span class="calibre21">
</span></p></td></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">(.someMethod someObj "foo" (.otherMethod otherObj 0))</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">someObj.someMethod("foo", otherObj.otherMethod(0))</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">someObj.someMethod("foo", otherObj.otherMethod(0))</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">someObj.someMethod("foo", otherObj.otherMethod(0))</tt></span><span class="calibre21">
</span></p></td></tr><tr border="1" valign="top" class="calibre27"><td colspan="4" border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos65274"></a><a href="#filepos59430"><span class="calibre32">a</span></a><span class="calibre32">] </span></small></sup><span class="calibre21">In-place increment and decrement operations have no direct corollary in Clojure, because unfettered mutability isn’t available. See </span><a href="#filepos215673"><span class="calibre21"><span class="calibre5">Chapter 2</span></span></a><span class="calibre21">, particularly </span><a href="#filepos221848"><span class="calibre21"><span class="calibre5">On the Importance of Values</span></span></a><span class="calibre21"> for a complete discussion of why this is a good thing.</span></p><p class="calibre42"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos65909"></a><a href="#filepos62169"><span class="calibre32">b</span></a><span class="calibre32">] </span></small></sup><span class="calibre21">Remember, even forms that influence control flow in Clojure evaluate to values just like any other expression, including </span><span class="calibre21"><tt class="calibre22">if</tt></span><span class="calibre21"> and </span><span class="calibre21"><tt class="calibre22">when</tt></span><span class="calibre21">. Here, the value of the </span><span class="calibre21"><tt class="calibre22">if</tt></span><span class="calibre21"> expression will be either </span><span class="calibre21"><tt class="calibre22">(inc b)</tt></span><span class="calibre21"> or </span><span class="calibre21"><tt class="calibre22">(dec b)</tt></span><span class="calibre21">, depending on the value of </span><span class="calibre21"><tt class="calibre22">(not a)</tt></span><span class="calibre21">.</span></p><p class="calibre45"><span class="calibre21"> </span></p><p class="calibre42"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos66732"></a><a href="#filepos63236"><span class="calibre32">c</span></a><span class="calibre32">] </span></small></sup><span class="calibre21">Here’s your first taste of what it looks like to call Java libraries from Clojure. For details, see </span><a href="#filepos1274079"><span class="calibre21"><span class="calibre5">Chapter 9</span></span></a><span class="calibre21">.</span></p></td></tr></table><p class="calibre23">Notice that call syntax is all over the map (we’re picking on Java here the most, but Python and Ruby aren’t so different):</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Infix operators are available (e.g., <tt class="calibre22">a + 1</tt>, <tt class="calibre22">al instanceof List</tt>), but any nontrivial code ends up having to use often-significant numbers of parentheses to override default precedence rules and make evaluation order explicit.</blockquote></li><a id="filepos67617"></a><li value="2" class="calibre16"><blockquote class="calibre17">Unary operators are seemingly arbitrary in regard to whether they use prefix (e.g., <tt class="calibre22">!k</tt> and <tt class="calibre22">++a</tt>) or postfix position (e.g., <tt class="calibre22">a++</tt>).</blockquote></li><a id="filepos67873"></a><li value="3" class="calibre16"><blockquote class="calibre17">Static method calls have prefix position, such as <tt class="calibre22">Math.pow(2, 10)</tt>, but…</blockquote></li><a id="filepos68056"></a><li value="4" class="calibre16"><blockquote class="calibre17">Instance method calls use an unusual variety of infix positions, where the target of the method (which will be assigned to <tt class="calibre22">this</tt> within the body of the method being called) is specified first, with the formal parameters to the method coming after the method name.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos68445"></a><a href="#filepos69100"><span class="calibre32">5</span></a><span class="calibre32">]</span></small></sup></blockquote></li><a id="filepos68556"></a></ul><p class="calibre18">In contrast, Clojure call expressions follow one simple rule: the first value in a list is the operator, the remainder are parameters to that operator. There are no call expressions that use infix or postfix position, and there are no difficult-to-remember precedence rules. This simplification helps make Clojure’s syntax very easy to learn and internalize, and helps make Clojure code very easy to read.</p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos69100"></a><a href="#filepos68445"><span class="calibre32">5</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Python uses the same sort of infix position for its instance methods, but varies from Algol-family brethren by requiring that methods explicitly name their first parameter, usually </span><span class="calibre10"><tt class="calibre22">self</tt></span><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos69475" class="calibre6"><span class="calibre4"><span class="bold">Homoiconicity</span></span></p><p id="filepos69549" class="calibre18">Clojure code is composed of literal representations of its own data structures and atomic values; this characteristic is formally called <span class="italic">homoiconicity</span>, or more casually, <span class="italic">code-as-data</span><a id="filepos69773"></a>.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos69816"></a><a href="#filepos75543"><span class="calibre32">6</span></a><span class="calibre32">]</span></small></sup> This is a significant simplification compared to most other languages, which also happens to enable metaprogramming facilities to a much greater degree than languages that are not homoiconic. To understand why, we’ll need to talk some about languages in general and how their code relates to their internal representations.</p><p class="calibre18">Recall that a REPL’s first stage is to <span class="italic">read</span> code provided to it by you. Every language has to provide a way to transform that textual representation of code into something that can be compiled and/or evaluated. Most languages do this by parsing that text into an <span class="italic">abstract syntax tree</span> (AST)<a id="filepos70572"></a>. This sounds more complicated than it is: an AST is simply a data structure that represents formally what is manifested concretely in text. For example, <a href="#filepos71037"><span class="calibre5">Figure 1-1</span></a> shows some examples of textual language and possible transformations to their corresponding syntax trees.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos70940"></a><a href="#filepos76010"><span class="calibre32">7</span></a><span class="calibre32">]</span></small></sup></p><blockquote id="filepos71037" class="calibre47"></blockquote><blockquote class="calibre48"><img src="images/00034.jpg" class="calibre49"/></blockquote><blockquote class="calibre47"><span class="calibre10"><span class="italic"><span class="calibre7">Figure 1-1. Sample transformations from textual language to formal models</span></span></span></blockquote><p class="calibre50">These transformations from a textual manifestation of language to an AST are at the heart of how languages are defined, how expressive they are, and how well-suited they are to the purpose of relating to the world within which they are designed to be used. Much of the appeal of domain-specific languages springs from exactly this point: if you have a language that is purpose-built for a given field of use, those that have expertise in that field will find it far easier to define and express what they wish in that language compared to a general-purpose language.</p><p class="calibre18">The downside of this approach is that most languages do not provide any way to control their ASTs; the correspondence between their textual syntax and their ASTs is defined solely by the language implementers. This prompts clever programmers to conjure up clever workarounds in order to maximize the expressivity and utility of the textual syntax that they have to work with:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Code generation</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Textual macros and preprocessors (used to legendary effect by C and C++ programmers for decades now)</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Compiler plug-ins (as in Scala, Project Lombok for Java, Groovy’s AST transformations, and Template Haskell)</blockquote></li></ul><p class="calibre18">That’s a lot of incidental complexity—complexity introduced solely because language designers often view textual syntax as primary, leaving formal models of it to be implementation-specific (when they’re exposed at all).</p><p class="calibre18">Clojure (like all Lisps) takes a different path: rather than defining a syntax that will be transformed into an AST, Clojure programs are written using Clojure data structures that represent that AST directly. Consider the <tt class="calibre22">requiresRole...</tt> example from <a href="#filepos71037"><span class="calibre5">Figure 1-1</span></a>, and see how a Clojure transliteration of the example <span class="italic">is</span> an AST for it (recalling the call semantics of function position in Clojure lists).</p><p class="calibre51"><img src="images/00036.jpg" class="calibre52"/></p><p class="calibre13">The fact that <span class="italic">Clojure programs are represented as data</span><a id="filepos73961"></a> means that Clojure programs can be used to write and transform other Clojure programs, trivially so. This is the basis for macros—Clojure’s metaprogramming facility—a far different beast than the gloriously painful hack that are C-style macros and other textual preprocessors, and the ultimate escape hatch when expressivity or domain-specific notation is paramount. We explore Clojure macros in <a href="#filepos831506"><span class="calibre5">Chapter 5</span></a>.</p><p class="calibre18">In practical terms, the direct correspondence between code and data means that the Clojure code you write in the REPL or in a text source file isn’t text at all: you are programming using Clojure data structure literals. Recall the simple <tt class="calibre22">averaging</tt> function from <a href="#filepos42427"><span class="calibre5">Example 1-2</span></a>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn average<br class="calibre33"/>  [numbers]<br class="calibre33"/>  (/ (apply + numbers) (count numbers)))</tt></span></blockquote><p class="calibre23">This isn’t just a bunch of text that is somehow transformed into a function definition through the operation of a black box; this is a list data structure that contains four values: the symbol <tt class="calibre22">defn</tt>, the symbol <tt class="calibre22">average</tt>, a vector data structure containing the symbol <tt class="calibre22">numbers</tt>, and another list that comprises the function’s body. Evaluating that list data structure is what defines the function.<a id="filepos75439"></a></p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos75543"></a><a href="#filepos69816"><span class="calibre32">6</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Clojure is by no means the only homoiconic language, nor is homoiconicity a new concept. Other homoiconic languages include all other Lisps, all sorts of machine language (and therefore arguably Assembly language as well), Postscript, XSLT and XQuery, Prolog, R, Factor, Io, and more.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos76010"></a><a href="#filepos70940"><span class="calibre32">7</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">The natural language parse tree was mostly lifted from </span><a href="http://en.wikipedia.org/wiki/Parse_tree"><span class="calibre10"><span class="calibre5">http://en.wikipedia.org/wiki/Parse_tree</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos76368" class="calibre6"><span class="calibre4"><span class="bold">The Reader</span></span></p><p id="filepos76439" class="calibre18">Although Clojure’s compilation and evaluation machinery operates exclusively on Clojure data structures, the practice of programming has not yet progressed beyond storing code as plain text. Thus, a way is needed to produce those data structures from textual code. This task falls to the Clojure <span class="italic">reader</span>.</p><p class="calibre18">The operation of the reader is completely defined by a single function, <tt class="calibre22">read</tt>, which reads text content from a character stream<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos76981"></a><a href="#filepos106092"><span class="calibre32">8</span></a><span class="calibre32">]</span></small></sup> and returns the next data structure encoded in the stream’s content. This is what the Clojure REPL uses to read text input; each complete data structure read from that input source is then passed on to be evaluated by the Clojure runtime.</p><p class="calibre18">More convenient for exploration’s sake is <tt class="calibre22">read-string</tt>, a function that does the same thing as <tt class="calibre22">read</tt> but uses a string argument as its content source:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(read-string "42")<br class="calibre33"/>;= 42<br class="calibre33"/>(read-string "(+ 1 2)")<br class="calibre33"/>;= (+ 1 2)</tt></span></blockquote><p class="calibre23">The operation of the reader is fundamentally one of deserialization.<a id="filepos77787"></a> Clojure data structures and other literals have a particular textual representation, which the reader deserializes to the corresponding values and data structures.</p><p class="calibre18">You may have noticed that values printed by the Clojure REPL have the same textual representation they do when entered into the REPL: numbers and other atomic literals are printed as you’d expect, lists are delimited by parentheses, vectors by square brackets, and so on. This is because there are duals to the reader’s <tt class="calibre22">read</tt> and <tt class="calibre22">read-string</tt> functions: <tt class="calibre22">pr</tt> and <tt class="calibre22">pr-str</tt>, which prints to <tt class="calibre22">*out*<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos78457"></a><a href="#filepos106461"><span class="calibre32">9</span></a><span class="calibre32">]</span></small></sup></tt> and returns as a string the <tt class="calibre22">read</tt>able textual representation of Clojure values, respectively. Thus, Clojure data structures and values are trivially serialized and deserialized in a way that is both human- and reader-readable:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(pr-str [1 2 3])<br class="calibre33"/>;= "[1 2 3]"<br class="calibre33"/>(read-string "[1 2 3]")<br class="calibre33"/>;= [1 2 3]</tt></span></blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">It is common for Clojure applications to use the reader as a general-purpose serialization mechanism where you might otherwise choose XML or </span><a id="filepos79300"></a><span class="calibre10"><tt class="calibre22">java.io.Serializable</tt></span><span class="calibre10"> serialization or pickling or marshaling, especially in cases where human-readable serializations are desirable.</span></blockquote><p id="filepos79505" class="calibre25"><span class="calibre19"><span class="bold"><span class="calibre5">Scalar Literals</span></span></span></p><p class="calibre18"><span class="italic">Scalar literals</span><a id="filepos79660"></a> are reader syntax for noncollection values. Many of these are bread-and-butter types that you already know intimately from Java or very similar analogues in Ruby, Python, and other languages; others are specific to Clojure and carry new semantics.</p><p id="filepos79919" class="calibre23"><span class="calibre53"><span class="bold">Strings</span></span></p><p class="calibre18">Clojure strings <a id="filepos80031"></a>are Java Strings (that is, instances of <tt class="calibre22">java.lang.String</tt>), and are represented in exactly the same way, delimited by double quotes:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">"hello there"<br class="calibre33"/>;= "hello there"</tt></span></blockquote><p class="calibre23">Clojure’s strings are naturally multiline-capable, without any special syntax (as in, for example, Python):</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">"multiline strings<br class="calibre33"/>are very handy"<br class="calibre33"/>;= "multiline strings\nare very handy"</tt></span></blockquote><p id="filepos80622" class="calibre23"><span class="calibre53"><span class="bold">Booleans</span></span></p><p id="filepos80691" class="calibre18">The tokens <tt class="calibre22">true</tt> and <tt class="calibre22">false</tt> are used to denote literal Boolean values in Clojure, just as in Java, Ruby, and Python (modulo the latter’s capitalization).</p><p id="filepos80894" class="calibre23"><span class="calibre53"><span class="bold">nil</span></span></p><p class="calibre18"><tt class="calibre22">nil</tt><a id="filepos80998"></a> in Clojure corresponds to <tt class="calibre22">null</tt> in Java, <tt class="calibre22">nil</tt> in Ruby, and <tt class="calibre22">None</tt> in Python. <tt class="calibre22">nil</tt> is also logically false in Clojure conditionals, as it is in Ruby and Python.</p><p id="filepos81200" class="calibre23"><span class="calibre53"><span class="bold">Characters</span></span></p><p class="calibre18">Character literals <a id="filepos81318"></a>are denoted by a backslash:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(class \c)<br class="calibre33"/>;= java.lang.Character</tt></span></blockquote><p class="calibre23">Both Unicode and octal representations of characters may be used with corresponding prefixes:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">\u00ff<br class="calibre33"/>;= \ÿ<br class="calibre33"/>\o41<br class="calibre33"/>;= \!</tt></span></blockquote><p class="calibre23">Additionally, there are a number of special named character literals for cases where the character in question is commonly used but prints as whitespace:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">\space</tt></blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">\newline</tt></blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">\formfeed</tt></blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">\return</tt></blockquote></li><li value="5" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">\backspace</tt></blockquote></li><li value="6" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">\tab</tt></blockquote></li></ul><p id="filepos82628" class="calibre23"><span class="calibre53"><span class="bold">Keywords</span></span></p><p class="calibre18">Keywords <a id="filepos82734"></a>evaluate to themselves, and are often used as accessors for the values they name in Clojure collections and types, such as hash maps and records:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def person {:name "Sandra Cruz"<br class="calibre33"/>             :city "Portland, ME"})<br class="calibre33"/>;= #'user/person<br class="calibre33"/>(:city person)<br class="calibre33"/>;= "Portland, ME"</tt></span></blockquote><p class="calibre23">Here we create a hashmap <a id="filepos83197"></a>with two slots, <tt class="calibre22">:name</tt> and <tt class="calibre22">:city</tt>, and then look up the value of <tt class="calibre22">:city</tt> in that map. This works because keywords are functions that look themselves up in collections passed to them.</p><p class="calibre18">Syntactically, keywords are always prefixed with a colon, and can otherwise consist of any nonwhitespace character. A slash character (<tt class="calibre22">/</tt>) denotes a <span class="italic">namespaced keyword</span><a id="filepos83623"></a>, while a keyword prefixed with two colons (<tt class="calibre22">::</tt>) is expanded by the reader to a namespaced keyword in the current namespace—or another namespace if the keyword started by a namespace alias, <tt class="calibre22">::alias/kw</tt> for example. These have similar usage and motivation as namespaced entities in XML; that is, being able to use the same name for values with different semantics or roles:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos84055"></a><a href="#filepos106977"><span class="calibre32">10</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def pizza {:name "Ramunto's"<br class="calibre33"/>            :location "Claremont, NH"<br class="calibre33"/>            ::location "43.3734,-72.3365"})<br class="calibre33"/>;= #'user/pizza<br class="calibre33"/>pizza<br class="calibre33"/>;= {:name "Ramunto's", :location "Claremont, NH", :user/location "43.3734,-72.3365"}<br class="calibre33"/>(:user/location pizza)<br class="calibre33"/>;= "43.3734,-72.3365"</tt></span></blockquote><p class="calibre23">This allows different modules in the same application and disparate groups within the same organization to safely lay claim to particular names, without complex domain modeling or conventions like underscored prefixes for conflicting names.</p><p class="calibre18">Keywords are one type of “named” values, so called because they have an intrinsic name that is accessible using the <tt class="calibre22">name</tt> function and an optional namespace accessible using <tt class="calibre22">namespace</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(name :user/location)<br class="calibre33"/>;= "location"<br class="calibre33"/>(namespace :user/location)<br class="calibre33"/>;= "user"<br class="calibre33"/>(namespace :location)<br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre23">The other named type of value is the symbol.</p><p id="filepos85406" class="calibre23"><span class="calibre53"><span class="bold">Symbols</span></span></p><p id="filepos85474" class="calibre18">Like keywords, symbols are identifiers, but they evaluate to values in the Clojure runtime they name. These values include those held by vars (which are named storage locations used to hold functions and other values), Java classes, local references, and so on. Thinking back to our original example in <a href="#filepos42427"><span class="calibre5">Example 1-2</span></a>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(average [60 80 100 400])<br class="calibre33"/>;= 160</tt></span></blockquote><p class="calibre23"><tt class="calibre22">average</tt> here is a symbol, referring to the function held in the var named <tt class="calibre22">average</tt>.</p><p class="calibre18">Symbols must begin with a non-numeric character, and can contain <tt class="calibre22">*</tt>, <tt class="calibre22">+</tt>, <tt class="calibre22">!</tt>, <tt class="calibre22">-</tt>, <tt class="calibre22">_</tt>, and <tt class="calibre22">?</tt> in addition to any alphanumeric characters. Symbols that contain a slash (<tt class="calibre22">/</tt>) denote a <span class="italic">namespaced symbol</span><a id="filepos86422"></a> and will evaluate to the named value in the specified namespace. The evaluation of symbols to the entity they name depends upon their context and the namespaces available within that context. We talk about the semantics of namespaces and symbol evaluation extensively in <a href="#filepos109342"><span class="calibre5">Namespaces</span></a>.</p><p id="filepos86771" class="calibre23"><span class="calibre53"><span class="bold">Numbers</span></span></p><p id="filepos86839" class="calibre18">Clojure provides a plethora of numeric literals (see <a href="#filepos88495"><span class="calibre5">Table 1-2</span></a>). Many of them are pedestrian, but others are rare to find in a general-purpose programming language and can simplify the implementation of certain algorithms—especially in cases where the algorithms <a id="filepos87188"></a>are defined in terms of particular numeric representations (octal, binary, rational numbers, and scientific notation).</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">While the Java runtime defines a particular range of numeric primitives, and Clojure supports interoperability with those primitives, Clojure has a bias toward longs and doubles at the expense of other widths, including bytes, shorts, ints, and floats. This means that these smaller primitives will be produced as needed from literals or runtime values for interop operations (such as calling Java methods), but pure-Clojure operations will default to using the wider numeric representations.</span><a id="filepos87996"></a></blockquote><blockquote class="calibre17"><span class="calibre10">For the vast majority of programming domains, you don’t need to worry about this. If you are doing work where mathematical precision and other related topics is important, please refer to </span><a href="#filepos1527443"><span class="calibre10"><span class="calibre5">Chapter 11</span></span></a><span class="calibre10"> for a comprehensive discussion of Clojure’s treatment of operations on primitives and other math topics.</span></blockquote><p id="filepos88495" class="calibre54"></p><p class="calibre1"><span class="italic">Table 1-2. Clojure numeric literals</span></p><table border="1" valign="top" class="calibre40"><tr border="1" valign="top" class="calibre27"><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Literal syntax </span></span></span></th><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Numeric type </span></span></span></th></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">42</tt></span><span class="calibre21">, </span><span class="calibre21"><tt class="calibre22">0xff</tt></span><span class="calibre21">, </span><span class="calibre21"><tt class="calibre22">2r111</tt></span><span class="calibre21">, </span><span class="calibre21"><tt class="calibre22">040</tt></span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">long</tt></span><span class="calibre21"> (64-bit signed integer)</span></p></td></tr><a id="filepos89586"></a><tr border="1" valign="top" class="calibre43"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">3.14</tt></span><span class="calibre21">, </span><span class="calibre21"><tt class="calibre22">6.0221415e23</tt></span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">double</tt></span><span class="calibre21"> (64-bit IEEE floating point decimal)</span></p></td></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">42N</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">clojure.lang.BigInt</tt></span><span class="calibre21"> (arbitrary-precision integer<sup class="calibre44"><small class="calibre31"><span class="calibre32">[</span><a id="filepos90661"></a><a href="#filepos92071"><span class="calibre32">a</span></a><span class="calibre32">]</span></small></sup>)</span></p></td></tr><tr border="1" valign="top" class="calibre43"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">0.01M</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">java.math.BigDecimal</tt></span><span class="calibre21"> (arbitrary-precision signed floating point decimal)</span></p></td></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">22/7</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">clojure.lang.Ratio</tt></span><span class="calibre21">
</span></p></td></tr><tr border="1" valign="top" class="calibre27"><td colspan="2" border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre45"><span class="calibre21"> </span></p><p class="calibre42"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos92071"></a><a href="#filepos90661"><span class="calibre32">a</span></a><span class="calibre32">] </span></small></sup><span class="calibre21"><tt class="calibre22">clojure.lang.BigInt</tt></span><span class="calibre21"> is automatically coerced to </span><span class="calibre21"><tt class="calibre22">java.math.BigInteger</tt></span><span class="calibre21"> when needed. Again, please see </span><a href="#filepos1527443"><span class="calibre21"><span class="calibre5">Chapter 11</span></span></a><span class="calibre21"> for the in-depth details of Clojure’s treatment of numerics.</span></p></td></tr></table><p class="calibre23">Any numeric literal can be negated by prefixing it with a dash (<tt class="calibre22">-</tt>).</p><p class="calibre18">Let’s take a quick look at the more interesting numeric literals:</p><p class="calibre23">Hexadecimal notation</p><blockquote id="filepos92825" class="calibre17">Just as in most languages, Clojure supports typical hexadecimal notation for integer values; <tt class="calibre22">0xff</tt> is <tt class="calibre22">255</tt>, <tt class="calibre22">0xd055</tt> is <tt class="calibre22">53333</tt>, and so on.</blockquote><p class="calibre23">Octal notation<a id="filepos93086"></a></p><blockquote class="calibre17">Literals starting with a zero are interpreted as octal numbers. For example, the octal <tt class="calibre22">040</tt> is <tt class="calibre22">32</tt> in the usual base-10 notation.</blockquote><p class="calibre23">Flexible numeral bases</p><blockquote class="calibre17">You can specify the base of an integer in a prefix <tt class="calibre22">BrN</tt>, where <tt class="calibre22">N</tt> is the digits that represent the desired number, and <tt class="calibre22">B</tt> is the base or radix by which <tt class="calibre22">N</tt> should be interpreted. So we can use a prefix of <tt class="calibre22">2r</tt> for binary integers (<tt class="calibre22">2r111</tt> is <tt class="calibre22">7</tt>), <tt class="calibre22">16r</tt> for hexadecimal (<tt class="calibre22">16rff</tt> is 255), and so on. This is supported up to base 36.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos93815"></a><a href="#filepos107432"><span class="calibre32">11</span></a><span class="calibre32">]</span></small></sup></blockquote><p class="calibre23">Arbitrary-precision numbers</p><blockquote id="filepos93981" class="calibre17">Any numeric literal (except for rational numbers) can be specified as arbitrary-precision by suffixing it appropriately; decimals with an <tt class="calibre22">M</tt>, integers with an <tt class="calibre22">N</tt>. Please see <a href="#filepos1557089"><span class="calibre5">Bounded Versus Arbitrary Precision</span></a> for a full exploration of why and when this is relevant.</blockquote><p class="calibre23">Rational numbers</p><blockquote id="filepos94415" class="calibre17">Clojure directly supports rational numbers, also called <span class="italic">ratios</span>, as literals in the reader as well as throughout its numeric operators. Rational number literals must always be two integers separated by a slash (<tt class="calibre22">/</tt>).</blockquote><p class="calibre18">For a full discussion of rational numbers in Clojure and how they interact with the rest of Clojure’s numerical model, please see <a href="#filepos1546739"><span class="calibre5">Rationals</span></a>.</p><p id="filepos94923" class="calibre23"><span class="calibre53"><span class="bold">Regular expressions</span></span></p><p id="filepos95003" class="calibre18">The Clojure reader treats strings prefixed with a hash character as regular expression (regex) literals:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(class #"(p|h)ail")<br class="calibre33"/>;= java.util.regex.Pattern</tt></span></blockquote><p class="calibre23">This is exactly equivalent to Ruby’s <tt class="calibre22">/.../</tt> regex syntax, with a minor difference of pattern delimiters. In fact, Ruby and Clojure are <span class="italic">very</span> similar in their handling of regular expressions:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22"># Ruby<br class="calibre33"/>&gt;&gt; "foo bar".match(/(...) (...)/).to_a<br class="calibre33"/>["foo bar", "foo", "bar"]<br class="calibre33"/><br class="calibre33"/>;; Clojure<br class="calibre33"/>(re-seq #"(...) (...)" "foo bar")<br class="calibre33"/>;= (["foo bar" "foo" "bar"])</tt></span></blockquote><p class="calibre23">Clojure’s regex syntax does not require escaping of backslashes as required in Java:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(re-seq #"(\d+)-(\d+)" "1-3")     ;; would be "(\\d+)-(\\d+)" in Java<br class="calibre33"/>;= (["1-3" "1" "3"])</tt></span></blockquote><p class="calibre23">The instances of <tt class="calibre22">java.util.regex.Pattern</tt> that Clojure regex literals yield are entirely equivalent to those you might create within Java, and therefore use the generally excellent <tt class="calibre22">java.util.regex</tt> regular expression implementation.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos96434"></a><a href="#filepos108117"><span class="calibre32">12</span></a><span class="calibre32">]</span></small></sup> Thus, you can use those <tt class="calibre22">Pattern</tt> instances directly via Clojure’s Java interop if you like, though you will likely find Clojure’s related utility functions (such as <tt class="calibre22">re-seq</tt>, <tt class="calibre22">re-find</tt>, <tt class="calibre22">re-matches</tt>, and others in the <tt class="calibre22">clojure.string</tt> namespace) simpler and more pleasant to use.<a id="filepos96848"></a></p><p id="filepos96859" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Comments</span></span></span></p><p id="filepos96957" class="calibre18">There are two comment types that are defined by the reader:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Single-line comments are indicated by prefixing the comment with a semicolon (<tt class="calibre22">;</tt>); all content following a semicolon is ignored entirely. These are equivalent to <tt class="calibre22">//</tt> in Java and JavaScript, and <tt class="calibre22">#</tt> in Ruby and Python.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17"><span class="italic">Form-level</span> are available using the <tt class="calibre22">#_</tt> reader macro. This cues the reader to elide the next Clojure <span class="italic">form</span> following the macro:</blockquote></li><a id="filepos97663"></a></ul><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(read-string "(+ 1 2 #_(* 2 2) 8)")<br class="calibre33"/>;= (+ 1 2 8)</tt></span></blockquote><p class="calibre23">What would have been a list with four numbers—<tt class="calibre22">(+ 1 2 4 8)</tt>—yields a list of only three numbers because the entire multiplication form was ignored due to the <tt class="calibre22">#_</tt> prefix.</p><p class="calibre18">Because Clojure code is defined using data structure literals, this comment form can be far more useful in certain cases than purely textual comments that affect lines or character offsets (such as the <tt class="calibre22">/* */</tt> multiline comments in Java and JavaScript). For example, consider the time-tested debugging technique of printing to <tt class="calibre22">stdout</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn some-function<br class="calibre33"/>  […arguments…]<br class="calibre33"/>  …code…<br class="calibre33"/>  (if …debug-conditional…<br class="calibre33"/>    (println …debug-info…)<br class="calibre33"/>    (println …more-debug-info…))<br class="calibre33"/>  …code…)</tt></span></blockquote><p class="calibre23">Making those <tt class="calibre22">println</tt> forms <a id="filepos98802"></a>functionally disappear is as easy as prefixing the <tt class="calibre22">if</tt> form with the <tt class="calibre22">#_</tt> reader macro and reloading the function definition; whether the form spans one or a hundred lines is irrelevant.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">There is only one other way to comment code in Clojure, the </span><span class="calibre10"><tt class="calibre22">comment</tt></span><span class="calibre10"> macro:</span><a id="filepos99325"></a></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(when true<br class="calibre33"/>  (comment (println "hello")))<br class="calibre33"/>;= nil</tt></span></blockquote><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">comment</tt></span><span class="calibre10"> forms can contain any amount of ignored code, but they are not elided from the reader’s output in the way that </span><a id="filepos99707"></a><span class="calibre10"><tt class="calibre22">#_</tt></span><span class="calibre10"> impacts the forms following it. Thus, </span><span class="calibre10"><tt class="calibre22">comment</tt></span><span class="calibre10"> forms always evaluate to </span><span class="calibre10"><tt class="calibre22">nil</tt></span><span class="calibre10">. This often is not a problem; but, sometimes it can be inconvenient. Consider a reformulation of our first </span><span class="calibre10"><tt class="calibre22">#_</tt></span><span class="calibre10"> example:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(+ 1 2 (comment (* 2 2)) 8)<br class="calibre33"/>;= #&lt;NullPointerException java.lang.NullPointerException&gt;</tt></span></blockquote><blockquote class="calibre35"><span class="calibre10">That fails because </span><span class="calibre10"><tt class="calibre22">comment</tt></span><span class="calibre10"> returns </span><span class="calibre10"><tt class="calibre22">nil</tt></span><span class="calibre10">, which is not a valid argument to </span><span class="calibre10"><tt class="calibre22">+</tt></span><span class="calibre10">.</span></blockquote><p id="filepos100630" class="calibre25"><span class="calibre19"><span class="bold"><span class="calibre5">Whitespace and Commas</span></span></span></p><p id="filepos100741" class="calibre18">You may have noticed that there have been no commas between forms, parameters to function calls, elements in data structure literals, and so on:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn silly-adder<br class="calibre33"/>  [x y]<br class="calibre33"/>  (+ x y))</tt></span></blockquote><p class="calibre23">This is because whitespace is sufficient to separate values and forms provided to the reader. In addition, <span class="italic">commas are considered whitespace by the reader</span>. For example, this is functionally equivalent to the snippet above:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn silly-adder<br class="calibre33"/>  [x, y]<br class="calibre33"/>  (+, x, y))</tt></span></blockquote><p class="calibre23">And to be slightly pedantic about it:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(= [1 2 3] [1, 2, 3])<br class="calibre33"/>;= true</tt></span></blockquote><p class="calibre23">Whether you use commas or not is entirely a question of personal style and preference. That said, they are generally used only when doing so enhances the <span class="italic">human</span> readability of the code in question. This is most common in cases where pairs of values are listed, but more than one pair appears per line:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos102026"></a><a href="#filepos108713"><span class="calibre32">13</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(create-user {:name new-username, :email email})</tt></span></blockquote><p id="filepos102257" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Collection Literals</span></span></span></p><p id="filepos102366" class="calibre18">The reader provides syntax for the most commonplace Clojure data structures:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">'(a b :name 12.5)       ;; list<br class="calibre33"/><br class="calibre33"/>['a 'b :name 12.5]      ;; vector<br class="calibre33"/><br class="calibre33"/>{:name "Chas" :age 31}  ;; map<br class="calibre33"/><br class="calibre33"/>#{1 2 3}                ;; set</tt></span></blockquote><p class="calibre23">Since lists <a id="filepos102819"></a>are used to denote calls in Clojure, you need to quote (<tt class="calibre22">'</tt>) the list literal in order to prevent the evaluation of the list as a call.</p><p class="calibre18">The specifics of these data structures are explored in detail in <a href="#filepos335797"><span class="calibre5">Chapter 3</span></a>.</p><p id="filepos103135" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Miscellaneous Reader Sugar</span></span></span></p><p id="filepos103251" class="calibre18">The reader provides for some additional syntax in certain cases to improve concision or regularity with other aspects of Clojure:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Evaluation can be suppressed by prefixing a form with a quote character (<tt class="calibre22">'</tt>); see <a href="#filepos123823"><span class="calibre5">Suppressing Evaluation: quote</span></a>.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Anonymous function literals can be defined very concisely using the <tt class="calibre22">#()</tt> notation; see <a href="#filepos176636"><span class="calibre5">Function literals</span></a>.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">While symbols evaluate to the values held by vars, vars themselves can be referred to by prefixing a symbol with <tt class="calibre22">#'</tt>; see <a href="#filepos189489"><span class="calibre5">Referring to Vars: var</span></a>.</blockquote></li><a id="filepos104285"></a><li value="4" class="calibre16"><blockquote class="calibre17">Instances of reference types can be dereferenced (yielding the value contained within the reference object) by prefixing <tt class="calibre22">@</tt> to a symbol naming the instance; see <a href="#filepos636143"><span class="calibre5">Clojure Reference Types</span></a>.</blockquote></li><li value="5" class="calibre16"><blockquote class="calibre17">The reader provides three bits of special syntax for macros: <tt class="calibre22">`</tt>, <tt class="calibre22">~</tt>, and <tt class="calibre22">~@</tt>. Macros are explored in <a href="#filepos831506"><span class="calibre5">Chapter 5</span></a>.</blockquote></li><li value="6" class="calibre16"><blockquote class="calibre17">While there are technically only two Java interop forms, the reader provides some sugar for interop that expands into those two special forms; see <a href="#filepos190560"><span class="calibre5">Java Interop: . and new</span></a>.</blockquote></li><li value="7" class="calibre16"><blockquote class="calibre17">All of Clojure’s data structures and reference types support <span class="italic">metadata</span>—small bits of information that can be associated with a value or reference that do not affect things like equality comparisons. While your applications can use metadata for many purposes, metadata is used in Clojure itself where you might otherwise use keywords in other languages (e.g., to indicate that a function is namespace-private, or to indicate the type of a value or return type of a function). The reader allows you to attach metadata to literal values being read using the <tt class="calibre22">^</tt> notation; see <a href="#filepos512813"><span class="calibre5">Metadata</span></a>.</blockquote></li><a id="filepos105987"></a></ul><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos106092"></a><a href="#filepos76981"><span class="calibre32">8</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Technically, </span><span class="calibre10"><tt class="calibre22">read</tt></span><span class="calibre10"> requires a </span><span class="calibre10"><tt class="calibre22">java.io.PushbackReader</tt></span><span class="calibre10"> as an implementation detail.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos106461"></a><a href="#filepos78457"><span class="calibre32">9</span></a><span class="calibre32">] </span></small></sup><span class="calibre10"><tt class="calibre22">*out*</tt></span><span class="calibre10"> defaults to </span><span class="calibre10"><tt class="calibre22">stdout</tt></span><span class="calibre10">, but can be redirected easily. See </span><a href="#filepos296083"><span class="calibre10"><span class="calibre5">Building a Primitive Logging System with Composable Higher-Order Functions</span></span></a><span class="calibre10"> for an example.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos106977"></a><a href="#filepos84055"><span class="calibre32">10</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Namespaced keywords are also used prominently with multimethods and </span><span class="calibre10"><tt class="calibre22">isa?</tt></span><span class="calibre10"> hierarchies, discussed in depth in </span><a href="#filepos1073489"><span class="calibre10"><span class="calibre5">Chapter 7</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos107432"></a><a href="#filepos93815"><span class="calibre32">11</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">The implementation limit of </span><span class="calibre10"><tt class="calibre22">java.math.BigInteger</tt></span><span class="calibre10">’s radix support. Note that even though </span><span class="calibre10"><tt class="calibre22">BigInteger</tt></span><span class="calibre10"> is used for parsing these literals, the concrete type of the number as emitted by the reader is consistent with other Clojure integer literals: either a </span><span class="calibre10"><tt class="calibre22">long</tt></span><span class="calibre10"> or a big integer if the number specified requires arbitrary precision to represent.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos108117"></a><a href="#filepos96434"><span class="calibre32">12</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See the </span><span class="calibre10"><tt class="calibre22">java.util.regex.Pattern</tt></span><span class="calibre10"> javadoc for a full specification of what forms the Java regular expression implementation supports: </span><a href="http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html"><span class="calibre10"><span class="calibre5">http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos108713"></a><a href="#filepos102026"><span class="calibre32">13</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Questions of style are notoriously difficult to answer in absolutes, but it would be very rare to see more than two or three pairs of values on the same line of text in any map literal, set of keyword arguments, and so on. Further, some forms that expect pairs of values (such as bindings in </span><span class="calibre10"><tt class="calibre22">let</tt></span><span class="calibre10">) are essentially </span><span class="calibre10"><span class="italic">always</span></span><span class="calibre10"> delimited by linebreaks rather than being situated on the same line.</span></p><div class="mbppagebreak"></div><p id="filepos109342" class="calibre6"><span class="calibre4"><span class="bold">Namespaces</span></span></p><p id="filepos109413" class="calibre18">At this point, we should understand much of how the nontrivial parts of the Clojure REPL (and therefore Clojure itself) work:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Read: the Clojure reader reads the textual representation of code, producing the data structures (e.g., lists, vectors, and so on) and atomic values (e.g., symbols, numbers, strings, etc.) indicated in that code.</blockquote></li><a id="filepos109916"></a><li value="2" class="calibre16"><blockquote class="calibre17">Evaluate: many of the values emitted by the reader evaluate to themselves (including most data structures and scalars like strings and keywords). We explored earlier in <a href="#filepos53327"><span class="calibre5">Expressions, Operators, Syntax, and Precedence</span></a> how lists evaluate to calls to the operator in <span class="italic">function position</span>.</blockquote></li><a id="filepos110360"></a></ul><p class="calibre18">The only thing left to understand about evaluation now is how symbols are evaluated. So far, we’ve used them to both name and refer to functions, locals, and so on. Outside of identifying locals, the semantics of symbol evaluation are tied up with namespaces, Clojure’s fundamental unit of code modularity.</p><p class="calibre18">All Clojure code is defined and evaluated within a namespace. Namespaces are roughly analogous to modules in Ruby or Python, or packages in Java.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos110922"></a><a href="#filepos117035"><span class="calibre32">14</span></a><span class="calibre32">]</span></small></sup> Fundamentally, they are dynamic mappings between <span class="italic">symbols</span> and either <span class="italic">vars</span> or imported Java classes.</p><p class="calibre18">One of Clojure’s <span class="italic">reference types</span>,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos111238"></a><a href="#filepos117795"><span class="calibre32">15</span></a><span class="calibre32">]</span></small></sup> vars <a id="filepos111338"></a>are mutable storage locations that can hold any value. Within the namespace where they are defined, vars are associated with a symbol that other code can use to look up the var, and therefore the value it holds.</p><p class="calibre18">Vars are defined in Clojure using the <tt class="calibre22">def</tt> special form, which only ever acts within the current namespace.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos111738"></a><a href="#filepos118234"><span class="calibre32">16</span></a><span class="calibre32">]</span></small></sup> Let’s define a var now in the <tt class="calibre22">user</tt> namespace, named <tt class="calibre22">x</tt>; the name of the var is the symbol that it is keyed under within the current namespace:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def x 1)<br class="calibre33"/>;= #'user/x</tt></span></blockquote><p class="calibre23">We can access the var’s value using that symbol:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">x<br class="calibre33"/>;= 1</tt></span></blockquote><p class="calibre23">The symbol <tt class="calibre22">x</tt> here is <span class="italic">unqualified</span>, so is resolved within the current namespace. We can also redefine vars; this is critical for supporting interactive development at the REPL:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def x "hello")<br class="calibre33"/>;= #'user/x<br class="calibre33"/>x<br class="calibre33"/>;= "hello"</tt></span></blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">VARS ARE NOT VARIABLES</span></span></span></blockquote><blockquote id="filepos112803" class="calibre17"><span class="calibre10">Vars should only ever be defined in an interactive context—such as a REPL—or within a Clojure source file as a way of defining named functions, other constant values, and the like. In particular, top-level vars (that is, globally accessible vars mapped within namespaces, as defined by </span><span class="calibre10"><tt class="calibre22">def</tt></span><span class="calibre10"> and its variants) should only ever be defined by top-level expressions, never in the bodies of functions in the normal course of operation of a Clojure program.</span></blockquote><blockquote class="calibre17"><span class="calibre10">See </span><a href="#filepos759240"><span class="calibre10"><span class="calibre5">Vars Are Not Variables</span></span></a><span class="calibre10"> for further elaboration.</span></blockquote><p class="calibre25">Symbols may also be namespace-qualified, in which case they are resolved within the specified namespace instead of the current one:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">*ns*                 </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #&lt;Namespace user&gt;<br class="calibre33"/>(ns foo)<br class="calibre33"/>;= nil<br class="calibre33"/>*ns*<br class="calibre33"/>;= #&lt;Namespace foo&gt;<br class="calibre33"/>user/x<br class="calibre33"/>;= "hello"<br class="calibre33"/>x<br class="calibre33"/>;= #&lt;CompilerException java.lang.RuntimeException:<br class="calibre33"/>;=   Unable to resolve symbol: x in this context, compiling:(NO_SOURCE_PATH:0)&gt;</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">The current namespace is always bound to <tt class="calibre22">*ns*</tt>.</blockquote><p class="calibre18">Here we created a new namespace using the <tt class="calibre22">ns</tt> macro (which has the side effect of switching us to that new namespace in our REPL), and then referred to the value of <tt class="calibre22">x</tt> in the <tt class="calibre22">user</tt> namespace by using the namespace-qualified symbol <tt class="calibre22">user/x</tt>. Since we only just created this new namespace <tt class="calibre22">foo</tt>, it doesn’t have a mapping for the <tt class="calibre22">x</tt> symbol, so attempting to resolve it fails.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">You need to know how to create, define, organize, and manipulate namespaces in order to use Clojure effectively. There is a whole suite of functions for this; please refer to </span><a href="#filepos1134534"><span class="calibre10"><span class="calibre5">Defining and Using Namespaces</span></span></a><span class="calibre10"> for our guidelines in their use.</span></blockquote><p class="calibre25">We mentioned earlier that namespaces also map between symbols and imported Java classes. All classes in the <tt class="calibre22">java.lang</tt> package are imported by default into each Clojure namespace, and so can be referred to without package qualification; to refer to un-imported classes, a package-qualified symbol must be used. Any symbol that names a class evaluates to that class:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">String<br class="calibre33"/>;= java.lang.String<br class="calibre33"/>Integer<br class="calibre33"/>;= java.lang.Integer<br class="calibre33"/>java.util.List<br class="calibre33"/>;= java.util.List<br class="calibre33"/>java.net.Socket<br class="calibre33"/>;= java.net.Socket</tt></span></blockquote><p class="calibre23">In addition, namespaces by default alias <a id="filepos116253"></a>all of the vars defined in the primary namespace of Clojure’s standard library, <tt class="calibre22">clojure.core</tt>. For example, there is a <tt class="calibre22">filter</tt> function defined in <tt class="calibre22">clojure.core</tt>, which we can access without namespace-qualifying our reference to it:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">filter<br class="calibre33"/>;= #&lt;core$filter clojure.core$filter@7444f787&gt;</tt></span></blockquote><p class="calibre23">These are just the barest basics of how Clojure namespaces work; learn more about them and how they should be used to help you structure your projects in <a href="#filepos1134534"><span class="calibre5">Defining and Using Namespaces</span></a>.</p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos117035"></a><a href="#filepos110922"><span class="calibre32">14</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">In fact, namespaces correspond precisely with Java packages when types defined in Clojure are compiled down to Java classes. For example, a </span><span class="calibre10"><tt class="calibre22">Person</tt></span><span class="calibre10"> type defined in the Clojure namespace </span><span class="calibre10"><tt class="calibre22">app.entities</tt></span><span class="calibre10"> will produce a Java class named </span><span class="calibre10"><tt class="calibre22">app.entities.Person</tt></span><span class="calibre10">. See more about defining types and records in Clojure in </span><a href="#filepos945443"><span class="calibre10"><span class="calibre5">Chapter 6</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos117795"></a><a href="#filepos111238"><span class="calibre32">15</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="#filepos636143"><span class="calibre10"><span class="calibre5">Clojure Reference Types</span></span></a><span class="calibre10"> for a full discussion of Clojure’s reference types, all of which contribute different capabilities to its concurrency toolbox.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos118234"></a><a href="#filepos111738"><span class="calibre32">16</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Remember that the Clojure REPL session always starts in the default </span><span class="calibre10"><tt class="calibre22">user</tt></span><span class="calibre10"> namespace.</span></p><div class="mbppagebreak"></div><p id="filepos118507" class="calibre6"><span class="calibre4"><span class="bold">Symbol Evaluation</span></span></p><p id="filepos118585" class="calibre18">With a basic understanding of namespaces under our belt, we can turn again to the example <tt class="calibre22">average</tt> function from <a href="#filepos42427"><span class="calibre5">Example 1-2</span></a> and have a more concrete idea of how it is evaluated:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn average<br class="calibre33"/>  [numbers]<br class="calibre33"/>  (/ (apply + numbers) (count numbers)))</tt></span></blockquote><p class="calibre23">As we learned in <a href="#filepos69475"><span class="calibre5">Homoiconicity</span></a>, this is just a canonical textual representation of a Clojure data structure that itself contains other data. Within the body of this function, there are many symbols, each of which refers to either a var in scope in the current namespace or a local value:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">/</tt>, <tt class="calibre22">apply</tt>, <tt class="calibre22">+</tt>, and <tt class="calibre22">count</tt> all evaluate to functions held in vars defined and so named in the <tt class="calibre22">clojure.core</tt> namespace</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">numbers</tt> either defines the sole argument to the function (when provided in the argument vector <tt class="calibre22">[numbers]</tt>),<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos119932"></a><a href="#filepos121156"><span class="calibre32">17</span></a><span class="calibre32">]</span></small></sup> or is used to refer to that argument’s value in the body of the function (when used in the <tt class="calibre22">(apply + numbers)</tt> and <tt class="calibre22">(count numbers)</tt> expressions).</blockquote></li></ul><p class="calibre18">With this information, and recalling the semantics of lists as calls with the operator in function position, you should have a nearly complete understanding of how calls to this function are evaluated:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(average [60 80 100 400])<br class="calibre33"/>;= 160</tt></span></blockquote><p class="calibre23">The symbol <tt class="calibre22">average</tt> refers here to the value of <tt class="calibre22">#'average</tt>, the var in the current namespace that holds the function we defined. That function is called with a vector of numbers, which is locally bound as <tt class="calibre22">numbers</tt> within the body of the <tt class="calibre22">average</tt> function. The result of the operations in that body produce a value—<tt class="calibre22">160</tt>—which is then returned to the caller: in this case, the REPL, which prints it to <tt class="calibre22">stdout</tt>.</p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos121156"></a><a href="#filepos119932"><span class="calibre32">17</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">We’ll get into all the details of how to define functions and therefore their arguments in </span><a href="#filepos161395"><span class="calibre10"><span class="calibre5">Creating Functions: fn</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos121508" class="calibre6"><span class="calibre4"><span class="bold">Special Forms</span></span></p><p id="filepos121582" class="calibre18">Ignoring Java interoperability for a moment, symbols <a id="filepos121663"></a>in function position can evaluate to only two things:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">The value of a named var or local, as we’ve already seen.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">A Clojure <span class="italic">special form</span>.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos122061"></a><a href="#filepos199128"><span class="calibre32">18</span></a><span class="calibre32">]</span></small></sup></blockquote></li></ol><p class="calibre18">Special forms are Clojure’s primitive building blocks of computation, on top of which all the rest of Clojure is built. This foundation shares a lineage with the earliest Lisps, <a id="filepos122386"></a>which also defined a limited set of primitives that define the fundamental operations of the runtime, and are taken as sufficient to describe any possible computation.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos122595"></a><a href="#filepos199644"><span class="calibre32">19</span></a><span class="calibre32">]</span></small></sup> Further, special forms have their own syntax (e.g., many do not take arguments per se) and evaluation semantics.</p><p class="calibre18">As you’ve seen, things that are often described as primitive operations or statements in most languages—including control forms like <tt class="calibre22">when</tt> and operators like addition and negation—are not primitives in Clojure. Rather, everything that isn’t a special form is implemented in Clojure itself by bootstrapping from that limited set of primitive operations.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos123237"></a><a href="#filepos200345"><span class="calibre32">20</span></a><span class="calibre32">]</span></small></sup> The practical effect of this is that, if Clojure doesn’t provide a language construct that you want or need, you can likely build it yourself.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos123511"></a><a href="#filepos201145"><span class="calibre32">21</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">Though all of Clojure is built on top of its special forms, you need to understand what each one does—as you’ll use many of them constantly. Let’s now discuss each one in turn.</p><p id="filepos123823" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Suppressing Evaluation: quote</span></span></span></p><p class="calibre18"><tt class="calibre22">quote</tt>
<a id="filepos123985"></a>suppresses evaluation of a Clojure expression. The most obvious impact of this relates to symbols, which, if they name a var, evaluate to that var’s value. With <tt class="calibre22">quote</tt>, evaluation is suppressed, so symbols evaluate to themselves (just like strings, numbers, and so on):</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(quote x)<br class="calibre33"/>;= x<br class="calibre33"/>(symbol? (quote x))<br class="calibre33"/>;= true</tt></span></blockquote><p class="calibre23">There is reader syntax for <tt class="calibre22">quote</tt>; prefixing any form with a quote character (<tt class="calibre22">'</tt>) will expand into a usage of <tt class="calibre22">quote</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">'x<br class="calibre33"/>;= x</tt></span></blockquote><p class="calibre23">Any Clojure form can be quoted, including data structures. Doing so returns the data structure in question, with evaluation recursively suppressed for all of its elements:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">'(+ x x)<br class="calibre33"/>;= (+ x x)<br class="calibre33"/>(list? '(+ x x))<br class="calibre33"/>;= true</tt></span></blockquote><p class="calibre23">While lists <a id="filepos125098"></a>are usually evaluated as calls, quoting a list suppresses that evaluation, yielding the list itself; in this case, a list of three symbols: <tt class="calibre22">'+</tt>, <tt class="calibre22">'x</tt>, and <tt class="calibre22">'x</tt>. Note that this is exactly what we get if we “manually” construct the list without using a list literal:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(list '+ 'x 'x)<br class="calibre33"/>;= (+ x x)</tt></span></blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">TIP</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">You can usually have a peek at what the reader produces by quoting a form. Let’s go meta for a moment and try it first on quote itself:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">''x<br class="calibre33"/>;= (quote x)</tt></span></blockquote><blockquote class="calibre35"><span class="calibre10">It’s informative to use this trick on other reader sugars:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">'@x<br class="calibre33"/>;= (clojure.core/deref x)<br class="calibre33"/>'#(+ % %)<br class="calibre33"/>;= (fn* [p1__3162792#] (+ p1__3162792# p1__3162792#))<br class="calibre33"/>'`(a b ~c)<br class="calibre33"/>;= (seq (concat (list (quote user/a))<br class="calibre33"/>;=              (list (quote user/b))<br class="calibre33"/>;=              (list c)))                  </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/></blockquote><blockquote class="calibre38"><img src="images/00011.jpg" class="calibre36"/><span class="calibre10">
</span></blockquote><blockquote class="calibre37"><span class="calibre10"><tt class="calibre22">clojure.core</tt></span><span class="calibre10"> namespace-prefixes elided for legibility.</span></blockquote><p id="filepos126892" class="calibre25"><span class="calibre19"><span class="bold"><span class="calibre5">Code Blocks: do</span></span></span></p><p class="calibre18"><tt class="calibre22">do</tt>
<a id="filepos127037"></a>evaluates all of the expressions <a id="filepos127077"></a>provided to it in order and yields the last expression’s value as its value. For example:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(do<br class="calibre33"/>  (println "hi")<br class="calibre33"/>  (apply * [4 5 6]))<br class="calibre33"/>; hi<br class="calibre33"/>;= 120</tt></span></blockquote><p class="calibre23">The values of all but the last expression are discarded, although their side effects do occur (such as printing to standard out as we’re doing here, or manipulations of a stateful object available in the current scope).</p><p class="calibre18">Note that many other forms (including <tt class="calibre22">fn</tt>, <tt class="calibre22">let</tt>, <tt class="calibre22">loop</tt>, and <tt class="calibre22">try</tt>—and any derivative of these, such as <tt class="calibre22">defn</tt>) wrap their bodies in an implicit <tt class="calibre22">do</tt> expression,<a id="filepos127844"></a> so that multiple inner expressions can be evaluated. For example, <tt class="calibre22">let</tt> expressions—like this one that defines two locals—provide an implicit <tt class="calibre22">do</tt> context to their bodies:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [a (inc (rand-int 6))<br class="calibre33"/>      b (inc (rand-int 6))]<br class="calibre33"/>  (println (format "You rolled a %s and a %s" a b))<br class="calibre33"/>  (+ a b))</tt></span></blockquote><p class="calibre23">This allows any number of expressions to be evaluated within the context of the <tt class="calibre22">let</tt> form, with only the final one determining its ultimate result. If <tt class="calibre22">let</tt> didn’t wrap its body with a <tt class="calibre22">do</tt> form, you would have to add it explicitly:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos128615"></a><a href="#filepos201581"><span class="calibre32">22</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [a (inc (rand-int 6))<br class="calibre33"/>      b (inc (rand-int 6))]<br class="calibre33"/>  (do<br class="calibre33"/>    (println (format "You rolled a %s and a %s" a b))<br class="calibre33"/>    (+ a b)))</tt></span></blockquote><p id="filepos128989" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Defining Vars: def</span></span></span></p><p id="filepos129097" class="calibre18">We’ve already seen <tt class="calibre22">def</tt> in action;<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos129204"></a><a href="#filepos202089"><span class="calibre32">23</span></a><span class="calibre32">]</span></small></sup> it defines (or redefines) a var (with an optional value) within the current namespace:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def p "foo")<br class="calibre33"/>;= #'user/p<br class="calibre33"/>p<br class="calibre33"/>;= "foo"</tt></span></blockquote><p class="calibre23">Many other forms implicitly create or redefine vars, and therefore use <tt class="calibre22">def</tt> internally. It is customary for such forms to be prefixed with “def,” such as <tt class="calibre22">defn</tt>, <tt class="calibre22">defn-</tt>, <tt class="calibre22">defprotocol</tt>, <tt class="calibre22">defonce</tt>, <tt class="calibre22">defmacro</tt>, and so on.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Although forms that create or redefine vars have names that start with “def,” unfortunately not all forms that start with “def” create or redefine vars. Examples of the latter include </span><span class="calibre10"><tt class="calibre22">deftype</tt></span><span class="calibre10">, </span><span class="calibre10"><tt class="calibre22">defrecord</tt></span><span class="calibre10">, and </span><span class="calibre10"><tt class="calibre22">defmethod</tt></span><span class="calibre10">.</span></blockquote><p id="filepos130417" class="calibre25"><span class="calibre19"><span class="bold"><span class="calibre5">Local Bindings: let</span></span></span></p><p class="calibre18"><tt class="calibre22">let</tt>
<a id="filepos130567"></a>allows you to define named references that are lexically scoped to the extent of the <tt class="calibre22">let</tt> expression. Said another way, <tt class="calibre22">let</tt> defines locals. For example, this rudimentary static method in Java:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">public static double hypot (double x, double y) {<br class="calibre33"/>    final double x2 = x * x;<br class="calibre33"/>    final double y2 = y * y;<br class="calibre33"/>    return Math.sqrt(x2 + y2);<br class="calibre33"/>}</tt></span></blockquote><p class="calibre23">is equivalent to this Clojure function:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn hypot<br class="calibre33"/>  [x y]<br class="calibre33"/>  (let [x2 (* x x)<br class="calibre33"/>        y2 (* y y)]<br class="calibre33"/>    (Math/sqrt (+ x2 y2))))</tt></span></blockquote><p class="calibre23">The <tt class="calibre22">x2</tt> and <tt class="calibre22">y2</tt> locals in the respective function/method bodies serve the same purpose: to establish a named, scoped reference to an intermediate value.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">There are many terms used to talk about named references established by </span><span class="calibre10"><tt class="calibre22">let</tt></span><span class="calibre10"> in Clojure parlance:</span></blockquote><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17"><span class="calibre10"><span class="italic">locals</span></span></blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17"><span class="calibre10"><span class="italic">local bindings</span></span></blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17"><span class="calibre10">particular values are said to be </span><span class="calibre10"><span class="italic">let-bound</span></span></blockquote></li></ul><blockquote class="calibre17"><span class="calibre10"><span class="italic">Bindings</span></span><span class="calibre10"> and </span><span class="calibre10"><span class="italic">bound</span></span><span class="calibre10"> used in connection with </span><span class="calibre10"><tt class="calibre22">let</tt></span><span class="calibre10"> are entirely distinct from the </span><span class="calibre10"><tt class="calibre22">binding</tt></span><span class="calibre10"> macro, which controls scoped thread-local variables; see </span><a href="#filepos744558"><span class="calibre10"><span class="calibre5">Dynamic Scope</span></span></a><span class="calibre10"> for more about the latter.</span></blockquote><p class="calibre25">Note that <tt class="calibre22">let</tt> is implicitly used anywhere locals are required. In particular, <tt class="calibre22">fn</tt> (and therefore all other function-creation and function-definition forms like <tt class="calibre22">defn</tt>) uses <tt class="calibre22">let</tt> to bind function parameters as locals within the scope of the function being defined. For example, <tt class="calibre22">x</tt> and <tt class="calibre22">y</tt> in the <tt class="calibre22">hypot</tt> function above are let-bound by <tt class="calibre22">defn</tt>. So, the vector that defines the set of bindings for a <tt class="calibre22">let</tt> scope obeys the same semantics whether it is used to define function parameters or an auxiliary local binding scope.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Occasionally, you will want evaluate an expression in the binding vector provided to </span><span class="calibre10"><tt class="calibre22">let</tt></span><span class="calibre10">, but have no need to refer to its result within the context of the </span><span class="calibre10"><tt class="calibre22">let</tt></span><span class="calibre10">’s body. In these cases, it is customary to use an underscore as the bound name for such values, so that readers of the code will know that results of such expressions are going unused intentionally.</span><a id="filepos134226"></a></blockquote><blockquote class="calibre17"><span class="calibre10">This is only ever relevant when the expression in question is side-effecting; a common example would be printing some intermediate value:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(let [location (get-lat-long)<br class="calibre33"/>      _ (println "Current location:" location)<br class="calibre33"/>      location (find-city-name location)]<br class="calibre33"/>  …display city name for current location in UI…)</tt></span></blockquote><blockquote class="calibre35"><span class="calibre10">Here we’re retrieving our current latitude and longitude using a hypothetical API, and we’d like to print that out before converting the location data to a human-recognizable city name. We might want to rebind the same name a couple of times in the course of the </span><span class="calibre10"><tt class="calibre22">let</tt></span><span class="calibre10">’s binding vector, paving over those intermediate values. To print out that intermediate value, we add it to the binding vector prior to rebinding its name, but we indicate that we are intentionally ignoring the return value of that expression by naming it </span><span class="calibre10"><tt class="calibre22">_</tt></span><span class="calibre10">.</span></blockquote><p class="calibre25"><tt class="calibre22">let</tt> has two particular semantic wrinkles that are very different from locals you may be used to in other languages:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">All locals are <span class="italic">immutable</span>. You can <span class="italic">override</span> a local binding within a nested <tt class="calibre22">let</tt> form or a later binding of the same name within the same binding vector, but there is no way to bash out a bound name and change its value within the scope of a single <tt class="calibre22">let</tt> form. This eliminates a source of common errors and bugs without sacrificing capability:</blockquote><ul class="calibre55"><li value="1" class="calibre16"><blockquote class="calibre17">The <tt class="calibre22">loop</tt> and <tt class="calibre22">recur</tt> special forms provide for looping cases where values need to change on each cycle of a loop; see <a href="#filepos184954"><span class="calibre5">Looping: loop and recur</span></a>.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">If you really need a “mutable” local binding, Clojure provides a raft of reference types that enforce specific mutation semantics; see <a href="#filepos636143"><span class="calibre5">Clojure Reference Types</span></a>.</blockquote></li></ul></li><a id="filepos136784"></a><li value="2" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">let</tt>’s binding vector is interpreted at compile time to provide optional <span class="italic">destructuring</span> of common collection types. Destructuring can aid substantially in eliminating certain types of verbose (and frankly, dull) code often associated with working with collections provided as arguments to functions.</blockquote></li><a id="filepos137200"></a></ol><div class="mbppagebreak"></div><p id="filepos137243" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Destructuring (let, Part 2)</span></span></span></p><p id="filepos137360" class="calibre18">A lot of Clojure programming involves working with various implementations of data structure abstractions, <span class="italic">sequential</span><a id="filepos137512"></a> and <span class="italic">map</span> collections <a id="filepos137547"></a>being two of those key abstractions. Many Clojure functions accept and return seqs and maps generally—rather than specific implementations—and most Clojure libraries and applications are built up relying upon these abstractions <a id="filepos137786"></a>instead of particular concrete structures, classes, and so on. This allows functions and libraries to be trivially composed around the data being handled with a minimum of integration, “glue code,” and other incidental complexity.</p><p class="calibre18">One challenge when working with abstract collections is being able to concisely access multiple values in those collections. For example, here’s a collection, a Clojure vector:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def v [42 "foo" 99.2 [5 12]])<br class="calibre33"/>;= #'user/v</tt></span></blockquote><p class="calibre23">Consider a couple of approaches for accessing the values in our sample vector:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(first v)    </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= 42<br class="calibre33"/>(second v)<br class="calibre33"/>;= "foo"<br class="calibre33"/>(last v)<br class="calibre33"/>;= [5 12]<br class="calibre33"/>(nth v 2)    </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= 99.2<br class="calibre33"/>(v 2)        </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= 99.2<br class="calibre33"/>(.get v 2)   </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= 99.2</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Clojure provides convenience functions <a id="filepos139417"></a>for accessing the <tt class="calibre22">first</tt>, <tt class="calibre22">second</tt>, and <tt class="calibre22">last</tt> values from a sequential collection.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">The <tt class="calibre22">nth</tt> function allows you pluck any value from a sequential collection using an index into that collection.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">Vectors <a id="filepos139957"></a>are functions of their indices.</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">All of Clojure’s sequential collections implement the <tt class="calibre22">java.util.List</tt> interface,<a id="filepos140236"></a> so you can use that interface’s <tt class="calibre22">.get</tt> method to access their contents.</blockquote><p class="calibre18">All of these are perfectly fine ways to access a single “top-level” value in a vector, but things start getting more complex if we need to access multiple values to perform some operation:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(+ (first v) (v 2))<br class="calibre33"/>;= 141.2</tt></span></blockquote><p class="calibre23">Or if we need to access values in nested collections:<a id="filepos140764"></a></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(+ (first v) (first (last v)))<br class="calibre33"/>;= 47</tt></span></blockquote><p class="calibre23">Clojure destructuring <a id="filepos140956"></a>provides a concise syntax for declaratively pulling apart collections and binding values contained therein as named locals within a <tt class="calibre22">let</tt> form. And, because destructuring is a facility provided by <tt class="calibre22">let</tt>, it can be used in any expression that implicitly uses <tt class="calibre22">let</tt> (like <tt class="calibre22">fn</tt>, <tt class="calibre22">defn</tt>, <tt class="calibre22">loop</tt>, and so on).</p><p class="calibre18">There are two flavors of destructuring: one that operates over sequential collections, and another that works with maps.</p><p id="filepos141464" class="calibre23"><span class="calibre53"><span class="bold">Sequential destructuring</span></span></p><p id="filepos141549" class="calibre18">Sequential destructuring works with any sequential collection, including:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Clojure lists, vectors, and seqs</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Any collection that implements <tt class="calibre22">java.util.List</tt> (like <tt class="calibre22">ArrayList</tt>s and <tt class="calibre22">LinkedList</tt>s)</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Java arrays</blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17">Strings, which are destructured into their characters</blockquote></li></ul><p class="calibre18">Here’s a basic example, where we are destructuring the same value <tt class="calibre22">v</tt> discussed above:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 1-3. Basic sequential destructuring</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(def v [42 "foo" 99.2 [5 12]])<br class="calibre33"/>;= #'user/v<br class="calibre33"/>(let [[x y z] v]<br class="calibre33"/>  (+ x z))<br class="calibre33"/>;= 141.2</tt></span></p><p class="calibre13">In its simplest form, the vector provided to <tt class="calibre22">let</tt> contains pairs of names and values, but here we’re providing a vector of symbols—<tt class="calibre22">[x y z]</tt>—instead of a scalar symbol name. What this does is cause the value <tt class="calibre22">v</tt> to be destructured sequentially, with the first value bound to <tt class="calibre22">x</tt> within the body of the <tt class="calibre22">let</tt> form, the second value bound to <tt class="calibre22">y</tt>, and the third value bound to <tt class="calibre22">z</tt>. We can then use those destructured locals like any other locals.<a id="filepos143237"></a> This is equivalent to:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [x (nth v 0)<br class="calibre33"/>      y (nth v 1)<br class="calibre33"/>      z (nth v 2)]<br class="calibre33"/>  (+ x z))<br class="calibre33"/>;= 141.2</tt></span></blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Python has something similar to Clojure’s sequential destructuring, called </span><a id="filepos143746"></a><span class="calibre10"><span class="italic">unpacking</span></span><a id="filepos143791"></a><span class="calibre10">. The equivalent to the preceding code snippet in Python would be something like:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">&gt;&gt;&gt; v = [42, "foo", 99.2, [5, 12]]<br class="calibre33"/>&gt;&gt;&gt; x, y, z, a = v<br class="calibre33"/>&gt;&gt;&gt; x + z<br class="calibre33"/>141.19999999999999</tt></span></blockquote><blockquote class="calibre35"><span class="calibre10">The same goes for Ruby:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">&gt;&gt; x, y, z, a = [42, "foo", 99.2, [5, 12]]<br class="calibre33"/>[42, "foo", 99.2, [5, 12]]<br class="calibre33"/>&gt;&gt; x + z<br class="calibre33"/>141.2</tt></span></blockquote><blockquote class="calibre35"><span class="calibre10">Clojure, Python, and Ruby all seem pretty similar on their face; but, as you’ll see as we go along, Clojure goes quite a long ways beyond what Python and Ruby offer.</span></blockquote><p class="calibre25">Destructuring forms are intended to mirror the structure of the collection that is being bound.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos144854"></a><a href="#filepos202715"><span class="calibre32">24</span></a><span class="calibre32">]</span></small></sup> So, we can line up our destructuring form with the collection being destructured and get a very accurate notion of which values are going to be bound to which names:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos145149"></a><a href="#filepos203082"><span class="calibre32">25</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">[x  y     z]<br class="calibre33"/>[42 "foo" 99.2 [5 12]]</tt></span></blockquote><p class="calibre23">Destructuring forms can be composed as well, so we can dig into the nested vector in <tt class="calibre22">v</tt> with ease:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos145551"></a><a href="#filepos203612"><span class="calibre32">26</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [[x _ _ [y z]] v]<br class="calibre33"/>  (+ x y z))<br class="calibre33"/>;= 59</tt></span></blockquote><p class="calibre23">If we visually line up our destructuring form and the source vector again, the work being done by that form should again be very clear:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">[x  _     _    [y z ]]<br class="calibre33"/>[42 "foo" 99.2 [5 12]]</tt></span></blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">If our nested vector had a vector inside of it, we could destructure it as well. The destructuring mechanism has no limit to how far it can descend into a deeply nested data structure, but there are limits to good taste. If you’re using destructuring to pull values out of a collection four or more levels down, chances are your destructuring form will be difficult to interpret for the next person to see that code—even if that next person is you!</span><a id="filepos146756"></a></blockquote><p class="calibre25">There are two additional features of sequential destructuring forms you should know about:</p><p class="calibre23">Gathering extra-positional sequential values</p><blockquote id="filepos146974" class="calibre17">You can use <tt class="calibre22">&amp;</tt>
<a id="filepos147038"></a>to gather values that lay beyond the positions you’ve named in your destructuring form into a sequence; this is similar to the mechanism underlying varargs in Java methods and is the basis of <tt class="calibre22">rest</tt> arguments<a id="filepos147262"></a> in Clojure functions:<a id="filepos147291"></a></blockquote><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [[x &amp; rest] v]<br class="calibre33"/>  rest)<br class="calibre33"/>;= ("foo" 99.2 [5 12])</tt></span></blockquote><blockquote class="calibre35">This is particularly useful when processing items from a sequence, either via recursive function calls or in conjunction with a <tt class="calibre22">loop</tt> form. Notice that the value of <tt class="calibre22">rest</tt> here is a sequence, and <span class="italic">not</span> a vector, even though we provided a vector to the destructuring form.</blockquote><p class="calibre23">Retaining the destructured value</p><blockquote class="calibre17">You can establish a local binding <a id="filepos147948"></a>for the original collection being destructured by specifying the name it should have via the <tt class="calibre22">:as</tt> option within the destructuring form:</blockquote><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [[x _ z :as original-vector] v]<br class="calibre33"/>  (conj original-vector (+ x z)))<br class="calibre33"/>;= [42 "foo" 99.2 [5 12] 141.2]</tt></span></blockquote><blockquote class="calibre35">Here, <tt class="calibre22">original-vector</tt> is bound to the unchanged value of <tt class="calibre22">v</tt>. This comes in handy when you are destructuring a collection that is the result of a function call, but you need to retain a reference to that unaltered result in addition to having the benefit of destructuring it. Without this feature, doing so would require something like this:<a id="filepos148722"></a></blockquote><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [some-collection (some-function …)<br class="calibre33"/>      [x y z [a b]] some-collection]<br class="calibre33"/>  …do something with some-collection and its values…)</tt></span></blockquote><p id="filepos148997" class="calibre23"><span class="calibre53"><span class="bold">Map destructuring</span></span></p><p id="filepos149075" class="calibre18">Map destructuring is conceptually identical to sequential destructuring—we aim to mirror the structure of the collection being bound. It works with:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Clojure <tt class="calibre22">hash-map</tt>s, <tt class="calibre22">array-map</tt>s, and records<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos149468"></a><a href="#filepos204014"><span class="calibre32">27</span></a><span class="calibre32">]</span></small></sup></blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Any collection that implements <tt class="calibre22">java.util.Map</tt></blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Any value that is supported by the <tt class="calibre22">get</tt> function can be map-destructured, using indices as keys:</blockquote><ul class="calibre55"><li value="1" class="calibre16"><blockquote class="calibre17">Clojure vectors</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Strings</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Arrays</blockquote></li></ul></li></ul><p class="calibre18">Let’s start with a Clojure map and a basic destructuring of it:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def m {:a 5 :b 6<br class="calibre33"/>        :c [7 8 9]<br class="calibre33"/>        :d {:e 10 :f 11}<br class="calibre33"/>        "foo" 88<br class="calibre33"/>        42 false})<br class="calibre33"/>;= #'user/m<br class="calibre33"/>(let [{a :a b :b} m]<br class="calibre33"/>  (+ a b))<br class="calibre33"/>;= 11</tt></span></blockquote><p class="calibre23">Here we’re binding the value for <tt class="calibre22">:a</tt> in the map to <tt class="calibre22">a</tt>, and the value for <tt class="calibre22">:b</tt> in the map to <tt class="calibre22">b</tt>. Going back to our visual alignment of the destructuring form with the (in this case, partial) collection being destructured, we can again see the structural correspondence:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">{a  :a b  :b}<br class="calibre33"/>{:a 5  :b 6}</tt></span></blockquote><p class="calibre23">Note that there is no requirement that the keys <a id="filepos151253"></a>used for map lookups in destructuring be keywords; any type of value may be used for lookup:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [{f "foo"} m]<br class="calibre33"/>  (+ f 12))<br class="calibre33"/>;= 100<br class="calibre33"/>(let [{v 42} m]<br class="calibre33"/>  (if v 1 0))<br class="calibre33"/>;= 0</tt></span></blockquote><p class="calibre23">Indices <a id="filepos151602"></a>into vectors, strings, and arrays can be used as keys in a map destructuring form.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos151726"></a><a href="#filepos204337"><span class="calibre32">28</span></a><span class="calibre32">]</span></small></sup> One place where this can be helpful is if you are representing matrices <a id="filepos151893"></a>by using vectors, but only need a couple of values from one. Using map destructuring to pull out two or three values from a 3×3 matrix can be much easier than using a potentially nine-element sequential destructuring form:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [{x 3 y 8} [12 0 0 -18 44 6 0 0 1]]<br class="calibre33"/>  (+ x y))<br class="calibre33"/>;= -17</tt></span></blockquote><p class="calibre23">Just as sequential destructuring forms could be composed, so can the map variety:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [{{e :e} :d} m]<br class="calibre33"/> (* 2 e))<br class="calibre33"/>;= 20</tt></span></blockquote><p class="calibre23">The outer map destructuring—<a id="filepos152612"></a><tt class="calibre22">{{e :e} :d}</tt>—is acting upon the top-level source collection <tt class="calibre22">m</tt> to pull out the value mapped to <tt class="calibre22">:d</tt>. The inner map destructuring—<a id="filepos152775"></a><tt class="calibre22">{e :e}</tt>—is acting on the value mapped to <tt class="calibre22">:d</tt> to pull out its value for <tt class="calibre22">:e</tt>.</p><p class="calibre18">The <span class="italic">coup de grâce</span> is the composition of both map and sequential destructuring, however they are needed to effectively extract the values you need from the collections at hand:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [{[x _ y] :c} m]<br class="calibre33"/>  (+ x y))<br class="calibre33"/>;= 16<br class="calibre33"/>(def map-in-vector ["James" {:birthday (java.util.Date. 73 1 6)}])<br class="calibre33"/>;= #'user/map-in-vector<br class="calibre33"/>(let [[name {bd :birthday}] map-in-vector]<br class="calibre33"/>  (str name " was born on " bd))<br class="calibre33"/>;= "James was born on Thu Feb 06 00:00:00 EST 1973"</tt></span></blockquote><p class="calibre23">Map destructuring also has some additional features.</p><p class="calibre18"><span class="bold">Retaining the destructured value</span>. Just like sequential destructuring, adding an <tt class="calibre22">:as</tt><a id="filepos153749"></a> pair to the destructuring form to hold a reference to the source collection, which you can use like any other <tt class="calibre22">let</tt>-bound value:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [{r1 :x r2 :y :as randoms}<br class="calibre33"/>      (zipmap [:x :y :z] (repeatedly (partial rand-int 10)))]<br class="calibre33"/>  (assoc randoms :sum (+ r1 r2)))<br class="calibre33"/>;= {:sum 17, :z 3, :y 8, :x 9}</tt></span></blockquote><p class="calibre23"><span class="bold">Default values</span>. You can use an <tt class="calibre22">:or</tt><a id="filepos154272"></a> pair to provide a defaults map; if a key specified in the destructuring form is not available in the source collection, then the defaults map will be consulted:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [{k :unknown x :a<br class="calibre33"/>       :or {k 50}} m]<br class="calibre33"/>  (+ k x))<br class="calibre33"/>;= 55</tt></span></blockquote><p class="calibre23">This allows you to avoid either merging the source map into a defaults map ahead of its destructuring, or manually setting defaults on destructured bindings that have <tt class="calibre22">nil</tt> values in the source collection, which would get <span class="italic">very</span> tiresome beyond one or two bindings with desired default values:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [{k :unknown x :a} m<br class="calibre33"/>      k (or k 50)]<br class="calibre33"/>  (+ k x))<br class="calibre33"/>;= 55</tt></span></blockquote><p class="calibre23">Furthermore, and unlike the code in the above example, <tt class="calibre22">:or</tt> knows the difference between no value and a false (<tt class="calibre22">nil</tt> or <tt class="calibre22">false</tt>) value:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [{opt1 :option} {:option false}<br class="calibre33"/>      opt1 (or opt1 true)<br class="calibre33"/>      {opt2 :option :or {opt2 true}} {:option false}]<br class="calibre33"/>  {:opt1 opt1 :opt2 opt2})<br class="calibre33"/>;= {:opt1 true, :opt2 false}</tt></span></blockquote><p class="calibre23"><span class="bold">Binding values to their keys’ names</span>. <a id="filepos155734"></a>There are often stable names for various values in maps, and it’s often desirable to bind those values by using the same names in the scope of the <tt class="calibre22">let</tt> form as they are mapped to in the source map. However, doing this using “vanilla” map destructuring can get very repetitive:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def chas {:name "Chas" :age 31 :location "Massachusetts"})<br class="calibre33"/>;= #'user/chas<br class="calibre33"/>(let [{name :name age :age location :location} chas]<br class="calibre33"/>  (format "%s is %s years old and lives in %s." name age location))<br class="calibre33"/>;= "Chas is 31 years old and lives in Massachusetts."</tt></span></blockquote><p class="calibre23">Having to type the content of each key twice is decidedly contrary to the spirit of destructuring’s concision. In such cases, you can use the <tt class="calibre22">:keys</tt>, <tt class="calibre22">:strs</tt>, and <tt class="calibre22">:syms</tt> options to specify keyword, string, and symbol keys (respectively) into the source map and the names the corresponding values should be bound to in the <tt class="calibre22">let</tt> form without repetition. Our sample map uses keywords for keys, so we’ll use <tt class="calibre22">:keys</tt> for it:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [{:keys [name age location]} chas]<br class="calibre33"/>  (format "%s is %s years old and lives in %s." name age location))<br class="calibre33"/>;= "Chas is 31 years old and lives in Massachusetts."</tt></span></blockquote><p class="calibre23">…and switch to using <tt class="calibre22">:strs</tt> or <tt class="calibre22">:syms</tt> when we know that the source collection is using strings or symbols for keys:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def brian {"name" "Brian" "age" 31 "location" "British Columbia"})<br class="calibre33"/>;= #'user/brian<br class="calibre33"/>(let [{:strs [name age location]} brian]<br class="calibre33"/>  (format "%s is %s years old and lives in %s." name age location))<br class="calibre33"/>;= "Brian is 31 years old and lives in British Columbia."<br class="calibre33"/><br class="calibre33"/>(def christophe {'name "Christophe" 'age 33 'location "Rhône-Alpes"})<br class="calibre33"/>;= #'user/christophe<br class="calibre33"/>(let [{:syms [name age location]} christophe]<br class="calibre33"/>  (format "%s is %s years old and lives in %s." name age location))<br class="calibre33"/>;= "Christophe is 31 years old and lives in Rhône-Alpes."</tt></span></blockquote><p class="calibre23">You will likely find yourself using <tt class="calibre22">:keys</tt> more than <tt class="calibre22">:strs</tt> or <tt class="calibre22">:syms</tt>; keyword keys are by far the most common key type in Clojure maps and <a href="#filepos170968">keyword arguments</a>, and are the general-purpose accessor by dint of their usage in conjunction with records.</p><p id="filepos158459" class="calibre18"><span class="bold">Destructuring rest sequences as map key/value pairs</span>. <a id="filepos158548"></a>We’ve already seen how extra-positional values in sequential destructuring forms can be gathered into a “rest” seq, and map and sequential destructuring can be composed as needed to drill into any given data structure. Here’s a simple case of a vector that contains some positional values, followed by a set of key/value pairs:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def user-info ["robert8990" 2011 :name "Bob" :city "Boston"])<br class="calibre33"/>;= #'user/user-info</tt></span></blockquote><p class="calibre23">Data like this isn’t uncommon, and handling it is rarely elegant. The “manual” approach in Clojure is tolerable as these things go:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [[username account-year &amp; extra-info] user-info     </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>      {:keys [name city]} (apply hash-map extra-info)]   </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  (format "%s is in %s" name city))<br class="calibre33"/>;= "Bob is in Boston"</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">We can destructure the original vector into its positional elements, gathering the remainder into a rest seq.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">That rest seq, consisting of alternating keys and values, can be used as the basis for creating a new hashmap, which we can then destructure as we wish.</blockquote><p class="calibre18">However, “tolerable” isn’t a very high bar given the prevalence of sequences of key/value pairs in programming. A better alternative is a special variety of the compositional behavior offered by <tt class="calibre22">let</tt>’s destructuring forms: map destructuring of rest seqs. If a rest seq has an even number of values—semantically, key/value pairs—then it can be destructured as a map of those key/value pairs instead of sequentially:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [[username account-year &amp; {:keys [name city]}] user-info]<br class="calibre33"/>  (format "%s is in %s" name city))<br class="calibre33"/>;= "Bob is in Boston"</tt></span></blockquote><p class="calibre23">That is a far cleaner notation for doing exactly the same work as us manually building a <tt class="calibre22">hash-map</tt> out of the rest seq and destructuring that map, and is the basis of Clojure functions’ optional keyword arguments described in <a href="#filepos170968"><span class="calibre5">“Keyword arguments”</span></a>.<a id="filepos161384"></a></p><p id="filepos161395" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Creating Functions: fn</span></span></span></p><p id="filepos161507" class="calibre18">Functions are first-class values in Clojure; creating them falls to the <tt class="calibre22">fn</tt> special form, which also folds in the semantics of <tt class="calibre22">let</tt> and <tt class="calibre22">do</tt>.</p><p class="calibre18">Here is a simple function that adds <tt class="calibre22">10</tt> to the number provided as an argument:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(fn [x]     </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  (+ 10 x)) </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">fn</tt> accepts a <tt class="calibre22">let</tt>-style binding vector that defines the names and numbers of arguments accepted by the function; the same optional destructuring forms discussed in <a href="#filepos137243"><span class="calibre5">Destructuring (let, Part 2)</span></a> can be applied to each argument here.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">The forms following the binding vector constitute the <span class="italic">body</span> of the function. This body is placed in an implicit <tt class="calibre22">do</tt> form, so each function’s body may contain any number of forms; as with <tt class="calibre22">do</tt>, the last form in the body supplies the result of the function call that is returned to the caller.</blockquote><p class="calibre18">The arguments to a function are matched to each name or destructuring form based on their positions in the calling form. So in this call:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">((fn [x] (+ 10 x)) 8)<br class="calibre33"/>;= 18</tt></span></blockquote><p class="calibre23"><tt class="calibre22">8</tt> is the sole argument to the function, and it is bound to the name <tt class="calibre22">x</tt> within the body of the function. This makes the function call the equivalent of this <tt class="calibre22">let</tt> form:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [x 8]<br class="calibre33"/>  (+ 10 x))</tt></span></blockquote><p class="calibre23">You can define functions <a id="filepos163728"></a>that accept multiple arguments:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">((fn [x y z] (+ x y z))<br class="calibre33"/> 3 4 12)<br class="calibre33"/>;= 19</tt></span></blockquote><p class="calibre23">In this case, the function call is the equivalent of this <tt class="calibre22">let</tt> form:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [x 3<br class="calibre33"/>      y 4<br class="calibre33"/>      z 12]<br class="calibre33"/>  (+ x y z))</tt></span></blockquote><p class="calibre23">Functions with <span class="italic">multiple arities</span><a id="filepos164260"></a> can be created as well; here, we’ll put the function in a <tt class="calibre22">var</tt> so we can call it multiple times by only referring to the <tt class="calibre22">var</tt>’s name:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def strange-adder (fn adder-self-reference<br class="calibre33"/>                     ([x] (adder-self-reference x 1))<br class="calibre33"/>                     ([x y] (+ x y))))<br class="calibre33"/>;= #'user/strange-adder<br class="calibre33"/>(strange-adder 10)<br class="calibre33"/>;= 11<br class="calibre33"/>(strange-adder 10 50)<br class="calibre33"/>;= 60</tt></span></blockquote><p class="calibre23">When defining a function with multiple arities, each arity’s binding vector and implementation body must be enclosed within a pair of parentheses. Function calls dispatch based on argument count; the proper arity is selected based on the number of arguments that we provide in our call.</p><p class="calibre18">In this last example, notice the optional name that we’ve given to the function, <tt class="calibre22">adder-self-reference</tt>. This optional first argument to <tt class="calibre22">fn</tt> can be used within the function’s bodies to refer to itself—in this case, so that the single-argument arity can call the two-argument arity with a default second argument without referring to or requiring any containing var.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">MUTUALLY RECURSIVE FUNCTIONS WITH LETFN</span></span></span></blockquote><blockquote id="filepos165731" class="calibre17"><span class="calibre10">Named </span><span class="calibre10"><tt class="calibre22">fn</tt></span><span class="calibre10">s (like the above </span><span class="calibre10"><tt class="calibre22">adder-self-reference</tt></span><span class="calibre10">) allow you to easily create self-recursive functions. What is more tricky is to create </span><span class="calibre10"><span class="italic">mutually</span></span><span class="calibre10"> recursive functions.</span></blockquote><blockquote class="calibre17"><span class="calibre10">For such rare cases, there is the </span><span class="calibre10"><tt class="calibre22">letfn</tt></span><span class="calibre10"> special form, which allows you to define several named functions at once, and all these functions will know each other. Consider these naive reimplementations of </span><span class="calibre10"><tt class="calibre22">odd?</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">even?</tt></span><span class="calibre10">:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(letfn [(odd? [n]<br class="calibre33"/>          (even? (dec n)))<br class="calibre33"/>        (even? [n]<br class="calibre33"/>          (or (zero? n)<br class="calibre33"/>            (odd? (dec n))))]  </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre21"><tt class="calibre22"><br class="calibre33"/>  (odd? 11))<br class="calibre33"/>;= true</tt></span></blockquote><blockquote class="calibre38"><img src="images/00011.jpg" class="calibre36"/><span class="calibre10">
</span></blockquote><blockquote class="calibre37"><span class="calibre10">The vector consists of several regular </span><span class="calibre10"><tt class="calibre22">fn</tt></span><span class="calibre10"> bodies, only the </span><span class="calibre10"><tt class="calibre22">fn</tt></span><span class="calibre10"> symbol is missing.</span></blockquote><p class="calibre25"><span class="bold">defn builds on fn</span>. <a id="filepos167455"></a>We’ve already seen <tt class="calibre22">defn</tt> used before, and the example above should look familiar; <tt class="calibre22">defn</tt> is a macro that encapsulates the functionality of <tt class="calibre22">def</tt> and <tt class="calibre22">fn</tt> so that you can concisely define functions that are named and registered in the current namespace with a given name. For example, these two definitions are equivalent:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def strange-adder (fn strange-adder<br class="calibre33"/>                     ([x] (strange-adder x 1))<br class="calibre33"/>                     ([x y] (+ x y))))<br class="calibre33"/><br class="calibre33"/>(defn strange-adder<br class="calibre33"/>  ([x] (strange-adder x 1))<br class="calibre33"/>  ([x y] (+ x y))))</tt></span></blockquote><p class="calibre23">and single-arity functions <a id="filepos168257"></a>can be defined, with the additional parentheses eliminated as well; these two definitions are also equivalent:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def redundant-adder (fn redundant-adder<br class="calibre33"/>                       [x y z]<br class="calibre33"/>                       (+ x y z)))<br class="calibre33"/><br class="calibre33"/>(defn redundant-adder<br class="calibre33"/>  [x y z]<br class="calibre33"/>  (+ x y z))</tt></span></blockquote><p class="calibre23">We’ll largely use <tt class="calibre22">defn</tt> forms to illustrate <tt class="calibre22">fn</tt> forms for the rest of this section, simply because calling functions bound to named vars is easier to read than continually defining the functions to be called inline.</p><p id="filepos168988" class="calibre23"><span class="calibre53"><span class="bold">Destructuring function arguments</span></span></p><p class="calibre18"><tt class="calibre22">defn</tt>
<a id="filepos169123"></a>supports the destructuring of function arguments thanks to it reusing <tt class="calibre22">let</tt> for binding function arguments for the scope of a function’s body. You should refer to the prior comprehensive discussion of destructuring to remind yourself of the full range of options available; here, we’ll discuss just a couple of destructuring idioms that are particularly common in conjunction with functions.</p><p id="filepos169536" class="calibre18"><span class="bold">Variadic functions</span>. <a id="filepos169592"></a>Functions can optionally gather all additional arguments used in calls to it into a seq; this uses the same mechanism as sequential destructuring does when gathering additional values into a seq. Such functions are called <span class="italic">variadic</span>, with the gathered arguments usually called <span class="italic">rest arguments</span><a id="filepos169902"></a> or <span class="italic">varargs</span>. Here’s a function that accepts one named positional argument, but gathers all additional arguments into a remainder seq:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn concat-rest<br class="calibre33"/>  [x &amp; rest]<br class="calibre33"/>  (apply str (butlast rest)))<br class="calibre33"/>;= #'user/concat-rest<br class="calibre33"/>(concat-rest 0 1 2 3 4)<br class="calibre33"/>;= "123"</tt></span></blockquote><p class="calibre23">The seq formed for the rest arguments can be destructured just like any other sequence; here we’re destructuring rest arguments to make a function behave as if it had an explicitly defined zero-arg arity:<a id="filepos170546"></a></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn make-user<br class="calibre33"/>  [&amp; [user-id]]<br class="calibre33"/>  {:user-id (or user-id<br class="calibre33"/>              (str (java.util.UUID/randomUUID)))})<br class="calibre33"/>;= #'user/make-user<br class="calibre33"/>(make-user)<br class="calibre33"/>;= {:user-id "ef165515-6d6f-49d6-bd32-25eeb024d0b4"}<br class="calibre33"/>(make-user "Bobby")<br class="calibre33"/>;= {:user-id "Bobby"}</tt></span></blockquote><p id="filepos170968" class="calibre23"><span class="bold">Keyword arguments</span>. <a id="filepos171023"></a>It is often the case that you would like to define a function that can accept many arguments, some of which might be optional and some of which might have defaults. Further, you would often like to avoid forcing a particular argument ordering upon callers.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos171321"></a><a href="#filepos205011"><span class="calibre32">29</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18"><tt class="calibre22">fn</tt> (and therefore <tt class="calibre22">defn</tt>) provides support for such use cases through <span class="italic">keyword arguments</span>, which is an idiom built on top of the <a href="#filepos158459">map destructuring of rest sequences</a> that <tt class="calibre22">let</tt> provides. Keyword arguments are pairs of keywords and values appended to any strictly positional arguments in a function call, and if the function was defined to accept keyword arguments, those keyword/value pairs will be gathered into a map and destructured by the function’s map destructuring form that is placed in the same position as the <a href="#filepos169536">rest arguments</a> seq:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn make-user<br class="calibre33"/>  [username &amp; {:keys [email join-date]                </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>               :or {join-date (java.util.Date.)}}]    </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  {:username username<br class="calibre33"/>   :join-date join-date<br class="calibre33"/>   :email email<br class="calibre33"/>   ;; 2.592e9 -&gt; one month in ms<br class="calibre33"/>   :exp-date (java.util.Date. (long (+ 2.592e9 (.getTime join-date))))})<br class="calibre33"/>;= #'user/make-user<br class="calibre33"/>(make-user "Bobby")                                   </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= {:username "Bobby", :join-date #&lt;Date Mon Jan 09 16:56:16 EST 2012&gt;,<br class="calibre33"/>;=  :email nil, :exp-date #&lt;Date Wed Feb 08 16:56:16 EST 2012&gt;}<br class="calibre33"/>(make-user "Bobby"                                    </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  :join-date (java.util.Date. 111 0 1)<br class="calibre33"/>  :email "bobby@example.com")<br class="calibre33"/>;= {:username "Bobby", :join-date #&lt;Date Sun Jan 01 00:00:00 EST 2011&gt;,<br class="calibre33"/>;=  :email "bobby@example.com", :exp-date #&lt;Date Tue Jan 31 00:00:00 EST 2011&gt;}</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">The <tt class="calibre22">make-user</tt> function strictly requires only one argument, a username. The rest of the arguments are assumed to be keyword/value pairs, gathered into a map, and then destructured using the map destructuring form following <tt class="calibre22">&amp;</tt>.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">In the map destructuring form, we define a default of “now” for the <tt class="calibre22">join-date</tt> value.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">Calling <tt class="calibre22">make-user</tt> with a single argument returns the user map, populated with defaulted join- and expiration-date values and a <tt class="calibre22">nil</tt> email value since none was provided in the keyword arguments.</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">Additional arguments provided to <tt class="calibre22">make-user</tt> are interpreted by the keyword destructuring map, without consideration of their order.</blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Because keyword arguments are built using </span><span class="calibre10"><tt class="calibre22">let</tt></span><span class="calibre10">’s map destructuring, there’s nothing stopping you from destructuring the rest argument map using types of key values besides keywords (such as strings or numbers or even collections). For example:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(defn foo<br class="calibre33"/>  [&amp; {k ["m" 9]}]<br class="calibre33"/>  (inc k))<br class="calibre33"/>;= #'user/foo<br class="calibre33"/>(foo ["m" 9] 19)<br class="calibre33"/>;= 20</tt></span></blockquote><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">["m" 9]</tt></span><span class="calibre10"> is being treated here as the name of a “keyword” argument.</span></blockquote><blockquote class="calibre17"><span class="calibre10">That said, we’ve never actually seen non-keyword key types used in named function arguments. Keywords are overwhelmingly the most common argument key type used, thus the use of </span><span class="calibre10"><span class="italic">keyword arguments</span></span><span class="calibre10"> to describe the idiom.</span></blockquote><p class="calibre25"><span class="bold">Pre- and postconditions</span>. <tt class="calibre22">fn</tt> provides support for pre- and postconditions <a id="filepos176353"></a>for performing assertions with function arguments and return values. They are valuable features when testing and for generally enforcing function invariants; we discuss them in <a href="#filepos1750353"><span class="calibre5">Preconditions and Postconditions</span></a>.<a id="filepos176625"></a></p><p id="filepos176636" class="calibre23"><span class="calibre53"><span class="bold">Function literals</span></span></p><p class="calibre18">We mentioned function literals briefly in <a href="#filepos103135"><span class="calibre5">Miscellaneous Reader Sugar</span></a>. Equivalent to blocks <a id="filepos176888"></a>in Ruby and <tt class="calibre22">lambda</tt>s <a id="filepos176924"></a>in Python, Clojure function literals’ role is straightforward: when you need to define an anonymous function—especially a very simple function—they provide the most concise syntax for doing so.</p><p class="calibre18">For example, these anonymous function expressions are equivalent:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(fn [x y] (Math/pow x y))<br class="calibre33"/><br class="calibre33"/>#(Math/pow %1 %2)</tt></span></blockquote><p class="calibre23">The latter is simply some reader sugar that is expanded into the former; we can clearly see this by checking the result of reading the textual code:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos177590"></a><a href="#filepos205399"><span class="calibre32">30</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(read-string "#(Math/pow %1 %2)")<br class="calibre33"/>;= (fn* [p1__285# p2__286#] (Math/pow p1__285# p2__286#))</tt></span></blockquote><p class="calibre23">The differences between the <tt class="calibre22">fn</tt> form and the shorter function literal are:</p><p class="calibre18"><span class="bold">No implicit do form</span>. “Regular” <tt class="calibre22">fn</tt> forms (and all of their derivatives) wrap their function bodies in an implicit <tt class="calibre22">do</tt> form,<a id="filepos178170"></a> as we discussed in <a href="#filepos161395"><span class="calibre5">Creating Functions: fn</span></a>. This allows you to do things like:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(fn [x y]<br class="calibre33"/>  (println (str x \^ y))<br class="calibre33"/>  (Math/pow x y))</tt></span></blockquote><p class="calibre23">The equivalent function literal requires an explicit <tt class="calibre22">do</tt> form:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">#(do (println (str %1 \^ %2))<br class="calibre33"/>     (Math/pow %1 %2))</tt></span></blockquote><p class="calibre23"><span class="bold">Arity and arguments specified using unnamed positional symbols</span>. The <tt class="calibre22">fn</tt> examples above use the named symbols <tt class="calibre22">x</tt> and <tt class="calibre22">y</tt> to specify both the arity <a id="filepos178935"></a>of the function being defined, as well as the names of the arguments passed to the function at runtime. In contrast, the literal uses unnamed positional <tt class="calibre22">%</tt> symbols, where <tt class="calibre22">%1</tt> is the first argument, <tt class="calibre22">%2</tt> is the second argument, and so on. In addition, the highest positional symbol defines the arity of the function, so if we wanted to define a function that accepted four arguments, we need only to refer to <tt class="calibre22">%4</tt> within the function literal’s body.</p><p class="calibre18">There are two additional wrinkles to defining arguments in function literals:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">Function literals that accept a single argument are so common that you can refer to the first argument to the function by just using <tt class="calibre22">%</tt>. So, <tt class="calibre22">#(Math/pow % %2)</tt> is equivalent to <tt class="calibre22">#(Math/pow %1 %2)</tt>. You should prefer the shorter notation in general.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">You can define a variadic function<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos180084"></a><a href="#filepos205871"><span class="calibre32">31</span></a><span class="calibre32">]</span></small></sup> and refer to that function’s rest arguments using the <tt class="calibre22">%&amp;</tt> symbol. These functions are therefore equivalent:</blockquote></li></ol><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(fn [x &amp; rest]<br class="calibre33"/>  (- x (apply + rest)))<br class="calibre33"/><br class="calibre33"/>#(- % (apply + %&amp;))</tt></span></blockquote><p class="calibre23"><span class="bold">Function literals cannot be nested</span>. <a id="filepos180580"></a>So, while this is perfectly legal:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(fn [x]<br class="calibre33"/>  (fn [y]<br class="calibre33"/>    (+ x y)))</tt></span></blockquote><p class="calibre23">This is not:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">#(#(+ % %))<br class="calibre33"/>;= #&lt;IllegalStateException java.lang.IllegalStateException:<br class="calibre33"/>;=   Nested #()s are not allowed&gt;</tt></span></blockquote><p class="calibre23">Aside from the fact that the bodies of function literals are intended to be terse, simple expressions, making the prospect of nested function literals a readability and comprehension nightmare, there’s simply no way to disambiguate which function’s first argument <tt class="calibre22">%</tt> is referring to.<a id="filepos181349"></a></p><p id="filepos181360" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Conditionals: if</span></span></span></p><p class="calibre18"><tt class="calibre22">if</tt>
<a id="filepos181506"></a>is Clojure’s sole primitive conditional operator. Its syntax is simple: if the value of the first expression in an <tt class="calibre22">if</tt> form is <span class="italic">logically</span> true, then the result of the <tt class="calibre22">if</tt> form is the value of the second expression. Otherwise, the result of the <tt class="calibre22">if</tt> form is the value of the third expression, if provided. The second and third expressions are only evaluated as necessary.</p><p class="calibre18">Clojure conditionals determine logical truth to be anything other than <tt class="calibre22">nil</tt> or <tt class="calibre22">false</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(if "hi" \t)<br class="calibre33"/>;= \t<br class="calibre33"/>(if 42 \t)<br class="calibre33"/>;= \t<br class="calibre33"/>(if nil "unevaluated" \f)<br class="calibre33"/>;= \f<br class="calibre33"/>(if false "unevaluated" \f)<br class="calibre33"/>;= \f<br class="calibre33"/>(if (not true) \t)<br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre23">Note that if a conditional expression is logically false, and no <tt class="calibre22">else</tt> expression is provided, the result of an <tt class="calibre22">if</tt> expression is <tt class="calibre22">nil</tt>.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos182572"></a><a href="#filepos206183"><span class="calibre32">32</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">Many refinements are built on top of <tt class="calibre22">if</tt>, including:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">when</tt>, best used when <tt class="calibre22">nil</tt> should be returned (or no action should be taken) if a condition is false.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">cond</tt>—similar to the <tt class="calibre22">else if</tt> construction in Java and Ruby, and <tt class="calibre22">elif</tt> in Python—allows you to concisely provide multiple conditions to check, along with multiple <tt class="calibre22">then</tt> expressions if a given conditional is true.</blockquote></li><a id="filepos183355"></a><li value="3" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">if-let</tt> and <tt class="calibre22">when-let</tt>, which are compositions of <tt class="calibre22">let</tt> with <tt class="calibre22">if</tt> and <tt class="calibre22">when</tt>, respectively: if the value of the test expression is logically true, it is bound to a local for the extent of the <tt class="calibre22">then</tt> expression.</blockquote></li><a id="filepos183709"></a></ul><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Clojure provides </span><span class="calibre10"><tt class="calibre22">true?</tt></span><a id="filepos183961"></a><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">false?</tt></span><a id="filepos184032"></a><span class="calibre10"> predicates, but these are unrelated to </span><span class="calibre10"><tt class="calibre22">if</tt></span><span class="calibre10"> conditionals. For example:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(true? "string")<br class="calibre33"/>;= false<br class="calibre33"/>(if "string" \t \f)<br class="calibre33"/>;= \t</tt></span></blockquote><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">true?</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">false?</tt></span><span class="calibre10"> check for the Boolean values </span><span class="calibre10"><tt class="calibre22">true</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">false</tt></span><span class="calibre10">, not the logical truth condition used by </span><span class="calibre10"><tt class="calibre22">if</tt></span><span class="calibre10">, which is equivalent to </span><span class="calibre10"><tt class="calibre22">(or (not (nil? x)) (true? x))</tt></span><span class="calibre10"> for any value </span><span class="calibre10"><tt class="calibre22">x</tt></span><span class="calibre10">.</span></blockquote><p id="filepos184954" class="calibre25"><span class="calibre19"><span class="bold"><span class="calibre5">Looping: loop and recur</span></span></span></p><p id="filepos185067" class="calibre18">Clojure provides a number of useful imperative looping constructs, including <tt class="calibre22">doseq</tt> and <tt class="calibre22">dotimes</tt>, all of which are built upon <tt class="calibre22">recur</tt>. <tt class="calibre22">recur</tt> transfers control to the local-most <span class="italic">loop head</span> without consuming stack space, which is defined either by <tt class="calibre22">loop</tt> or a function. Let’s take a look at a very simple countdown loop:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(loop [x 5]            </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  (if (neg? x)<br class="calibre33"/>    x                  </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>    (recur (dec x))))  </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= -1</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">loop</tt> establishes bindings via an implicit <tt class="calibre22">let</tt> form, so it takes a vector of binding names and initial values.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">If the final expression within a <tt class="calibre22">loop</tt> form consists of a value, that is taken as the value of the form itself. Here, when <tt class="calibre22">x</tt> is negative, the <tt class="calibre22">loop</tt> form returns the value of <tt class="calibre22">x</tt>.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">A <tt class="calibre22">recur</tt> form will transfer control to the local-most loop head, in this case the <tt class="calibre22">loop</tt> form, resetting the local bindings to the values provided as arguments to <tt class="calibre22">recur</tt>. In this case, control jumps to the beginning of the <tt class="calibre22">loop</tt> form, with <tt class="calibre22">x</tt> bound to the value <tt class="calibre22">(dec x)</tt>.</blockquote><p class="calibre18">Loop heads are also established by functions, in which case <tt class="calibre22">recur</tt> rebinds the function’s parameters using the values provided as arguments to <tt class="calibre22">recur</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn countdown<br class="calibre33"/>  [x]<br class="calibre33"/>  (if (zero? x)<br class="calibre33"/>    :blastoff!<br class="calibre33"/>    (do (println x)<br class="calibre33"/>        (recur (dec x)))))<br class="calibre33"/>;= #'user/countdown<br class="calibre33"/>(countdown 5)<br class="calibre33"/>; 5<br class="calibre33"/>; 4<br class="calibre33"/>; 3<br class="calibre33"/>; 2<br class="calibre33"/>; 1<br class="calibre33"/>;= :blastoff!</tt></span></blockquote><p class="calibre23"><span class="bold">Appropriate use of recur</span>. <tt class="calibre22">recur</tt> is a very low-level looping and recursion operation that is usually not necessary:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">When they can do the job, use the higher-level looping and iteration forms found in Clojure’s core library, <tt class="calibre22">doseq</tt> and <tt class="calibre22">dotimes</tt>.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">When “iterating” over a collection or sequence, functional operations like <tt class="calibre22">map</tt>, <tt class="calibre22">reduce</tt>, <tt class="calibre22">for</tt>, and so on are almost always preferable.</blockquote></li></ul><p class="calibre18">Because <tt class="calibre22">recur</tt> does not consume stack space <a id="filepos188516"></a>(thereby avoiding stack overflow errors), <tt class="calibre22">recur</tt>
<span class="italic">is</span> critical when implementing certain recursive algorithms. In addition, because it allows you to work with numerics without the overhead of boxed representations, <tt class="calibre22">recur</tt> is very useful in the implementation of many mathematical and data-oriented operations. See <a href="#filepos1634180"><span class="calibre5">Visualizing the Mandelbrot Set in Clojure</span></a> for a live example of <tt class="calibre22">recur</tt> within such circumstances.</p><p class="calibre18">Finally, there are scenarios where the accumulation or consumption of a collection or set of collections is complicated enough that orchestrating things with a series of purely functional operations using <tt class="calibre22">map</tt>, <tt class="calibre22">reduce</tt>, and so on is either difficult or inefficient. In these cases, the use of <tt class="calibre22">recur</tt> (and sometimes <tt class="calibre22">loop</tt> in order to set up intermediate loop heads) can provide an important escape hatch.</p><p id="filepos189489" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Referring to Vars: var</span></span></span></p><p id="filepos189601" class="calibre18">Symbols that name a var evaluate to that var’s value:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def x 5)<br class="calibre33"/>;= #'user/x<br class="calibre33"/>x<br class="calibre33"/>;= 5</tt></span></blockquote><p class="calibre23">However, there are occasions when you’d like to have a reference to the var itself, rather than the value it holds. The <tt class="calibre22">var</tt> special form does this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(var x)<br class="calibre33"/>;= #'user/x</tt></span></blockquote><p class="calibre23">You’ve seen a number of times now how vars are printed in the REPL: <tt class="calibre22">#'</tt>, followed by a symbol. This is reader syntax that expands to a call to <tt class="calibre22">var</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">#'x<br class="calibre33"/>;= #'user/x</tt></span></blockquote><p class="calibre23">You’ll learn a lot more about vars in <a href="#filepos735003"><span class="calibre5">Vars</span></a>.</p><p id="filepos190560" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Java Interop: . and new</span></span></span></p><p id="filepos190673" class="calibre18">All Java interoperability—instantiation, static and instance method invocation, and field access—flows through the <tt class="calibre22">new</tt> and <tt class="calibre22">.</tt> special forms. That said, the Clojure reader provides some syntactic sugar on top of these primitive interop forms that makes Java interop more concise in general and more syntactically consistent with Clojure’s notion of function position for method calls and instantiation. Thus, it’s rare to see <tt class="calibre22">.</tt> and <tt class="calibre22">new</tt> used directly, but you will nevertheless come across them out in the wild at some point:</p><p id="filepos191271" class="calibre3"></p><p class="calibre1"><span class="italic">Table 1-3. Sugared Java interop forms and their fully expanded equivalents</span></p><table border="1" valign="top" class="calibre40"><tr border="1" valign="top" class="calibre27"><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Operation </span></span></span></th><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Java code </span></span></span></th><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Sugared interop form </span></span></span></th><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Equivalent special form usage </span></span></span></th></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Object instantiation </span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">new java.util.ArrayList(100)</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">(java.util.ArrayList. 100)</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">(new java.util.ArrayList 100)</tt></span><span class="calibre21">
</span></p></td></tr><a id="filepos192877"></a><tr border="1" valign="top" class="calibre43"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Static method invocation </span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">Math.pow(2, 10)</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">(Math/pow 2 10)</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">(. Math pow 2 10)</tt></span><span class="calibre21">
</span></p></td></tr><a id="filepos193763"></a><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Instance method invocation </span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">"hello".substring(1, 3)</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">(.substring "hello" 1 3)</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">(. "hello" substring 1 3)</tt></span><span class="calibre21">
</span></p></td></tr><a id="filepos194680"></a><tr border="1" valign="top" class="calibre43"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Static field access </span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">Integer.MAX_VALUE</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">Integer/MAX_VALUE</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">(. Integer MAX_VALUE)</tt></span><span class="calibre21">
</span></p></td></tr><a id="filepos195569"></a><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Instance field access </span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">someObject.someField</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">(.someField some-object)</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">(. some-object some-field)</tt></span><span class="calibre21">
</span></p></td></tr><a id="filepos196479"></a></table><p class="calibre23">The sugared syntax shown in <a href="#filepos191271"><span class="calibre5">Table 1-3</span></a> is idiomatic and should be preferred in every case over direct usage of the <tt class="calibre22">.</tt> and <tt class="calibre22">new</tt> special forms. Java interop is discussed in depth in <a href="#filepos1274079"><span class="calibre5">Chapter 9</span></a>.</p><p id="filepos196843" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Exception Handling: try and throw</span></span></span></p><p id="filepos196966" class="calibre18">These special forms allow you to participate in and use the exception-handling and -throwing mechanisms in Java from Clojure. They are explained in <a href="#filepos1306175"><span class="calibre5">Exceptions and Error Handling</span></a>.</p><p id="filepos197231" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Specialized Mutation: set!</span></span></span></p><p class="calibre18">While Clojure emphasizes the use of immutable data structures and values, there are contexts where you need to effect an in-place mutation of state. The most common settings for this involve the use of setter and other stateful methods on Java objects you are using in an interop setting; for the remaining cases, Clojure provides <tt class="calibre22">set!</tt><a id="filepos197719"></a>, which can be used to:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Set the thread-local value of vars that have a non-root binding, discussed in <a href="#filepos744558"><span class="calibre5">Dynamic Scope</span></a></blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Set the value of a Java field, demonstrated in <a href="#filepos1296055"><span class="calibre5">“Accessing object fields”</span></a></blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Set the value of mutable fields defined by <tt class="calibre22">deftype</tt>; see <a href="#filepos995374"><span class="calibre5">Types</span></a> for details of that usage</blockquote></li></ul><p id="filepos198508" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Primitive Locking: monitor-enter and monitor-exit</span></span></span></p><p id="filepos198647" class="calibre18">These are lock primitives that allow Clojure to synchronize on the monitor associated with every Java object. You should never need to use these special forms, as there’s a macro, <tt class="calibre22">locking</tt>, that ensures proper acquisition and release of an object’s monitor. See <a href="#filepos829168"><span class="calibre5">Locking</span></a> for details.<a id="filepos199024"></a></p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos199128"></a><a href="#filepos122061"><span class="calibre32">18</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Special forms are always given precedence when resolving symbols in function position. For example, you can have a var or local named </span><span class="calibre10"><tt class="calibre22">def</tt></span><span class="calibre10">, but you will not be able to refer to the value of that var or local in function position—though you can refer to that value anywhere else.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos199644"></a><a href="#filepos122595"><span class="calibre32">19</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Paul Graham’s </span><span class="calibre10"><span class="italic">The Roots of Lisp</span></span><span class="calibre10"> (</span><a href="http://www.paulgraham.com/rootsoflisp.html"><span class="calibre10"><span class="calibre5">http://www.paulgraham.com/rootsoflisp.html</span></span></a><span class="calibre10">) is a brief yet approachable precis of the fundamental operations of computation, as originally discovered and enumerated by John McCarthy. Though that characterization of computation was made more than 50 years ago, you can see it thriving in Clojure today.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos200345"></a><a href="#filepos123237"><span class="calibre32">20</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">If you were to open the </span><span class="calibre10"><span class="italic">core.clj</span></span><span class="calibre10"> file from Clojure’s source repository, you will see this bootstrapping in action: everything from </span><span class="calibre10"><tt class="calibre22">when</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">or</tt></span><span class="calibre10"> to </span><span class="calibre10"><tt class="calibre22">defn</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">=</tt></span><span class="calibre10"> is defined in Clojure itself. Indeed, if you were so motivated, you could implement Clojure (or another language of your choosing) from scratch, on your own, on top of Clojure’s special forms.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos201145"></a><a href="#filepos123511"><span class="calibre32">21</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">This sort of syntactic extension generally requires </span><span class="calibre10"><span class="italic">macros</span></span><span class="calibre10">, which are treated in detail in </span><a href="#filepos831506"><span class="calibre10"><span class="calibre5">Chapter 5</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos201581"></a><a href="#filepos128615"><span class="calibre32">22</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">The other alternative would be for </span><span class="calibre10"><tt class="calibre22">let</tt></span><span class="calibre10"> (and all other forms that utilize </span><span class="calibre10"><tt class="calibre22">do</tt></span><span class="calibre10">) to (re?) implement its own semantics of “do several things and return the value of the last expression”: hardly a reasonable thing to do.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos202089"></a><a href="#filepos129204"><span class="calibre32">23</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="#filepos109342"><span class="calibre10"><span class="calibre5">Namespaces</span></span></a><span class="calibre10"> for a discussion of the typical usage of vars as stable references to values in namespaces; see </span><a href="#filepos735003"><span class="calibre10"><span class="calibre5">Vars</span></span></a><span class="calibre10"> for more a more comprehensive treatment of them, including esoteric usages related to dynamic scope and thread-local references.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos202715"></a><a href="#filepos144854"><span class="calibre32">24</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Thus the term: destructuring is undoing (</span><span class="calibre10"><span class="italic">de-</span></span><span class="calibre10">) the creation of the data </span><span class="calibre10"><span class="italic">structure</span></span><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos203082"></a><a href="#filepos145149"><span class="calibre32">25</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Values in the source collection that have no corresponding bound name are simply not bound within the context of the </span><span class="calibre10"><tt class="calibre22">let</tt></span><span class="calibre10"> form; you do not need to fully match the structure of the source collection, but sequential destructuring forms do need to be “anchored” at the beginning of the source.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos203612"></a><a href="#filepos145551"><span class="calibre32">26</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Again, note the use of underscores (</span><span class="calibre10"><tt class="calibre22">_</tt></span><span class="calibre10">) in this destructuring form to indicate an ignored binding, similar to the idiom discussed in the note earlier in this chapter.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos204014"></a><a href="#filepos149468"><span class="calibre32">27</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="#filepos977618"><span class="calibre10"><span class="calibre5">Records</span></span></a><span class="calibre10"> to learn more about records.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos204337"></a><a href="#filepos151726"><span class="calibre32">28</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">This is due to the polymorphic behavior of </span><span class="calibre10"><tt class="calibre22">get</tt></span><span class="calibre10">, which looks up values in a collection given a key into that collection; in the case of these indexable sequential values, </span><span class="calibre10"><tt class="calibre22">get</tt></span><span class="calibre10"> uses indices as keys. For more about </span><span class="calibre10"><tt class="calibre22">get</tt></span><span class="calibre10">, see </span><a href="#filepos387941"><span class="calibre10"><span class="calibre5">Associative</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos205011"></a><a href="#filepos171321"><span class="calibre32">29</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Python is a language that supports this usage pervasively, where every argument may be named and provided in any order in a function call, and argument defaults can be provided when a function is defined.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos205399"></a><a href="#filepos177590"><span class="calibre32">30</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Since the name of the arguments to the function is irrelevant, the function literal generates a unique symbol for each argument to refer to them; in this case, </span><span class="calibre10"><tt class="calibre22">p1__285#</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">p2__286#</tt></span><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos205871"></a><a href="#filepos180084"><span class="calibre32">31</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="#filepos169536"><span class="calibre10"><span class="calibre5">“Variadic functions”</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos206183"></a><a href="#filepos182572"><span class="calibre32">32</span></a><span class="calibre32">] </span></small></sup><span class="calibre10"><tt class="calibre22">when</tt></span><span class="calibre10"> is far more appropriate for such scenarios.</span></p><div class="mbppagebreak"></div><p id="filepos206399" class="calibre6"><span class="calibre4"><span class="bold">Putting It All Together</span></span></p><p class="calibre18">We’ve continued to pick at the running example from <a href="#filepos42427"><span class="calibre5">Example 1-2</span></a> throughout our first explorations of Clojure:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn average<br class="calibre33"/>  [numbers]<br class="calibre33"/>  (/ (apply + numbers) (count numbers)))</tt></span></blockquote><p class="calibre23">We learned how this expression is simply a canonical representation of Clojure data structures in <a href="#filepos69475"><span class="calibre5">Homoiconicity</span></a>. In the beginning, in <a href="#filepos53327"><span class="calibre5">Expressions, Operators, Syntax, and Precedence</span></a>, we established that lists are evaluated as calls, with the value in function position as the operator. After exploring namespaces, we saw in <a href="#filepos118507"><span class="calibre5">Symbol Evaluation</span></a> how the symbols in that data structure are evaluated at runtime in the course of a call. Now, after we’ve learned about special forms—in particular, <tt class="calibre22">def</tt> and <tt class="calibre22">fn</tt>—we have the final pieces in hand to comprehensively understand what happens when you evaluate this expression (whether at the REPL or as part of loading a Clojure source file from disk in a production application).</p><p class="calibre18"><tt class="calibre22">defn</tt> is simply a shorthand for:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def average (fn average<br class="calibre33"/>               [numbers]<br class="calibre33"/>               (/ (apply + numbers) (count numbers))))</tt></span></blockquote><p class="calibre23">So, <tt class="calibre22">fn</tt> creates the <tt class="calibre22">average</tt> function (recall from <a href="#filepos161395"><span class="calibre5">Creating Functions: fn</span></a> that the first argument to <tt class="calibre22">fn</tt> here, <tt class="calibre22">average</tt>, is a self-reference, so the function can be called recursively if necessary without looking up the value of the corresponding var again), and <tt class="calibre22">def</tt> registers it as the value of the <tt class="calibre22">average</tt> var in the current namespace.</p><p id="filepos208576" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">eval</span></span></span></p><p id="filepos208670" class="calibre18">All of the evaluation semantics we’ve been discussing are encapsulated within <tt class="calibre22">eval</tt>, a function that evaluates a single argument form. We can see very clearly that, for example, scalars and other literals evaluate to the values they describe:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(eval :foo)<br class="calibre33"/>;= :foo<br class="calibre33"/>(eval [1 2 3])<br class="calibre33"/>;= [1 2 3]<br class="calibre33"/>(eval "text")<br class="calibre33"/>;= "text"</tt></span></blockquote><p class="calibre23">…and a list will <tt class="calibre22">eval</tt>uate to the return value of the call it describes:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(eval '(average [60 80 100 400]))<br class="calibre33"/>;= 160</tt></span></blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">While </span><span class="calibre10"><tt class="calibre22">eval</tt></span><span class="calibre10">’s semantics underly all of Clojure, it is itself very rarely used within Clojure programs. It provides the ultimate in flexibility—allowing you to evaluate any data that represents a valid Clojure expression—that you simply don’t need most of the time. In general, if you’re using </span><span class="calibre10"><tt class="calibre22">eval</tt></span><span class="calibre10"> in application code, it’s likely that you’re working with far more rope than you need, and might end up hanging yourself in the process.</span></blockquote><blockquote class="calibre17"><span class="calibre10">Most problems where </span><span class="calibre10"><tt class="calibre22">eval</tt></span><span class="calibre10"> is applicable are better solved through judicious application of macros, which we explore in </span><a href="#filepos831506"><span class="calibre10"><span class="calibre5">Chapter 5</span></span></a><span class="calibre10">.</span></blockquote><p class="calibre25">Knowing everything we do now, we can <span class="italic">reimplement</span> the Clojure REPL quite easily. Remember that <tt class="calibre22">read</tt> (or <tt class="calibre22">read-string</tt>) is used to produce Clojure values from their textual representations:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(eval (read-string "(average [60 80 100 400])"))<br class="calibre33"/>;= 160</tt></span></blockquote><p class="calibre23">…and we can construct a control loop using a <tt class="calibre22">recur</tt> within a function (a <tt class="calibre22">loop</tt> form would work as well). Just a sprinkling of I/O-related functions for printing results and the REPL prompt, and we have a functioning REPL:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 1-4. A naive reimplementation of Clojure’s REPL</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(defn embedded-repl<br class="calibre33"/>  "A naive Clojure REPL implementation.  Enter `:quit`<br class="calibre33"/>   to exit."<br class="calibre33"/>  []<br class="calibre33"/>  (print (str (ns-name *ns*) "&gt;&gt;&gt; "))<br class="calibre33"/>  (flush)<br class="calibre33"/>  (let [expr (read)<br class="calibre33"/>        value (eval expr)]<br class="calibre33"/>    (when (not= :quit value)<br class="calibre33"/>      (println value)<br class="calibre33"/>      (recur))))<br class="calibre33"/><br class="calibre33"/>(embedded-repl)<br class="calibre33"/>; user&gt;&gt;&gt; (defn average2<br class="calibre33"/>;           [numbers]<br class="calibre33"/>;           (/ (apply + numbers) (count numbers)))<br class="calibre33"/>; #'user/average2<br class="calibre33"/>; user&gt;&gt;&gt; (average2 [3 7 5])<br class="calibre33"/>; 5<br class="calibre33"/>; user&gt;&gt;&gt; :quit<br class="calibre33"/>;= nil</tt></span></p><p class="calibre13">This REPL implementation is ill-behaved in a variety of ways—for example, any thrown error leaks out of the loop in <tt class="calibre22">embedded-repl</tt>—but it’s a start.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos212330"></a><a href="#filepos212521"><span class="calibre32">33</span></a><span class="calibre32">]</span></small></sup></p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos212521"></a><a href="#filepos212330"><span class="calibre32">33</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Clojure’s actual REPL is also implemented in Clojure, in the </span><span class="calibre10"><tt class="calibre22">clojure.main</tt></span><span class="calibre10"> namespace, and is waiting for you if you are interested in seeing how the REPL you’ll use every day is built.</span></p><div class="mbppagebreak"></div><p id="filepos212898" class="calibre6"><span class="calibre4"><span class="bold">This Is Just the Beginning</span></span></p><p class="calibre18">What we’ve explored here is the bedrock of Clojure: the fundamental operations of computation (special forms), the interchangeability of code and data, and the tip of the iceberg that is interactive development. On top of this foundation, and in conjunction with the facilities of its JVM host, Clojure provides immutable data structures; concurrency primitives with defined, tractable semantics; macros; and much, much more.</p><p class="calibre18">We’ll help you understand much of it throughout the rest of the book, and hopefully tie Clojure into your day-to-day life as a programmer with the practicums in <a href="#filepos1527345"><span class="calibre5">Part IV</span></a>.</p><p class="calibre18">There are some key resources you’ll may want to keep close at hand along the way:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">The core API documentation, available at <a href="http://clojure.github.com/clojure"><span class="calibre5">http://clojure.github.com/clojure</span></a></blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">The main Clojure mailing list, available at <a href="http://groups.google.com/group/clojure"><span class="calibre5">http://groups.google.com/group/clojure</span></a>, and the <tt class="calibre22">#clojure</tt> IRC channel on Freenode,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos214430"></a><a href="#filepos215149"><span class="calibre32">34</span></a><span class="calibre32">]</span></small></sup> both friendly places to get quality help with Clojure, no matter your skill or experience level</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">The companion site for this book, <a href="http://clojurebook.com"><span class="calibre5">http://clojurebook.com</span></a>, which will be maintained over time with additional resources to help you along in learning and using Clojure effectively</blockquote></li></ul><p class="calibre18">Are you ready to take the next step?<a id="filepos215045"></a></p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos215149"></a><a href="#filepos214430"><span class="calibre32">34</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">You can use </span><a href="http://webchat.freenode.net/?channels=#clojure"><span class="calibre10"><span class="calibre5">http://webchat.freenode.net/?channels=#clojure</span></span></a><span class="calibre10"> if you aren’t on IRC regularly enough to maintain a desktop client.</span></p><div class="mbppagebreak"></div><p id="filepos215548" class="calibre6"><span class="calibre4"><span class="bold">Part I. Functional Programming and Concurrency</span></span></p><div class="mbppagebreak"></div><p id="filepos215673" class="calibre6"><span class="calibre2"><span class="bold">Chapter 2. Functional Programming</span></span></p><p id="filepos215769" class="calibre13">Functional programming (FP) is one of those amorphous concepts in software development that means different things to different people. Despite the many shades of gray that exist in the FP spectrum, it’s easy to assert that Clojure is a functional programming language, and that that character is the root of many of its most attractive facilities and advantages.</p><p class="calibre18">In this chapter, we will:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">Give you a reasonable introduction to what functional programming is</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Explain why you should care about it</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Discuss the details of Clojure’s implementation that make it a desirable functional programming language</blockquote></li></ol><p class="calibre18">Along the way, we hope to make the case that FP—and Clojure’s flavor of FP in particular—far from being an academic exercise, can improve your practice of software design and development just as structural- and object-oriented programming concepts have over the years.</p><p class="calibre18">If you’re already familiar with functional programming (whether via Ruby, or JavaScript, or even more opinionated functional languages like Scala, F#, or Haskell, et al.), much of what follows will appear to be old hat, but it’s worth internalizing so that you can understand Clojure’s cut at FP.</p><p class="calibre18">If you are completely new to FP or initially skeptical of it, we’d urge you in particular to hang on for the ride, it’ll be worth your time and effort.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos217618"></a><a href="#filepos220360"><span class="calibre32">35</span></a><span class="calibre32">]</span></small></sup> Recall again from <a href="#filepos28661"><span class="calibre5">Chapter 1</span></a> the adage <span class="italic">Clojure demands that you raise your game, and pays you back for doing so</span>; just as you may have had to grow to learn object-oriented programming, or Java generics, or Ruby, you’ll have to reach a little to be able to understand and make the most of FP—and therefore Clojure. But in return, you’ll have not just a “new way of thinking,” but a set of tools and practices highly applicable to day-to-day programming challenges.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos218282"></a><a href="#filepos220935"><span class="calibre32">36</span></a><span class="calibre32">]</span></small></sup></p><p id="filepos218380" class="calibre6"><span class="calibre4"><span class="bold">What Does Functional Programming Mean?</span></span></p><p id="filepos218479" class="calibre18">Functional programming is an umbrella term that encompasses a number of language-level primitives and capabilities of which different languages provide different treatments. In Clojure, functional programming means:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">A preference for working with immutable <span class="italic">values</span>; this includes:</blockquote><ul class="calibre55"><li value="1" class="calibre16"><blockquote class="calibre17">The use of immutable data structures that satisfy simple abstractions, rather than mutable bags of state</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">The treatment of functions as values themselves, enabling <span class="italic">higher-order functions</span></blockquote></li></ul></li><a id="filepos219342"></a><li value="2" class="calibre16"><blockquote class="calibre17">A preference for declarative processing of data over imperative control structures and iteration</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">The natural incremental composition of functions, higher-order functions, and immutable data structures in order to solve complex problems by working with higher-level (or, <span class="italic">right-level</span>) abstractions</blockquote></li></ul><p class="calibre18">These are all part of the foundation for many of the more advanced features of Clojure that you may have heard of—in particular, Clojure’s fantastic support for concurrency, parallelism, and more generally, providing defined semantics for the management of identities and changing state, which we’ll cover separately in <a href="#filepos593810"><span class="calibre5">Chapter 4</span></a>.</p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos220360"></a><a href="#filepos217618"><span class="calibre32">35</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">After you’ve internalized what we provide here, you may find the Wikipedia entry for functional programming to be a surprisingly good springboard for diving deeper into a variety of related topics: </span><a href="http://en.wikipedia.org/wiki/Functional_programming"><span class="calibre10"><span class="calibre5">http://en.wikipedia.org/wiki/Functional_programming</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos220935"></a><a href="#filepos218282"><span class="calibre32">36</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Note that it </span><span class="calibre10"><span class="italic">is</span></span><span class="calibre10"> possible to use functional programming principles even in languages—like Java—that do little to encourage (and sometimes actively </span><span class="calibre10"><span class="italic">discourage</span></span><span class="calibre10">) FP styles. This is made much easier if you have some quality persistent data structures and implementations of FP fundamentals like those provided by the Google Guava (</span><a href="https://code.google.com/p/guava-libraries/"><span class="calibre10"><span class="calibre5">https://code.google.com/p/guava-libraries/</span></span></a><span class="calibre10">) or Functional Java (</span><a href="http://functionaljava.org"><span class="calibre10"><span class="calibre5">http://functionaljava.org</span></span></a><span class="calibre10">) libraries.</span></p><div class="mbppagebreak"></div><p id="filepos221848" class="calibre6"><span class="calibre4"><span class="bold">On the Importance of Values</span></span></p><p id="filepos221936" class="calibre18">The notion of <span class="italic">program state</span><a id="filepos221998"></a> is a broad one with a long history, but in general, it refers to all of the scalars and aggregate data structures that you use to represent entities within your application, along with all of the connections that your application maintains with the external world (such as open files, sockets, and so on). Much of the character of a programming language is determined by its posture toward handling state: what it provides, what it prevents, and what it encourages.</p><p class="calibre18">Most programming languages, either through idiom or explicit design, encourage the use of <span class="italic">mutable</span> state,<a id="filepos222614"></a> whether within the guise of objects or not. Functional programming languages tend to encourage the use of <span class="italic">immutable</span> objects—<a id="filepos222755"></a>referred to as <span class="italic">values</span><a id="filepos222790"></a>—to represent program state. Clojure is no different in this respect.</p><p class="calibre18">“But wait,” you might say, “talking about eliminating mutability doesn’t make any sense—my programs need to <span class="italic">do things in the world</span>, so changing state is inevitable.” You would certainly be right in that all useful programs need to interact with the outside world, to take input and deliver output…</p><blockquote id="filepos223222" class="calibre47"></blockquote><blockquote class="calibre39"><img src="images/00021.jpg" class="calibre56"/></blockquote><blockquote class="calibre57"><span class="calibre10"><span class="italic"><span class="calibre7">Figure 2-1. A diagram of all programs ever<sup class="calibre58"><small class="calibre31"><span class="calibre32"><span class="italic"><span class="calibre7">[</span></span></span><a id="filepos223623"></a><a href="#filepos245116"><span class="calibre32"><span class="italic"><span class="calibre7">37</span></span></span></a><span class="calibre32"><span class="italic"><span class="calibre7">]</span></span></span></small></sup></span></span></span></blockquote><p class="calibre50">…but this does not preclude the use of immutable values. On the contrary, the more you can make your program rely upon operations over values, the easier it will be to reason about the program’s behavior compared with what is possible given mutable state. We’ll come to see how this is true throughout this chapter.</p><p class="calibre18">The shift from mutable state and objects to immutable values can be jarring for many, but it may be encouraging to know that you are already using immutable values every day as a programmer, and that they are probably the most reliable, easy-to-reason-about elements within your applications.</p><p id="filepos224492" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">About Values</span></span></span></p><p id="filepos224594" class="calibre18">What are values, exactly, and how do they and their immutable nature compare to mutable objects? Here are a few examples of values:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">true  false  5  14.2  \T  "hello"  nil</tt></span></blockquote><p class="calibre23">These standard JVM Booleans, numbers, characters, and strings—which Clojure conveniently reuses—are all immutable, are all values, and you use and rely upon them (or, values analogous to them in other languages) every day.</p><p class="calibre18">A key characteristic of values are the semantics they ensure with regard to equality and comparison, at a single point in time as well as over time. For example, these expressions <a id="filepos225354"></a>will <span class="italic">always</span> be true:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(= 5 5)<br class="calibre33"/><br class="calibre33"/>(= 5 (+ 2 3))<br class="calibre33"/><br class="calibre33"/>(= "boot" (str "bo" "ot"))<br class="calibre33"/><br class="calibre33"/>(= nil nil)<br class="calibre33"/><br class="calibre33"/>(let [a 5]<br class="calibre33"/>  (do-something-with-a-number a)<br class="calibre33"/>  (= a 5))</tt></span></blockquote><p class="calibre23">The equivalent expressions in Java, Python, and Ruby are <span class="italic">always</span> true, too,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos225837"></a><a href="#filepos245315"><span class="calibre32">38</span></a><span class="calibre32">]</span></small></sup> and this fact helps us reason about operations in our programs that involve such values. To understand why, it would be helpful to see what would happen if one of these so familiar types were to lose its value semantics.</p><p id="filepos226156" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Comparing Values to Mutable Objects</span></span></span></p><p id="filepos226281" class="calibre18">Choosing between mutable objects and immutable values is a momentous decision that carries significant consequences, even for the most trivial of examples; yet, this decision is often made out of habit or familiarity or based on what’s close at hand, rather than by considering the consequences of the respective options. Because the state held by mutable objects can change, and potentially be changed without your knowledge, using them when an immutable alternative is available can only be described as dangerous.</p><p class="calibre18">That may sound like hyperbole, especially if your current practice of using mutable objects on a daily basis seems to be working out for you. However, let’s take a moment to consider the effect of making mutable something that nearly every programmer takes for granted to be an immutable value, the reliable<a id="filepos227168"></a> integer:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 2-1. Implementation of a mutable integer in Java</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">public class StatefulInteger extends Number {<br class="calibre33"/>    private int state;<br class="calibre33"/><br class="calibre33"/>    public StatefulInteger (int initialState) {<br class="calibre33"/>        this.state = initialState;<br class="calibre33"/>    }<br class="calibre33"/><br class="calibre33"/>    public void setInt (int newState) {<br class="calibre33"/>        this.state = newState;<br class="calibre33"/>    }<br class="calibre33"/><br class="calibre33"/>    public int intValue () {<br class="calibre33"/>        return state;<br class="calibre33"/>    }<br class="calibre33"/><br class="calibre33"/>    public int hashCode () {<br class="calibre33"/>        return state;<br class="calibre33"/>    }<br class="calibre33"/><br class="calibre33"/>    public boolean equals (Object obj) {<br class="calibre33"/>        return obj instanceof StatefulInteger &amp;&amp;<br class="calibre33"/>            state == ((StatefulInteger)obj).state;<br class="calibre33"/>    }<br class="calibre33"/><br class="calibre33"/>    // remaining xxxValue() methods from java.lang.Number...<br class="calibre33"/>}</tt></span></p><p class="calibre13">This class is fundamentally identical to <tt class="calibre22">java.lang.Integer</tt><a id="filepos228393"></a>, aside from the absence of a variety of static utility methods. The one big change is that its sole field is mutable (i.e., it is not declared <tt class="calibre22">final</tt>), and it provides a setter for that field, <tt class="calibre22">setInt(int)</tt>. Let’s see what working with a mutable number looks like:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos228717"></a><a href="#filepos246053"><span class="calibre32">39</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def five (StatefulInteger. 5))        </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #'user/five<br class="calibre33"/>(def six (StatefulInteger. 6))<br class="calibre33"/>;= #'user/six<br class="calibre33"/>(.intValue five)                       </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= 5<br class="calibre33"/>(= five six)                           </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= false<br class="calibre33"/>(.setInt five 6)                       </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= nil<br class="calibre33"/>(= five six)                           </tt></span><a></a><img src="images/00001.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= true</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">We create a couple instances of <tt class="calibre22">StatefulInteger</tt>, one containing the value <tt class="calibre22">5</tt>, the other, <tt class="calibre22">6</tt>.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">We can verify that, yes, <tt class="calibre22">five</tt> contains the value “5”…</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">…and <tt class="calibre22">5</tt> does not equal <tt class="calibre22">6</tt>.</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">We change the state of <tt class="calibre22">five</tt> to <tt class="calibre22">6</tt>, and…</blockquote><p class="calibre23"><img src="images/00001.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">five</tt> is now equal to <tt class="calibre22">6</tt>.</blockquote><p class="calibre18">You should find this deeply troubling. Our common conception is that numbers really <span class="italic">are</span> values, in far more than a technical sense—honest-to-goodness universal Platonic forms. <tt class="calibre22">5</tt> should always be <tt class="calibre22">5</tt>, and certainly shouldn’t be subject to the sadistic whims of a programmer somewhere.</p><p class="calibre18">A final example, illustrating the consequences of mutable objects in connection with any function or method invocation:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn print-number          </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  [n]<br class="calibre33"/>  (println (.intValue n))<br class="calibre33"/>  (.setInt n 42))<br class="calibre33"/>;= #'user/print-number<br class="calibre33"/>(print-number six)          </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>; 6<br class="calibre33"/>;= nil<br class="calibre33"/>(= five six)                </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= false<br class="calibre33"/>(= five (StatefulInteger. 42))<br class="calibre33"/>;= true</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">A simple <tt class="calibre22">print-number</tt> function, which ostensibly should just print the value of the given number to <tt class="calibre22">stdout</tt>. Unbeknownst to us, it additionally modifies <tt class="calibre22">StatefulInteger</tt> arguments.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos232646"></a><a href="#filepos246486"><span class="calibre32">40</span></a><span class="calibre32">]</span></small></sup></blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">We call the <tt class="calibre22">print-number</tt> function with our <tt class="calibre22">StatefulInteger</tt> instance of <tt class="calibre22">six</tt>. By the time this function returns, that object has been changed as well.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">Now, while the prior example showed that <tt class="calibre22">six</tt> was equal to <tt class="calibre22">five</tt>, that is no longer true either.</blockquote><p class="calibre18">In the general case, the function <a id="filepos233404"></a>called with mutable arguments above does not have to be malicious code, nor does it need to be implemented by an incompetent developer; the mutation of arguments provided to methods and functions is common, and chances are you’ve encountered (and likely produced!) bugs that were due to an object being modified by a method to which it was passed as an argument. The same holds true for mutable objects held in global pools of state. Neither of these conditions are suitably guarded against with documentation (which is read even more rarely than it is written!), and indeed, such pitfalls of mutability are the <span class="italic">raison d’être</span> for the notion of deep object copying and copy constructors.</p><p class="calibre18">If numbers in your programming language worked this way, you might just quit your job tomorrow morning and take up carpentry. Unfortunately, nearly all other objects <span class="italic">do</span> work this way.</p><p class="calibre18">In Ruby,<a id="filepos234371"></a> even strings, often faithfully immutable in other languages, are mutable. This can be the source of all sorts of trouble:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">&gt;&gt; s = "hello"<br class="calibre33"/>=&gt; "hello"<br class="calibre33"/>&gt;&gt; s &lt;&lt; "*"<br class="calibre33"/>=&gt; "hello*"<br class="calibre33"/>&gt;&gt; s == "hello"<br class="calibre33"/>=&gt; false</tt></span></blockquote><p class="calibre23">Ruby collections like hashes and sets work around this by “freezing” strings when they are added to a collection. However, any classes or structs you write that contain strings must take similar precautions to prevent potentially serious bugs—the same class of errors that can occur when you attempt to use mutable objects as keys in a hash:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">&gt;&gt; h = {[1, 2] =&gt; 3}          </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>=&gt; {[1, 2]=&gt;3}<br class="calibre33"/>&gt;&gt; h[[1,2]]                   </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>=&gt; 3<br class="calibre33"/>&gt;&gt; h.keys[0] &lt;&lt; 3             </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>=&gt; [1, 2, 3]<br class="calibre33"/>&gt;&gt; h[[1,2]]                   </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>=&gt; nil</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">A hash(map) is created, mapping an array to a number…</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">…which, as expected, provides that number when we look up the value corresponding to the array.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">If any keys in a hash ever changed…</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">…then lookups that had succeeded before will fail.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos236841"></a><a href="#filepos246809"><span class="calibre32">41</span></a><span class="calibre32">]</span></small></sup></blockquote><p class="calibre18">Problems like this exist in any language where mutable objects are available, but their effects are most pernicious in languages where immutable values are rarely used: many programmers learn the hard way to avoid sharp edges, so even if a particular programming task is most efficiently modeled with, say, a map that has collections for keys, past lessons preclude the simplest solution in favor of other approaches that are generally more complicated and baroque. Create a new class that contains and guards the map with a restricted set of operations? Use unsophisticated immutable collections that provide some sane semantics, but that require full copies to produce changed versions? Ouch.</p><p class="calibre18">In contrast, you can use collections in Clojure’s maps (or as entries in its sets or vectors or records) safely, without any concern for the values of those keys or thread safety when in concurrent contexts, all because Clojure data structures are immutable <span class="italic">and</span> efficient:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def h {[1 2] 3})           </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #'user/h<br class="calibre33"/>(h [1 2])<br class="calibre33"/>;= 3<br class="calibre33"/>(conj (first (keys h)) 3)   </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= [1 2 3]<br class="calibre33"/>(h [1 2])                   </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= 3<br class="calibre33"/>h                           </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= {[1 2] 3}</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">A Clojure map is created, mapping a vector key to a number value, which has the lookup behavior we would expect.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">We can “add” a value to the vector key, which returns the “updated” vector. However…</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">…this has no impact at all upon the original map, vector, or any lookups that have succeeded in the past. This is because…</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">…the vector key was not modified, and indeed, <span class="italic">could never be modified</span>; when we added a value to it, a completely new vector reference was returned.</blockquote><p class="calibre18">This is absolutely just the tip of the iceberg. Understanding and utilizing Clojure’s data abstractions and data structure implementations is fundamental to wielding the language effectively. While we’ll use Clojure’s data structures casually for various examples in this chapter, we’ll spend all of the <a href="#filepos335797">next chapter</a> exploring them in detail.<a id="filepos240312"></a></p><p id="filepos240323" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">A Critical Choice</span></span></span></p><p id="filepos240430" class="calibre18">In summary, the use of unfettered object state means that<a id="filepos240515"></a>:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos240558"></a><a href="#filepos247342"><span class="calibre32">42</span></a><span class="calibre32">]</span></small></sup></p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Mutable objects cannot be safely passed to methods.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Mutable objects cannot be reliably used as keys in maps, entries in sets, and so on, because their equality and lookup semantics change over time.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Mutable objects cannot be reliably cached.</blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17">Mutable objects cannot be reliably used in a multithreaded environment because of the requirement for proper synchronization of action among different threads.</blockquote></li></ul><p class="calibre18">Entire classes of bugs made possible solely by the use of mutable objects simply cannot occur if you were to use immutable values in their place. The consequences of mutability are actually well-established and have been understood for some time,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos241784"></a><a href="#filepos247789"><span class="calibre32">43</span></a><span class="calibre32">]</span></small></sup> and apply to any language that does not provide easy alternatives to mutability. These issues are so common that a range of fairly pathological coping mechanisms have developed in the object-oriented world to deal with the problem of unfettered mutability of state, including:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Copy constructors and deep copy methods in order to ensure reliable access to an object in a particular state.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos242420"></a><a href="#filepos248469"><span class="calibre32">44</span></a><span class="calibre32">]</span></small></sup></blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">A host of patterns for tracking and managing change over time, including “Observer,” “Reactor,” and so on.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos242757"></a><a href="#filepos248838"><span class="calibre32">45</span></a><span class="calibre32">]</span></small></sup></blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">A plethora of utilities for erecting relatively flimsy immutable facades in front of mutable data structures, such as those provided by <tt class="calibre22">java.util.Collections</tt>. Such facades almost uniformly simply delegate to the underlying mutable collection; thus, if the underlying collection is changed, the “immutable” view of that collection does, too.</blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17">Reams of documentation and bad advice<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos243464"></a><a href="#filepos249256"><span class="calibre32">46</span></a><span class="calibre32">]</span></small></sup> given over the course of years on how to sanely manage concurrent access and modification of shared mutable state via manual lock management; the result being, deadlocks and race conditions are some of the most common sources of quality issues industry-wide.</blockquote></li></ul><p class="calibre18">In the end, much of the challenge of programming is in identifying and holding tight to every <span class="italic">invariant</span><a id="filepos243978"></a> you can find, those things in your algorithms, applications, or business rules that do not change. The more invariants you can identify, the more you can focus on the local effects of a particular piece of code, and the more risk you can drive out of whatever system you are building. Immutable values establish a whole new beachhead of invariants; using them, you can know with absolute certainty that calling a function with a collection won’t result in changes to that collection, that multiple threads can touch a value without risking its consistency or imposing a complexity tax in the form of complicated lock strategies, and that time-dependent changes will not result in timing-dependent behavior.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos244729"></a><a href="#filepos249915"><span class="calibre32">47</span></a><span class="calibre32">]</span></small></sup> These things are guaranteed when working with values like numbers; there are few reasons to not demand the same from your aggregates, such as Clojure’s immutable collections and records.<a id="filepos245012"></a></p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos245116"></a><a href="#filepos223623"><span class="calibre32">37</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Patent pending!</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos245315"></a><a href="#filepos225837"><span class="calibre32">38</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Aside from the </span><span class="calibre10"><tt class="calibre22">(= nil nil)</tt></span><span class="calibre10"> example; many languages provide limited support for checks involving </span><span class="calibre10"><tt class="calibre22">nil</tt></span><span class="calibre10"> or </span><span class="calibre10"><tt class="calibre22">null</tt></span><span class="calibre10">, and bad things generally happen when you pass an object’s </span><span class="calibre10"><tt class="calibre22">equals</tt></span><span class="calibre10"> method a </span><span class="calibre10"><tt class="calibre22">null</tt></span><span class="calibre10"> pointer. </span><span class="calibre10"><tt class="calibre22">nil</tt></span><span class="calibre10"> is just another value in Clojure.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos246053"></a><a href="#filepos228717"><span class="calibre32">39</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">We’ll be working with this Java class from Clojure, which provides a rich set of Java and JVM interoperability features. See </span><a href="#filepos1274079"><span class="calibre10"><span class="calibre5">Chapter 9</span></span></a><span class="calibre10"> for details.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos246486"></a><a href="#filepos232646"><span class="calibre32">40</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">We could just as easily implement this as a Java method; presenting the same functionality here as a Clojure function is merely convenient.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos246809"></a><a href="#filepos236841"><span class="calibre32">41</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Yes, we could use the hash’s </span><span class="calibre10"><tt class="calibre22">rehash</tt></span><span class="calibre10"> method, which would “solve” the problem. That’s fine if you’re happy to rehash maps prior to any lookup, and potentially hold a lock for the map for the duration of the rehashing and any lookup or update operation in a map shared by multiple threads.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos247342"></a><a href="#filepos240558"><span class="calibre32">42</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Brian Goetz discusses these pitfalls in detail at </span><a href="http://www.ibm.com/developerworks/java/library/j-jtp02183.html"><span class="calibre10"><span class="calibre5">http://www.ibm.com/developerworks/java/library/j-jtp02183.html</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos247789"></a><a href="#filepos241784"><span class="calibre32">43</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">For example, Joshua Bloch, one of the key architects of the Java standard libraries, recommends that you should “minimize mutability” (</span><a href="http://www.artima.com/intv/bloch11.html"><span class="calibre10"><span class="calibre5">http://www.artima.com/intv/bloch11.html</span></span></a><span class="calibre10">), and said in his 2001 book </span><span class="calibre10"><span class="italic">Effective Java</span></span><span class="calibre10"> that “classes should be immutable unless there’s a very good reason to make them mutable.”</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos248469"></a><a href="#filepos242420"><span class="calibre32">44</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Even going so far in certain settings as to use serialization as a reliable deep copy mechanism when an object model doesn’t provide a reliable copy constructor or duplication method.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos248838"></a><a href="#filepos242757"><span class="calibre32">45</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">In </span><a href="#filepos1656269"><span class="calibre10"><span class="calibre5">Chapter 12</span></span></a><span class="calibre10">, we provide examples of how Clojure’s facilities make many familiar object-oriented patterns unnecessary or invisible.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos249256"></a><a href="#filepos243464"><span class="calibre32">46</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Perhaps you recall the confusion and uncertainty that existed around </span><span class="calibre10"><span class="italic">double-checked locking</span></span><span class="calibre10"> some years ago—eventually resolved, but with much complexity and the help of a new JVM memory model: </span><a href="http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html"><span class="calibre10"><span class="calibre5">http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos249915"></a><a href="#filepos244729"><span class="calibre32">47</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">A.k.a. Heisenbugs, </span><a href="https://en.wikipedia.org/wiki/Heisenbug"><span class="calibre10"><span class="calibre5">https://en.wikipedia.org/wiki/Heisenbug</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos250238" class="calibre6"><span class="calibre4"><span class="bold">First-Class and Higher-Order Functions</span></span></p><p id="filepos250337" class="calibre18">Despite the great variability about what “functional programming” means in different languages, one requirement is consistent: functions must themselves be values, so that they may be treated like any other data, accepted as arguments and returned as results by other functions.</p><p class="calibre18">Functions as data <a id="filepos250697"></a>permits a means of abstraction that a language without first-class functions lacks. As a simple example, imagine writing a function that simply calls some other function twice. Rather than call a specific function, our <tt class="calibre22">call_twice</tt> function should be generic enough to call <span class="italic">any</span> function on <span class="italic">any</span> argument.</p><p class="calibre18">This is trivial in a language with first-class functions. In Ruby<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos251160"></a><a href="#filepos279687"><span class="calibre32">48</span></a><span class="calibre32">]</span></small></sup> and Python:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22"># Ruby<br class="calibre33"/>def call_twice(x, &amp;f)<br class="calibre33"/>  f.call(x)<br class="calibre33"/>  f.call(x)<br class="calibre33"/>end<br class="calibre33"/><br class="calibre33"/>call_twice(123) {|x| puts x}<br class="calibre33"/><br class="calibre33"/># Python<br class="calibre33"/>def call_twice(f, x):<br class="calibre33"/>  f(x)<br class="calibre33"/>  f(x)<br class="calibre33"/><br class="calibre33"/>call_twice(print, 123)</tt></span></blockquote><p class="calibre23">The Clojure code is just as simple:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn call-twice [f x]<br class="calibre33"/>  (f x)<br class="calibre33"/>  (f x))<br class="calibre33"/><br class="calibre33"/>(call-twice println 123)<br class="calibre33"/>; 123<br class="calibre33"/>; 123</tt></span></blockquote><p class="calibre23">By contrast, it would be difficult to write even this trivial function in Java. Ironically, the majority language on the JVM does not provide for functions as first class values. In Java, code may only exist within methods, which must be associated with a class, and methods can’t be referenced as objects short of resorting to Java’s reflection API.</p><p class="calibre18">Classes defined only to contain static utility methods—like <tt class="calibre22">java.lang.Math</tt>—end up functioning as impoverished namespaces created to compensate for the lack of first-class functions. Other useful methods—like many of the string-manipulation operations defined by <tt class="calibre22">java.lang.String</tt>—are <span class="italic">not</span> static methods, and so must be invoked in conjunction with a specific instance.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">Math.max(a, b);<br class="calibre33"/><br class="calibre33"/>someString.toLowerCase();</tt></span></blockquote><p class="calibre23">This may seem reasonable; what could be simpler than grouping related utility methods in a dedicated class, or tying operations for a particular type to instances of that type?</p><p class="calibre18">Really, doing neither of those things is simpler and more powerful in so many ways.</p><p class="calibre18">For example, what do you need to do in Java to determine the largest number in an array, or perhaps transform a list of strings into a list containing their lowercase counterparts?</p><p id="filepos253411" class="calibre23"></p><p class="calibre23"><span class="italic">Example 2-2. Some static utility methods in Java</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">public static int maxOf (int[] numbers) {<br class="calibre33"/>    int max = Integer.MIN_VALUE;<br class="calibre33"/>    for (int i : numbers) {<br class="calibre33"/>        max = Math.max(i, max);<br class="calibre33"/>    }<br class="calibre33"/>    return max;<br class="calibre33"/>}<br class="calibre33"/><br class="calibre33"/>public static void toLowerCase (List&lt;String&gt; strings) {<br class="calibre33"/>    for (ListIterator&lt;String&gt; iter = strings.listIterator(); iter.hasNext(); ) {<br class="calibre33"/>        iter.set(iter.next().toLowerCase()); </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>    }<br class="calibre33"/>}</tt></span></p><p class="calibre23"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">A tangent: this is modifying the <tt class="calibre22">strings</tt>
<tt class="calibre22">List</tt> in place…we sure hope no one else was holding a reference to it without expecting this mutation to occur.</blockquote><p class="calibre13">In contrast, all functions <a id="filepos254608"></a>in Clojure are first-class values. They exist of their own right, can be called directly (without any intervening classes/quasi-namespaces), and can be provided as arguments in function calls and returned as results from functions. They are data, just as much as data structures, numbers, and strings are.</p><p class="calibre18">Clojure defines a <tt class="calibre22">max</tt> function and a <tt class="calibre22">lower-case</tt> function (the latter in the <tt class="calibre22">clojure.string</tt> namespace), which correspond to <tt class="calibre22">Math.max</tt> and <tt class="calibre22">String.toLowerCase</tt> as shown above.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos255202"></a><a href="#filepos280321"><span class="calibre32">49</span></a><span class="calibre32">]</span></small></sup> Of course, they can be used directly:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(max 5 6)<br class="calibre33"/>;= 6<br class="calibre33"/>(require 'clojure.string)<br class="calibre33"/>;= nil<br class="calibre33"/>(clojure.string/lower-case "Clojure")<br class="calibre33"/>;= "clojure"</tt></span></blockquote><p class="calibre23">But that isn’t intended to impress. What is different is that, because Clojure functions are values themselves, they can be used with <span class="italic">higher-order functions</span>, sometimes referred to as “HOFs”; these are any functions that take other functions as arguments or return a function as a result.</p><p class="calibre18">Clojure comes with far too many higher-order functions for us to discuss comprehensively, so we’ll talk about some key ones as we go along—including <tt class="calibre22">map</tt>, <tt class="calibre22">reduce</tt>, <tt class="calibre22">partial</tt>, <tt class="calibre22">comp</tt>, <tt class="calibre22">complement</tt>, <tt class="calibre22">repeatedly</tt>, and others. Let’s look at <tt class="calibre22">map</tt> first; it is perhaps the most frequently used HOF in Clojure codebases.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos256330"></a><a href="#filepos280586"><span class="calibre32">50</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18"><span class="bold">map</span>. <tt class="calibre22">map</tt><a id="filepos256481"></a> accepts a single function argument, followed by one or more collections, and returns a sequence of the results of applying that function to successive members of the provided collections. More formally, any usage of <tt class="calibre22">map</tt> of the form <tt class="calibre22">(map ƒ [a b c])</tt> is equivalent to <tt class="calibre22">[(ƒ a) (ƒ b) (ƒ c)]</tt>, usage of the form <tt class="calibre22">(map ƒ [a b c] [x y z])</tt> is equivalent to <tt class="calibre22">[(ƒ a x) (ƒ b y) (ƒ c z)]</tt>, and so on.</p><p class="calibre18">A few examples will make <tt class="calibre22">map</tt>’s semantics obvious:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(map clojure.string/lower-case ["Java" "Imperative" "Weeping"    </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>                                "Clojure" "Learning" "Peace"])<br class="calibre33"/>;= ("java" "imperative" "weeping" "clojure" "learning" "peace")<br class="calibre33"/>(map * [1 2 3 4] [5 6 7 8])                                      </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= (5 12 21 32)</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Just about the simplest usage of <tt class="calibre22">map</tt>: given <tt class="calibre22">lower-case</tt> and a collection of strings, <tt class="calibre22">map</tt> will return a sequence of those strings lowercased.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">Given <tt class="calibre22">*</tt> and <span class="italic">n</span> collections of numbers, <tt class="calibre22">map</tt> will return a sequence of the products of the corresponding numbers from each collection.</blockquote><p class="calibre18">The first example above is the Clojure corollary to the <tt class="calibre22">toLowerCase</tt> static utility method in <a href="#filepos253411"><span class="calibre5">Example 2-2</span></a>. The contrast between the two approaches is striking, even for such a trivial example:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">The <tt class="calibre22">toLowerCase</tt> static method mutated its argument in place, whereas <tt class="calibre22">map</tt>, like all other well-behaved functions in Clojure, returns immutable values.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">If we were to make <tt class="calibre22">toLowerCase</tt> return a new collection containing the transformed strings, we would need to explicitly consider and define the allocation and type of a return collection. <tt class="calibre22">map</tt> always returns a sequence.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos259277"></a><a href="#filepos280961"><span class="calibre32">51</span></a><span class="calibre32">]</span></small></sup></blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">In Java, we are constantly concerned with the imperative flow of control, from manually iterating over an input collection to which methods are called to how they are ordered. Python’s list comprehensions and Ruby’s <tt class="calibre22">each</tt> idiom improve on Java in this regard. Clojure goes even further though, encouraging the separation of operations from the specifics of their application. For example, there’s nothing in the general contract of “mapping” over a sequence or set of sequences that requires that a given function must be applied to the provided collections in order, or even all on one thread.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos260112"></a><a href="#filepos281529"><span class="calibre32">52</span></a><span class="calibre32">]</span></small></sup></blockquote></li></ul><p class="calibre18">Where <tt class="calibre22">map</tt> is the fundamental higher-order function for transforming the contents of any sequential collection, we often need to coalesce a collection into a single value that might not be sequential. For such cases, <tt class="calibre22">reduce</tt> awaits.</p><p class="calibre18"><span class="bold">reduce</span>. <a id="filepos260553"></a>Flexibly producing any value from the application of a function to a collection is called a <span class="italic">reduction</span> in many circles. Clojure implements this concept via a higher-order function called <tt class="calibre22">reduce</tt>.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos260804"></a><a href="#filepos282362"><span class="calibre32">53</span></a><span class="calibre32">]</span></small></sup> The simplest possible example of <tt class="calibre22">reduce</tt> provides us with a Clojure analogue to the <tt class="calibre22">maxOf</tt> static method from <a href="#filepos253411"><span class="calibre5">Example 2-2</span></a>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(reduce max [0 -3 10 48])<br class="calibre33"/>;= 10</tt></span></blockquote><p class="calibre23">Given a function and a collection to operate over, <tt class="calibre22">reduce</tt> applies the function to each of the items of the collection, accumulating and returning a single result value. The key to <tt class="calibre22">reduce</tt> is understanding how it manages the application of the function to the collection’s items. If you were to invoke the same operations yourself manually, they’d look like this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(max 0 -3)<br class="calibre33"/>;= 0<br class="calibre33"/>(max 0 10)<br class="calibre33"/>;= 10<br class="calibre33"/>(max 10 48)<br class="calibre33"/>;= 48</tt></span></blockquote><p class="calibre23">or, in a single expression:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos261908"></a><a href="#filepos282645"><span class="calibre32">54</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(max (max (max 0 -3) 10) 48)<br class="calibre33"/>;= 48</tt></span></blockquote><p class="calibre23">On the first “iteration” of <tt class="calibre22">reduce</tt>’s operation, it applies the provided function to the first two items in the collection, obtaining a result. After that, <tt class="calibre22">reduce</tt> applies the function to the previous result (e.g., <tt class="calibre22">0</tt> above) and the next item in the collection (e.g., <tt class="calibre22">10</tt> above, since it had only consumed <tt class="calibre22">0</tt> and <tt class="calibre22">-3</tt> so far) to obtain its next result, and so on. You can also optionally provide an initial value to “seed” the reduction:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(reduce + 50 [1 2 3 4])<br class="calibre33"/>;= 60</tt></span></blockquote><p class="calibre23">Here, <tt class="calibre22">reduce</tt> is doing nothing different, except that the first time it invokes the provided function, it uses the initial value as the first argument to the function, with the second argument being the first item from the collection. Being able to provide an initial value to seed the reduction is a key capability, as this allows us to easily reduce a collection of values into a result of any type. For example, we can reduce a collection of numbers into a map, with numbers for keys, and their squares for values:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(reduce<br class="calibre33"/>  (fn [m v]             </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>    (assoc m v (* v v)))<br class="calibre33"/>  {}                    </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  [1 2 3 4])<br class="calibre33"/>;= {4 16, 3 9, 2 4, 1 1}</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">We provide a function to <tt class="calibre22">reduce</tt> as in our other examples, but in this case, one that we define inline. It takes two arguments, a map (always the result of the prior step of the reduction, or the initial value we provide), and the next item in the collection we’re reducing over. The function we supply here is simply <tt class="calibre22">assoc</tt>ing<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos264376"></a><a href="#filepos283207"><span class="calibre32">55</span></a><span class="calibre32">]</span></small></sup> into the map the next item from the collection and that item’s square; <tt class="calibre22">assoc</tt> returns a new map that contains that entry, which will be used as the first argument to our function for the next step in the reduction.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">We provide our initial value to “seed” the reduce here, just before our collection to be reduced over. <tt class="calibre22">{}</tt> is a Clojure literal for an empty map.</blockquote><blockquote class="calibre38"></blockquote><blockquote class="calibre39"><span class="calibre10"><span class="bold">WHEN TO USE ANONYMOUS FUNCTIONS OR FUNCTION LITERALS</span></span></blockquote><blockquote id="filepos265212" class="calibre17"><span class="calibre10">The previous example is written using an anonymous function created with the </span><span class="calibre10"><tt class="calibre22">fn</tt></span><span class="calibre10"> form. Providing anonymous functions like this in conjunction with usage of </span><span class="calibre10"><tt class="calibre22">map</tt></span><span class="calibre10">, </span><span class="calibre10"><tt class="calibre22">reduce</tt></span><span class="calibre10">, and other higher-order functions is incredibly common. However, you should also ensure that you’re familiar with Clojure’s function literals; as we saw in </span><a href="#filepos176636"><span class="calibre10"><span class="calibre5">Function literals</span></span></a><span class="calibre10">, they do away with the </span><span class="calibre10"><tt class="calibre22">fn</tt></span><span class="calibre10"> symbol and an explicit argument vector, thus eliminating a fair bit of verbosity when the function being defined is particularly simple.</span></blockquote><blockquote class="calibre17"><span class="calibre10">For example, here’s the previous </span><span class="calibre10"><tt class="calibre22">reduce</tt></span><span class="calibre10"> example rewritten using a function literal instead of the longer </span><span class="calibre10"><tt class="calibre22">fn</tt></span><span class="calibre10"> form:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(reduce<br class="calibre33"/>  #(assoc % %2 (* %2 %2))<br class="calibre33"/>  {}<br class="calibre33"/>  [1 2 3 4])<br class="calibre33"/>;= {4 16, 3 9, 2 4, 1 1}</tt></span></blockquote><blockquote class="calibre35"><span class="calibre10">Whether you use the longer form of anonymous function or a function literal is largely a matter of personal taste. The latter are certainly more concise, and make sense for very short functions, whereas the former allows you to be more explicit and informative about arguments and their purpose. In either case, Clojure code in the wild often uses both forms, so you need to be able to read them equally well.</span></blockquote><p class="calibre50">Many of the same comparisons can be made between our use of <tt class="calibre22">reduce</tt> with <tt class="calibre22">max</tt> and the <tt class="calibre22">maxOf</tt> static method we defined in Java in <a href="#filepos253411"><span class="calibre5">Example 2-2</span></a> as we made between the use of <tt class="calibre22">map</tt> with <tt class="calibre22">lower-case</tt> and the <tt class="calibre22">toLowerCase</tt> static method: the separation of operations from their modes of application, the avoidance of explicitly defining imperative control flow, and so on. However, perhaps the most significant point of contrast is that, <span class="italic">no one would define functions analogous to the </span><tt class="calibre22"><span class="italic">maxOf</span></tt><span class="italic"> and </span><tt class="calibre22"><span class="italic">toLowerCase</span></tt><span class="italic"> static methods in Clojure</span>; it is far more sensible to define core operations like <tt class="calibre22">max</tt> and <tt class="calibre22">lower-case</tt>, and then apply them to your data in place as needed by using whatever higher-order function is most appropriate.</p><p id="filepos268007" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Applying Ourselves Partially</span></span></span></p><p class="calibre18"><span class="italic">Function application</span>
<a id="filepos268181"></a>is the invocation of a function with a sequence of arguments, in contrast to function calls indicated by syntactic convention. For example, in Ruby and Python (Examples <a href="#filepos268598"><span class="calibre5">2-3</span></a> and <a href="#filepos270807"><span class="calibre5">2-4</span></a>), a function can be applied to an array or list of arguments by prepending the argument reference with an asterisk:</p><p id="filepos268598" class="calibre23"></p><p class="calibre23"><span class="italic">Example 2-3. Function (method) application in Ruby</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">&gt;&gt; interval = [-10, 10]<br class="calibre33"/>=&gt; [-10, 10]<br class="calibre33"/>&gt;&gt; Range.new(*interval)<br class="calibre33"/>=&gt; -10..10<br class="calibre33"/><br class="calibre33"/>&gt;&gt; h = {}<br class="calibre33"/>=&gt; {}<br class="calibre33"/>&gt;&gt; pair = ['a', 5]<br class="calibre33"/>=&gt; ["a", 5]<br class="calibre33"/>&gt;&gt; h.store(*pair)<br class="calibre33"/>=&gt; 5<br class="calibre33"/>&gt;&gt; h<br class="calibre33"/>=&gt; {"a"=&gt;5}</tt></span></p><p class="calibre13">This capability is absolutely fundamental if a language is to be able to support various functional programming idioms—especially when the function you need to invoke is unknown (perhaps provided to you in a particular context as an argument), and arguments to that function are data of indefinite size, it would simply be impossible (or, prohibitively verbose and error-prone) to have to pluck arguments out of the data and align them as necessary to construct a “regular” function call.</p><p class="calibre18">Function application is available in Clojure via <tt class="calibre22">apply</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(apply hash-map [:a 5 :b 6])<br class="calibre33"/>;= {:a 5, :b 6}</tt></span></blockquote><p class="calibre23">As a convenience, <tt class="calibre22">apply</tt> allows you to prefix the argument sequence with any number of explicit arguments. In many cases where you have some discrete values as well as a sequence of arguments, this allows you to avoid having to create a new sequence that includes the former:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def args [2 -2 10])<br class="calibre33"/>;= #'user/args<br class="calibre33"/>(apply * 0.5 3 args)<br class="calibre33"/>;= -60.0</tt></span></blockquote><p class="calibre23">Whereas function application is when a function is applied to its arguments held in a sequential collection—<tt class="calibre22">apply</tt> must be provided with <span class="italic">all</span> arguments to that function—<span class="italic">partial application</span> is where you can provide only <span class="italic">some</span> of the arguments to a function, yielding a new function that can be called with the remainder of the arguments to the original function later.</p><p id="filepos270807" class="calibre23"></p><p class="calibre23"><span class="italic">Example 2-4. Partial application in Python</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">&gt;&gt; from functools import partial<br class="calibre33"/>&gt;&gt; only_strings = partial(filter, lambda x: isinstance(x, basestring))<br class="calibre33"/>&gt;&gt; only_strings(['a', 5, 'b', 6])<br class="calibre33"/>['a', 'b']</tt></span></p><p class="calibre13">What’s happening here? <tt class="calibre22">partial</tt> accepts some function (<tt class="calibre22">filter</tt> above, but can be any <tt class="calibre22">ƒ</tt>), and one or more arguments to that function (a string type predicate above, but can be any <tt class="calibre22">a</tt>, <tt class="calibre22">b</tt>, …), and returns a new function <tt class="calibre22">g</tt> that retains those arguments as well as a reference to <tt class="calibre22">ƒ</tt>:</p><p class="calibre51"><img src="images/00017.jpg" class="calibre59"/></p><p class="calibre13">When <tt class="calibre22">g</tt>, the function returned from <tt class="calibre22">partial</tt>, is invoked, its return is the result of calling the original function <tt class="calibre22">ƒ</tt> with the arguments provided to <tt class="calibre22">partial</tt> (<tt class="calibre22">a</tt>, <tt class="calibre22">b</tt>, …) <span class="italic">plus</span> any arguments provided to <tt class="calibre22">g</tt>:</p><p class="calibre51"><img src="images/00022.jpg" class="calibre60"/></p><p class="calibre13"><tt class="calibre22">partial</tt> provides for partial application in Clojure:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def only-strings (partial filter string?))<br class="calibre33"/>;= #'user/only-strings<br class="calibre33"/>(only-strings ["a" 5 "b" 6])<br class="calibre33"/>;= ("a" "b")</tt></span></blockquote><p class="calibre23">Partial application is commonly used in a number of contexts. For example, functions that require some configuration (maybe to connect to a database, maybe to indicate where a file should be written) often have that configuration as their first (or first couple) arguments. This allows you to easily use <tt class="calibre22">partial</tt> to create a derivative of such functions that have the necessary configuration “locked in,” without necessarily worrying about what additional arguments the underlying function requires:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def database-lookup (partial get-data "jdbc:mysql://..."))</tt></span></blockquote><p class="calibre23">This characteristic of <tt class="calibre22">partial</tt>—where it can be used to easily toss off a derivative of a function without concern for what the remainder of the function’s arguments should be—can be very useful and is part of what makes <tt class="calibre22">partial</tt> attractive to use in conjunction with <tt class="calibre22">comp</tt>.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos273473"></a><a href="#filepos283913"><span class="calibre32">56</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Be aware that, compared to a regular function call with explicit arguments, higher-order functions like </span><span class="calibre10"><tt class="calibre22">apply</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">partial</tt></span><span class="calibre10"> do carry a performance penalty, albeit a small one and only on large arities: </span><a id="filepos274065"></a><span class="calibre10"><tt class="calibre22">comp</tt></span><span class="calibre10"> up to three arguments and </span><span class="calibre10"><tt class="calibre22">partial</tt></span><span class="calibre10"> up to four use specialized implementations, which create plain closures without requiring packing and unpacking arguments in a varargs sequence.</span></blockquote><blockquote class="calibre17"><span class="calibre10">The performance penalty associated with larger arities of </span><a id="filepos274491"></a><span class="calibre10"><tt class="calibre22">apply</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">partial</tt></span><span class="calibre10"> is because such functions need to unpack sequence(s) of provided arguments in order to call the arity of the function that corresponds to the total number of arguments provided. This can never be as fast as “regular” Clojure function calls, which simply reuse the JVM’s (</span><span class="calibre10"><span class="italic">really</span></span><span class="calibre10"> fast) method invocation machinery. On the bright side, because of that underlying efficient machinery, calling functions with </span><span class="calibre10"><tt class="calibre22">apply</tt></span><span class="calibre10"> and the functions returned by </span><span class="calibre10"><tt class="calibre22">partial</tt></span><span class="calibre10"> remain leaps and bounds faster in Clojure than, for example, direct, explicit method calls in Python or Ruby.</span></blockquote><p class="calibre25"><span class="bold">partial versus function literals</span>. <a id="filepos275425"></a>You might have noticed that function literals technically provide a superset of what <tt class="calibre22">partial</tt> provides: they allow you to concisely create a function that calls another function with some subset of its arguments predefined.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(#(filter string? %) ["a" 5 "b" 6])<br class="calibre33"/>;= ("a" "b")</tt></span></blockquote><p class="calibre23">However, function literals do not limit you to defining only the initial arguments to the function:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(#(filter % ["a" 5 "b" 6]) string?)<br class="calibre33"/>;= ("a" "b")<br class="calibre33"/>(#(filter % ["a" 5 "b" 6]) number?)<br class="calibre33"/>;= (5 6)</tt></span></blockquote><p class="calibre23">The tradeoff is that function literals force you to fully specify all of the arguments to the functions it calls, whereas <tt class="calibre22">partial</tt> allows you to be ignorant of such details:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(#(map *) [1 2 3] [4 5 6] [7 8 9])                    </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #&lt;ArityException clojure.lang.ArityException:<br class="calibre33"/>;=   Wrong number of args (3) passed to: user$eval812$fn&gt;<br class="calibre33"/>(#(map * % %2 %3) [1 2 3] [4 5 6] [7 8 9])            </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= (28 80 162)<br class="calibre33"/>(#(map * % %2 %3) [1 2 3] [4 5 6])                    </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #&lt;ArityException clojure.lang.ArityException:<br class="calibre33"/>;=   Wrong number of args (2) passed to: user$eval843$fn&gt;<br class="calibre33"/>(#(apply map * %&amp;) [1 2 3] [4 5 6] [7 8 9])           </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= (28 80 162)<br class="calibre33"/>(#(apply map * %&amp;) [1 2 3])<br class="calibre33"/>;= (1 2 3)<br class="calibre33"/><br class="calibre33"/>((partial map *) [1 2 3] [4 5 6] [7 8 9])             </tt></span><a></a><img src="images/00001.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= (28 80 162)</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">We can’t avoid providing a full accounting of the arguments to <tt class="calibre22">map</tt>; the function literal ends up taking zero arguments, because functions defined by literals have a single arity based on the number of arguments they refer to.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">We can “solve” this for some inputs by enumerating additional arguments to <tt class="calibre22">map</tt>…</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">…but this will fail if the usage of our function literal does not align exactly with what we define.</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">A solution for such cases is to use <tt class="calibre22">apply</tt>, along with the function literal syntax indicating the acceptance of rest args, <tt class="calibre22">%&amp;</tt>.</blockquote><p class="calibre23"><img src="images/00001.jpg" class="calibre36"/></p><blockquote class="calibre37">This is essentially duplicating what <tt class="calibre22">partial</tt> will do for you with ease, and without the syntactic penalties.</blockquote><p class="calibre18">As you can see, there are cases where the use of <tt class="calibre22">partial</tt> will produce more easily readable code, and others where <tt class="calibre22">partial</tt> is a clearly preferable way to bind some initial subset of arguments to a function with unknown arities.<a id="filepos279583"></a></p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos279687"></a><a href="#filepos251160"><span class="calibre32">48</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Ruby’s </span><span class="calibre10"><span class="italic">blocks</span></span><span class="calibre10">, the objects created via </span><span class="calibre10"><tt class="calibre22">lambda</tt></span><span class="calibre10">, and </span><span class="calibre10"><tt class="calibre22">Proc.new</tt></span><span class="calibre10">, and even class methods via </span><span class="calibre10"><tt class="calibre22">SomeClass.method(:foo)</tt></span><span class="calibre10"> are all slightly different variants of first-class functions. On the other hand, Clojure’s functions fill all of those roles.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos280321"></a><a href="#filepos255202"><span class="calibre32">49</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">These Clojure functions actually just delegate to the corresponding Java methods.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos280586"></a><a href="#filepos256330"><span class="calibre32">50</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">This is likely due to the great utility of the sequence abstraction, described in </span><a href="#filepos354167"><span class="calibre10"><span class="calibre5">Sequences</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos280961"></a><a href="#filepos259277"><span class="calibre32">51</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">The sequences returned by </span><span class="calibre10"><tt class="calibre22">map</tt></span><span class="calibre10"> are </span><span class="calibre10"><span class="italic">lazy</span></span><span class="calibre10">, as are most other sequence-producing functions in Clojure. We discuss lazy sequences fully in </span><a href="#filepos368238"><span class="calibre10"><span class="calibre5">Lazy seqs</span></span></a><span class="calibre10">; for now, you can ignore this detail.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos281529"></a><a href="#filepos260112"><span class="calibre32">52</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">This is incredibly useful, and makes possible things like </span><span class="calibre10"><tt class="calibre22">pmap</tt></span><span class="calibre10">, which you can use to easily parallelize the application of a </span><span class="calibre10"><span class="italic">pure</span></span><span class="calibre10"> function across collection(s). See </span><a href="#filepos316677"><span class="calibre10"><span class="calibre5">Pure Functions</span></span></a><span class="calibre10"> for a discussion of them, and </span><a href="#filepos618299"><span class="calibre10"><span class="calibre5">Parallelism on the Cheap</span></span></a><span class="calibre10"> for details on </span><span class="calibre10"><tt class="calibre22">pmap</tt></span><span class="calibre10"> and related parallelization facilities.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos282362"></a><a href="#filepos260804"><span class="calibre32">53</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">And somewhat confusingly named </span><span class="calibre10"><tt class="calibre22">inject</tt></span><span class="calibre10"> in Ruby.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos282645"></a><a href="#filepos261908"><span class="calibre32">54</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Clojure provides plenty of options for making sure that code like this should never be seen in the wild. For example, </span><span class="calibre10"><tt class="calibre22">max</tt></span><span class="calibre10"> is variadic already, so </span><span class="calibre10"><tt class="calibre22">(max 0 -3 10 48)</tt></span><span class="calibre10"> is far preferable compared to the pointlessly nested parentheses shown here purely for illustrative purposes.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos283207"></a><a href="#filepos264376"><span class="calibre32">55</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">That is, </span><span class="calibre10"><span class="italic">associate</span></span><span class="calibre10">, the equivalent of </span><span class="calibre10"><tt class="calibre22">java.util.Map.put(Object, Object)</tt></span><span class="calibre10"> in Java or </span><span class="calibre10"><tt class="calibre22">hash_map[key] = value</tt></span><span class="calibre10"> in Python and Ruby. We cover maps, </span><span class="calibre10"><tt class="calibre22">assoc</tt></span><span class="calibre10">, and all of the rest of Clojure’s rich collections in </span><a href="#filepos335797"><span class="calibre10"><span class="calibre5">Chapter 3</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos283913"></a><a href="#filepos273473"><span class="calibre32">56</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">We’ll get to </span><span class="calibre10"><tt class="calibre22">comp</tt></span><span class="calibre10"> shortly, in </span><a href="#filepos284265"><span class="calibre10"><span class="calibre5">Composition of Function(ality)</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos284265" class="calibre6"><span class="calibre4"><span class="bold">Composition of Function(ality)</span></span></p><p class="calibre18"><span class="italic">Compositionality</span><a id="filepos284407"></a> is an overloaded term; we use it to refer to the ability of various parts to be joined together to create a well-formed composite that is itself reusable.</p><p class="calibre18">Different programming models provide varying support for assembling constituent parts into larger wholes. Imperative, procedural code is generally not composable at all; calling a subroutine or method in the course of a procedure is little more than a difference in notation. Object orientation offers some basic facilities for composition, most notably the concept of an attribute where a composite establishes a “has-a” relationship between itself and another entity. Patterns like delegation and pluggable strategies are other ways you can coherently glom smaller pieces together.</p><p class="calibre18">Functional programming puts an even greater emphasis on compositionality, making it astonishingly easy to start with small pieces and loosely join them into purpose-built abstractions. We dig into Clojure’s additional specific mechanisms for building abstractions at length in <a href="#filepos831397"><span class="calibre5">Part II</span></a>, but the simplest abstraction of all is the function. Because they are generally divorced from data entirely—and, ideally, able to polymorphically work with whatever concrete types of data might be semantically suitable—functions can be used to assemble very powerful composites with a minimum of ceremony.</p><p class="calibre18"><span class="italic">Function composition</span><a id="filepos285932"></a> has a very distinct meaning in functional programming circles:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos286037"></a><a href="#filepos311229"><span class="calibre32">57</span></a><span class="calibre32">]</span></small></sup> given any number of functions, it is the creation of a function that applies its arguments to one of the provided functions, using each successive result as the argument to the next provided function, usually in the reverse order that the functions were originally specified.</p><p class="calibre18">For example, say we frequently needed the negation of a sum of some given numbers, but as a string. That’s simple enough to write:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn negated-sum-str<br class="calibre33"/>  [&amp; numbers]<br class="calibre33"/>  (str (- (apply + numbers))))<br class="calibre33"/>;= #'user/negated-sum-str<br class="calibre33"/>(negated-sum-str 10 12 3.4)<br class="calibre33"/>;= "-25.4"</tt></span></blockquote><p class="calibre23">Function composition, implemented in Clojure via <tt class="calibre22">comp</tt><a id="filepos286936"></a>, can bring together operations like this more concisely, and usually with more clarity:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def negated-sum-str (comp str - +))<br class="calibre33"/>;= #'user/negated-sum-str<br class="calibre33"/>(negated-sum-str 10 12 3.4)<br class="calibre33"/>;= "-25.4"</tt></span></blockquote><p class="calibre23">These two definitions of <tt class="calibre22">negated-sum-str</tt> are functionally equivalent; they differ only in their construction.</p><p class="calibre18">What’s going on here? You can think of <tt class="calibre22">comp</tt> as defining a pipeline: it accepts any number of functions—<tt class="calibre22">str</tt>, <tt class="calibre22">-</tt>, and <tt class="calibre22">+</tt> above, but can be any <tt class="calibre22">ƒ</tt>, <tt class="calibre22">g</tt>, and <tt class="calibre22">h</tt>—and produces a new function (labeled <tt class="calibre22">k</tt> in the figure) that accepts the same arguments as <tt class="calibre22">h</tt> (since it is the first stage in the pipeline), and then calls <tt class="calibre22">g</tt> with the result given by <tt class="calibre22">h</tt>, calls <tt class="calibre22">ƒ</tt> with the result given by <tt class="calibre22">g</tt>, and so on.</p><p class="calibre51"><img src="images/00031.jpg" class="calibre61"/></p><p class="calibre13">The final result is that given by the first function provided to <tt class="calibre22">comp</tt>.</p><p class="calibre18">The sole limitation of <tt class="calibre22">comp</tt> is that the result of each function in the composite <span class="italic">must</span> be a suitable argument for the function that precedes it syntactically. So, if we reverse the order of functions in the composition that produced the <tt class="calibre22">negated-sum-str</tt> function, we get an error:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">((comp + - str) 5 10)<br class="calibre33"/>;= #&lt;ClassCastException java.lang.ClassCastException:<br class="calibre33"/>;=   java.lang.String cannot be cast to java.lang.Number&gt;</tt></span></blockquote><p class="calibre23">…because the result of the call <tt class="calibre22">(str 5 10)</tt> is a string, which cannot be negated by <tt class="calibre22">-</tt>.</p><p class="calibre18">Far from being relegated to toy examples, <tt class="calibre22">comp</tt> can be used to build up significant chains of functionality, either in a single composition, or as a result of composing functions that are themselves products of <tt class="calibre22">comp</tt>. For example, many identifiers—in Java, in XML and other markup, and so on—are often provided in <tt class="calibre22">CamelCase</tt> style. We may reasonably want to put data that uses such identifiers as keys into a Clojure map, but we would like to idiomatically continue to use lowercase, hyphen-delimited keywords to refer to those entries in Clojure.</p><p class="calibre18">A function to do this might reasonably use <tt class="calibre22">comp</tt>, and look like so:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(require '[clojure.string :as str])                               </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/><br class="calibre33"/>(def camel-&gt;keyword (comp keyword<br class="calibre33"/>                          str/join<br class="calibre33"/>                          (partial interpose \-)<br class="calibre33"/>                          (partial map str/lower-case)<br class="calibre33"/>                          #(str/split % #"(?&lt;=[a-z])(?=[A-Z])"))) </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #'user/camel-&gt;keyword<br class="calibre33"/>(camel-&gt;keyword "CamelCase")<br class="calibre33"/>;= :camel-case<br class="calibre33"/>(camel-&gt;keyword "lowerCamelCase")<br class="calibre33"/>;= :lower-camel-case</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">We use <tt class="calibre22">require</tt> here to ensure that the <tt class="calibre22">clojure.string</tt> namespace is loaded, and establish a <tt class="calibre22">str</tt> prefix for its vars in the current namespace.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">There’s no need to use predefined functions with <tt class="calibre22">comp</tt>. This function literal uses a regular expression<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos291187"></a><a href="#filepos311837"><span class="calibre32">58</span></a><span class="calibre32">]</span></small></sup> to split provided strings between a lowercase character and an uppercase character to suit <tt class="calibre22">CamelCase</tt> identifiers.</blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">You can achieve much the same effect as </span><span class="calibre10"><tt class="calibre22">comp</tt></span><span class="calibre10"> in another way, using the </span><span class="calibre10"><tt class="calibre22">-&gt;</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">-&gt;&gt;</tt></span><a id="filepos291828"></a><span class="calibre10"> macros.<sup class="calibre58"><small class="calibre31"><span class="calibre32">[</span><a id="filepos291893"></a><a href="#filepos312218"><span class="calibre32">59</span></a><span class="calibre32">]</span></small></sup> Being macros, they do not operate over functions; rather, they rearrange the code you provide to “thread” a value or collection as either the first or last argument in each form. For example, this is functionally equivalent to the </span><span class="calibre10"><tt class="calibre22">camel-&gt;keyword</tt></span><span class="calibre10"> function we produce using </span><span class="calibre10"><tt class="calibre22">comp</tt></span><span class="calibre10"> above:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(defn camel-&gt;keyword<br class="calibre33"/>  [s]<br class="calibre33"/>  (-&gt;&gt; (str/split s #"(?&lt;=[a-z])(?=[A-Z])")<br class="calibre33"/>    (map str/lower-case)<br class="calibre33"/>    (interpose \-)<br class="calibre33"/>    str/join<br class="calibre33"/>    keyword))</tt></span></blockquote><blockquote class="calibre35"><span class="calibre10">Whether you use </span><span class="calibre10"><tt class="calibre22">comp</tt></span><span class="calibre10"> or threading macros for any given task is largely a matter of style.<sup class="calibre58"><small class="calibre31"><span class="calibre32">[</span><a id="filepos292941"></a><a href="#filepos312682"><span class="calibre32">60</span></a><span class="calibre32">]</span></small></sup></span></blockquote><p class="calibre25">We can use <tt class="calibre22">camel-&gt;keyword</tt> as part of a further composition, defining a function that returns an idiomatic Clojure map given a sequence of key/value pairs that use <tt class="calibre22">CamelCase</tt>-style keys:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def camel-pairs-&gt;map (comp (partial apply hash-map)<br class="calibre33"/>                            (partial map-indexed (fn [i x]<br class="calibre33"/>                                                   (if (odd? i)<br class="calibre33"/>                                                     x<br class="calibre33"/>                                                     (camel-&gt;keyword x))))))<br class="calibre33"/>;= #'user/camel-pairs-&gt;map<br class="calibre33"/>(camel-pairs-&gt;map ["CamelCase" 5 "lowerCamelCase" 3])<br class="calibre33"/>;= {:camel-case 5, :lower-camel-case 3}</tt></span></blockquote><p id="filepos294075" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Writing Higher-Order Functions</span></span></span></p><p id="filepos294195" class="calibre18">The notion of function composition as embodied by <tt class="calibre22">comp</tt> is just one possible way to compose functionality—a useful one to be sure, but just as it is broadly applicable, it is in some sense the lowest common denominator of compositionality. While Clojure provides a number of general-purpose higher-order functions, they are by no means reserved for general-purpose things.</p><p class="calibre18">More sophisticated and sometimes more utilitarian composites are only made possible by tailoring your own contracts between functions and higher-order functions. Once you are accustomed to treating functions as just another category of values, you’ll find yourself writing function-producing and function-accepting functions quite naturally.</p><p class="calibre18">Let’s look at some fairly trivial examples. First, a HOF that returns a function that adds a given number to its argument:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn adder<br class="calibre33"/>  [n]<br class="calibre33"/>  (fn [x] (+ n x)))<br class="calibre33"/>;= #'user/adder<br class="calibre33"/>((adder 5) 18)<br class="calibre33"/>;= 23</tt></span></blockquote><p class="calibre23">Less trivial might be a higher-order function that doubles the result of calling the provided function:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn doubler<br class="calibre33"/>  [f]<br class="calibre33"/>  (fn [&amp; args]<br class="calibre33"/>    (* 2 (apply f args))))<br class="calibre33"/>;= #'user/doubler<br class="calibre33"/>(def double-+ (doubler +))<br class="calibre33"/>;= #'user/double-+<br class="calibre33"/>(double-+ 1 2 3)<br class="calibre33"/>;= 12</tt></span></blockquote><p class="calibre23">Let’s build something more interesting, and along the way, see how some aspects of functional programming are actually very well-suited for solving problems related to state and IO in addition to those dealing with immutable data and algorithms.</p><p id="filepos296083" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Building a Primitive Logging System with Composable Higher-Order Functions</span></span></span></p><p id="filepos296247" class="calibre18">Logging is a common necessity of applications large and small, and the configuration of logging is often fairly cumbersome and complicated for a variety of reasons. We can skin this cat in a slightly different way using a couple of higher-order functions.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos296565"></a><a href="#filepos313261"><span class="calibre32">61</span></a><span class="calibre32">]</span></small></sup> We’ll end up having to use a couple of bits of Clojure that we’ve not discussed in detail yet, but you’ll be able to follow along easily.</p><p class="calibre18">We’re all guilty of using <tt class="calibre22">System.out.println</tt> or <tt class="calibre22">puts</tt> or <tt class="calibre22">print</tt> for logging—it’s brutish, yet effective in a pinch. To improve on this, let’s start simply, with a simple HOF that returns a function that prints messages to any writer we provide to the HOF:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn print-logger<br class="calibre33"/>  [writer]                   </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  #(binding [*out* writer]   </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>     (println %)))           </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Our HOF accepts as a single argument any instance of <tt class="calibre22">java.io.Writer</tt>, the base of any type that provides for the writing of character data to some output device.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">print-logger</tt> returns a function that <span class="italic">binds</span>
<tt class="calibre22">*out*<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos298234"></a><a href="#filepos313828"><span class="calibre32">62</span></a><span class="calibre32">]</span></small></sup></tt> with the value of <tt class="calibre22">writer</tt>, the <tt class="calibre22">Writer</tt> we provided to the HOF.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">The body of our returned function writes its sole argument (the message we want to log) using <tt class="calibre22">println</tt>, which always writes to <tt class="calibre22">*out*</tt> (which we’ve replaced in this scope with our <tt class="calibre22">writer</tt>).</blockquote><p class="calibre18">Let’s see how it works:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def *out*-logger (print-logger *out*))  </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #'user/*out*-logger<br class="calibre33"/>(*out*-logger "hello")                   </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>; hello<br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">We provide <tt class="calibre22">*out*</tt> to <tt class="calibre22">print-logger</tt>, so all messages sent to the returned function will be logged to <tt class="calibre22">*out*</tt>—or rather to the value of <tt class="calibre22">*out*</tt> at the moment when <tt class="calibre22">*out*-logger</tt> was defined.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">print-logger</tt> always returns a function that accepts a single argument, which we call here with a string.</blockquote><p class="calibre18">Okay, all we did there was produce a more complicated <tt class="calibre22">println</tt> that dumps output to <tt class="calibre22">stdout</tt>. More interesting would be capturing logging output in an in-memory buffer. <tt class="calibre22">java.io.StringWriter</tt> does this for us; it is a <tt class="calibre22">java.io.Writer</tt> implementation that is backed not by an output device, but by a character buffer:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def writer (java.io.StringWriter.))         </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #'user/writer<br class="calibre33"/>(def retained-logger (print-logger writer))<br class="calibre33"/>;= #'user/retained-logger<br class="calibre33"/>(retained-logger "hello")                    </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= nil<br class="calibre33"/>(str writer)                                 </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= "hello\n"</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">We create and retain a <tt class="calibre22">StringWriter</tt> separately, so we can poke at it after we use <tt class="calibre22">print-logger</tt> to produce a logging function targeting it.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">Calling our logging function doesn’t write anything to <tt class="calibre22">stdout</tt>…</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">…because it’s been <tt class="calibre22">println</tt>ed to our <tt class="calibre22">StringWriter</tt> instead.</blockquote><p class="calibre18">This is slightly more interesting; but any logging approach worth its salt can log to files. The contract of <tt class="calibre22">print-logger</tt> allows us to get there pretty easily: given a <tt class="calibre22">Writer</tt>, it will return a function that writes provided messages to that <tt class="calibre22">Writer</tt>. So, as long as we can obtain a <tt class="calibre22">Writer</tt> that dumps output to a file of our choosing, we’ll be good to go.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(require 'clojure.java.io)<br class="calibre33"/><br class="calibre33"/>(defn file-logger<br class="calibre33"/>  [file]                                                     </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  #(with-open [f (clojure.java.io/writer file :append true)] </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>     ((print-logger f) %)))                                  </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">The <tt class="calibre22">file-logger</tt> HOF accepts a single <tt class="calibre22">file</tt> argument, to which log messages will be written. Because of the semantics of <tt class="calibre22">clojure.java.io/writer</tt>, this argument can be a string naming a file path or an instance of either <tt class="calibre22">java.io.File</tt>, <tt class="calibre22">java.net.URL</tt>, or <tt class="calibre22">java.net.URI</tt> that does the same.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">The function literal that <tt class="calibre22">file-logger</tt> returns creates a new <tt class="calibre22">Writer</tt> for the <tt class="calibre22">file</tt>, opens it for appending (so we don’t clobber any messages written to it in the past), and names it <tt class="calibre22">f</tt> within the local scope.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos303941"></a><a href="#filepos314545"><span class="calibre32">63</span></a><span class="calibre32">]</span></small></sup></blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">Instead of repeating the binding of <tt class="calibre22">*out*</tt> and use of <tt class="calibre22">println</tt> here, we just call <tt class="calibre22">print-logger</tt> with our file’s <tt class="calibre22">Writer</tt>, and call the function it returns straight off with the message to be logged. Remember that since functions are values, there’s no need to define a top-level var in order to call one; the function returned by <tt class="calibre22">print-logger</tt> is created, called, and then discarded immediately.</blockquote><p class="calibre18">Let’s see how we’re doing:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def log-&gt;file (file-logger "messages.log"))<br class="calibre33"/>;= #'user/log-&gt;file<br class="calibre33"/>(log-&gt;file "hello")<br class="calibre33"/>;= nil<br class="calibre33"/><br class="calibre33"/>% more messages.log<br class="calibre33"/>hello</tt></span></blockquote><p class="calibre23">Fabulous: we can create a function that logs to a given file (<tt class="calibre22">messages.log</tt> in the current directory here), and messages logged via that function are written to that logfile as we’d expect. This is not so bad for 10 lines of code, and you could easily add to the set of <tt class="calibre22">*-logger</tt> HOFs; having ones that produced functions that logged to databases, message queues, and other sinks would be straightforward enough, and they could all be swapped around however your needs dictate.</p><p class="calibre18">But, what if we needed to log to multiple destinations? That’s not a detail that code using a logger function should have to care about. For this, we need a different kind of logging HOF, one that produces a function that doesn’t do any logging itself, but that routes a message to multiple other loggers:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn multi-logger<br class="calibre33"/>  [&amp; logger-fns]           </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  #(doseq [f logger-fns]   </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>     (f %)))</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">multi-logger</tt> accepts any number of other logging functions.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">The function it returns will imperatively loop over the sequence of logging functions,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos306745"></a><a href="#filepos315309"><span class="calibre32">64</span></a><span class="calibre32">]</span></small></sup> calling each with the message to be logged.</blockquote><p class="calibre18">Having this available makes it easy for us to define logging functions that dump messages to multiple sinks:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def log (multi-logger                        </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>           (print-logger *out*)<br class="calibre33"/>           (file-logger "messages.log")))<br class="calibre33"/>;= #'user/log<br class="calibre33"/>(log "hello again")<br class="calibre33"/>; hello again<br class="calibre33"/>;= nil<br class="calibre33"/><br class="calibre33"/>% more messages.log<br class="calibre33"/>hello<br class="calibre33"/>hello again</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">We create a new “top-level” logging function that, thanks to <tt class="calibre22">multi-logger</tt>, will direct messages to <tt class="calibre22">*out*</tt> as well as to our <span class="italic">messages.log</span> logfile.</blockquote><p class="calibre18">Yes, now we can log to any number of destinations.</p><p class="calibre18">Let’s look at one final enhancement to our miniature logging library. Because the data being passed around by all of the functions produced by our logging HOFs is uniform (just a string at the moment), there’s nothing stopping us from defining other higher-order functions that can enhance and transform that data in various ways. Log messages almost always include a timestamp, so maybe a HOF that prepends timestamps to messages is a good start:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 2-5. Adding a piece of “logging middleware” to include a timestamp with each log message</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(defn timestamped-logger<br class="calibre33"/>  [logger]<br class="calibre33"/>  #(logger (format "[%1$tY-%1$tm-%1$te %1$tH:%1$tM:%1$tS] %2$s" (java.util.Date.) %))) </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/><br class="calibre33"/>(def log-timestamped (timestamped-logger<br class="calibre33"/>                       (multi-logger<br class="calibre33"/>                         (print-logger *out*)<br class="calibre33"/>                         (file-logger "messages.log"))))<br class="calibre33"/><br class="calibre33"/>(log-timestamped "goodbye, now")<br class="calibre33"/>; [2011-11-30 08:54:00] goodbye, now<br class="calibre33"/>;= nil<br class="calibre33"/><br class="calibre33"/>% more messages.log<br class="calibre33"/>hello<br class="calibre33"/>hello again<br class="calibre33"/>[2011-11-30 08:54:00] goodbye, now</tt></span></p><p class="calibre23"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">The function returned by <tt class="calibre22">timestamped-logger</tt> simply prepends a timestamp to the string message passed to it and calls the logging function provided to the HOF with the enhanced message. <tt class="calibre22">format</tt> is a Clojure function that uses Java’s <tt class="calibre22">String.format</tt> method to apply <tt class="calibre22">sprintf</tt>-style formatting to some number of objects.</blockquote><p class="calibre13">We can imagine transforming logged messages in a variety of ways—adding the current namespace, implicit contextual information (e.g., which host the application is running on), maybe the source line number of a logging message,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos310287"></a><a href="#filepos315744"><span class="calibre32">65</span></a><span class="calibre32">]</span></small></sup> and so on. More significantly, if you were to use something like this in nontrivial applications, the most pressing improvement would be to make logging messages richer and more flexible than strings, so that logging data itself was open and more easily enhanced. For example, if each logging event were a map of data,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos310735"></a><a href="#filepos316239"><span class="calibre32">66</span></a><span class="calibre32">]</span></small></sup> then that map could be easily enhanced with all sorts of useful information without complicating the consumption or processing of logging data down the road. Such a structured approach would also make it very simple to compose in filtering of log events based on their “level” or importance.<a id="filepos311125"></a></p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos311229"></a><a href="#filepos286037"><span class="calibre32">57</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Function composition even has special notation in some settings. For example, mathematical notation for composition of functions </span><span class="calibre10"><tt class="calibre22">f</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">g</tt></span><span class="calibre10"> is </span><span class="calibre10"><tt class="calibre22">f ∘ g</tt></span><span class="calibre10">, while Haskell uses a period as the composition operator, </span><span class="calibre10"><tt class="calibre22">f . g</tt></span><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos311837"></a><a href="#filepos291187"><span class="calibre32">58</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">The reader supports convenient regular expression literals as we described in </span><a href="#filepos94923"><span class="calibre10"><span class="calibre5">Regular expressions</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos312218"></a><a href="#filepos291893"><span class="calibre32">59</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">We discuss </span><span class="calibre10"><tt class="calibre22">-&gt;</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">-&gt;&gt;</tt></span><span class="calibre10"> at length in </span><a href="#filepos935751"><span class="calibre10"><span class="calibre5">In Detail: -&gt; and -&gt;&gt;</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos312682"></a><a href="#filepos292941"><span class="calibre32">60</span></a><span class="calibre32">] </span></small></sup><span class="calibre10"><tt class="calibre22">comp</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">partial</tt></span><span class="calibre10"> enable </span><span class="calibre10"><span class="italic">point-free style</span></span><span class="calibre10"> (also known as </span><span class="calibre10"><span class="italic">tacit programming</span></span><span class="calibre10">), the distinguishing feature of which is that functions are defined without explicitly naming or referring to arguments (“points”).</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos313261"></a><a href="#filepos296565"><span class="calibre32">61</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">What we’re going to build here should not be confused for any sort of replacement for the accepted general-purpose Clojure logging library, </span><span class="calibre10"><tt class="calibre22">tools.logging</tt></span><span class="calibre10"> from </span><a href="https://github.com/clojure/tools.logging"><span class="calibre10"><span class="calibre5">https://github.com/clojure/tools.logging</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos313828"></a><a href="#filepos298234"><span class="calibre32">62</span></a><span class="calibre32">] </span></small></sup><span class="calibre10"><tt class="calibre22">*out*</tt></span><span class="calibre10"> is bound to a </span><span class="calibre10"><tt class="calibre22">Writer</tt></span><span class="calibre10"> that writes to </span><span class="calibre10"><tt class="calibre22">stdout</tt></span><span class="calibre10"> by default; by rebinding it, content written to </span><span class="calibre10"><tt class="calibre22">*out*</tt></span><span class="calibre10"> is redirected to the writer we specify. You can learn more about </span><span class="calibre10"><span class="italic">binding</span></span><span class="calibre10"> in </span><a href="#filepos744558"><span class="calibre10"><span class="calibre5">Dynamic Scope</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos314545"></a><a href="#filepos303941"><span class="calibre32">63</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">The </span><span class="calibre10"><tt class="calibre22">with-open</tt></span><span class="calibre10"> form will ensure that </span><span class="calibre10"><tt class="calibre22">f</tt></span><span class="calibre10"> is closed at the end of its body; this is equivalent to the “</span><span class="calibre10"><tt class="calibre22">try</tt></span><span class="calibre10"> with resources” syntax in Java 7 and </span><span class="calibre10"><tt class="calibre22">with</tt></span><span class="calibre10"> in Python. See </span><a href="#filepos1315176"><span class="calibre10"><span class="calibre5">with-open, finally’s Lament</span></span></a><span class="calibre10"> for more on </span><span class="calibre10"><tt class="calibre22">with-open</tt></span><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos315309"></a><a href="#filepos306745"><span class="calibre32">64</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="#filepos361409"><span class="calibre10"><span class="calibre5">Sequences are not iterators</span></span></a><span class="calibre10"> for details on </span><span class="calibre10"><tt class="calibre22">doseq</tt></span><span class="calibre10"> and “iterating” over sequences in Clojure.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos315744"></a><a href="#filepos310287"><span class="calibre32">65</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">This one would require a macro in order to access the line number of a call to a logger function via </span><span class="calibre10"><tt class="calibre22">:line</tt></span><span class="calibre10"> metadata; see </span><a href="#filepos914343"><span class="calibre10"><span class="calibre5">Producing useful macro error messages</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos316239"></a><a href="#filepos310735"><span class="calibre32">66</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Of course, the logging of strings should remain possible; it would be trivial to ensure that logging </span><span class="calibre10"><tt class="calibre22">"foo"</tt></span><span class="calibre10"> would be always be implicitly converted into a structured log map like </span><span class="calibre10"><tt class="calibre22">{:message "foo"}</tt></span><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos316677" class="calibre6"><span class="calibre4"><span class="bold">Pure Functions</span></span></p><p id="filepos316752" class="calibre18">While the use of immutable values eliminates many classes of errors when working with data in our programs, there are many other sorts of errors that are rooted in how we write the functions that work with those values. Most of these errors are due to <span class="italic">side effects</span><a id="filepos317051"></a>, changes that functions make to their environment in addition to their response of a return value.</p><p class="calibre18">Thinking back to our diagram in <a href="#filepos223222"><span class="calibre5">Figure 2-1</span></a>, side effects are any interaction that a function has with the outside world in either direction. Any function that works with random numbers<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos317464"></a><a href="#filepos330847"><span class="calibre32">67</span></a><span class="calibre32">]</span></small></sup> is a perfect example of a side-effecting function, as it:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">Depends upon the state of the random number generator being used<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos317835"></a><a href="#filepos331188"><span class="calibre32">68</span></a><span class="calibre32">]</span></small></sup></blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Necessarily modifies the state of that random number generator, so the next caller of the function will end up working with a different series of random numbers than it otherwise would have</blockquote></li></ol><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">By definition, performing I/O of any kind or the modification of any shared mutable object are side effects.</span></blockquote><p class="calibre25">Random numbers <a id="filepos318583"></a>seem a bit prosaic, so perhaps these not-really-hypothetical functions are a bit more illustrative:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos318724"></a><a href="#filepos331478"><span class="calibre32">69</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn perform-bank-transfer!<br class="calibre33"/>  [from-account to-account amount]<br class="calibre33"/>  ...)<br class="calibre33"/><br class="calibre33"/>(defn authorize-medical-treatment!<br class="calibre33"/>  [patient-id treatment-id]<br class="calibre33"/>  ...)<br class="calibre33"/><br class="calibre33"/>(defn launch-missiles!<br class="calibre33"/>  [munition-type target-coordinates]<br class="calibre33"/>  ...)</tt></span></blockquote><p class="calibre23">Maybe more concretely, consider a naive implementation of a function that accepts Twitter usernames and returns the number of followers of the named user:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(require 'clojure.xml)<br class="calibre33"/><br class="calibre33"/>(defn twitter-followers<br class="calibre33"/>  [username]<br class="calibre33"/>  (-&gt;&gt; (str "https://api.twitter.com/1/users/show.xml?screen_name=" username)<br class="calibre33"/>    clojure.xml/parse<br class="calibre33"/>    :content<br class="calibre33"/>    (filter (comp #{:followers_count} :tag))<br class="calibre33"/>    first<br class="calibre33"/>    :content<br class="calibre33"/>    first<br class="calibre33"/>    Integer/parseInt))<br class="calibre33"/><br class="calibre33"/>(twitter-followers "ClojureBook")<br class="calibre33"/>;= 106<br class="calibre33"/>(twitter-followers "ClojureBook")              </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= 107</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">The results of calling <tt class="calibre22">twitter-followers</tt> with the same argument at different times <span class="italic">may</span> yield a different result.</blockquote><p class="calibre18">It should be obvious that it’s impossible to deterministically test a function that depends upon a random number generator. For all intents and purposes however, the same is true of any function that depends upon or produces external state, since it is often very difficult to enumerate (never mind comprehensively reason about) all the potential edge cases and failure conditions related to that state. This is what mocks are for in testing, to dummy up an external data source or sink so that it will reliably behave in ways we know ahead of time so as to provoke particular results from a function under test. Unfortunately, any mock you produce—really, any test of any kind you may produce—will never have the same range of behavior or exercise your code in the same ways that it will be abused in the real world.</p><p class="calibre18">In contrast with side-effecting functions, <span class="italic">pure functions</span><a id="filepos321373"></a> are those that do not depend upon external data sources, do not provoke side effects of any kind in their environment, and, when invoked with a particular set of arguments, will always respond with the same return value.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos321636"></a><a href="#filepos331893"><span class="calibre32">70</span></a><span class="calibre32">]</span></small></sup> All arithmetic functions <a id="filepos321756"></a>are pure—e.g., <tt class="calibre22">+</tt> does not depend upon its environment, produces no side effects, and always returns the same value for a given set of arguments—and the same goes for any other well-behaved operation over immutable values.</p><p id="filepos322001" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Why Are Pure Functions Interesting?</span></span></span></p><p class="calibre18">We’ve already hinted at a couple of practical implications of working with and writing pure functions. For a number of reasons, they can have a profound simplifying effect upon the practice and experience of writing software, especially in conjunction with the use of a capable set of immutable value types.</p><p class="calibre18"><span class="bold">Pure functions are easier to reason about</span>. Recall our discussion in <a href="#filepos226156"><span class="calibre5">Comparing Values to Mutable Objects</span></a> about how immutable values allow you to identify whole new categories of invariants. Pure functions provide much the same aid, but with regard to <span class="italic">operations</span> and not just the state of data. If you know that some function ƒ always returns γ when called with arguments α and β, and you know that calling ƒ will never modify a database or write to a file or read from a socket, then you can call ƒ in <span class="italic">any</span> context with those arguments and be confident about the results.</p><p class="calibre18"><span class="bold">Pure functions are easier to test</span>. <a id="filepos323222"></a>This follows naturally from prior points of discussion. If you know your functions have no side effects, and that their results are derived deterministically from their arguments, testing those functions becomes markedly easier. You can strictly define the domain of each function’s inputs, and equally strictly define the range of each function’s results. Since the results of pure functions are determined solely by their inputs, mocking becomes unnecessary. These characteristics allow you to—if you are so inclined—comprehensively test a pure function to a degree that is simply not possible with side-effecting functions.</p><p class="calibre18">You’re probably doing this already by driving as much functionality as possible into unit-testable methods, which leaves the (far more difficult-to-test) highly stateful bits over for integration and functional testing. Thinking in terms of pure functions may help you to brighten the line between these two domains and further motivate you to maximize the time you spend in the more pleasant one of them.</p><p class="calibre18"><span class="bold">Pure functions are cacheable and trivial to parallelize</span>. Expressions that involve only pure functions are said to be <span class="italic">referentially transparent</span><a id="filepos324491"></a>; meaning, such expressions are semantically indistinguishable from their results. For example, all these expressions are equivalent, because all the functions involved are pure:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(+ 1 2)  (- 10 7)  (count [-1 0 1])</tt></span></blockquote><p class="calibre23">Each of these expressions could be replaced by its result value of <tt class="calibre22">3</tt> without affecting the body of code within which it might be found.</p><p class="calibre18">In practical terms, this means that the results of pure functions may be freely cached, where the result of each call of a function is retained so that future calls of the function with the same arguments can immediately return the prior result instead of recalculating it. This technique, called <span class="italic">memoization</span><a id="filepos325326"></a>, is used to help solve a variety of problems where the costs of computing the result of some function call is too high to bear more than once per set of arguments. Clojure includes a simple implementation of this called <tt class="calibre22">memoize</tt>; calling it with a function will return another function that has been <span class="italic">memoized</span>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn prime?                                   </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  [n]<br class="calibre33"/>  (cond<br class="calibre33"/>    (== 1 n) false<br class="calibre33"/>    (== 2 n) true<br class="calibre33"/>    (even? n) false<br class="calibre33"/>    :else (-&gt;&gt; (range 3 (inc (Math/sqrt n)) 2)<br class="calibre33"/>            (filter #(zero? (rem n %)))<br class="calibre33"/>            empty?)))<br class="calibre33"/><br class="calibre33"/>(time (prime? 1125899906842679))               </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>; "Elapsed time: 2181.014 msecs"<br class="calibre33"/>;= true<br class="calibre33"/>(let [m-prime? (memoize prime?)]<br class="calibre33"/>  (time (m-prime? 1125899906842679))<br class="calibre33"/>  (time (m-prime? 1125899906842679)))<br class="calibre33"/>; "Elapsed time: 2085.029 msecs"               </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>; "Elapsed time: 0.042 msecs"                  </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= true</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">First, the definition of a function that checks whether a given integer is prime (here a naive implementation of the naive prime-testing approach of trial division).</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">For large primes, this test will take some time.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">After being memoized, that same function takes the same amount of time for the first call with a given set of arguments. However…</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">…subsequent calls with previously provided arguments return instantly, the corresponding result having been cached by the function returned by <tt class="calibre22">memoize</tt>.</blockquote><p class="calibre18">Side-effecting functions,<a id="filepos328183"></a> however, are not referentially transparent, and so are generally not safe to memoize. For example, what if we memoized <tt class="calibre22">rand-int</tt>?<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos328363"></a><a href="#filepos332389"><span class="calibre32">71</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(repeatedly 10 (partial rand-int 10))<br class="calibre33"/>;= (3 0 2 9 8 8 5 7 3 5)<br class="calibre33"/>(repeatedly 10 (partial (memoize rand-int) 10))<br class="calibre33"/>;= (4 4 4 4 4 4 4 4 4 4)</tt></span></blockquote><p class="calibre23">Right, the expression that uses memoization isn’t going to yield random numbers! Because memoization elides the invocation of the function in question, any side effects the underlying function might have caused or relied upon will not occur when a memoized result is returned.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">In order to work its magic, </span><span class="calibre10"><tt class="calibre22">memoize</tt></span><span class="calibre10"> retains all arguments and return values from all calls to the function it produces, so none of that data will ever be garbage-collected. Thus, memoized functions that have highly variable domains or particularly memory-intensive arguments or return values are often the source of memory “leaks,” especially when they are naively defined in a top-level var with </span><span class="calibre10"><tt class="calibre22">def</tt></span><span class="calibre10"> or similar.</span></blockquote><blockquote class="calibre17"><span class="calibre10">The solution for such situations is to either:</span></blockquote><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17"><span class="calibre10">Keep a tight leash on the scope of memoized functions. In particular, don’t define them in top-level vars; rather, create memoized functions local to a high-level function call as necessary.</span></blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17"><span class="calibre10">Use </span><span class="calibre10"><tt class="calibre22">core.memoize</tt></span><span class="calibre10"> (</span><a href="https://github.com/clojure/core.memoize"><span class="calibre10"><span class="calibre5">https://github.com/clojure/core.memoize</span></span></a><span class="calibre10">), a library that provides a number of different memoization strategies, including ones that expire cached arguments and return values based on various criteria.</span></blockquote></li><a id="filepos330742"></a></ol><br class="calibre33"/><hr class="calibre34"/><p class="calibre25"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos330847"></a><a href="#filepos317464"><span class="calibre32">67</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Generally provided by </span><span class="calibre10"><tt class="calibre22">rand</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">rand-int</tt></span><span class="calibre10"> in Clojure.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos331188"></a><a href="#filepos317835"><span class="calibre32">68</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">In Clojure’s case, an instance of </span><span class="calibre10"><tt class="calibre22">java.math.Random</tt></span><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos331478"></a><a href="#filepos318724"><span class="calibre32">69</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">It is a common for the names of functions that manipulate external state to be suffixed with an exclamation point, which serves as an immediate reminder for users (and readers!) that the operation being considered has side effects.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos331893"></a><a href="#filepos321636"><span class="calibre32">70</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">This final characteristic is called </span><span class="calibre10"><span class="italic">idempotence</span></span><span class="calibre10">, a close cousin of function purity. For example, a function that always returns the same value for a given set of arguments but that does have side effects—say, writing to a logfile—is idempotent but not pure.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos332389"></a><a href="#filepos328363"><span class="calibre32">71</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Note that the same effect will occur whether </span><span class="calibre10"><tt class="calibre22">rand-int</tt></span><span class="calibre10"> itself is memoized or the result of </span><span class="calibre10"><tt class="calibre22">(partial rand-int 10)</tt></span><span class="calibre10"> were to be memoized. Understanding why is left as an exercise for the reader. Hint: think about what argument(s) are being passed to the memoized function in each case.</span></p><div class="mbppagebreak"></div><p id="filepos332912" class="calibre6"><span class="calibre4"><span class="bold">Functional Programming in the Real World</span></span></p><p class="calibre18">At the beginning of our discussion of functional programming, we looked at a diagrammatic characterization of all programs (<a href="#filepos223222"><span class="calibre5">Figure 2-1</span></a>) and we waved at any potential objections that, yes, dealing with potentially messy, unreliable external state is necessary in order to write software that does useful things. What we’d like to leave you with is a slightly adjusted perspective that indicates how you might enjoy the fruits of functional programming within your everyday programming practice without sacrificing any degree of practicality at all.</p><p class="calibre18">No matter what kind of software you build, you likely tend to try to isolate the bulk of what makes your creation unique from all the chaos that might surround it once you get it out in the world. We build models of our domain, construct abstractions for key operations, define core algorithms, try to avoid repeating ourselves, and winnow implementations down to fine-grained, easily testable units, all in an effort to find and define invariants, thereby circumscribing an area of sanity and control in stark contrast to the unforgiving wilds of “production.”</p><p class="calibre18">Taking that existing effort and recasting it with a functional approach can yield huge benefits, as we’ve described throughout this chapter. Given such a solid foundation, you can tackle the task of coping with the wooly outside world more confidently than before, knowing that at least one side of the bridge between that world and the rest of your application is reliable. The result can be characterized with a slight yet critical adjustment to our original diagram.</p><blockquote class="calibre47"></blockquote><blockquote class="calibre48"><img src="images/00035.jpg" class="calibre62"/></blockquote><blockquote class="calibre47"><span class="calibre10"><span class="italic"><span class="calibre7">Figure 2-2. A diagram of all programs ever, functional programming style</span></span></span></blockquote><p class="calibre50">So many of Clojure’s most attractive facilities depend upon the use of immutable data structures, functions as first class, composable values, and the emphasis on minimizing side effects in general. As we’ve summarized in this chapter, the repercussions of this orientation are far-reaching, making code easier to reason about, test, and compose, while turning otherwise esoteric notions like parallelization and reliable concurrency semantics into low-hanging fruit. It is functional programming that provides the sort of raw materials you should want to build the core of your programs upon.<a id="filepos335770"></a></p><div class="mbppagebreak"></div><p id="filepos335797" class="calibre6"><span class="calibre2"><span class="bold">Chapter 3. Collections and Data Structures</span></span></p><p id="filepos335902" class="calibre13">Maps, vectors, sets, and lists are the basic data structures provided by Clojure. As you’ve seen already, each of these has its own convenient literal notation:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">'(a b :name 12.5)       ;; list<br class="calibre33"/><br class="calibre33"/>['a 'b :name 12.5]      ;; vector<br class="calibre33"/><br class="calibre33"/>{:name "Chas" :age 31}  ;; map<br class="calibre33"/><br class="calibre33"/>#{1 2 3}                ;; set<br class="calibre33"/><br class="calibre33"/>{Math/PI "~3.14"<br class="calibre33"/> [:composite "key"] 42<br class="calibre33"/> nil "nothing"}         ;; another map<br class="calibre33"/><br class="calibre33"/>#{{:first-name "chas" :last-name "emerick"}<br class="calibre33"/>  {:first-name "brian" :last-name "carper"}<br class="calibre33"/>  {:first-name "christophe" :last-name "grand"}}  ;; a set of maps</tt></span></blockquote><p class="calibre23">These categories of data structures and their notations are likely familiar to you for the most part; particularly with regard to notation, Ruby and Python are quite similar. However, Clojure data structures have a couple of distinctive characteristics:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">They are first and foremost used in terms of abstractions, not the details of concrete implementations.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">They are <span class="italic">immutable</span> and <span class="italic">persistent</span>, both essential to Clojure’s flavor of efficient functional programming.</blockquote></li></ol><p class="calibre18">Each data structure has its own characteristics and idiomatic patterns of usage that we’ll explore progressively, but it is far more important to internalize the above points and what they imply about Clojure, its data structures, and how you can and should design your Clojure applications.</p><p id="filepos337805" class="calibre6"><span class="calibre4"><span class="bold">Abstractions over Implementations</span></span></p><blockquote class="calibre35"><span class="calibre10"><span class="italic">It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.<sup class="calibre58"><small class="calibre31"><span class="calibre32"><span class="italic">[</span></span><a id="filepos338101"></a><a href="#filepos426115"><span class="calibre32"><span class="italic">72</span></span></a><span class="calibre32"><span class="italic">]</span></span></small></sup></span></span></blockquote><blockquote class="calibre63"><span class="calibre10">—Alan J. Perlis in the foreword to </span><span class="calibre10"><span class="italic">Structure and Interpretation of Computer Programs</span></span><span class="calibre10">, </span><a href="http://mitpress.mit.edu/sicp/toc/toc.html"><span class="calibre10"><span class="calibre5">http://mitpress.mit.edu/sicp/toc/toc.html</span></span></a></blockquote><p id="filepos338606" class="calibre23">Clojure’s stance is that it is even better to have those 100 functions to operate on one <span class="italic">abstraction</span>. In some ways, the primacy of Clojure’s collection abstractions over particular implementations parallels the polymorphism <a id="filepos338869"></a>of operations in Python and Ruby, and the use of interfaces in Java, but there are subtle (and not so subtle) ways in which Clojure’s emphasis is more thorough and yields more powerful effects.</p><p class="calibre18">To set the stage, let’s jump ahead and look at some operations on a vector:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def v [1 2 3])<br class="calibre33"/>;= #'user/v<br class="calibre33"/>(conj v 4)<br class="calibre33"/>;= [1 2 3 4]<br class="calibre33"/>(conj v 4 5)<br class="calibre33"/>;= [1 2 3 4 5]<br class="calibre33"/>(seq v)<br class="calibre33"/>;= (1 2 3)</tt></span></blockquote><p class="calibre23"><tt class="calibre22">seq</tt> always yields a sequential view over a collection—called a <span class="italic">sequence</span><a id="filepos339559"></a>—and<a id="filepos339572"></a>
<tt class="calibre22">conj<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos339623"></a><a href="#filepos426498"><span class="calibre32">73</span></a><span class="calibre32">]</span></small></sup></tt> adds new value(s) into the provided collection. This is pretty pedestrian so far; but, the same operations work on maps:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def m {:a 5 :b 6})<br class="calibre33"/>;= #'user/m<br class="calibre33"/>(conj m [:c 7])<br class="calibre33"/>;= {:a 5, :c 7, :b 6}<br class="calibre33"/>(seq m)<br class="calibre33"/>;= ([:a 5] [:b 6])</tt></span></blockquote><p class="calibre23">…and sets:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def s #{1 2 3})<br class="calibre33"/>;= #'user/s<br class="calibre33"/>(conj s 10)<br class="calibre33"/>;= #{1 2 3 10}<br class="calibre33"/>(conj s 3 4)<br class="calibre33"/>;= #{1 2 3 4}<br class="calibre33"/>(seq s)<br class="calibre33"/>;= (1 2 3)</tt></span></blockquote><p class="calibre23">…and lists:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def lst '(1 2 3))<br class="calibre33"/>;= #'user/lst<br class="calibre33"/>(conj lst 0)<br class="calibre33"/>;= (0 1 2 3)<br class="calibre33"/>(conj lst 0 -1)<br class="calibre33"/>;= (-1 0 1 2 3)<br class="calibre33"/>(seq lst)<br class="calibre33"/>;= (1 2 3)</tt></span></blockquote><p class="calibre23">Clearly, <tt class="calibre22">seq</tt> and <tt class="calibre22">conj</tt> are polymorphic over the type of collection they are operating upon. <tt class="calibre22">conj</tt> appends a value to a vector; or, prepends a value to a list; or, properly adds a key/value entry to a map with any preexisting keys having their values properly replaced; or, adds a value to a set, presuming that value is not already present. <tt class="calibre22">seq</tt> provides an intuitive sequential view over a vector or set or list, and brings maps into the fold by yielding a sequential view over a map’s key/value pairs, represented as vector pairs.</p><p class="calibre18">It is the essence of Clojure to have small, approachable APIs,<a id="filepos341393"></a> on top of which auxiliary functions are built. From a user standpoint, “core” functions and helper functions are indistinguishable, and nothing forces the developer to prematurely specialize new helper functions or to make a false choice between which interfaces and types to support for a given operation.</p><p class="calibre18">For example, <tt class="calibre22">into</tt> is built on top of <tt class="calibre22">seq</tt> and <tt class="calibre22">conj</tt>, which means that <tt class="calibre22">into</tt> automatically works on any values that support <tt class="calibre22">seq</tt> and <tt class="calibre22">conj</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(into v [4 5])<br class="calibre33"/>;= [1 2 3 4 5]<br class="calibre33"/>(into m [[:c 7] [:d 8]])<br class="calibre33"/>;= {:a 5, :c 7, :b 6, :d 8}<br class="calibre33"/>(into #{1 2} [2 3 4 5 3 3 2])<br class="calibre33"/>;= #{1 2 3 4 5}<br class="calibre33"/>(into [1] {:a 1 :b 2})     </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= [1 [:a 1] [:b 2]]</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Because the <tt class="calibre22">seq</tt> of a map is a sequence of its key/value pairs, <tt class="calibre22">conj</tt>ing those pairs into a vector retains the structure of those pairs.</blockquote><p class="calibre18">In contrast, Java <a id="filepos342753"></a>maps are not even collections within the <tt class="calibre22">java.util</tt> framework, and Python relies upon concrete data structures that each have their own set of siloed operations. Ruby <a id="filepos342935"></a>fares a little better insofar as both lists and hashes provide an <tt class="calibre22">.each</tt> method to support imperative iteration, but they otherwise remain entirely distinct data structures with their own vocabularies. Meanwhile, Clojure encourages the use of unifying abstractions (sequences, protocols, collection interfaces, and so on), leaving you to have to explicitly go out of your way to depend upon the specific behavior of concrete types.</p><blockquote class="calibre38"></blockquote><blockquote class="calibre39"><span class="calibre10"><span class="bold">ABSTRACTION DILEMMAS</span></span></blockquote><blockquote class="calibre17"><span class="calibre10">It is common in Java to have a small interface (a particular type of abstraction), but at the same time need to provide convenience functions. These are very often added to the interface (hence making it more difficult to implement) and implemented in an abstract base class, with only the core methods unimplemented. This leaves code reuse tied to inheritance. Since Java supports only single inheritance, when a user needs to develop a new class that implements two such interfaces, she has to choose which helper methods to reimplement because she can’t reuse the existing implementations from two abstract classes.</span><a id="filepos344228"></a></blockquote><blockquote class="calibre17"><span class="calibre10">Thus goes a primary dilemma of the main tools of abstraction in Java, leaving many developers caught between the devil and the deep blue sea—their own personal Scylla and Charybdis (</span><a href="https://en.wikipedia.org/wiki/Scylla_and_Charybdis"><span class="calibre10"><span class="calibre5">https://en.wikipedia.org/wiki/Scylla_and_Charybdis</span></span></a><span class="calibre10">)—left with a choice between maintaining multiple implementations (and minimal code reuse),or a poor API.</span></blockquote><blockquote class="calibre17"><span class="calibre10">In </span><a href="#filepos945443"><span class="calibre10"><span class="calibre5">Chapter 6</span></span></a><span class="calibre10">, we’ll look at some Clojure facilities you can use to design your own abstractions and types while adhering to its principle of ensuring that common abstractions remain primary.</span></blockquote><p class="calibre50">Small and widely supported abstractions are one of the Clojure design principles that cannot be stressed enough. It is easy to see parallels with HTTP, which achieves robust interoperability and flexibility while defining just one small interface, which is usually less than half-implemented. Similarly, many Clojure data structures support many different abstractions partially, just as they implement only the <span class="italic">read-only</span> portions of the Java collection API’s interfaces (doing more would open Clojure’s collections to in-place mutation). An abstraction does not necessarily require full conformance by all of its participants in order to be useful.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos345887"></a><a href="#filepos426767"><span class="calibre32">74</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">There are seven different primary abstractions in which Clojure’s data structure implementations participate:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Collection</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Sequence</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Associative</blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17">Indexed</blockquote></li><li value="5" class="calibre16"><blockquote class="calibre17">Stack</blockquote></li><li value="6" class="calibre16"><blockquote class="calibre17">Set</blockquote></li><li value="7" class="calibre16"><blockquote class="calibre17">Sorted</blockquote></li></ul><p class="calibre18">In the following pages, we’ll explore the semantics of the operations that define each abstraction’s API. Along the way, you’ll learn how to use Clojure’s data structures in terms of those abstractions, and therefore, <span class="italic">any</span> data structure that participates in those abstractions.</p><p id="filepos347205" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Collection</span></span></span></p><p id="filepos347305" class="calibre18">All data structures in Clojure participate in the common <span class="italic">collection</span> abstraction. A collection is a value that you can use with the set of core collection functions:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">conj</tt> to add an item to a collection</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">seq</tt> to get a sequence of a collection</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">count</tt> to get the number of items in a collection</blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">empty</tt> to obtain an empty instance of the same type as a provided collection</blockquote></li><li value="5" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">=</tt> to determine value equality of a collection compared to one or more other collections<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos348362"></a><a href="#filepos427181"><span class="calibre32">75</span></a><span class="calibre32">]</span></small></sup></blockquote></li></ul><p class="calibre18">These functions are all polymorphic with regard to the concrete type of collection being operated upon. Said another way, each operation provides semantics consistent with the constraints of each data structure implementation.</p><p class="calibre18">We’ve already previewed <tt class="calibre22">seq</tt>, but we’ll learn much more about it in <a href="#filepos354167"><span class="calibre5">Sequences</span></a>, as it is the gateway to Clojure’s other most pervasive abstraction, the sequence.</p><p class="calibre18">Similarly, we’ve seen <tt class="calibre22">conj</tt><a id="filepos349063"></a> applied to vectors where it appends items; to maps, it adds a key/value association; and to sets, where it ensures the membership of a given value. One guarantee of <tt class="calibre22">conj</tt> however, is that it will always add a given value to the subject collection <span class="italic">efficiently</span>. This leads to an initially surprising effect: due to their implementation—which we’ll detail later in <a href="#filepos447909"><span class="calibre5">Lists</span></a>—<tt class="calibre22">conj</tt> prepends items to lists:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(conj '(1 2 3) 4)<br class="calibre33"/>;= (4 1 2 3)<br class="calibre33"/>(into '(1 2 3) [:a :b :c])<br class="calibre33"/>;= (:c :b :a 1 2 3)</tt></span></blockquote><p class="calibre23">Doing anything else would require traversing the list, a costly operation if you are working with larger datasets. The broader point is that the specific action of <tt class="calibre22">conj</tt> is dependent upon the local characteristics of the subject collection.</p><p class="calibre18"><span class="bold">empty</span>. <tt class="calibre22">empty</tt><a id="filepos350096"></a> likely represents an unfamiliar concept. In many circumstances, you must know what concrete type of data structure you’re working with, and therefore you simply create the structure in question directly. <tt class="calibre22">empty</tt> allows you to break out of that pattern and generically work with collections of the same type as a given instance, such as one you have received as an argument to a function. For example, we can write a function that will swap pairs of values in a sequential collection:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn swap-pairs<br class="calibre33"/>  [sequential]<br class="calibre33"/>  (into (empty sequential)<br class="calibre33"/>        (interleave<br class="calibre33"/>          (take-nth 2 (drop 1 sequential))<br class="calibre33"/>          (take-nth 2 sequential))))<br class="calibre33"/><br class="calibre33"/>(swap-pairs (apply list (range 10)))<br class="calibre33"/>;= (8 9 6 7 4 5 2 3 0 1)<br class="calibre33"/>(swap-pairs (apply vector (range 10)))<br class="calibre33"/>;= [1 0 3 2 5 4 7 6 9 8]</tt></span></blockquote><p class="calibre23">Notice that <tt class="calibre22">swap-pairs</tt>’ return type is the same as its argument: a list if we provide a list, and a vector if we provide a vector. This is thanks to the polymorphic behavior of <tt class="calibre22">into</tt> (bolstered by <tt class="calibre22">conj</tt> and <tt class="calibre22">seq</tt>), and the semantics of <tt class="calibre22">empty</tt> that allow us to obtain an empty data structure that we can guarantee will be of the same concrete type as what our caller provided.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos351595"></a><a href="#filepos427565"><span class="calibre32">76</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">This doesn’t only work with sequential types; consider a function that allows you to map a given function over every value in a map. What if the map you’re provided is sorted…or not? No problem, just use <tt class="calibre22">empty</tt> to work with a fresh instance of the given concrete type—in this case, a map that preserves the sorting guarantees of some other provided map:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn map-map<br class="calibre33"/>  [f m]<br class="calibre33"/>  (into (empty m)<br class="calibre33"/>        (for [[k v] m] </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>          [k (f v)])))</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">for</tt><a id="filepos352581"></a> is a list comprehension form, very similar in spirit to list comprehensions in Python; this one produces a lazy sequence of vector pairs <tt class="calibre22">[k (f v)]</tt>, one for each key/value pair <tt class="calibre22">[k v]</tt> destructured from the entries in the map argument <tt class="calibre22">m</tt>.</blockquote><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(map-map inc (hash-map :z 5 :c 6 :a 0))<br class="calibre33"/>;= {:z 6, :a 1, :c 7}<br class="calibre33"/>(map-map inc (sorted-map :z 5 :c 6 :a 0))<br class="calibre33"/>;= {:a 1, :c 7, :z 6}</tt></span></blockquote><p class="calibre23">Unsorted in, unsorted out; or, sorted in, sorted out. The caller gets to determine the types of values they get in return, if you allow for it.</p><p class="calibre18"><span class="bold">count</span>. <tt class="calibre22">count</tt><a id="filepos353353"></a> does just what you’d expect: indicates the number of entries in a collection:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(count [1 2 3])<br class="calibre33"/>;= 3<br class="calibre33"/>(count {:a 1 :b 2 :c 3})<br class="calibre33"/>;= 3<br class="calibre33"/>(count #{1 2 3})<br class="calibre33"/>;= 3<br class="calibre33"/>(count '(1 2 3))<br class="calibre33"/>;= 3</tt></span></blockquote><p class="calibre23"><tt class="calibre22">count</tt> guarantees efficient operation on all collections other than sequences (the lengths of which can be undefined, as we’ll see next).</p><p class="calibre18"><tt class="calibre22">count</tt> helpfully works on Java types that aren’t Clojure collections, like <tt class="calibre22">String</tt>s,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos354038"></a><a href="#filepos428038"><span class="calibre32">77</span></a><span class="calibre32">]</span></small></sup> maps, collections, and arrays.</p><p id="filepos354167" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Sequences</span></span></span></p><p id="filepos354266" class="calibre18">The <span class="italic">sequence</span> abstraction defines a way to obtain and traverse sequential views over some source of values: either another collection, or successive values that are the result of some computation. Sequences—often called “seqs”—involve a couple of operations in addition to the base provided by the collection abstraction:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">seq</tt> produces a sequence over its argument.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">first</tt>, <tt class="calibre22">rest</tt>, and <tt class="calibre22">next</tt> provide ways to consume sequences.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">lazy-seq</tt> produces a <span class="italic">lazy sequence</span> that is the result of evaluating an expression.</blockquote></li></ul><p class="calibre18">The set of types that are <span class="italic">seqable</span>—that is, those for which <tt class="calibre22">seq</tt> can produce a valid value—include:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">All Clojure collection types</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">All Java collections (i.e., <tt class="calibre22">java.util.*</tt>)</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">All Java maps</blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17">All <tt class="calibre22">java.lang.CharSequence</tt>s, including <tt class="calibre22">String</tt>s</blockquote></li><li value="5" class="calibre16"><blockquote class="calibre17">Any type that implements <tt class="calibre22">java.lang.Iterable<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos356069"></a><a href="#filepos428566"><span class="calibre32">78</span></a><span class="calibre32">]</span></small></sup></tt></blockquote></li><li value="6" class="calibre16"><blockquote class="calibre17">Arrays</blockquote></li><li value="7" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">nil</tt> (i.e., <tt class="calibre22">null</tt> as returned from Java methods)</blockquote></li><li value="8" class="calibre16"><blockquote class="calibre17">Anything that implements Clojure’s <tt class="calibre22">clojure.lang.Seqable</tt> interface</blockquote></li></ul><p class="calibre18">Demonstrating all of these comprehensively would be excessive; a small subset will suffice:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(seq "Clojure")<br class="calibre33"/>;= (\C \l \o \j \u \r \e)<br class="calibre33"/>(seq {:a 5 :b 6})<br class="calibre33"/>;= ([:a 5] [:b 6])<br class="calibre33"/>(seq (java.util.ArrayList. (range 5)))<br class="calibre33"/>;= (0 1 2 3 4)<br class="calibre33"/>(seq (into-array ["Clojure" "Programming"]))<br class="calibre33"/>;= ("Clojure" "Programming")<br class="calibre33"/>(seq [])                                     </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= nil<br class="calibre33"/>(seq nil)<br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">The <tt class="calibre22">seq</tt> of <tt class="calibre22">nil</tt> or any empty collection is <tt class="calibre22">nil</tt>. This is convenient in many circumstances, including in places where you need a conditional that is equivalent to <tt class="calibre22">(not (empty? some-collection))</tt>.</blockquote><p class="calibre18">Note that many functions that work with sequences call <tt class="calibre22">seq</tt> on their argument(s) implicitly. For example, we don’t have to wrap this <tt class="calibre22">String</tt> in a <tt class="calibre22">seq</tt> call just to use it with <tt class="calibre22">map</tt> or <tt class="calibre22">set</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(map str "Clojure")<br class="calibre33"/>;= ("C" "l" "o" "j" "u" "r" "e")<br class="calibre33"/>(set "Programming")<br class="calibre33"/>;= #{\a \g \i \m \n \o \P \r}</tt></span></blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Your own functions will get this behavior for free if you are building them on top of others’ sequence functions. If you use </span><span class="calibre10"><tt class="calibre22">lazy-seq</tt></span><a id="filepos358579"></a><span class="calibre10"> then it is your responsibility to call </span><span class="calibre10"><tt class="calibre22">seq</tt></span><span class="calibre10"> on your arguments to maintain this convenient characteristic of </span><span class="calibre10"><tt class="calibre22">seq</tt></span><span class="calibre10">.</span></blockquote><p class="calibre25">Traversing and processing sequences can be done in many ways, and the Clojure standard library contains many dozens of functions for manipulating and producing sequences in <tt class="calibre22">clojure.core</tt>. However, most fundamental are <tt class="calibre22">first</tt>, <tt class="calibre22">rest</tt>, and <tt class="calibre22">next</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(first "Clojure")<br class="calibre33"/>;= \C<br class="calibre33"/>(rest "Clojure")<br class="calibre33"/>;= (\l \o \j \u \r \e)<br class="calibre33"/>(next "Clojure")<br class="calibre33"/>;= (\l \o \j \u \r \e)</tt></span></blockquote><p class="calibre23"><tt class="calibre22">first</tt> and <tt class="calibre22">rest</tt> should strike you as quite obvious. The latter should seem familiar to you if you recall how to define and work with variadic functions <a id="filepos359583"></a>in Clojure, with their “rest arguments”; it is <tt class="calibre22">rest</tt> that lies beneath such functions.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos359723"></a><a href="#filepos429964"><span class="calibre32">79</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">The distinction between <tt class="calibre22">rest</tt><a id="filepos359886"></a> and <tt class="calibre22">next</tt><a id="filepos359911"></a> is not so clear though: their results are identical for most values, as we see above. They only differ in their treatment of sequences containing zero or one value:</p><p id="filepos360087" class="calibre23"></p><p class="calibre23"><span class="italic">Example 3-1. rest versus next</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(rest [1])<br class="calibre33"/>;= ()<br class="calibre33"/>(next [1])<br class="calibre33"/>;= nil<br class="calibre33"/>(rest nil)<br class="calibre33"/>;= ()<br class="calibre33"/>(next nil)<br class="calibre33"/>;= nil</tt></span></p><p class="calibre13">As you can see, <tt class="calibre22">rest</tt> will always return an empty sequence, whereas <tt class="calibre22">next</tt> will return <tt class="calibre22">nil</tt> if the resulting sequence is empty. In short, this will always be true for any value <tt class="calibre22">x</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(= (next x)<br class="calibre33"/>   (seq (rest x)))</tt></span></blockquote><p class="calibre23">The distinction is a small one, but makes it possible for sequences to be realized entirely lazily. We’ll learn about lazy sequences and <tt class="calibre22">lazy-seq</tt> in a little bit.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Sequences are colloquially referred to as “seqs” (perhaps a natural consequence of the key sequence-producing function being called </span><span class="calibre10"><tt class="calibre22">seq</tt></span><span class="calibre10">), and we’ll do so as well throughout the rest of the book.</span></blockquote><p id="filepos361409" class="calibre25"><span class="calibre53"><span class="bold">Sequences are not iterators</span></span></p><p id="filepos361497" class="calibre18">When you see code like this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(doseq [x (range 3)]<br class="calibre33"/>  (println x))<br class="calibre33"/>; 0<br class="calibre33"/>; 1<br class="calibre33"/>; 2</tt></span></blockquote><p class="calibre23">it might be reasonable to think that the <tt class="calibre22">doseq</tt><a id="filepos361809"></a> form here is pulling <tt class="calibre22">x</tt> values from some iterator that is walking over the sequential collection returned by <tt class="calibre22">range</tt>. While it’s true that <tt class="calibre22">x</tt> is bound to successive values from the <tt class="calibre22">seq</tt> of <tt class="calibre22">(range 3)</tt>, that seq is an immutable, persistent collection just like any other in Clojure:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [r (range 3)<br class="calibre33"/>      rst (rest r)]<br class="calibre33"/>  (prn (map str rst))<br class="calibre33"/>  (prn (map #(+ 100 %) r))<br class="calibre33"/>  (prn (conj r -1) (conj rst 42)))<br class="calibre33"/>; ("1" "2")<br class="calibre33"/>; (100 101 102)<br class="calibre33"/>; (-1 0 1 2) (42 1 2)</tt></span></blockquote><p class="calibre23">The “derivative” <tt class="calibre22">rst</tt> seq works just as its “parent” seq <tt class="calibre22">r</tt> does, and both can be operated upon separately by using the breadth of functions available for sequences and collections. In particular, we can map a function over a seq without affecting it or its source values, any of its “descendants” or its parents. None of these characteristics are shared by mutably stateful iterators and generators, which cannot be checkpointed, safely used as the basis for other iterators, and, once consumed, cannot be consumed again.</p><p id="filepos363075" class="calibre23"><span class="calibre53"><span class="bold">Sequences are not lists</span></span></p><p id="filepos363159" class="calibre18">At first sight, sequences look very much like lists: they are either empty or consist of a head value and a tail that is itself a sequence. In addition, lists are their own sequences.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos363405"></a><a href="#filepos430276"><span class="calibre32">80</span></a><span class="calibre32">]</span></small></sup> However, they are quite different in some important ways:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Obtaining the length of a seq carries a cost.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">The contents of sequences may be computed lazily and actually <span class="italic">realized</span> only when the values involved are accessed.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">The computation that is producing values for a lazy sequence can opt to produce an unlimited progression of those values, thus making it possible for sequences to be <span class="italic">infinite</span> and therefore uncountable.</blockquote></li></ul><p class="calibre18">In contrast, lists track their length, so getting the <tt class="calibre22">count</tt><a id="filepos364358"></a> of one is a cheap, constant-time operation. Seqs cannot provide the same guarantee, because they may be produced lazily and can potentially be infinite. Thus, the only way to obtain a <tt class="calibre22">count</tt> of a seq is to force a full traversal of it. You can see the effect of this when <tt class="calibre22">count</tt> is applied to a lazy sequence versus a fully realized list:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [s (range 1e6)]            </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  (time (count s)))<br class="calibre33"/>; "Elapsed time: 147.661 msecs"<br class="calibre33"/>;= 1000000<br class="calibre33"/>(let [s (apply list (range 1e6))]    </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  (time (count s)))<br class="calibre33"/>; "Elapsed time: 0.03 msecs"<br class="calibre33"/>;= 1000000</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">range</tt> returns a lazy seq of numbers that are produced <span class="italic">only</span> when needed. <tt class="calibre22">count</tt>ing a lazy seq is one way to ensure that it is fully realized, since all of the seq’s values must be produced in order to count them. Here, we’re including that realization within the scope of activity we’re timing.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">Lists always track their size, so getting the <tt class="calibre22">count</tt> of one will always return immediately.</blockquote><p id="filepos366032" class="calibre23"><span class="calibre53"><span class="bold">Creating seqs</span></span></p><p id="filepos366106" class="calibre18">You may have noticed that we’ve not explicitly created any seqs so far. Given that seqs are just sequential views over other collections, this makes sense; generally, a seq is produced by a collection, either explicitly via <tt class="calibre22">seq</tt> or via another function (like <tt class="calibre22">map</tt>) calling <tt class="calibre22">seq</tt> on its argument(s) implicitly. However, there are two ways to <span class="italic">create</span> a seq: <tt class="calibre22">cons</tt> and <tt class="calibre22">list*</tt>.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos366589"></a><a href="#filepos430615"><span class="calibre32">81</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18"><tt class="calibre22">cons</tt><a id="filepos366728"></a> accepts two arguments, a value to serve as the head of the new seq, and another collection, the seq of which will serve as its tail:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(cons 0 (range 1 5))<br class="calibre33"/>;= (0 1 2 3 4)</tt></span></blockquote><p class="calibre23">You can think of <tt class="calibre22">cons</tt> as <span class="italic">always</span> “prepending” to the tail collection’s sequence regardless of the collection’s concrete type, thus distinguishing itself from <tt class="calibre22">conj</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(cons :a [:b :c :d])<br class="calibre33"/>;= (:a :b :c :d)</tt></span></blockquote><p class="calibre23"><tt class="calibre22">list*<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos367438"></a><a href="#filepos431166"><span class="calibre32">82</span></a><span class="calibre32">]</span></small></sup></tt><a id="filepos367537"></a> is just a helper for producing seqs with any number of head values, followed by a sequence. So, these two expressions are equivalent:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(cons 0 (cons 1 (cons 2 (cons 3 (range 4 10)))))<br class="calibre33"/>;= (0 1 2 3 4 5 6 7 8 9)<br class="calibre33"/>(list* 0 1 2 3 (range 4 10))<br class="calibre33"/>;= (0 1 2 3 4 5 6 7 8 9)</tt></span></blockquote><p class="calibre23"><tt class="calibre22">cons</tt> and <tt class="calibre22">list*</tt> functions are most commonly used when writing macros—where seqs and lists are equivalent, and you just need to prepend a value to a list or seq—and when assembling the next step of a lazy sequence, as we’ll see next.</p><p id="filepos368238" class="calibre23"><span class="calibre53"><span class="bold">Lazy seqs</span></span></p><p id="filepos368308" class="calibre18">It is possible for the contents of a sequence to be evaluated <span class="italic">lazily</span>, where values are produced as the result of a computation performed on demand when a consumer attempts to access them. Each such value is always computed once and only once. The process of accessing a lazy sequence is called <span class="italic">realization</span>; when all values in a lazy sequence have been computed, it is said that the sequence has been <span class="italic">fully realized</span>.</p><p class="calibre18">You can create a lazy sequence with <tt class="calibre22">lazy-seq</tt><a id="filepos368857"></a>, a macro that accepts any expression that will evaluate to a seqable value. Here’s a silly example:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(lazy-seq [1 2 3])<br class="calibre33"/>;= (1 2 3)</tt></span></blockquote><p class="calibre23">That’s not very interesting, insofar as the lazy sequence here is “realizing” its values from a fully formed data structure to begin with. More interesting is a sequence that lazily produces a sequence of random integers:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 3-2. Implementing a lazy sequence</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(defn random-ints<br class="calibre33"/>  "Returns a lazy seq of random integers in the range [0,limit)."<br class="calibre33"/>  [limit]<br class="calibre33"/>  (lazy-seq<br class="calibre33"/>    (cons (rand-int limit)        </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>          (random-ints limit))))  </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/><br class="calibre33"/>(take 10 (random-ints 50))<br class="calibre33"/>;= (32 37 8 2 22 41 19 27 34 27)</tt></span></p><p class="calibre23"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">We return a lazy seq that is defined by a head of <tt class="calibre22">(rand-int limit)</tt>…</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">…and a tail that is itself a lazy sequence as produced by a recursive call to this same <tt class="calibre22">random-ints</tt> function.</blockquote><p class="calibre13">The result of this might not look very special, but the sequence of digits in the seq returned from <tt class="calibre22">random-ints</tt> is produced lazily—it’s only shown in its entirety here because printing a sequence forces its contents to be realized.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos370906"></a><a href="#filepos432155"><span class="calibre32">83</span></a><span class="calibre32">]</span></small></sup> Let’s prove this by modifying <tt class="calibre22">random-ints</tt> a bit to print something every time a value is realized:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn random-ints<br class="calibre33"/>  [limit]<br class="calibre33"/>  (lazy-seq<br class="calibre33"/>    (println "realizing random number")  </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>    (cons (rand-int limit)<br class="calibre33"/>          (random-ints limit))))<br class="calibre33"/><br class="calibre33"/>(def rands (take 10 (random-ints 50)))   </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #'user/rands<br class="calibre33"/>(first rands)                            </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>; realizing random number<br class="calibre33"/>;= 39<br class="calibre33"/>(nth rands 3)<br class="calibre33"/>; realizing random number<br class="calibre33"/>; realizing random number<br class="calibre33"/>; realizing random number<br class="calibre33"/>;= 44<br class="calibre33"/>(count rands)                            </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>; realizing random number<br class="calibre33"/>; realizing random number<br class="calibre33"/>; realizing random number<br class="calibre33"/>; realizing random number<br class="calibre33"/>; realizing random number<br class="calibre33"/>; realizing random number<br class="calibre33"/>;= 10<br class="calibre33"/>(count rands)                            </tt></span><a></a><img src="images/00001.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= 10</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Each time <tt class="calibre22">lazy-seq</tt> is evaluated (which will occur every time a concrete value is produced by looking at the head of the <tt class="calibre22">cons</tt>), we’ll print a message.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">We define the lazy sequence so it’s not printed, which would force its full evaluation. Notice that no message is printed; the sequence is entirely lazy, and has not yet produced any values.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">Asking the seq for its head value via <tt class="calibre22">first</tt>
<span class="italic">forces</span> the production of that value based on whatever calculation or logic defined in the <tt class="calibre22">lazy-seq</tt> form. We get a random number and a corresponding printed message as expected.</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">If we ask for values later in the lazy seq, it and all preceding values are necessarily realized; here, we see that <tt class="calibre22">count</tt> forces the entire sequence to be realized so it can determine its size.</blockquote><p class="calibre23"><img src="images/00001.jpg" class="calibre36"/></p><blockquote class="calibre37">Asking for the count again (or, similarly, if we asked for the <tt class="calibre22">nth</tt> value in the seq) does not require recomputing each value: once realized, values in lazy seqs are retained.</blockquote><p class="calibre18">When we first define the lazy seq in a var, its contents simply do not exist:</p><p class="calibre51"><img src="images/00040.jpg" class="calibre64"/></p><p class="calibre13">Once we attempt to access its first value, that value is realized and retained so that the computation that produced it does not have to be repeated:</p><p class="calibre51"><img src="images/00042.jpg" class="calibre65"/></p><p class="calibre13">Its head is a concrete value, but its tail is defined entirely by a computation suspended in a function that <tt class="calibre22">lazy-seq</tt> creates from the expression it is provided that will not be invoked by our accessing its corresponding value. This points to a key advantage of <tt class="calibre22">cons</tt> and <tt class="calibre22">list*</tt>: these functions do <span class="italic">not</span> force the evaluation of the (potentially lazy) sequences they are provided as their final argument. This makes these functions a key helper in building up lazy seqs, where a common pattern is to return the result of a <tt class="calibre22">cons</tt> or <tt class="calibre22">list*</tt> call with one or more concrete seq values, followed by a <tt class="calibre22">lazy-seq</tt> that suspends the call or computation that will produce the rest of the lazy sequence.</p><p class="calibre18"><tt class="calibre22">random-ints</tt> is actually a very poor, overly complex implementation of functionality you can obtain just from composing a couple of standard-library Clojure functions together: <tt class="calibre22">rand-int</tt>, which <tt class="calibre22">random-ints</tt> already uses, and <tt class="calibre22">repeatedly</tt>, which produces a lazy seq that contains values obtained by invoking a given function for each value:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(repeatedly 10 (partial rand-int 50))<br class="calibre33"/>;= (47 19 26 14 18 37 44 13 41 38)</tt></span></blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">It’s worth reemphasizing that the expression provided to </span><span class="calibre10"><tt class="calibre22">lazy-seq</tt></span><span class="calibre10"> can do just about anything—you’re not limited simply to numerical tricks like random numbers or operations on small bits of data. Any pure function implementing computation that is appropriate for a value in a sequence is fair game.</span></blockquote><p class="calibre25">Note that the single-argument arity of <tt class="calibre22">repeatedly</tt> would return an infinite lazy sequence of random numbers. It is not uncommon to work with infinite lazy sequences in Clojure. There is a considerable body of functions both in Clojure’s standard library and throughout Clojure’s community libraries that deal in (potentially infinite) lazy sequences transparently. Handily, all of the core sequence-processing functions in the standard library—such as <tt class="calibre22">map</tt>, <tt class="calibre22">for</tt>, <tt class="calibre22">filter</tt>, <tt class="calibre22">take</tt>, and <tt class="calibre22">drop<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos377500"></a><a href="#filepos432991"><span class="calibre32">84</span></a><span class="calibre32">]</span></small></sup></tt>—return lazy sequences, and can be layered as needed without affecting the laziness of underlying seqs. Given these facilities, it is very common to characterize many problems as processing sequences of values, from things as general as the lazy processing of data from queues and parallelized search<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos377936"></a><a href="#filepos433470"><span class="calibre32">85</span></a><span class="calibre32">]</span></small></sup> to the lazy consumption and transformation of data from various sources, as with <tt class="calibre22">file-seq</tt>, <tt class="calibre22">line-seq</tt>, and <tt class="calibre22">xml-seq</tt>.</p><p class="calibre18">There are cases where you will want to be very careful to minimize the degree to which you force the realization of a lazy sequence—for example, if each value required some I/O or a significant amount of computation to produce. This is where the difference between <tt class="calibre22">next</tt> and <tt class="calibre22">rest</tt> is critical. Remember from <a href="#filepos360087"><span class="calibre5">Example 3-1</span></a> that <tt class="calibre22">next</tt> always returns <tt class="calibre22">nil</tt> instead of an empty sequence? This is only possible because <tt class="calibre22">next</tt> checks for a nonempty tail seq; this check necessarily forces the potential realization of the head of that nonempty tail seq:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def x (next (random-ints 50)))<br class="calibre33"/>; realizing random number<br class="calibre33"/>; realizing random number</tt></span></blockquote><p class="calibre23">In contrast, <tt class="calibre22">rest</tt> will “blindly” return the tail of a given sequence, thereby avoiding realizing its head and therefore maximizing laziness:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def x (rest (random-ints 50)))<br class="calibre33"/>; realizing random number</tt></span></blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Sequential destructuring </span><a id="filepos379588"></a><span class="calibre10"><span class="italic">always</span></span><span class="calibre10"> uses </span><span class="calibre10"><tt class="calibre22">next</tt></span><span class="calibre10">, and not </span><span class="calibre10"><tt class="calibre22">rest</tt></span><span class="calibre10">. Thus, destructuring a lazy seq will always realize its tail’s head value:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(let [[x &amp; rest] (random-ints 50)])<br class="calibre33"/>; realizing random number<br class="calibre33"/>; realizing random number<br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre25">On the other hand, there are times when you need to force the complete realization of a lazy sequence. In such cases, you should use <tt class="calibre22">doall</tt><a id="filepos380262"></a> if you wish to retain the contents of the sequence,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos380356"></a><a href="#filepos434083"><span class="calibre32">86</span></a><span class="calibre32">]</span></small></sup> or <tt class="calibre22">dorun</tt><a id="filepos380468"></a> if you want the contents disposed of as each value in the sequence is produced:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(dorun (take 5 (random-ints 50)))<br class="calibre33"/>; realizing random number<br class="calibre33"/>; realizing random number<br class="calibre33"/>; realizing random number<br class="calibre33"/>; realizing random number<br class="calibre33"/>; realizing random number<br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre23">Not retaining the contents of a lazy sequence might seem like a waste, but this can be a very useful if a lazy seq’s computations are side-effecting, and you are only interested in ensuring that those side effects occur. For example, if you have a lazy sequence of files (via <tt class="calibre22">file-seq</tt>), and you need to perform the some set of operations on them, characterizing that as one or many functions <tt class="calibre22">map</tt>ped across that lazy sequence is very convenient. Then, <tt class="calibre22">dorun</tt> will actually apply those operations, but not wastefully retain any return values of the functions involved in the operations performed.</p><p class="calibre18">Usually, documentation for functions that operate over seqs is explicit about whether they produce lazy seqs or force their realization:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(doc iterate)<br class="calibre33"/>; -------------------------<br class="calibre33"/>; clojure.core/iterate<br class="calibre33"/>; ([f x])<br class="calibre33"/>;   Returns a lazy sequence of x, (f x), (f (f x)) etc.<br class="calibre33"/>;   f must be free of side-effects<br class="calibre33"/><br class="calibre33"/>(doc reverse)<br class="calibre33"/>; -------------------------<br class="calibre33"/>; clojure.core/reverse<br class="calibre33"/>; ([coll])<br class="calibre33"/>;   Returns a seq of the items in coll in reverse order. Not lazy.</tt></span></blockquote><p class="calibre23">Clearly, <tt class="calibre22">iterate</tt> is lazy, <tt class="calibre22">reverse</tt> is not. The admonition that the function provided to <tt class="calibre22">iterate</tt> “must be free of side effects” deserves some explanation, though.</p><p class="calibre18"><span class="bold">Code defining lazy sequences should minimize side effects</span>. <a id="filepos382542"></a>We already learned of many of the advantages of pure functions in <a href="#filepos316677"><span class="calibre5">Pure Functions</span></a>, but those characteristics—and the pitfalls of side-effecting code—are accentuated in the context of lazy sequences. Because values in lazy seqs are realized when they are accessed and not when they are defined, it’s very, very easy to lose track of when and where any side effects associated with the production of those values will happen, if they ever happen! For example, changing a logging level while a lazy seq is being consumed may cause log events to be suddenly passed through, even if the log level was set to squelch such messages when the lazy seq was defined.</p><p class="calibre18">To make things worse, the evaluation of some lazy sequences may be batched as a performance optimization,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos383436"></a><a href="#filepos434684"><span class="calibre32">87</span></a><span class="calibre32">]</span></small></sup> thus making the realization of items run ahead of consumption by some amount, causing any side effects to occur in bursts as opposed to being coincident with the consumption of each value.</p><p class="calibre18">The moral of this story is that you should generally not rely upon the evaluation of sequences to control execution flow. Clojure’s laziness does not serve the same purpose as in other languages where lazy evaluation is pervasive. In Clojure, laziness is restricted to sequences, with the rest of the language and its data structures being otherwise entirely “eagerly” evaluated. Lazy sequences allow Clojure to transparently process big datasets that don’t fit in memory and to express algorithms in a more uniform, declarative, pipelined way; in this context, sequences can be considered <span class="italic">an ephemeral medium of computation</span>, not as collections.</p><p class="calibre18">You will often notice this pattern in Clojure code: given one or more data sources, you extract a sequence from it, process it, and turn it back into a more appropriate data structure. This pattern can be spotted in code as simple as this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(apply str (remove (set "aeiouy")<br class="calibre33"/>             "vowels are useless! or maybe not..."))<br class="calibre33"/>;= "vwls r slss! r mb nt..."</tt></span></blockquote><p class="calibre23">Here we have a data source, the <tt class="calibre22">String</tt>
<tt class="calibre22">"vowels are useless! or maybe not..."</tt>, which is implicitly turned into a sequence of characters. All vowels are then removed from it before aggregating the resulting sequence back into a <tt class="calibre22">String</tt>.<a id="filepos385214"></a></p><p id="filepos385225" class="calibre23"><span class="calibre53"><span class="bold">Head retention</span></span></p><p id="filepos385300" class="calibre18">One fact often overlooked by newcomers to Clojure is that lazy sequences are persistent: an item is computed once, but is still retained by the sequence.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos385516"></a><a href="#filepos435241"><span class="calibre32">88</span></a><span class="calibre32">]</span></small></sup> This means that, as long as you maintain a reference to a sequence, you’ll prevent its items from being garbage-collected. This type of fault is called <span class="italic">head retention</span> (or, <span class="italic">holding onto head</span>) and can put pressure on the VM that will impact performance, potentially even causing an out of memory error if the realized portion of a sequence grows too large.</p><p class="calibre18"><tt class="calibre22">split-with</tt><a id="filepos386032"></a> is a function that, given a predicate and seq-able value, will return a vector of two lazy seqs; the prefix that satisfies the predicate and the suffix starting at the first item that does not satisfy the predicate:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(split-with neg? (range -5 5))<br class="calibre33"/>;= [(-5 -4 -3 -2 -1) (0 1 2 3 4)]</tt></span></blockquote><p class="calibre23">Consider a case using <tt class="calibre22">split-with</tt> where you know that the prefix is going to be very small, but the suffix will be very large. If you retain a reference to the prefix, all of the values in the sequence will be retained even if your processing of the suffix is lazy. If the sequence in question is very large, then this head retention will ensure that an out of memory error will occur:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [[t d] (split-with #(&lt; % 12) (range 1e8))]<br class="calibre33"/>  [(count d) (count t)])<br class="calibre33"/>;= #&lt;OutOfMemoryError java.lang.OutOfMemoryError: Java heap space&gt;</tt></span></blockquote><p class="calibre23">Reversing the order of evaluation solves the problem:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [[t d] (split-with #(&lt; % 12) (range 1e8))]<br class="calibre33"/>  [(count t) (count d)])<br class="calibre33"/>;= [12 99999988]</tt></span></blockquote><p class="calibre23">Since the last reference of <tt class="calibre22">t</tt> occurs before the processing of <tt class="calibre22">d</tt>, no reference to the head of the <tt class="calibre22">range</tt> sequence is kept, and no memory issues arise.</p><p class="calibre18">Insertion into a map or set, <tt class="calibre22">=</tt>, and <tt class="calibre22">count</tt> are also common causes of “head retention”<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos387779"></a><a href="#filepos435720"><span class="calibre32">89</span></a><span class="calibre32">]</span></small></sup> since they force complete realization of lazy sequences.<a id="filepos387930"></a></p><p id="filepos387941" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Associative</span></span></span></p><p id="filepos388042" class="calibre18">The <span class="italic">associative</span> abstraction is shared by data structures that link keys and values in some way. It is defined by four operations:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">assoc</tt>, which establishes new associations between keys and values within the given collection</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">dissoc</tt>, which drops associations for given keys from the collection</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">get</tt>, which looks up the value for a particular key in a collection</blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">contains?</tt>, which is a predicate that returns <tt class="calibre22">true</tt> only if the collection has a value associated with the given key</blockquote></li></ul><p class="calibre18">The canonical associative data structure is the map, which also happens to be the most versatile data structure provided by Clojure. You’ll soon find maps to be your best friend.</p><p class="calibre18">As we have already seen, maps are seen as collections of entries (key/value pairs) when used with the core collection functions of <tt class="calibre22">conj</tt> and <tt class="calibre22">seq</tt>, but the associative functions are a more natural fit.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def m {:a 1, :b 2, :c 3})<br class="calibre33"/>;= #'user/m<br class="calibre33"/>(get m :b)<br class="calibre33"/>;= 2<br class="calibre33"/>(get m :d)<br class="calibre33"/>;= nil<br class="calibre33"/>(get m :d "not-found")<br class="calibre33"/>;= "not-found"<br class="calibre33"/>(assoc m :d 4)<br class="calibre33"/>;= {:a 1, :b 2, :c 3, :d 4}<br class="calibre33"/>(dissoc m :b)<br class="calibre33"/>;= {:a 1, :c 3}</tt></span></blockquote><p class="calibre23">Conveniently, you can also use <tt class="calibre22">assoc</tt><a id="filepos389936"></a> and <tt class="calibre22">dissoc</tt><a id="filepos389963"></a> to affect multiple entries in the given map:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(assoc m<br class="calibre33"/>  :x 4<br class="calibre33"/>  :y 5<br class="calibre33"/>  :z 6)<br class="calibre33"/>;= {:z 6, :y 5, :x 4, :a 1, :c 3, :b 2}<br class="calibre33"/>(dissoc m :a :c)<br class="calibre33"/>;= {:b 2}</tt></span></blockquote><p class="calibre23">Though they are used more frequently with maps, <tt class="calibre22">get</tt> and <tt class="calibre22">assoc</tt> are supported by vectors <a id="filepos390405"></a>too. While it might be initially counterintuitive, maps and vectors are <span class="italic">both</span> associative collections, where vectors associate values with indices:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def v [1 2 3])<br class="calibre33"/>;= #'user/v<br class="calibre33"/>(get v 1)                </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= 2<br class="calibre33"/>(get v 10)<br class="calibre33"/>;= nil<br class="calibre33"/>(get v 10 "not-found")<br class="calibre33"/>;= "not-found"<br class="calibre33"/>(assoc v<br class="calibre33"/>  1 4<br class="calibre33"/>  0 -12<br class="calibre33"/>  2 :p)                  </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= [-12 4 :p]</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">v</tt> “associates” the index <tt class="calibre22">1</tt> with the value <tt class="calibre22">2</tt>.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">You can update the value at an index in a vector using <tt class="calibre22">assoc</tt>; again, following the intent of the associative abstraction, but having data structure-dependent effects. Note that this <tt class="calibre22">assoc</tt> call is structurally identical to the multiple-entry <tt class="calibre22">assoc</tt> in the previous listing that operated on a map.</blockquote><p class="calibre18">Just as <tt class="calibre22">conj</tt> appends to vectors because that is where value may be added efficiently, you can also use <tt class="calibre22">assoc</tt> to append to vectors—with the caveat that you need to know what the new value’s index <span class="italic">will be</span>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(assoc v 3 10)<br class="calibre33"/>;= [1 2 3 10]</tt></span></blockquote><p class="calibre23">Finally, <tt class="calibre22">get</tt><a id="filepos392332"></a> works on sets, where if the “key” is present, it is returned:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(get #{1 2 3} 2)<br class="calibre33"/>;= 2<br class="calibre33"/>(get #{1 2 3} 4)<br class="calibre33"/>;= nil<br class="calibre33"/>(get #{1 2 3} 4 "not-found")<br class="calibre33"/>;= "not-found"</tt></span></blockquote><p class="calibre23">While sets by themselves have no key/value semantics, <tt class="calibre22">get</tt>’s return values when operating on a set imply that a set “associates” its values with themselves. This may seem strange, but it allows sets to satisfy the semantics of <tt class="calibre22">get</tt>, while remaining consistent with typical usage as a test in a conditional:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(when (get #{1 2 3} 2)<br class="calibre33"/>  (println "it contains `2`!"))<br class="calibre33"/>; it contains `2`!</tt></span></blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Clojure maps and sets support the semantics of </span><span class="calibre10"><tt class="calibre22">get</tt></span><span class="calibre10"> quite directly, beyond being usable with </span><span class="calibre10"><tt class="calibre22">get</tt></span><span class="calibre10"> itself. See </span><a href="#filepos438808"><span class="calibre10"><span class="calibre5">Collections are functions</span></span></a><span class="calibre10"> for how lookups can be done concisely, without touching </span><span class="calibre10"><tt class="calibre22">get</tt></span><span class="calibre10">.</span></blockquote><p class="calibre25"><span class="bold">contains?</span> <tt class="calibre22">contains?</tt><a id="filepos393891"></a> is a predicate that returns true for an associative collection only if the given key is present:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(contains? [1 2 3] 0)<br class="calibre33"/>;= true<br class="calibre33"/>(contains? {:a 5 :b 6} :b)<br class="calibre33"/>;= true<br class="calibre33"/>(contains? {:a 5 :b 6} 42)<br class="calibre33"/>;= false<br class="calibre33"/>(contains? #{1 2 3} 1)<br class="calibre33"/>;= true</tt></span></blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">It is a common mistake for Clojure programmers to initially believe that </span><span class="calibre10"><tt class="calibre22">contains?</tt></span><span class="calibre10"> always searches for the presence of a </span><span class="calibre10"><span class="italic">value</span></span><span class="calibre10"> in a collection, that is, that it would be appropriate to use to determine if the vector </span><span class="calibre10"><tt class="calibre22">[0 1 2 3]</tt></span><span class="calibre10"> contained a particular numeric value. This misconception can lead to some very confusing results:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(contains? [1 2 3] 3)<br class="calibre33"/>;= false<br class="calibre33"/>(contains? [1 2 3] 2)<br class="calibre33"/>;= true<br class="calibre33"/>(contains? [1 2 3] 0)<br class="calibre33"/>;= true</tt></span></blockquote><blockquote class="calibre35"><span class="calibre10">Of course, the results above are correct, since </span><span class="calibre10"><tt class="calibre22">contains?</tt></span><span class="calibre10"> is only checking to see if any mapping exists for the provided </span><span class="calibre10"><span class="italic">key</span></span><span class="calibre10">—in this case, the indices </span><span class="calibre10"><tt class="calibre22">3</tt></span><span class="calibre10">, </span><span class="calibre10"><tt class="calibre22">2</tt></span><span class="calibre10">, and </span><span class="calibre10"><tt class="calibre22">0</tt></span><span class="calibre10">. To check for the existence of a particular </span><span class="calibre10"><span class="italic">value</span></span><span class="calibre10"> in a collection, it is typical to use </span><span class="calibre10"><tt class="calibre22">some</tt></span><span class="calibre10">, described in </span><a href="#filepos443204"><span class="calibre10"><span class="calibre5">Collections and Keys and Higher-Order Functions</span></span></a><span class="calibre10">.</span></blockquote><p class="calibre25"><tt class="calibre22">get</tt> and <tt class="calibre22">contains?</tt> are particularly versatile: they work effectively on vectors, maps, sets, Java maps, <tt class="calibre22">String</tt>s, and Java arrays:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(get "Clojure" 3)<br class="calibre33"/>;= \j<br class="calibre33"/>(contains? (java.util.HashMap.) "not-there")<br class="calibre33"/>;= false<br class="calibre33"/>(get (into-array [1 2 3]) 0)<br class="calibre33"/>;= 1</tt></span></blockquote><p id="filepos396484" class="calibre23"><span class="calibre53"><span class="bold">Beware of nil values</span></span></p><p class="calibre18"><tt class="calibre22">get</tt><a id="filepos396605"></a> returns <tt class="calibre22">nil</tt> when there’s no entry for a given key and when no default value is provided. However, <tt class="calibre22">nil</tt> is a perfectly valid value, and is obviously returned when it is associated with a given key:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(get {:ethel nil} :lucy)<br class="calibre33"/>;= nil<br class="calibre33"/>(get {:ethel nil} :ethel)<br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre23">How can we tell the difference between a key that is associated with <tt class="calibre22">nil</tt> and a key that is not present?</p><p class="calibre18">We could use <tt class="calibre22">contains?</tt>, but then we’d be doing two map lookups all the time: one so that <tt class="calibre22">contains?</tt> could determine that an entry exists for a given key, and then the same lookup again to actually get the value. We could get clever and use a special default value, assuming that a key was not found if a <tt class="calibre22">get</tt> call returns the default value. However, such schemes have serious drawbacks as well: it’s often too easy for that special default value to leak into a map as a normal key, and using one ensures that the result of a <tt class="calibre22">get</tt> lookup won’t play nicely with conditionals, since any special default value will always be logically true, even when the given key is absent.</p><p class="calibre18">The answer is to use <tt class="calibre22">find</tt><a id="filepos397957"></a>. <tt class="calibre22">find</tt> works very much like <tt class="calibre22">get</tt> except that, instead of returning the associated value, it returns the whole entry; or, <tt class="calibre22">nil</tt> when not found.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(find {:ethel nil} :lucy)<br class="calibre33"/>;= nil<br class="calibre33"/>(find {:ethel nil} :ethel)<br class="calibre33"/>;= [:ethel nil]</tt></span></blockquote><p class="calibre23">Additionally <tt class="calibre22">find</tt> works very well with destructuring and conditional forms like <tt class="calibre22">if-let</tt> (or <tt class="calibre22">when-let</tt>):</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(if-let [e (find {:a 5 :b 6} :a)]<br class="calibre33"/>  (format "found %s =&gt; %s" (key e) (val e))<br class="calibre33"/>  "not found")<br class="calibre33"/>;= "found :a =&gt; 5"<br class="calibre33"/>(if-let [[k v] (find {:a 5 :b 6} :a)]<br class="calibre33"/>  (format "found %s =&gt; %s" k v)<br class="calibre33"/>  "not found")<br class="calibre33"/>;= "found :a =&gt; 5"</tt></span></blockquote><p class="calibre23">Of course, if you <span class="italic">only</span> want to check for the presence of a given key, just use <tt class="calibre22">contains?</tt>.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">BEWARE OF FALSE TOO</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">When used with a conditional, false values in associative collections present nearly the same problems as </span><a id="filepos399336"></a><span class="calibre10"><tt class="calibre22">nil</tt></span><span class="calibre10">, and the same measures must be taken to gracefully handle them.</span><a id="filepos399463"></a></blockquote><p id="filepos399483" class="calibre25"><span class="calibre19"><span class="bold"><span class="calibre5">Indexed</span></span></span></p><p id="filepos399580" class="calibre18">So far, we’ve talked about vectors while mostly avoiding talking about how to reach directly for the n<sup class="calibre30"><small class="calibre31"><span class="calibre32">th</span></small></sup> item in one, or changing the value at that position. There’s a reason for that: <span class="italic">indices are the new pointers</span>.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos399916"></a><a href="#filepos436000"><span class="calibre32">90</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">Honestly, indices—be they for strings or arrays or other sequential data—are rarely mandated by your algorithms.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos400193"></a><a href="#filepos436302"><span class="calibre32">91</span></a><span class="calibre32">]</span></small></sup> In many cases, dealing with indices induces complexity: either through index arithmetic and bounds-checking or through unneeded indirections. Outside of special circumstances, we feel safe in saying that excessive indexed lookup or modification is a code smell.</p><p class="calibre18">That said, there is a time and place for such things, and this is where the <span class="italic">indexed</span> abstraction comes in. It consists of a single function, <tt class="calibre22">nth</tt>, which is a specialization of <tt class="calibre22">get</tt>. They differ on how they deal with out-of-bounds indices: <tt class="calibre22">nth</tt> throws an exception while <tt class="calibre22">get</tt><a id="filepos400893"></a> returns <tt class="calibre22">nil</tt>:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 3-3. Comparing nth and get on vectors</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(nth [:a :b :c] 2)<br class="calibre33"/>;= :c<br class="calibre33"/>(get [:a :b :c] 2)<br class="calibre33"/>;= :c<br class="calibre33"/>(nth [:a :b :c] 3)<br class="calibre33"/>;= java.lang.IndexOutOfBoundsException<br class="calibre33"/>(get [:a :b :c] 3)<br class="calibre33"/>;= nil<br class="calibre33"/>(nth [:a :b :c] -1)<br class="calibre33"/>;= java.lang.IndexOutOfBoundsException<br class="calibre33"/>(get [:a :b :c] -1)<br class="calibre33"/>;= nil</tt></span></p><p class="calibre13">Despite this difference, when you provide a default return value, their semantics are identical:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(nth [:a :b :c] -1 :not-found)<br class="calibre33"/>;= :not-found<br class="calibre33"/>(get [:a :b :c] -1 :not-found)<br class="calibre33"/>;= :not-found</tt></span></blockquote><p class="calibre23"><tt class="calibre22">nth</tt><a id="filepos401818"></a> and <tt class="calibre22">get</tt> convey different meaning. First, <tt class="calibre22">nth</tt> can only work with numerical indices and works on many things that can be numerically indexed: vectors, lists, sequences, Java arrays, Java lists, strings, and regular expression matchers. On the other hand, <tt class="calibre22">get</tt> is more general: it works on any kind of associative type, as we’ve already seen, and treats numerical indices as keys into the collection or value in question.</p><p class="calibre18">Another major difference between <tt class="calibre22">nth</tt> and <tt class="calibre22">get</tt> is that <tt class="calibre22">get</tt> is more resilient. We have already seen that <tt class="calibre22">get</tt> returns <tt class="calibre22">nil</tt> when an index (treated as a key) is not found, rather than throwing an exception. <tt class="calibre22">get</tt> goes even further: it returns <tt class="calibre22">nil</tt> when the subject of the lookup is not supported, while <tt class="calibre22">nth</tt> throws an exception.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(get 42 0)<br class="calibre33"/>;= nil<br class="calibre33"/>(nth 42 0)<br class="calibre33"/>;= java.lang.UnsupportedOperationException: nth not supported on this type: Long</tt></span></blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Clojure vectors support the semantics of </span><a id="filepos403149"></a><span class="calibre10"><tt class="calibre22">nth</tt></span><span class="calibre10"> quite directly, beyond being usable with </span><span class="calibre10"><tt class="calibre22">nth</tt></span><span class="calibre10"> itself. See </span><a href="#filepos438808"><span class="calibre10"><span class="calibre5">“Collections are functions”</span></span></a><span class="calibre10"> for how lookups can be done concisely, without touching </span><span class="calibre10"><tt class="calibre22">nth</tt></span><span class="calibre10">.</span></blockquote><p id="filepos403580" class="calibre25"><span class="calibre19"><span class="bold"><span class="calibre5">Stack</span></span></span></p><p class="calibre18"><span class="italic">Stacks</span>
<a id="filepos403717"></a>are collections that classically support last-in, first-out (LIFO)<a id="filepos403790"></a> semantics; that is, the most recent item added to a stack is the first one that can be pulled off of it. Clojure doesn’t have a distinct stack data structure, but it does support a stack abstraction via three operations:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">conj</tt>, for pushing a value onto the stack (conveniently reusing the collection-generalized operation)</blockquote></li><a id="filepos404267"></a><li value="2" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">pop</tt>, for obtaining the stack with its top value removed</blockquote></li><a id="filepos404432"></a><li value="3" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">peek</tt>, for obtaining the value on the top of the stack</blockquote></li><a id="filepos404595"></a></ul><p class="calibre18">Both lists and vectors can be used as stacks (Examples <a href="#filepos404934"><span class="calibre5">3-4</span></a> and <a href="#filepos405306"><span class="calibre5">3-5</span></a>), where the top of the stack is the end of each respective data structure where <tt class="calibre22">conj</tt> can efficiently operate.</p><p id="filepos404934" class="calibre23"></p><p class="calibre23"><span class="italic">Example 3-4. Using a list as a stack</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(conj '() 1)<br class="calibre33"/>;= (1)<br class="calibre33"/>(conj '(2 1) 3)<br class="calibre33"/>;= (3 2 1)<br class="calibre33"/>(peek '(3 2 1))<br class="calibre33"/>;= 3<br class="calibre33"/>(pop '(3 2 1))<br class="calibre33"/>;= (2 1)<br class="calibre33"/>(pop '(1))<br class="calibre33"/>;= ()</tt></span></p><p id="filepos405306" class="calibre13"></p><p class="calibre23"><span class="italic">Example 3-5. Using a vector as a stack</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(conj [] 1)<br class="calibre33"/>;= [1]<br class="calibre33"/>(conj [1 2] 3)<br class="calibre33"/>;= [1 2 3]<br class="calibre33"/>(peek [1 2 3])<br class="calibre33"/>;= 3<br class="calibre33"/>(pop [1 2 3])<br class="calibre33"/>;= [1 2]<br class="calibre33"/>(pop [1])<br class="calibre33"/>;= []</tt></span></p><p class="calibre13"><tt class="calibre22">pop</tt>ping an empty stack will result in an error.</p><p id="filepos405763" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Set</span></span></span></p><p id="filepos405856" class="calibre18">We’ve already seen how sets participate partially in the associative abstraction, where they are treated as a sort of degenerate map, associating keys with themselves:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(get #{1 2 3} 2)<br class="calibre33"/>;= 2<br class="calibre33"/>(get #{1 2 3} 4)<br class="calibre33"/>;= nil<br class="calibre33"/>(get #{1 2 3} 4 "not-found")<br class="calibre33"/>;= "not-found"</tt></span></blockquote><p class="calibre23">To be complete though, the <span class="italic">set</span> abstraction requires <tt class="calibre22">disj</tt>, which removes value(s) from the given set:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(disj #{1 2 3} 3 1)<br class="calibre33"/>;= #{2}</tt></span></blockquote><p class="calibre23">While the set abstraction itself is slight, reusing common collection and associative semantics for most of the fundamental operations on sets, we recommend that you become familiar with <tt class="calibre22">clojure.set</tt>. A namespace in Clojure’s standard library, <tt class="calibre22">clojure.set</tt> provides a suite of functions implementing various higher-level operations and predicates over sets, including <tt class="calibre22">subset?</tt>, <tt class="calibre22">superset?</tt>, <tt class="calibre22">union</tt>, <tt class="calibre22">intersection</tt>, <tt class="calibre22">project</tt>, and more.</p><p id="filepos407075" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Sorted</span></span></span></p><p id="filepos407171" class="calibre18">Collections that participate in the <span class="italic">sorted</span> abstraction guarantee that their values will be maintained in a stable ordering that is optionally defined by a predicate or implementation of a special comparator interface. This allows you to efficiently obtain in-order and reverse-order seqs over all or a subrange of such collections’ values. These operations are provided by:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">rseq</tt>, which returns a seq of a collection’s values in reverse, with the guarantee that doing so will return in constant time</blockquote></li><a id="filepos407854"></a><li value="2" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">subseq</tt>, which returns a seq of a collection’s values that fall within a specified range of keys</blockquote></li><a id="filepos408061"></a><li value="3" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">rsubseq</tt>, the same as <tt class="calibre22">subseq</tt>, but the seq is in reversed order</blockquote></li><a id="filepos408241"></a></ul><p class="calibre18">Only maps and sets are available in sorted variants. They do not have any literal notation; they may be created by <tt class="calibre22">sorted-map</tt> and <tt class="calibre22">sorted-set</tt>, or <tt class="calibre22">sorted-map-by</tt> and <tt class="calibre22">sorted-set-by</tt> if you provide your own predicate or comparator to define sort order.</p><p class="calibre18">Given a sorted collection, you can use any of the abstraction’s functions to query it:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def sm (sorted-map :z 5 :x 9 :y 0 :b 2 :a 3 :c 4))<br class="calibre33"/>;= #'user/sm<br class="calibre33"/>sm<br class="calibre33"/>;= {:a 3, :b 2, :c 4, :x 9, :y 0, :z 5}<br class="calibre33"/>(rseq sm)                                            </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= ([:z 5] [:y 0] [:x 9] [:c 4] [:b 2] [:a 3])<br class="calibre33"/>(subseq sm &lt;= :c)                                    </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= ([:a 3] [:b 2] [:c 4])<br class="calibre33"/>(subseq sm &gt; :b &lt;= :y)                               </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= ([:c 4] [:x 9] [:y 0])<br class="calibre33"/>(rsubseq sm &gt; :b &lt;= :y)                              </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= ([:y 0] [:x 9] [:c 4])</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">rseq</tt> will return a seq over <tt class="calibre22">sm</tt> in reverse order in constant time.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">Here we are querying <tt class="calibre22">sm</tt> for all values that have keys that sort before or equal to <tt class="calibre22">:c</tt>.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">This query is looking for all values that have keys that sort after <tt class="calibre22">:b</tt>
<span class="italic">and</span> before or equal to <tt class="calibre22">:y</tt>.</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">rsubseq</tt> performs the same query as <tt class="calibre22">subseq</tt>, but returns results in reverse order.</blockquote><p class="calibre18">Because <tt class="calibre22">sm</tt> is sorted, each of these operations have far better performance characteristics than their seq-only corollaries, which would need various linear-time operations (e.g., <tt class="calibre22">filter</tt>, <tt class="calibre22">take-while</tt>) to yield the same results. In particular, <tt class="calibre22">rseq</tt> is guaranteed to return in constant time, in contrast to <tt class="calibre22">reverse</tt>, which can be used to obtain a seq of any collection in reverse order, but which operates in linear time.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos411490"></a><a href="#filepos437082"><span class="calibre32">92</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">The <tt class="calibre22">compare</tt> function defines the default sort: ascending, supporting all Clojure scalars and sequential collections, sorting lexicographically at each level:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos411817"></a><a href="#filepos437698"><span class="calibre32">93</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(compare 2 2)<br class="calibre33"/>;= 0<br class="calibre33"/>(compare "ab" "abc")<br class="calibre33"/>;= -1<br class="calibre33"/>(compare ["a" "b" "c"] ["a" "b"])<br class="calibre33"/>;= 1<br class="calibre33"/>(compare ["a" 2] ["a" 2 0])<br class="calibre33"/>;= -1</tt></span></blockquote><p class="calibre23">In truth, <tt class="calibre22">compare</tt><a id="filepos412242"></a> supports more than strings, numbers, and sequential collections: it supports anything that implements <tt class="calibre22">java.lang.Comparable</tt>—which includes Booleans, keywords, symbols, and all Java and third-party classes implementing this interface. <tt class="calibre22">compare</tt> is a potent function but is only the default <span class="italic">comparator</span>.</p><p id="filepos412578" class="calibre23"><span class="calibre53"><span class="bold">Comparators and predicates to define ordering</span></span></p><p id="filepos412684" class="calibre18">A <span class="italic">comparator</span> is a two-argument function that returns a positive integer when the first argument is greater than the second one, a negative integer when the first is less than the second, and zero when both arguments are equal.</p><p class="calibre18">All Clojure functions implement <tt class="calibre22">java.util.Comparator</tt> and can therefore be used as comparators—although obviously, not all functions are intended to be used as such. Specifically, you don’t have to do anything special to make a function implement that <tt class="calibre22">Comparator</tt> interface—any two-argument predicate will do.</p><p class="calibre18">Beyond not having to implement special interfaces to produce a comparator, this fact means that it is much easier to create composite orderings: a secondary sort is just a function composition away. Comparison functions can be passed directly to sorted collections’ factory functions as well as <tt class="calibre22">sort</tt> and <tt class="calibre22">sort-by</tt>:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos413707"></a><a href="#filepos437965"><span class="calibre32">94</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(sort &lt; (repeatedly 10 #(rand-int 100)))<br class="calibre33"/>;= (12 16 22 23 41 42 61 63 83 87)<br class="calibre33"/>(sort-by first &gt; (map-indexed vector "Clojure"))<br class="calibre33"/>;= ([6 \e] [5 \r] [4 \u] [3 \j] [2 \o] [1 \l] [0 \C])</tt></span></blockquote><blockquote class="calibre38"></blockquote><blockquote class="calibre39"><span class="calibre10"><span class="bold">HOW DOES CLOJURE TURN A PREDICATE INTO A COMPARATOR?</span></span></blockquote><blockquote id="filepos414324" class="calibre17"><span class="calibre10">It may seem confusing that predicates—like </span><span class="calibre10"><tt class="calibre22">&lt;</tt></span><span class="calibre10">, which return Boolean values—can be used as comparators, since their return values are defined as negative or positive integers, or zero if arguments are equal.</span></blockquote><blockquote class="calibre17"><span class="calibre10">The algorithm used to turn a predicate into a comparator is quite simple: the predicate is called first with the two arguments in the order given to the comparator. If the predicate returns true, then </span><span class="calibre10"><tt class="calibre22">-1</tt></span><span class="calibre10"> is returned. Otherwise, the predicate is called again but with the order of the two arguments reversed. If this time it returns true, then </span><span class="calibre10"><tt class="calibre22">1</tt></span><span class="calibre10"> is returned. Otherwise, given that no argument appears to be dominated by the other, the arguments are considered equal, and </span><span class="calibre10"><tt class="calibre22">0</tt></span><span class="calibre10"> is returned.</span></blockquote><blockquote class="calibre17"><span class="calibre10"><tt class="calibre22">comparator</tt></span><span class="calibre10"> will explicitly turn a two-argument predicate into a comparator function that uses this logic:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">((comparator &lt;) 1 4)<br class="calibre33"/>;= -1<br class="calibre33"/>((comparator &lt;) 4 1)<br class="calibre33"/>;= 1<br class="calibre33"/>((comparator &lt;) 4 4)<br class="calibre33"/>;= 0</tt></span></blockquote><blockquote class="calibre35"><span class="calibre10">although this is rarely used, since functions implicitly provide this conversion when used with the various Clojure functions that accept comparators, and two-argument functions already implement the </span><span class="calibre10"><tt class="calibre22">java.util.Comparator</tt></span><span class="calibre10"> interface.</span></blockquote><p class="calibre50">So, while <tt class="calibre22">sorted-map</tt><a id="filepos416218"></a> and <tt class="calibre22">sorted-set</tt><a id="filepos416249"></a> create maps and sets where their keys are sorted according to the default <tt class="calibre22">compare</tt>, <tt class="calibre22">sorted-map-by</tt><a id="filepos416371"></a> and <tt class="calibre22">sorted-set-by</tt><a id="filepos416405"></a> will accept a comparator (again, any two-argument predicate function will do) to drive their sort order. The simplest comparator you can pass to a sorted collection (apart from <tt class="calibre22">compare</tt> itself) is probably <tt class="calibre22">(comp - compare)</tt>, which negates the result of <tt class="calibre22">compare</tt>, and therefore the sort order of the collection:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(sorted-map-by compare :z 5 :x 9 :y 0 :b 2 :a 3 :c 4)<br class="calibre33"/>;= {:a 3, :b 2, :c 4, :x 9, :y 0, :z 5}<br class="calibre33"/>(sorted-map-by (comp - compare) :z 5 :x 9 :y 0 :b 2 :a 3 :c 4)<br class="calibre33"/>;= {:z 5, :y 0, :x 9, :c 4, :b 2, :a 3}</tt></span></blockquote><p class="calibre23">It must be noted that <span class="italic">sort order defines equality within a sorted map or set</span>; this can sometimes lead to rational but surprising results. For example, say we have a function that returns the order of magnitude of numbers:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn magnitude<br class="calibre33"/>  [x]<br class="calibre33"/>  (-&gt; x Math/log10 Math/floor))<br class="calibre33"/>;= #'user/magnitude<br class="calibre33"/>(magnitude 100)<br class="calibre33"/>;= 2.0<br class="calibre33"/>(magnitude 100000)<br class="calibre33"/>;= 5.0</tt></span></blockquote><p class="calibre23">Straightforward enough, and we can create a comparison predicate that uses <tt class="calibre22">magnitude</tt>, which will return the difference in orders of magnitude between its first and second arguments:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn compare-magnitude<br class="calibre33"/>  [a b]<br class="calibre33"/>  (- (magnitude a) (magnitude b)))<br class="calibre33"/><br class="calibre33"/>((comparator compare-magnitude) 10 10000)<br class="calibre33"/>;= -1<br class="calibre33"/>((comparator compare-magnitude) 100 10)<br class="calibre33"/>;= 1<br class="calibre33"/>((comparator compare-magnitude) 10 75)<br class="calibre33"/>;= 0</tt></span></blockquote><p class="calibre23">Things get interesting when we use this as a comparator with a sorted collection:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(sorted-set-by compare-magnitude 10 1000 500)  </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #{10 500 1000}<br class="calibre33"/>(conj *1 600)                                  </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #{10 500 1000}<br class="calibre33"/>(disj *1 750)                                  </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #{10 1000}<br class="calibre33"/>(contains? *1 1239)                            </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= true</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Each of 10, 1000, and 500 have different orders of magnitude, so they are all retained in the set as different elements according to the comparator.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">Adding 600 to that set is a no-op because 600 is the same order of magnitude as 500, and therefore is considered equal to 500 by the comparator.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">Because 750 is also considered equal to 500 by the comparator, 500 is removed from the set even though 750 was provided as the argument to <tt class="calibre22">disj</tt>.</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">Similarly, 1239 has the same order of magnitude as 1000, so <tt class="calibre22">contains?</tt> returns true because a key equal to its argument is found in the given set.</blockquote><p class="calibre18">Sometimes this behavior is what you want, sometimes not. Keep in mind that you have complete control over the implementation of your comparators; while it is convenient to use (or reuse) predicates, you can opt to return negative or positive integers or zero at any time in order to enforce the equality semantics you desire. <tt class="calibre22">compare-magnitude</tt> can be rewritten to ensure that only equivalent numbers are considered equal, by delegating to <tt class="calibre22">compare</tt> when its arguments have the same order of magnitude:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn compare-magnitude<br class="calibre33"/>  [a b]<br class="calibre33"/>  (let [diff (- (magnitude a) (magnitude b))]<br class="calibre33"/>    (if (zero? diff)<br class="calibre33"/>      (compare a b)<br class="calibre33"/>      diff)))<br class="calibre33"/><br class="calibre33"/>(sorted-set-by compare-magnitude 10 1000 500)<br class="calibre33"/>;= #{10 500 1000}<br class="calibre33"/>(conj *1 600)<br class="calibre33"/>;= #{10 500 600 1000}<br class="calibre33"/>(disj *1 750)<br class="calibre33"/>;= #{10 500 600 1000}</tt></span></blockquote><p class="calibre23">Now our set’s values remain sorted by their order of magnitude, but operations that rely upon numerical equality (like <tt class="calibre22">conj</tt> and <tt class="calibre22">disj</tt>) will behave as we might intuitively expect.</p><p class="calibre18"><tt class="calibre22">subseq</tt><a id="filepos421802"></a> and <tt class="calibre22">rsubseq</tt><a id="filepos421830"></a> continue to work as you’d expect to extract intervals (in natural or reverse order) from a sorted collection defined with a custom comparator:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(sorted-set-by compare-magnitude 10 1000 500 670 1239)<br class="calibre33"/>;= #{10 500 670 1000 1239}<br class="calibre33"/>(def ss *1)<br class="calibre33"/>;= #'user/ss<br class="calibre33"/>(subseq ss &gt; 500)<br class="calibre33"/>;= (670 1000 1239)<br class="calibre33"/>(subseq ss &gt; 500 &lt;= 1000)<br class="calibre33"/>;= (670 1000)<br class="calibre33"/>(rsubseq ss &gt; 500 &lt;= 1000)<br class="calibre33"/>;= (1000 670)</tt></span></blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">The interval specification required by these functions uses </span><span class="calibre10"><tt class="calibre22">&lt;</tt></span><span class="calibre10">, </span><span class="calibre10"><tt class="calibre22">&lt;=</tt></span><span class="calibre10">, </span><span class="calibre10"><tt class="calibre22">&gt;</tt></span><span class="calibre10">, and </span><span class="calibre10"><tt class="calibre22">&gt;=</tt></span><span class="calibre10"> solely as hints with regard to the actual comparator in use in the sorted collection; the corresponding predicates are not used.</span></blockquote><p class="calibre25">One amusing use of these functions is to implement linear interpolation:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn interpolate<br class="calibre33"/> "Takes a collection of points (as [x y] tuples), returning a function<br class="calibre33"/>  which is a linear interpolation between those points."<br class="calibre33"/> [points]<br class="calibre33"/>  (let [results (into (sorted-map) (map vec points))] </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>    (fn [x]<br class="calibre33"/>      (let [[xa ya] (first (rsubseq results &lt;= x))    </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>            [xb yb] (first (subseq results &gt; x))]<br class="calibre33"/>        (if (and xa xb)                               </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>          (/ (+ (* ya (- xb x)) (* yb (- x xa)))      </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>             (- xb xa))<br class="calibre33"/>          (or ya yb))))))</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">(map vec points)</tt> ensures that each point is a vector and thus can be added as an entry to a map.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">Here and at the line below we find the two closest neighbors of <tt class="calibre22">x</tt> in the known points.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">When we are out of range either <tt class="calibre22">xa</tt> or <tt class="calibre22">xb</tt> is <tt class="calibre22">nil</tt> and we return <tt class="calibre22">(or ya yb)</tt>, which is the only value we know.</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">The linear interpolation formula for the regular case.</blockquote><p class="calibre18">Let’s test it; say we have three known points, <tt class="calibre22">[0 0]</tt>, <tt class="calibre22">[10 10]</tt>, and <tt class="calibre22">[15 5]</tt>:</p><p class="calibre51"><img src="images/00043.jpg" class="calibre66"/></p><p class="calibre13">For known <tt class="calibre22">x</tt> coordinates, we can find the <tt class="calibre22">y</tt> that fits the data we have:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def f (interpolate [[0 0] [10 10] [15 5]]))<br class="calibre33"/>;= #'user/f<br class="calibre33"/>(map f [2 10 12])<br class="calibre33"/>;= (2 10 8)</tt></span></blockquote><p class="calibre23">Perfect!<a id="filepos426011"></a></p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos426115"></a><a href="#filepos338101"><span class="calibre32">72</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">More wonderful Perlisisms may be found at </span><a href="http://www.cs.yale.edu/quotes.html"><span class="calibre10"><span class="calibre5">http://www.cs.yale.edu/quotes.html</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos426498"></a><a href="#filepos339623"><span class="calibre32">73</span></a><span class="calibre32">] </span></small></sup><span class="calibre10"><tt class="calibre22">conj</tt></span><span class="calibre10"> is derived from “conjoin,” to bring together.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos426767"></a><a href="#filepos345887"><span class="calibre32">74</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">A strategy used throughout software to good effect: witness all of the various “unsupported operation” errors and exception types in nearly all languages, used to indicate a corner of an abstraction that remains unimplemented.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos427181"></a><a href="#filepos348362"><span class="calibre32">75</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Equality is a subtle subject that goes beyond the topic of collections; see </span><a href="#filepos1575967"><span class="calibre10"><span class="calibre5">Equality and Equivalence</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos427565"></a><a href="#filepos351595"><span class="calibre32">76</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Compare this to, for example, Java collections helper methods that can opt to accept generic types like </span><span class="calibre10"><tt class="calibre22">java.util.List</tt></span><span class="calibre10">, but then must either specialize their return type or only guarantee that they also return something equally generic.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos428038"></a><a href="#filepos354038"><span class="calibre32">77</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Really, any </span><span class="calibre10"><tt class="calibre22">java.lang.CharSequence</tt></span><span class="calibre10">, including </span><span class="calibre10"><tt class="calibre22">java.lang.StringBuilder</tt></span><span class="calibre10">s, </span><span class="calibre10"><tt class="calibre22">java.lang.StringBuffer</tt></span><span class="calibre10">s, and </span><span class="calibre10"><tt class="calibre22">java.nio.CharBuffer</tt></span><span class="calibre10">s instances.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos428566"></a><a href="#filepos356069"><span class="calibre32">78</span></a><span class="calibre32">] </span></small></sup><span class="calibre10"><tt class="calibre22">seq</tt></span><span class="calibre10"> works on </span><span class="calibre10"><tt class="calibre22">Iterable</tt></span><span class="calibre10"> objects directly; </span><span class="calibre10"><tt class="calibre22">iterator-seq</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">enumerator-seq</tt></span><span class="calibre10"> are available for obtaining a seq of a </span><span class="calibre10"><tt class="calibre22">java.lang.Iterator</tt></span><span class="calibre10"> or </span><span class="calibre10"><tt class="calibre22">java.lang.Enumerator</tt></span><span class="calibre10">, respectively. These functions are separate from </span><span class="calibre10"><tt class="calibre22">seq</tt></span><span class="calibre10"> because they are destructive: an </span><span class="calibre10"><tt class="calibre22">Iterator</tt></span><span class="calibre10"> or </span><span class="calibre10"><tt class="calibre22">Enumerator</tt></span><span class="calibre10"> can only be traversed </span><span class="calibre10"><span class="italic">once</span></span><span class="calibre10">, which is required if you obtain and consume a seq over either of them. In contrast, </span><span class="calibre10"><tt class="calibre22">seq</tt></span><span class="calibre10"> is nondestructive with regard to </span><span class="calibre10"><tt class="calibre22">Iterable</tt></span><span class="calibre10"> objects because they can always provide a fresh </span><span class="calibre10"><tt class="calibre22">Iterator</tt></span><span class="calibre10"> for each </span><span class="calibre10"><tt class="calibre22">seq</tt></span><span class="calibre10"> call.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos429964"></a><a href="#filepos359723"><span class="calibre32">79</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="#filepos169536"><span class="calibre10"><span class="calibre5">“Variadic functions”</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos430276"></a><a href="#filepos363405"><span class="calibre32">80</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">This is an implementation detail, but currently </span><span class="calibre10"><tt class="calibre22">(identical? some-list (seq some-list))</tt></span><span class="calibre10"> is always true.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos430615"></a><a href="#filepos366589"><span class="calibre32">81</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">If you have any experience with other Lisps, take note that Clojure’s </span><span class="calibre10"><tt class="calibre22">cons</tt></span><span class="calibre10"> has little to nothing to do with the </span><span class="calibre10"><tt class="calibre22">cons</tt></span><span class="calibre10"> found elsewhere. Similarly, Clojure’s lists are not composed of a series of </span><span class="calibre10"><tt class="calibre22">cons</tt></span><span class="calibre10"> cells.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos431166"></a><a href="#filepos367438"><span class="calibre32">82</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Confusingly, </span><span class="calibre10"><tt class="calibre22">list*</tt></span><span class="calibre10"> does </span><span class="calibre10"><span class="italic">not</span></span><span class="calibre10"> return a list—i.e., </span><span class="calibre10"><tt class="calibre22">(list? (list* 0 (range 1 5)))</tt></span><span class="calibre10"> will return false—unless only one value is provided. This will not cause any problems, unless you were to use the concrete type of a data structure to dictate program behavior by using, for example, </span><span class="calibre10"><tt class="calibre22">list?</tt></span><span class="calibre10">. As always, it is better to code to abstractions instead of concrete types, so anywhere you might want to use </span><span class="calibre10"><tt class="calibre22">list?</tt></span><span class="calibre10">, use </span><span class="calibre10"><tt class="calibre22">seq?</tt></span><span class="calibre10"> or </span><span class="calibre10"><tt class="calibre22">sequential?</tt></span><span class="calibre10"> instead.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos432155"></a><a href="#filepos370906"><span class="calibre32">83</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">That means that you should be cautious about evaluating references to infinite or otherwise very large sequences without constraining their scope, such as via </span><span class="calibre10"><tt class="calibre22">(take 100 infinite-seq)</tt></span><span class="calibre10"> to limit the printed subsequence to the first </span><span class="calibre10"><tt class="calibre22">100</tt></span><span class="calibre10"> values. Alternatively, you can </span><span class="calibre10"><tt class="calibre22">set!</tt></span><span class="calibre10">
</span><span class="calibre10"><tt class="calibre22">*print-length*</tt></span><span class="calibre10"> to some reasonable value (maybe </span><span class="calibre10"><tt class="calibre22">100</tt></span><span class="calibre10">) to limit the number of entries shown from each printed collection.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos432991"></a><a href="#filepos377500"><span class="calibre32">84</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">…and their derivatives, like </span><span class="calibre10"><tt class="calibre22">take-nth</tt></span><span class="calibre10">, </span><span class="calibre10"><tt class="calibre22">take-while</tt></span><span class="calibre10">, </span><span class="calibre10"><tt class="calibre22">drop-while</tt></span><span class="calibre10">, </span><span class="calibre10"><tt class="calibre22">remove</tt></span><span class="calibre10">, and so on.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos433470"></a><a href="#filepos377936"><span class="calibre32">85</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Being able to filter gigabytes of data on multiple cores simply by using </span><span class="calibre10"><tt class="calibre22">pmap</tt></span><span class="calibre10"> in conjunction with a lazy seq while using just a couple of megabytes of memory inspires giddiness. See </span><a href="#filepos618299"><span class="calibre10"><span class="calibre5">Parallelism on the Cheap</span></span></a><span class="calibre10"> for more on </span><span class="calibre10"><tt class="calibre22">pmap</tt></span><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos434083"></a><a href="#filepos380356"><span class="calibre32">86</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">As we saw before, </span><span class="calibre10"><tt class="calibre22">count</tt></span><span class="calibre10"> (and a few other functions) will do the same, but only as an implementation detail. It is </span><span class="calibre10"><span class="italic">possible</span></span><span class="calibre10"> (though very rare) for a lazy sequence to know its length, and therefore return it as the result of </span><span class="calibre10"><tt class="calibre22">count</tt></span><span class="calibre10"> without realizing its contents.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos434684"></a><a href="#filepos383436"><span class="calibre32">87</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Some data structures like vectors generate “chunked” sequences, and many sequence functions (e.g., </span><span class="calibre10"><tt class="calibre22">map</tt></span><span class="calibre10">, </span><span class="calibre10"><tt class="calibre22">filter</tt></span><span class="calibre10">) process those sequences one chunk (containing 32 values per chunk in the case of seqs obtained from vectors) at a time rather than one value at a time.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos435241"></a><a href="#filepos385516"><span class="calibre32">88</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">This is in sharp contrast with generators in Python and </span><span class="calibre10"><tt class="calibre22">Enumerator</tt></span><span class="calibre10">s in Ruby, which can lazily produce potentially infinite series of values on demand, but which do not provide a consistent way to retain previously generated values if desired.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos435720"></a><a href="#filepos387779"><span class="calibre32">89</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Or rather, premature realization—but the end result of an out-of-memory condition is the same.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos436000"></a><a href="#filepos399916"><span class="calibre32">90</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Alternatively, an </span><span class="calibre10"><tt class="calibre22">IndexOutOfBoundsException</tt></span><span class="calibre10"> is the new core dump.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos436302"></a><a href="#filepos400193"><span class="calibre32">91</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Every generalization has its exceptions; if you are writing numerical libraries or implementing sublinear algorithms like the Boyer-Moore string search, you need indices. Sometimes you need to step back when considering a given algorithm for implementation in Clojure. Many textbooks and other guides use arrays and indices everywhere simply because they are a </span><span class="calibre10"><span class="italic">lingua franca</span></span><span class="calibre10">, a kind of least common denominator between languages. That doesn’t mean that the cleanest or most efficient implementation in Clojure won’t use a different approach.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos437082"></a><a href="#filepos411490"><span class="calibre32">92</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">We’re fibbing a bit here: </span><span class="calibre10"><tt class="calibre22">rseq</tt></span><span class="calibre10"> is technically part of another minor abstraction—</span><span class="calibre10"><span class="italic">reversible</span></span><span class="calibre10">—that establishes this guarantee. We’re glossing over it because, aside from sorted collections, only vectors are also reversible (and so </span><span class="calibre10"><tt class="calibre22">rseq</tt></span><span class="calibre10"> may be used with vectors as well).</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos437698"></a><a href="#filepos411817"><span class="calibre32">93</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">It follows that, for example, vectors of vectors of vectors can be reliably sorted.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos437965"></a><a href="#filepos413707"><span class="calibre32">94</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Or any Java API that expects a </span><span class="calibre10"><tt class="calibre22">java.util.Comparator</tt></span><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos438207" class="calibre6"><span class="calibre4"><span class="bold">Concise Collection Access</span></span></p><p id="filepos438293" class="calibre18">Accessing values is easily the most common operation performed over collections, especially those that support the associative abstraction. That being the case, having to constantly type <tt class="calibre22">get</tt> or <tt class="calibre22">nth</tt> could get very tiring. Thankfully, Clojure collections and the most common types of keys used in associative collections <span class="italic">are also functions</span><a id="filepos438683"></a> with the semantics of <tt class="calibre22">get</tt> or <tt class="calibre22">nth</tt> (as appropriate for the concrete type of collection involved).</p><p id="filepos438808" class="calibre18"><span class="bold">Collections are functions</span>. Very simply, Clojure collections are functions that look up the value associated with the key or index that is provided. So these:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(get [:a :b :c] 2)<br class="calibre33"/>;= :c<br class="calibre33"/>(get {:a 5 :b 6} :b)<br class="calibre33"/>;= 6<br class="calibre33"/>(get {:a 5 :b 6} :c 7)<br class="calibre33"/>;= 7<br class="calibre33"/>(get #{1 2 3} 3)<br class="calibre33"/>;= 3</tt></span></blockquote><p class="calibre23">are exactly equivalent to these more concise expressions:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">([:a :b :c] 2)<br class="calibre33"/>;= :c<br class="calibre33"/>({:a 5 :b 6} :b)<br class="calibre33"/>;= 6<br class="calibre33"/>({:a 5 :b 6} :c 7)<br class="calibre33"/>;= 7<br class="calibre33"/>(#{1 2 3} 3)<br class="calibre33"/>;= 3</tt></span></blockquote><p class="calibre23">In each of these cases, the collection is in function position, so <span class="italic">it</span> is being called with the key or index to look up within itself. Maps accept an optional second argument just like <tt class="calibre22">get</tt>, the optional default value returned if the lookup fails. Both vectors and sets accept only a single value/index for the lookup; defaults are not supported. Indices provided for vector lookups must also be within the range of the vector, just as with <tt class="calibre22">nth</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">([:a :b :c] -1)<br class="calibre33"/>;= #&lt;IndexOutOfBoundsException java.lang.IndexOutOfBoundsException&gt;</tt></span></blockquote><p class="calibre23"><span class="bold">Collection keys are (often) functions</span>. <a id="filepos440352"></a>Similarly, the most common types of keys—keywords and symbols—are also functions that look themselves up in the provided collection. Thus, these:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(get {:a 5 :b 6} :b)<br class="calibre33"/>;= 6<br class="calibre33"/>(get {:a 5 :b 6} :c 7)<br class="calibre33"/>;= 7<br class="calibre33"/>(get #{:a :b :c} :d)<br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre23">are exactly equivalent to these more concise expressions:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(:b {:a 5 :b 6})<br class="calibre33"/>;= 6<br class="calibre33"/>(:c {:a 5 :b 6} 7)<br class="calibre33"/>;= 7<br class="calibre33"/>(:d #{:a :b :c})<br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre23">Since the value in function position must be a function, numeric indices can’t be used; therefore, vector lookups cannot be performed using this approach.</p><p id="filepos441214" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Idiomatic Usage</span></span></span></p><p id="filepos441319" class="calibre18">Great, so there are less verbose ways to access values in collections. That’s clearly good, but without some additional guidance, it might not be so clear as to how and when to use each variation: when should the collection be used as the lookup function versus the keyword or symbol?</p><p class="calibre18">This is treading dangerously into the realm of taste; but, <span class="italic">in general</span>, we recommend using the keyword <a id="filepos441774"></a>or symbol <a id="filepos441791"></a>being looked up as the function. The most immediate advantage of this idiom is that null pointer exceptions are usually avoided, since keywords and symbols are most often literals when used as lookup functions. Consider:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn get-foo<br class="calibre33"/>  [map]<br class="calibre33"/>  (:foo map))<br class="calibre33"/>;= #'user/get-foo<br class="calibre33"/>(get-foo nil)<br class="calibre33"/>;= nil<br class="calibre33"/>(defn get-bar<br class="calibre33"/>  [map]<br class="calibre33"/>  (map :bar))<br class="calibre33"/>;= #'user/get-bar<br class="calibre33"/>(get-bar nil)<br class="calibre33"/>;= #&lt;NullPointerException java.lang.NullPointerException&gt;</tt></span></blockquote><p class="calibre23">Additionally, the form <tt class="calibre22">(coll :foo)</tt> assumes that <tt class="calibre22">coll</tt>, a collection, is also a function. That is true for most Clojure data structures, but is not true for (for example) lists, and is not necessarily true for other types that participate in Clojure’s collection abstractions but that are not also functions. This makes <tt class="calibre22">(:foo coll)</tt> more desirable, insofar as you can be certain that the literal keyword <tt class="calibre22">:foo</tt> is always a function and is never <tt class="calibre22">nil</tt>, whereas the value referenced by <tt class="calibre22">coll</tt> may satisfy neither condition.</p><p class="calibre18">Of course, if a collection has keys other than keywords or symbols, then you must use the collection or <tt class="calibre22">get</tt> or <tt class="calibre22">nth</tt> as the lookup function.</p><p id="filepos443204" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Collections and Keys and Higher-Order Functions</span></span></span></p><p id="filepos443341" class="calibre18">Because keywords, symbols, and many collections are functions, using them as inputs to higher-order functions is both common and incredibly convenient. Say we want all the names of our customers; no need to define any functions, and no need to explicitly use <tt class="calibre22">get</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(map :name [{:age 21 :name "David"}<br class="calibre33"/>            {:gender :f :name "Suzanne"}<br class="calibre33"/>            {:name "Sara" :location "NYC"}])<br class="calibre33"/>;= ("David" "Suzanne" "Sara")</tt></span></blockquote><p class="calibre23"><tt class="calibre22">some</tt> searches for the first value in a sequence that returns a logically true value from a provided predicate; using it in conjunction with sets is a common pattern:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(some #{1 3 7} [0 2 4 5 6])<br class="calibre33"/>;= nil<br class="calibre33"/>(some #{1 3 7} [0 2 3 4 5 6])<br class="calibre33"/>;= 3</tt></span></blockquote><p class="calibre23">This makes <tt class="calibre22">some</tt> a very concise way to use the result of searching a collection in a conditional. A more generalized operation is <tt class="calibre22">filter</tt><a id="filepos444519"></a>, which returns a lazy sequence that retains only values that are true according to a given predicate. Again, we can just use a collection or a keyword or symbol when appropriate, potentially composed with other functions as necessary:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(filter :age [{:age 21 :name "David"}<br class="calibre33"/>              {:gender :f :name "Suzanne"}<br class="calibre33"/>              {:name "Sara" :location "NYC"}])<br class="calibre33"/>;= ({:age 21, :name "David"})<br class="calibre33"/><br class="calibre33"/>(filter (comp (partial &lt;= 25) :age) [{:age 21 :name "David"}<br class="calibre33"/>                                     {:gender :f :name "Suzanne" :age 20}<br class="calibre33"/>                                     {:name "Sara" :location "NYC" :age 34}])<br class="calibre33"/>;= ({:age 34, :name "Sara", :location "NYC"})</tt></span></blockquote><p class="calibre23"><tt class="calibre22">remove</tt><a id="filepos445515"></a> is the complement to <tt class="calibre22">filter</tt>, quite literally: it is implemented by filtering the given collection with the <tt class="calibre22">complement</tt> of the given function, <tt class="calibre22">(filter (complement f) collection)</tt>.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">BEWARE OF THE NIL (AGAIN)</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">It is so simple to use sets to test whether some value belongs to a given collection that it is easy to forget that when the value in question is </span><span class="calibre10"><tt class="calibre22">nil</tt></span><a id="filepos446115"></a><span class="calibre10"> or </span><span class="calibre10"><tt class="calibre22">false</tt></span><a id="filepos446184"></a><span class="calibre10">, results may not align with our expectations because both of them are logically false:</span><a id="filepos446300"></a></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(remove #{5 7} (cons false (range 10)))<br class="calibre33"/>;= (false 0 1 2 3 4 6 8 9)<br class="calibre33"/>(remove #{5 7 false} (cons false (range 10)))<br class="calibre33"/>;= (false 0 1 2 3 4 6 8 9)</tt></span></blockquote><blockquote class="calibre35"><span class="calibre10">So, when you don’t know for sure that you’ll never have </span><span class="calibre10"><tt class="calibre22">nil</tt></span><span class="calibre10"> or </span><span class="calibre10"><tt class="calibre22">false</tt></span><span class="calibre10"> in the set you’re using as a predicate, prefer </span><span class="calibre10"><tt class="calibre22">contains?</tt></span><span class="calibre10"> over </span><span class="calibre10"><tt class="calibre22">get</tt></span><span class="calibre10"> or a direct call:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(remove (partial contains? #{5 7 false}) (cons false (range 10)))<br class="calibre33"/>;= (0 1 2 3 4 6 8 9)</tt></span></blockquote><div class="mbppagebreak"></div><p id="filepos447245" class="calibre6"><span class="calibre4"><span class="bold">Data Structure Types</span></span></p><p id="filepos447326" class="calibre18">Clojure provides a number of concrete data structures, each of which satisfy various abstractions as appropriate. We’ve already been working with these concrete implementations quite a lot—indeed, as we’d hope, their behavior and semantics are defined for the most part by the abstractions (or parts of abstractions) they participate in.</p><p class="calibre18">Here, we’ll rapidly move through some of the implementation details that separate each of the concrete data structure types, most of which have to do with their construction.</p><p id="filepos447909" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Lists</span></span></span></p><p id="filepos448004" class="calibre18">Lists are the simplest collection type in Clojure. Their primary and most typical purpose is to serve as a representation for calls in Clojure code, as we explained in <a href="#filepos53327"><span class="calibre5">Expressions, Operators, Syntax, and Precedence</span></a>; as such, you’ll use them far more as literals in your source files than you ever will at runtime in your programs.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos448454"></a><a href="#filepos472750"><span class="calibre32">95</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">Clojure lists are singly linked, but are only efficiently accessed or “modified” at their head, using <tt class="calibre22">conj</tt><a id="filepos448699"></a> to push a new head value on, or <tt class="calibre22">pop</tt><a id="filepos448751"></a> or the sequence operator <tt class="calibre22">rest</tt><a id="filepos448797"></a> to obtain a reference to the sublist without the prior head value. Because they are linked lists, they do not support efficient random access; thus, <tt class="calibre22">nth</tt><a id="filepos448966"></a> on a list will run in linear time (as opposed to constant time when used with vectors, arrays, and so on), and <tt class="calibre22">get</tt> does not support lists at all because doing so would not align with <tt class="calibre22">get</tt>’s objective of sublinear efficiency.</p><p class="calibre18">It is worth noting that lists are their own sequences; therefore, <tt class="calibre22">seq</tt><a id="filepos449327"></a> of a list will always return that list and not a separate sequential view over the list.</p><p class="calibre18">We’ve only really seen list literals before:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">'(1 2 3)<br class="calibre33"/>;= (1 2 3)</tt></span></blockquote><p class="calibre23">If we didn’t quote this list, it would be evaluated as a call of the value <tt class="calibre22">1</tt>, which would fail.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos449787"></a><a href="#filepos473204"><span class="calibre32">96</span></a><span class="calibre32">]</span></small></sup> The side effect of this is that expressions within the list literal are also not evaluated:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">'(1 2 (+ 1 2))<br class="calibre33"/>;= (1 2 (+ 1 2))</tt></span></blockquote><p class="calibre23">Most people simply use a vector literal for such cases, within which member expressions will always be evaluated. However, there are some cases where you really do need a list, and no other data structure will do.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos450382"></a><a href="#filepos473657"><span class="calibre32">97</span></a><span class="calibre32">]</span></small></sup> For those times, reach for <tt class="calibre22">list</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(list 1 2 (+ 1 2))<br class="calibre33"/>;= (1 2 3)</tt></span></blockquote><p class="calibre23"><tt class="calibre22">list</tt> accepts any number of values, where each value will become an element of the returned list.</p><p class="calibre18">Finally, you can use the <tt class="calibre22">list?</tt> predicate to test if a value is specifically a list.</p><p id="filepos450909" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Vectors</span></span></span></p><p id="filepos451006" class="calibre18">Vectors are a sequential data structure that supports efficient random access lookup and alteration that will match the expectations of programmers used to <tt class="calibre22">java.util.ArrayList</tt><a id="filepos451218"></a>, Python’s lists, and Ruby’s arrays. Vectors are also particularly versatile, participating in the associative, indexed, and stack abstractions as we’ve seen.</p><p class="calibre18">Aside from now-familiar vector literals, vectors can be created using <tt class="calibre22">vector</tt> and <tt class="calibre22">vec</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(vector 1 2 3)<br class="calibre33"/>;= [1 2 3]<br class="calibre33"/>(vec (range 5))<br class="calibre33"/>;= [0 1 2 3 4]</tt></span></blockquote><p class="calibre23"><tt class="calibre22">vector</tt><a id="filepos451745"></a> is the analog to <tt class="calibre22">list</tt>, whereas <tt class="calibre22">vec</tt> expects only a single sequential argument whose entire contents will be used to create the new vector. This is useful when you have some data in an array, list, sequence, or other <tt class="calibre22">seq</tt>able value, but further manipulation of that data needs to benefit from a vector’s capabilities.</p><p class="calibre18"><tt class="calibre22">vector?</tt><a id="filepos452144"></a> is the predictable analog to <tt class="calibre22">list?</tt>, used for testing whether a value is a vector.</p><p id="filepos452246" class="calibre23"><span class="calibre53"><span class="bold">Vectors as tuples</span></span></p><p id="filepos452324" class="calibre18">Tuples are one of the most common use cases for vectors. Any time several values should be batched together with as little ceremony as possible—like when returning multiple values from a function—they can be put into a vector:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn euclidian-division   </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  [x y]<br class="calibre33"/>  [(quot x y) (rem x y)])<br class="calibre33"/><br class="calibre33"/>(euclidian-division 42 8)<br class="calibre33"/>;= [5 2]</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Just in case you’re golfing for concision, <tt class="calibre22">(juxt quot rem)</tt> returns a function that is equivalent to this one.</blockquote><p class="calibre18">This pairs nicely with Clojure’s pervasive destructuring mechanism (see <a href="#filepos137243"><span class="calibre5">Destructuring (let, Part 2)</span></a>), allowing us to easily unpack such return values into their constituents:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [[q r] (euclidian-division 53 7)]<br class="calibre33"/>  (str "53/7 = " q " * 7 + " r))<br class="calibre33"/>;= "53/7 = 7 * 7 + 4"</tt></span></blockquote><p class="calibre23">As tempting and easy as tuples are, you should not forget that they are an expeditive mean to an end: they are best kept hidden in your libraries’ and modules’ internals rather than exposed as part of a public API. The rationale behind this is twofold:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Tuples are not self-documenting. You have to consistently recall the respective roles of each index.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Tuples are inflexible. You have to provide values even in middle slots that aren’t appropriate for a particular return value and you can’t extend a tuple in ways other than appending to its tail.</blockquote></li></ul><p class="calibre18">Maps don’t suffer from those two limitations; thus, for functions that are part of a public API and for nontrivial return values, maps are a better fit.</p><p class="calibre18">Of course, as with any rule, this one has exceptions. In places where the purpose of a tuple is obvious for the domain at hand—coordinates, oriented edges in graphs, and so on—using vectors as tuples is entirely appropriate:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def point-3d [42 26 -7])<br class="calibre33"/><br class="calibre33"/>(def travel-legs [["LYS" "FRA"] ["FRA" "PHL"] ["PHL" "RDU"]])</tt></span></blockquote><p class="calibre23">In the latter case above, note that we have two different usages of vectors: the outer vector is just a better list, while the inner vectors are acting as tuples of airport trigrams, <tt class="calibre22">[from to]</tt>.</p><p id="filepos455372" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Sets</span></span></span></p><p id="filepos455466" class="calibre18">There is little to say about sets as a concrete data structure implementation that we’ve not touched on already when discussing the associative and set abstractions. Like Clojure’s other data structure types, sets have a literal notation we’ve seen already:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">#{1 2 3}<br class="calibre33"/>;= #{1 2 3}<br class="calibre33"/>#{1 2 3 3}   </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #&lt;IllegalArgumentException java.lang.IllegalArgumentException:<br class="calibre33"/>;=   Duplicate key: 3&gt;</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Since sets by definition cannot contain duplicate values, literals including duplicate values will be rejected.</blockquote><p class="calibre18">And the <tt class="calibre22">hash-set</tt><a id="filepos456442"></a> function is available to create unsorted sets from any number of arguments:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(hash-set :a :b :c :d)<br class="calibre33"/>;= #{:a :c :b :d}</tt></span></blockquote><p class="calibre23">Finally, you can create a set from the values in any collection by using the <tt class="calibre22">set</tt><a id="filepos456783"></a> function:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(set [1 6 1 8 3 7 7])<br class="calibre33"/>;= #{1 3 6 7 8}</tt></span></blockquote><p class="calibre23">This actually works with anything that is <tt class="calibre22">seq</tt>able, and allows for some very succinct idioms given that sets are functions themselves:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(apply str (remove (set "aeiouy") "vowels are useless"))<br class="calibre33"/>;= "vwls r slss"<br class="calibre33"/><br class="calibre33"/>(defn numeric? [s] (every? (set "0123456789") s))<br class="calibre33"/>;= #'user/numeric?<br class="calibre33"/>(numeric? "123")<br class="calibre33"/>;= true<br class="calibre33"/>(numeric? "42b")<br class="calibre33"/>;= false</tt></span></blockquote><p class="calibre23">Sorted set variants are also available, as we saw in <a href="#filepos407075"><span class="calibre5">Sorted</span></a>.</p><p id="filepos457623" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Maps</span></span></span></p><p id="filepos457717" class="calibre18">Aside from the now-familiar map literal:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">{:a 5 :b 6}<br class="calibre33"/>;= {:a 5, :b 6}<br class="calibre33"/>{:a 5 :a 5}                                                 </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #&lt;IllegalArgumentException java.lang.IllegalArgumentException:<br class="calibre33"/>;=   Duplicate key: :a&gt;</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">As with values in sets, keys in maps must be unique; literals that violate this requirement are rejected.</blockquote><p class="calibre18">unsorted maps can be created using <tt class="calibre22">hash-map</tt><a id="filepos458594"></a>, which accepts any number of key/value pairs. This is most often used in conjunction with <tt class="calibre22">apply</tt> when you have a collection of key/value pairs that are not themselves grouped into vector tuples:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(hash-map :a 5 :b 6)<br class="calibre33"/>;= {:a 5, :b 6}<br class="calibre33"/>(apply hash-map [:a 5 :b 6])<br class="calibre33"/>;= {:a 5, :b 6}</tt></span></blockquote><p class="calibre23">Sorted map variants are also available, as we saw in <a href="#filepos407075"><span class="calibre5">Sorted</span></a>.</p><p class="calibre18"><span class="bold">keys and vals</span>. <a id="filepos459209"></a>Though specific to maps, these functions are handy shortcuts that return a sequence of keys or values from a source map:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(keys m)<br class="calibre33"/>;= (:a :b :c)<br class="calibre33"/>(vals m)<br class="calibre33"/>;= (1 2 3)</tt></span></blockquote><p class="calibre23">They are fundamentally just shortcuts for using <tt class="calibre22">seq</tt> on a map to obtain its sequence of entries, and then obtaining the <tt class="calibre22">key</tt> or <tt class="calibre22">val</tt> from each entry:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(map key m)<br class="calibre33"/>;= (:a :c :b)<br class="calibre33"/>(map val m)<br class="calibre33"/>;= (1 3 2)</tt></span></blockquote><p id="filepos459863" class="calibre23"><span class="calibre53"><span class="bold">Maps as ad-hoc structs</span></span></p><p id="filepos459946" class="calibre18">Since map values can be of any type, they are frequently used as simple, flexible models, most often with keywords for keys to identify each field (also called <span class="italic">slots</span><a id="filepos460146"></a>).</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def playlist<br class="calibre33"/>  [{:title "Elephant", :artist "The White Stripes", :year 2003}<br class="calibre33"/>   {:title "Helioself", :artist "Papas Fritas", :year 1997}<br class="calibre33"/>   {:title "Stories from the City, Stories from the Sea",<br class="calibre33"/>    :artist "PJ Harvey", :year 2000}<br class="calibre33"/>   {:title "Buildings and Grounds", :artist "Papas Fritas", :year 2000}<br class="calibre33"/>   {:title "Zen Rodeo", :artist "Mardi Gras BB", :year 2002}])</tt></span></blockquote><p class="calibre23">It is very common for data modeling in Clojure to start with simple maps. Especially when you aren’t sure of what slots your entities will consist of, maps allow you to get to work right away without having to predefine a rigid data model.</p><p class="calibre18">Once you are using maps (and other data structures that participate in Clojure’s abstractions) for your model, all of their capabilities flow into any work you do with it. For example, assuming you’re using keywords as keys, “querying” data aggregates becomes trivial:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(map :title playlist)<br class="calibre33"/>;= ("Elephant" "Helioself" "Stories from the City, Stories from the Sea"<br class="calibre33"/>;=  "Buildings and Grounds" "Zen Rodeo")</tt></span></blockquote><p class="calibre23">Similarly, things like associative destructuring, introduced in <a href="#filepos148997"><span class="calibre5">Map destructuring</span></a>, can help simplify operations on individual map “structs,” eliminating more verbose <tt class="calibre22">(:slot data)</tt> accesses:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn summarize [{:keys [title artist year]}]<br class="calibre33"/>  (str title " / " artist " / " year))</tt></span></blockquote><p class="calibre23">Clojure tries to save you from premature over-architecting by offering a clear upgrade path—if you need it—from prototyping using map-based “structs” to a more mature model. Thus, modeling with maps is not a dead end. Rather, as long as you program to Clojure’s collection abstractions instead of any particular implementation (the latter being something you really need to go out of your way to do), you’ll be able to cleanly swap out a map-based model for a specialized type—like one defined by <tt class="calibre22">defrecord</tt>, which always produces associative types.</p><p class="calibre18">We’ll discuss <tt class="calibre22">defrecord</tt> in detail in <a href="#filepos967758"><span class="calibre5">Defining Your Own Types</span></a>, and compare them with maps in <a href="#filepos993043"><span class="calibre5">When to use maps or records</span></a>.</p><p id="filepos462899" class="calibre23"><span class="calibre53"><span class="bold">Other usages of maps</span></span></p><p class="calibre18">Maps are also often used as summaries, indexes, or translation tables; think here of database indexes and views.</p><p class="calibre18">For example, <tt class="calibre22">group-by</tt><a id="filepos463182"></a> is very useful to partition a collection according to a key function:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(group-by #(rem % 3) (range 10))<br class="calibre33"/>;= {0 [0 3 6 9], 1 [1 4 7], 2 [2 5 8]}</tt></span></blockquote><p class="calibre23">Here we see numbers grouped together under keys defined by the provided function. Following on with our playlist data, we can easily create an index on albums by artist:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(group-by :artist playlist)<br class="calibre33"/>;= {"Papas Fritas" [{:title "Helioself", :artist "Papas Fritas", :year 1997}<br class="calibre33"/>;=                  {:title "Buildings and Grounds", :artist "Papas Fritas"}]<br class="calibre33"/>;=  ...}</tt></span></blockquote><p class="calibre23">Indexing on two “columns” is as easy as <tt class="calibre22">(group-by (juxt :col1 :col2) data)</tt>.</p><p class="calibre18">Sometimes you just want to compute a summary of items for a given key rather than returning a vector of those items. You could use <tt class="calibre22">group-by</tt> and then process each value to summarize it:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(into {} (for [[k v] (group-by key-fn coll)]<br class="calibre33"/>           [k (summarize v)]))</tt></span></blockquote><p class="calibre23">…where <tt class="calibre22">key-fn</tt> and <tt class="calibre22">summarize</tt> are placeholders for your actual functions. However, this can become cumbersome if your collections are particularly large, as when dealing with large result sets from a database query. In this case, you have to resort to your own mix of <tt class="calibre22">group-by</tt> and <tt class="calibre22">reduce</tt>. <tt class="calibre22">reduce-by</tt> will help to compute all kinds of summaries on data, not unlike a <tt class="calibre22">SELECT ... GROUP BY ...</tt> query in SQL:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn reduce-by<br class="calibre33"/>  [key-fn f init coll]<br class="calibre33"/>  (reduce (fn [summaries x]<br class="calibre33"/>            (let [k (key-fn x)]<br class="calibre33"/>              (assoc summaries k (f (summaries k init) x))))<br class="calibre33"/>    {} coll))</tt></span></blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">X, XS, AND OTHER NOT-SO-CRYPTIC NAMES</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Newcomers to Clojure often find the usage of very brief names like </span><span class="calibre10"><tt class="calibre22">x</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">xs</tt></span><span class="calibre10"> confusing. The meaning of each letter is partly codified by the Library Coding Standards style guide (</span><a id="filepos465839"></a><a href="http://dev.clojure.org/display/design/Library+Coding+Standards"><span class="calibre10"><span class="calibre5">http://dev.clojure.org/display/design/Library+Coding+Standards</span></span></a><span class="calibre10">). In essence, when you use the name </span><span class="calibre10"><tt class="calibre22">x</tt></span><span class="calibre10">, you are saying that your code is generic and oblivious to </span><span class="calibre10"><tt class="calibre22">x</tt></span><span class="calibre10">’s type, so there’s no point in calling it </span><span class="calibre10"><tt class="calibre22">invoice</tt></span><span class="calibre10">. Likewise, a collection or sequence of </span><span class="calibre10"><tt class="calibre22">x</tt></span><span class="calibre10"> values is often named </span><span class="calibre10"><tt class="calibre22">xs</tt></span><span class="calibre10">, and so on. </span><span class="calibre10"><span class="italic">The more generic your code is, the less specific the names you use are going to be.</span></span></blockquote><p class="calibre25">Let’s assume we have a list of purchase orders to ACME Corp, represented using plain maps as “structs”:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def orders<br class="calibre33"/>  [{:product "Clock", :customer "Wile Coyote", :qty 6, :total 300}<br class="calibre33"/>   {:product "Dynamite", :customer "Wile Coyote", :qty 20, :total 5000}<br class="calibre33"/>   {:product "Shotgun", :customer "Elmer Fudd", :qty 2, :total 800}<br class="calibre33"/>   {:product "Shells", :customer "Elmer Fudd", :qty 4, :total 100}<br class="calibre33"/>   {:product "Hole", :customer "Wile Coyote", :qty 1, :total 1000}<br class="calibre33"/>   {:product "Anvil", :customer "Elmer Fudd", :qty 2, :total 300}<br class="calibre33"/>   {:product "Anvil", :customer "Wile Coyote", :qty 6, :total 900}])</tt></span></blockquote><p class="calibre23">With <tt class="calibre22">reduce-by</tt>, we can easily compute order totals by customer:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(reduce-by :customer #(+ %1 (:total %2)) 0 orders)<br class="calibre33"/>;= {"Elmer Fudd" 1200, "Wile Coyote" 7200}</tt></span></blockquote><p class="calibre23">Likewise, you can get the customers for each product:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(reduce-by :product #(conj %1 (:customer %2)) #{} orders)<br class="calibre33"/>;= {"Anvil" #{"Wile Coyote" "Elmer Fudd"},<br class="calibre33"/>;=  "Hole" #{"Wile Coyote"},<br class="calibre33"/>;=  "Shells" #{"Elmer Fudd"},<br class="calibre33"/>;=  "Shotgun" #{"Elmer Fudd"},<br class="calibre33"/>;=  "Dynamite" #{"Wile Coyote"},<br class="calibre33"/>;=  "Clock" #{"Wile Coyote"}}</tt></span></blockquote><p class="calibre23">What if you want a two-level breakup, say, all orders by customer, and then by product? You simply need to return a vector of the two values as the key. There are several ways to write such a function:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(fn [order]<br class="calibre33"/>  [(:customer order) (:product order)])<br class="calibre33"/><br class="calibre33"/>#(vector (:customer %) (:product %))<br class="calibre33"/><br class="calibre33"/>(fn [{:keys [customer product]}]<br class="calibre33"/>  [customer product])<br class="calibre33"/><br class="calibre33"/>(juxt :customer :product)</tt></span></blockquote><p class="calibre23">We’ll prefer the most clear and succinct one:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(reduce-by (juxt :customer :product)<br class="calibre33"/>  #(+ %1 (:total %2)) 0 orders)<br class="calibre33"/>;= {["Wile Coyote" "Anvil"] 900,<br class="calibre33"/>;=  ["Elmer Fudd" "Anvil"] 300,<br class="calibre33"/>;=  ["Wile Coyote" "Hole"] 1000,<br class="calibre33"/>;=  ["Elmer Fudd" "Shells"] 100,<br class="calibre33"/>;=  ["Elmer Fudd" "Shotgun"] 800,<br class="calibre33"/>;=  ["Wile Coyote" "Dynamite"] 5000,<br class="calibre33"/>;=  ["Wile Coyote" "Clock"] 300}</tt></span></blockquote><p class="calibre23">Not quite what we were expecting—we don’t have a map of maps. This problem boils down to <tt class="calibre22">reduce-by</tt> assuming that the map is shallow. You can either “fix” <tt class="calibre22">reduce-by</tt> by creating a version for nested maps, or you can massage your result map.</p><p class="calibre18">Making <tt class="calibre22">reduce-by</tt><a id="filepos469808"></a> work with nested maps <a id="filepos469838"></a>is as easy as replacing calls to <tt class="calibre22">assoc</tt> and the implicit <tt class="calibre22">get</tt> (when the map is used as a function) with <tt class="calibre22">assoc-in</tt> and <tt class="calibre22">get-in</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn reduce-by-in<br class="calibre33"/>  [keys-fn f init coll]<br class="calibre33"/>  (reduce (fn [summaries x]<br class="calibre33"/>            (let [ks (keys-fn x)]<br class="calibre33"/>              (assoc-in summaries ks<br class="calibre33"/>                (f (get-in summaries ks init) x))))<br class="calibre33"/>    {} coll))</tt></span></blockquote><p class="calibre23">As expected, we now get a two-level breakup:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(reduce-by-in (juxt :customer :product)<br class="calibre33"/>  #(+ %1 (:total %2)) 0 orders)<br class="calibre33"/>;= {"Elmer Fudd" {"Anvil" 300,<br class="calibre33"/>;=                "Shells" 100,<br class="calibre33"/>;=                "Shotgun" 800},<br class="calibre33"/>;=  "Wile Coyote" {"Anvil" 900,<br class="calibre33"/>;=                 "Hole" 1000,<br class="calibre33"/>;=                 "Dynamite" 5000,<br class="calibre33"/>;=                 "Clock" 300}}</tt></span></blockquote><p class="calibre23">The second option is to transform our previous result data:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def flat-breakup<br class="calibre33"/>  {["Wile Coyote" "Anvil"] 900,<br class="calibre33"/>   ["Elmer Fudd" "Anvil"] 300,<br class="calibre33"/>   ["Wile Coyote" "Hole"] 1000,<br class="calibre33"/>   ["Elmer Fudd" "Shells"] 100,<br class="calibre33"/>   ["Elmer Fudd" "Shotgun"] 800,<br class="calibre33"/>   ["Wile Coyote" "Dynamite"] 5000,<br class="calibre33"/>   ["Wile Coyote" "Clock"] 300})</tt></span></blockquote><p class="calibre23">…into the expected map of maps. To do so, we are also going to use <tt class="calibre22">assoc-in</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(reduce #(apply assoc-in %1 %2) {} flat-breakup)<br class="calibre33"/>;= {"Elmer Fudd" {"Shells" 100,<br class="calibre33"/>;=                "Anvil" 300,<br class="calibre33"/>;=                "Shotgun" 800},<br class="calibre33"/>;=  "Wile Coyote" {"Hole" 1000,<br class="calibre33"/>;=                 "Dynamite" 5000,<br class="calibre33"/>;=                 "Clock" 300,<br class="calibre33"/>;=                 "Anvil" 900}}</tt></span></blockquote><p class="calibre23">Each value in the seq provided by the <tt class="calibre22">flat-breakup</tt> map is a map entry like <tt class="calibre22">[["Wile Coyote" "Anvil"] 900]</tt>. Thus, when our reduction function uses <tt class="calibre22">apply</tt> with each of these map entries, the resulting call to <tt class="calibre22">assoc-in</tt>—e.g., <tt class="calibre22">(assoc-in {} ["Wile Coyote" "Anvil"] 900)</tt>—conveniently uses the data in each entry to define both the structure of the resulting map and its deepest values.<a id="filepos472646"></a></p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos472750"></a><a href="#filepos448454"><span class="calibre32">95</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">This is a departure from prior Lisps, where lists and cons cells play a central role. Clojure’s use of richer composites—like maps, sets, vectors, and the list’s abstract cousin, the sequence—markedly diminish the cases for which lists are themselves applicable.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos473204"></a><a href="#filepos449787"><span class="calibre32">96</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Note that an </span><span class="calibre10"><span class="italic">empty</span></span><span class="calibre10"> list does not need to be quoted, since there is no first item that could be construed as a callable value. Thus, </span><span class="calibre10"><tt class="calibre22">()</tt></span><span class="calibre10"> is a valid empty list literal.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos473657"></a><a href="#filepos450382"><span class="calibre32">97</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">The most common such cases are when writing macros; see </span><a href="#filepos831506"><span class="calibre10"><span class="calibre5">Chapter 5</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos473960" class="calibre6"><span class="calibre4"><span class="bold">Immutability and Persistence</span></span></p><p id="filepos474049" class="calibre18">We’ve now gone through much of the nuts and bolts of Clojure’s collections and surveyed many of their abstractions. What we haven’t yet emphasized and explored are two characteristics that are shared by all of Clojure’s data structures: they are <span class="italic">immutable</span>, and they are <span class="italic">persistent</span>.</p><p class="calibre18">We explored the notion of immutability in <a href="#filepos215673"><span class="calibre5">Chapter 2</span></a> and learned how the value semantics provided by working with immutable entities can be a great simplifying force. However, you might have some lingering concerns. For example, consider this operation over numbers:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(+ 1 2)<br class="calibre33"/>;= 3</tt></span></blockquote><p class="calibre23"><tt class="calibre22">3</tt> here is a value entirely separate from the arguments to <tt class="calibre22">+</tt>. Certainly, the act of adding numbers doesn’t modify one of the addends to make it <span class="italic">be</span> another number. This is in stark contrast to how most data structures work in languages that encourage unfettered mutation, like Python here:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">&gt;&gt;&gt; lst = []<br class="calibre33"/>&gt;&gt;&gt; lst.append(0)<br class="calibre33"/>&gt;&gt;&gt; lst<br class="calibre33"/>[0]</tt></span></blockquote><p class="calibre23"><tt class="calibre22">append</tt> really did modify <tt class="calibre22">lst</tt>. That has many implications, not necessary all pleasant, but you can be certain that such operations are <span class="italic">efficient</span>, almost regardless of the size of the collection in question. On the other hand, this looks like it might be problematic:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def v (vec (range 1e6)))  </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #'user/v<br class="calibre33"/>(count v)<br class="calibre33"/>;= 1000000<br class="calibre33"/>(def v2 (conj v 1e6))      </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #'user/v2<br class="calibre33"/>(count v2)<br class="calibre33"/>;= 1000001<br class="calibre33"/>(count v)                  </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= 1000000</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Start with a vector, containing the range of all integers from <tt class="calibre22">0</tt> through <tt class="calibre22">1e6</tt>: a million elements, a reasonably sized collection.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">Using <tt class="calibre22">conj</tt>, append an integer to the vector, which now has 1,000,001 items in it.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">As we’ve said though, all of Clojure’s data structures are immutable, so <tt class="calibre22">v</tt> is not changed.</blockquote><p class="calibre18"><tt class="calibre22">v2</tt> here is a whole separate data structure. You might say, “Surely that isn’t efficient: it looks like <tt class="calibre22">conj</tt> (and maybe every other operation on Clojure data structures) creates a <span class="italic">full copy</span> of the collection it’s <span class="italic">modifying</span>!”</p><p class="calibre18">Thankfully, that is not the case.</p><p id="filepos477515" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Persistence and Structural Sharing</span></span></span></p><p id="filepos477639" class="calibre18">Operations over Clojure’s immutable data structures<a id="filepos477720"></a>
<span class="italic">are</span> efficient; often as fast as the equivalent operations in Java. This is because the data structures are <span class="italic">persistent</span>, an implementation technique where collections reuse internal structure to minimize the number of operations needed to represent altered versions of an instance of a collection while ensuring that all versions of a collection will maintain the same efficiency guarantees.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">THE SEMANTICS OF “PERSISTENCE”</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Clearly, we’re not talking about “persistence” as it applies to the serialization and storage of data, objects, and so on. The notion under consideration here is rooted in Okasaki’s </span><a href="http://www.amazon.com/dp/0521663504"><span class="calibre10"><span class="italic"><span class="calibre5">Purely Functional Data Structures</span></span></span></a><span class="calibre10">, where he describes techniques that allow the performance guarantees of immutable data structures to </span><span class="calibre10"><span class="italic">persist</span></span><span class="calibre10"> in later versions of those collections produced by various operations.</span></blockquote><blockquote class="calibre17"><span class="calibre10"><span class="italic">Purely Functional Data Structures</span></span><span class="calibre10"> is a seminal work in functional programming, and the designs of Clojure and many other current functional programming languages owe a great deal to its foundational vision. Those interested in deepening their understanding of functional programming as it intersects with data structures should consider it required reading.</span></blockquote><p class="calibre25">To achieve persistence without sacrificing performance, Clojure’s data structures implement <span class="italic">structural sharing</span>. That is, they never perform deep copies to satisfy an operation; rather, only the portions of the data structure affected by a change are swapped out, while references are retained to those parts that are uninvolved.</p><p id="filepos479774" class="calibre23"><span class="calibre53"><span class="bold">Visualizing persistence: lists</span></span></p><p id="filepos479865" class="calibre18">The simplest example of this dynamic in play involves operations over lists. Consider this list:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def a (list 1 2 3))</tt></span></blockquote><p class="calibre23">Recalling that Clojure lists are linked lists, we can visualize this like so:</p><p class="calibre51"><img src="images/00053.jpg" class="calibre67"/></p><p class="calibre13">Let’s <tt class="calibre22">conj</tt><a id="filepos480373"></a> a new value onto the list, remembering that <tt class="calibre22">conj</tt> always prepends to lists:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def b (conj a 0))<br class="calibre33"/>;= #'user/b<br class="calibre33"/>b<br class="calibre33"/>;= (0 1 2 3)</tt></span></blockquote><p class="calibre23">We can visualize this operation:</p><p class="calibre51"><img src="images/00056.jpg" class="calibre68"/></p><p class="calibre13"><tt class="calibre22">conj</tt>
<span class="italic">does</span> create a new list with <tt class="calibre22">0</tt> as the first value, but it reuses the entirety of <tt class="calibre22">a</tt> to form the new list’s tail. Clearly, this is an efficient operation:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">There is no copying of data.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">The original list <tt class="calibre22">a</tt> remains as-is and can be accessed and used as the basis of other lists as needed.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">The new list <tt class="calibre22">b</tt> shares the structure of <tt class="calibre22">a</tt>, with the addition of a single value.</blockquote></li></ul><p class="calibre18">As we said earlier, part of the contract of <tt class="calibre22">conj</tt> is that it operates in constant time: conjoining a value onto a collection of three elements should take the same amount of time as the same operation on a collection of a million elements, and that is certainly true in the case of lists. Thus, the characteristics of <tt class="calibre22">a</tt>
<span class="italic">persist</span> on to a later version of it, the list <tt class="calibre22">b</tt>.</p><p class="calibre18">What about other operations? Clojure lists aren’t random access (just like all other linked lists), so we know we can’t use, for example, <tt class="calibre22">nth</tt> to obtain a value within a list in anything better than linear time. However, we can pop the head off of lists efficiently:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def c (rest a))<br class="calibre33"/>;= #'user/c<br class="calibre33"/>c<br class="calibre33"/>;= (2 3)</tt></span></blockquote><p class="calibre69"><img src="images/00058.jpg" class="calibre70"/></p><p class="calibre13"><tt class="calibre22">rest</tt><a id="filepos482644"></a> on a list is similarly a constant-time operation, thanks to the data structure ensuring that it shares structure however possible across versions. <tt class="calibre22">rest<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos482842"></a><a href="#filepos508923"><span class="calibre32">98</span></a><span class="calibre32">]</span></small></sup></tt> will return that list’s tail in the same time, regardless of the size of the list in question, and the result continues to maintain the same guarantees for future operations.</p><p id="filepos483122" class="calibre23"><span class="calibre53"><span class="bold">Visualizing persistence: maps (and vectors and sets)</span></span></p><p id="filepos483235" class="calibre18">So operations on a linked list can be made efficient. What about the data structures that carry the load of most of the work in Clojure programming? Maps, vectors, and sets all share the same fundamental implementation strategy,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos483526"></a><a href="#filepos509203"><span class="calibre32">99</span></a><span class="calibre32">]</span></small></sup> even though their internal structure is considerably more involved than that of lists.</p><p class="calibre18">For the sake of our example, let’s look at a map:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def a {:a 5 :b 6 :c 7 :d 8})</tt></span></blockquote><blockquote class="calibre47"></blockquote><blockquote class="calibre39"><img src="images/00060.jpg" class="calibre71"/></blockquote><blockquote class="calibre57"><span class="calibre10"><span class="italic"><span class="calibre7">Figure 3-1. The internal structure of the map {:a 5 :b 6 :c 7 :d 8}<sup class="calibre58"><small class="calibre31"><span class="calibre32"><span class="italic"><span class="calibre7">[</span></span></span><a id="filepos484339"></a><a href="#filepos509702"><span class="calibre32"><span class="italic"><span class="calibre7">100</span></span></span></a><span class="calibre32"><span class="italic"><span class="calibre7">]</span></span></span></small></sup></span></span></span></blockquote><p class="calibre50">Like most maps, Clojure’s is implemented as a tree structure, with values in the map stored in the tree’s leaves.</p><p class="calibre18">Let’s update our map:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def b (assoc a :c 0))<br class="calibre33"/>;= #'user/b<br class="calibre33"/>b<br class="calibre33"/>;= {:a 5, :c 0, :b 6, :d 8}</tt></span></blockquote><blockquote class="calibre47"></blockquote><blockquote class="calibre39"><img src="images/00062.jpg" class="calibre72"/></blockquote><blockquote class="calibre57"><span class="calibre10"><span class="italic"><span class="calibre7">Figure 3-2. Effect of (assoc a :c 0)</span></span></span></blockquote><p class="calibre50">More so than in the example where we added a value to a list using <tt class="calibre22">conj</tt>, you can see that the map produced by <tt class="calibre22">assoc</tt><a id="filepos485439"></a> shares a great deal of structure with the prior version of that map. The entire subtree that contains the entries for <tt class="calibre22">:a</tt>, <tt class="calibre22">:b</tt>, and <tt class="calibre22">:d</tt> is reused in its entirety without modification, and the only allocations required are for the leaf associated with the change and the internal nodes that lead back up to the new tree’s root.</p><p class="calibre18">Removing an entry from the map has much the same result in terms of the structural sharing in play:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def c (dissoc a :d))<br class="calibre33"/>;= #'user/c<br class="calibre33"/>c<br class="calibre33"/>;= {:a 5, :c 7, :b 6}</tt></span></blockquote><blockquote class="calibre47"></blockquote><blockquote class="calibre39"><img src="images/00065.jpg" class="calibre73"/></blockquote><blockquote class="calibre57"><span class="calibre10"><span class="italic"><span class="calibre7">Figure 3-3. Effect of (dissoc a :d)</span></span></span></blockquote><p class="calibre50">Again, much of the tree’s structure is not impacted by the change, so the new tree shares most of its structure with its basis.</p><blockquote class="calibre38"></blockquote><blockquote class="calibre39"><span class="calibre10"><span class="bold">A FOREST OF TREES</span></span></blockquote><blockquote id="filepos486787" class="calibre17"><span class="calibre10">To provide persistent semantics, nearly all of Clojure’s data structures are implemented as trees, including hash maps and sets, sorted maps and sets, and vectors. The specific tree structure that is used varies significantly though: hash maps use a persistent variant of hash array mapped tries,<sup class="calibre58"><small class="calibre31"><span class="calibre32">[</span><a id="filepos487172"></a><a href="#filepos510141"><span class="calibre32">101</span></a><span class="calibre32">]</span></small></sup> vectors use a further variant called an array mapped hash trie,<sup class="calibre58"><small class="calibre31"><span class="calibre32">[</span><a id="filepos487366"></a><a href="#filepos510750"><span class="calibre32">102</span></a><span class="calibre32">]</span></small></sup> while sets are built on top of hash maps and sorted sets and sorted maps use a persistent variant of red-black trees so as to guarantee sort order efficiently.</span></blockquote><blockquote class="calibre17"><span class="calibre10">In all of these cases, Clojure’s tree implementations are such that operations you would expect to be fast (e.g., appending to a vector, adding to a set, establishing a new association in a map, and performing lookups across all collections) </span><span class="calibre10"><span class="italic">are</span></span><span class="calibre10"> fast. In “big-O” terms, these operations are either O(log<sub class="calibre74"><small class="calibre31"><span class="calibre32">32</span></small></sub> n) (for unsorted collections) or O(log<sub class="calibre74"><small class="calibre31"><span class="calibre32">2</span></small></sub> n) (for sorted collections), where </span><span class="calibre10"><tt class="calibre22">n</tt></span><span class="calibre10"> is the number of values in the collection. The upshot? Operations over immutable data structures that are as fast or nearly as fast as the analogous operations performed over mutable collections, while ensuring all of the beneficial semantics we’ve talked about that only immutable values can provide.</span></blockquote><blockquote class="calibre17"><span class="calibre10">Interestingly, many systems are emerging that utilize the same implementation strategy of using immutable, persistent trees. Aside from Clojure, other examples include Git and CouchDB. A high-level overview of the similarities involved can be found at </span><a href="http://eclipsesource.com/blogs/2009/12/13/persistent-trees-in-git-clojure-and-couchdb-data-structure-convergence"><span class="calibre10"><span class="calibre5">http://eclipsesource.com/blogs/2009/12/13/persistent-trees-in-git-clojure-and-couchdb-data-structure-convergence</span></span></a><span class="calibre10">.</span></blockquote><p id="filepos489242" class="calibre75"><span class="calibre53"><span class="bold">Tangible benefits</span></span></p><p id="filepos489321" class="calibre18">While this might have seemed like a diversion into the implementation details of Clojure’s data structures (as appealing and interesting as that may be), there are some distinct tangible benefits that you enjoy <span class="italic">because of</span> the fact they are persistent and immutable. We already detailed in <a href="#filepos215673"><span class="calibre5">Chapter 2</span></a> how working with immutable values can be a powerful simplifying force, eliminating entire categories of bugs and unintended consequences that can crop up when unfettered mutable data structures are in play. There’s more, though.</p><p class="calibre18"><span class="bold">Enabling concurrency</span>. Clojure’s reference types—explored<a id="filepos490043"></a> in <a href="#filepos636143"><span class="calibre5">Clojure Reference Types</span></a>—would not exist as they do if there were no useful, efficient, immutable values for them to hold. Insofar as those reference types define the semantics of change over time for a particular identified piece of data, it would be pointless to store mutable data structures in them. At any time, some other code could potentially be making changes to such mutable collections, thereby undermining the purpose of the reference types and again putting the onus on you to ensure correctness in your systems in the face of concurrent access and modification.</p><p class="calibre18"><span class="bold">Free versioning</span>. <a id="filepos490742"></a>One requirement in many systems is the need to keep and refer to multiple versions of some data. This can be challenging to implement and represent if your data structures are mutable. How do you make a copy of some data so future modifications can’t affect it? How do you reasonably roll back to some prior state?</p><p class="calibre18">Immutable collections make answering these questions easy:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def version1 {:name "Chas" :info {:age 31}})<br class="calibre33"/>;= #'user/version1<br class="calibre33"/>(def version2 (update-in version1 [:info :age] + 3))  </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #'user/version2<br class="calibre33"/>version1<br class="calibre33"/>;= {:info {:age 31}, :name "Chas"}<br class="calibre33"/>version2<br class="calibre33"/>;= {:info {:age 34}, :name "Chas"}</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">update-in</tt> updates the value (identified by the vector argument) located in the (potentially nested) associative structure by applying the given function (<tt class="calibre22">+</tt> here) to it and any additional arguments (<tt class="calibre22">3</tt> here).</blockquote><p class="calibre18">Each “update” to a Clojure collection leaves that collection in its original state, and provides the new version. Each can be used, modified, and stored however your application needs; but, you never have to strain yourself to do the housekeeping around the production of such useful versioned data, because that naturally falls out of the collections’ implementation for free.<a id="filepos492450"></a></p><p id="filepos492461" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Transients</span></span></span></p><p class="calibre18"><span class="italic">Transient</span><a id="filepos492605"></a> collections are the dual to those that are persistent: while persistent collections make guarantees about the integrity of prior revisions of a value, transient collections do not. After modification, any reference to an old revision of a transient collection cannot be relied upon; it may be valid, it may be the new value, or it may be garbage.</p><p class="calibre18">This may seem like a foolish notion, but it is born of an adaptation of an age-old notion: <span class="italic">if a data structure is mutated, and no one sees it happen, does that mutation hurt anyone?</span></p><p class="calibre18">In stark contrast to nearly everything else in Clojure, <span class="italic">transient collections are mutable</span>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def x (transient []))  </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #'user/x<br class="calibre33"/>(def y (conj! x 1))     </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #'user/y<br class="calibre33"/>(count y)               </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= 1<br class="calibre33"/>(count x)               </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= 1</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">We create a transient vector using a persistent vector as a basis.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">A single value is added to the transient vector using <tt class="calibre22">conj!</tt>, the transient analog to <tt class="calibre22">conj</tt>…</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">…which unsurprisingly returns a new reference to a transient vector containing that one value. However…</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">…our old transient vector reflects that change as well!<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos495022"></a><a href="#filepos511345"><span class="calibre32">103</span></a><span class="calibre32">]</span></small></sup></blockquote><p class="calibre18">So, given everything we’ve said so far, why would transients ever be a good idea? Clojure’s persistent data structures possess a number of <span class="italic">very</span> attractive characteristics, and for what they deliver, they are <span class="italic">very</span> fast<a id="filepos495393"></a>. However, there are some inescapable realities about them that cannot be ignored: chiefly, that the semantic guarantees of persistent data structures require allocation on every update, something that does carry some overhead. However marginal that overhead might be, when you need to perform mass updates where, for example, hundreds or thousands of values are being <tt class="calibre22">conj</tt>ed into a collection, the result in aggregate is subpar.</p><p class="calibre18">Transients are nothing more than an optimization for this scenario. In some cases, transients can reduce or eliminate the cumulative object allocation rate of an operation, thereby minimizing garbage collection time and improving overall collection construction times. In particular, they are an easy way to reduce object churn in a tight loop.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos496249"></a><a href="#filepos511826"><span class="calibre32">104</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">What sort of circumstances are we talking about, exactly? Well, let’s look at a core Clojure function we’ve seen before, <tt class="calibre22">into</tt><a id="filepos496514"></a>; it takes a collection, some seq of values, and <tt class="calibre22">conj</tt>’s all of the latter into the former:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(into #{} (range 5))<br class="calibre33"/>;= #{0 1 2 3 4}</tt></span></blockquote><p class="calibre23">What would it take for us to reimplement this? As a first draft, not much:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn naive-into<br class="calibre33"/>  [coll source]<br class="calibre33"/>  (reduce conj coll source))<br class="calibre33"/><br class="calibre33"/>(= (into #{} (range 500))<br class="calibre33"/>   (naive-into #{} (range 500)))<br class="calibre33"/>;= true</tt></span></blockquote><p class="calibre23">Great, so we have our own implementation of <tt class="calibre22">into</tt>, and it will work with any persistent collection. However, let’s look at the performance of our implementation versus Clojure’s:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(time (do (into #{} (range 1e6))         </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>        nil))<br class="calibre33"/>; "Elapsed time: 1756.696 msecs"<br class="calibre33"/>(time (do (naive-into #{} (range 1e6))<br class="calibre33"/>        nil))<br class="calibre33"/>; "Elapsed time: 3394.684 msecs"</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">We don’t want to print a set of a million numbers to the REPL, so we make sure to return <tt class="calibre22">nil</tt> from the <tt class="calibre22">do</tt> form.</blockquote><p class="calibre18">Ouch, <tt class="calibre22">naive-into</tt> is 2× slower! The reason is that <tt class="calibre22">into</tt> uses a transient collection when it can,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos498267"></a><a href="#filepos512129"><span class="calibre32">105</span></a><span class="calibre32">]</span></small></sup> that is, when the “destination” collection is a vector or unsorted map or set, the only types of collections for which transient variants exist to date.</p><p class="calibre18">We can do the same though:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn faster-into<br class="calibre33"/>  [coll source]<br class="calibre33"/>  (persistent! (reduce conj! (transient coll) source)))</tt></span></blockquote><p class="calibre23">Prior to entering the reduction, we turn the initial collection into a <tt class="calibre22">transient</tt>. At each step of the reduction, we use <tt class="calibre22">conj!</tt>—the transient analogue to <tt class="calibre22">conj</tt>—to add the next value from <tt class="calibre22">source</tt> to the transient collection. <tt class="calibre22">reduce</tt> returns the newly populated transient collection, which we make persistent again using <tt class="calibre22">persistent!</tt>. What is the upshot?</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(time (do (faster-into #{} (range 1e6))<br class="calibre33"/>        nil))<br class="calibre33"/>; "Elapsed time: 1639.156 msecs"</tt></span></blockquote><p class="calibre23">Yes, performance parity with <tt class="calibre22">into</tt>. Let’s take a step back for just a moment though: faster is almost always better, but are we losing all that we gained by using persistent, immutable collections? In short, no. It’s true that we are working with a mutable collection throughout the course of <tt class="calibre22">faster-into</tt>’s reduction, but <span class="italic">that transient never escapes the scope of the function that uses it</span>! This means that <tt class="calibre22">faster-into</tt> has <span class="italic">exactly</span> the same semantics as <tt class="calibre22">naive-into</tt>—persistent collection in, persistent collection out. Thus, users get all the beneficial semantics of persistent collections and all the speed of unfettered mutation.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Remember that only vectors and unsorted maps and vectors have transient variants. Therefore, </span><a id="filepos500412"></a><span class="calibre10"><tt class="calibre22">faster-into</tt></span><span class="calibre10"> will fail if it is provided with, for example, a sorted set as the collection to populate.</span></blockquote><blockquote class="calibre17"><span class="calibre10">There is unfortunately no standard predicate to indicate if a given collection’s type has a transient variant. You need to check if a given collection is an instance of </span><span class="calibre10"><tt class="calibre22">clojure.lang.IEditableCollection</tt></span><a id="filepos500880"></a><span class="calibre10">, the interface Clojure uses to indicate that a collection can produce a transient variant. A predicate to check for this might be </span><span class="calibre10"><tt class="calibre22">transient-capable?</tt></span><span class="calibre10">:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(defn transient-capable?<br class="calibre33"/>  "Returns true if a transient can be obtained for the given collection.<br class="calibre33"/>   i.e. tests if `(transient coll)` will succeed."<br class="calibre33"/>  [coll]<br class="calibre33"/>  (instance? clojure.lang.IEditableCollection coll))</tt></span></blockquote><p class="calibre25">Now that we’ve seen the benefits of transients and understand the limited scope within which they should be used, let’s look at the finer details of their mechanics.</p><p class="calibre18">True to its name, a persistent collection used as the basis of a transient is unaffected:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def v [1 2])<br class="calibre33"/>;= #'user/v<br class="calibre33"/>(def tv (transient v))<br class="calibre33"/>;= #'user/tv<br class="calibre33"/>(conj v 3)<br class="calibre33"/>;= [1 2 3]</tt></span></blockquote><p class="calibre23">On the other hand, turning a transient collection into a persistent one by using <tt class="calibre22">persistent!</tt> makes the source transient unusable:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos502217"></a><a href="#filepos512539"><span class="calibre32">106</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(persistent! tv)<br class="calibre33"/>;= [1 2]<br class="calibre33"/>(get tv 0)<br class="calibre33"/>;= #&lt;IllegalAccessError java.lang.IllegalAccessError:<br class="calibre33"/>;=   Transient used after persistent! call&gt;</tt></span></blockquote><p class="calibre23">Both <tt class="calibre22">transient</tt> and <tt class="calibre22">persistent!</tt> return in constant time.</p><p class="calibre18">Transient collections support many of the access functions of their persistent parents, but not all:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(nth (transient [1 2]) 1)<br class="calibre33"/>;= 2<br class="calibre33"/>(get (transient {:a 1 :b 2}) :a)<br class="calibre33"/>;= 1<br class="calibre33"/>((transient {:a 1 :b 2}) :a)       </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= 1<br class="calibre33"/>((transient [1 2]) 1)<br class="calibre33"/>;= 2<br class="calibre33"/>(find (transient {:a 1 :b 2}) :a)<br class="calibre33"/>;= #&lt;CompilerException java.lang.ClassCastException:<br class="calibre33"/>;=   clojure.lang.PersistentArrayMap$TransientArrayMap<br class="calibre33"/>;=   cannot be cast to java.util.Map (NO_SOURCE_FILE:0)&gt;</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Transients are functions too!</blockquote><p class="calibre18">A notable exception is that <tt class="calibre22">seq</tt><a id="filepos503732"></a> is not supported on transients, the rationale being that a sequence can outlive its source, and transients cannot be relied upon to satisfy the guarantees that seqs make as persistent collections themselves.</p><p class="calibre18">However, none of the persistent update functions may be used with transients. Transients have their own update functions that, other than being dedicated for use with transients, perform the same operations as their namesakes: <tt class="calibre22">conj!</tt>, <tt class="calibre22">assoc!</tt>, <tt class="calibre22">dissoc!</tt>, <tt class="calibre22">disj!</tt>, and <tt class="calibre22">pop!</tt>.</p><p class="calibre18">All transient functions end with an exclamation mark <a id="filepos504376"></a>to denote their invalidating behavior with regard to the collection passed as their first argument. Once you use any of these functions on a transient collection, <span class="italic">that collection should never be touched again</span>—even for read-only purposes. Just as you must always use the result of <tt class="calibre22">conj</tt> and <tt class="calibre22">assoc</tt> and <tt class="calibre22">disj</tt>, et al., in order to benefit from their effect, you must always use the result of their transient analogues. That is, you cannot bash transient collections in-place, or bad things happen:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [tm (transient {})]<br class="calibre33"/>  (doseq [x (range 100)]<br class="calibre33"/>    (assoc! tm x 0))      </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  (persistent! tm))<br class="calibre33"/>;= {0 0, 1 0, 2 0, 3 0, 4 0, 5 0, 6 0, 7 0}</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Even though we <tt class="calibre22">assoc!</tt> 100 entries into the transient map, nearly all of them are lost because we are not using the result of <tt class="calibre22">assoc!</tt>.</blockquote><p class="calibre18">Transients are intended to be used just like their persistent counterparts, with the additional restriction that prior revisions of a transient must not be used again. The easiest and safest way to use transients is to write normal Clojure code, add the required <tt class="calibre22">transient</tt> and <tt class="calibre22">persistent!</tt> calls, and tack exclamation marks at the end of functions that return modified transients. You still have to be sure that the linear use of transients is respected (that is, once modified, a transient is never used again). As we saw with <tt class="calibre22">faster-into</tt> earlier, reductions are perhaps the easiest operations to transform to use transients.</p><p class="calibre18">Because transients are solely an optimization, they should be used with discretion and strictly locally, usually local to a single function (or perhaps, local to a cluster of related private functions within a single library). Part of this good practice is enforced: there is a concurrency safeguard built into transients ensuring that only the thread that creates a given transient can ever use or modify it. We’ll talk about concurrency in general in <a href="#filepos593810"><span class="calibre5">Chapter 4</span></a>, but suffice it to say that <tt class="calibre22">future</tt> here will cause the <tt class="calibre22">get</tt> call to run in a different thread than the one that establishes the local binding <tt class="calibre22">t</tt> and creates the transient map:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [t (transient {})]<br class="calibre33"/>  @(future (get t :a)))<br class="calibre33"/>;= #&lt;IllegalAccessError java.lang.IllegalAccessError:<br class="calibre33"/>;=   Transient used by non-owner thread&gt;</tt></span></blockquote><p class="calibre23">Transients may be an effective optimization but they don’t come for free: you have to restructure your code to follow their restrictions and work around their limited support of Clojure core functions. As with any optimization technique, you should analyze whether this is the best optimization strategy for your code, and once implemented, whether it’s effective.</p><p class="calibre18"><span class="bold">Transients don’t compose.</span> Transients don’t compose well; <tt class="calibre22">persistent!</tt> will not traverse a hierarchy of nested transients you may have created, so calling <tt class="calibre22">persistent!</tt> on the top level reference will not apply to subcollections:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(persistent! (transient [(transient {})]))<br class="calibre33"/>;= [#&lt;TransientArrayMap clojure.lang.PersistentArrayMap$TransientArrayMap@b57b39f&gt;]</tt></span></blockquote><p class="calibre23">In any case, because transients are mutable, they do not have value semantics and cannot be treated as such:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(= (transient [1 2]) (transient [1 2]))<br class="calibre33"/>;= false</tt></span></blockquote><p class="calibre23">This should drive home the point that transients and their mutability should not be let out to mix with collections with polite semantics. They are strictly a local optimization that you should keep hidden, like the proverbial falling tree that no one has a chance to hear.<a id="filepos508819"></a></p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos508923"></a><a href="#filepos482842"><span class="calibre32">98</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">We could have just as easily used </span><span class="calibre10"><tt class="calibre22">pop</tt></span><span class="calibre10"> here.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos509203"></a><a href="#filepos483526"><span class="calibre32">99</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">There are many subtle differences in their internals, but those do not prevent us from discussing their persistent semantics in general. Please keep in mind that the map data structure visualizations in this section are intended solely to highlight those semantics, not to accurately reflect implementation details.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos509702"></a><a href="#filepos484339"><span class="calibre32">100</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Note that these illustrations are “not to scale” in that the branching factor used by Clojure’s tree implementations is not faithfully represented. Our illustrations are solely intended to convey the semantics of structural sharing and persistence.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos510141"></a><a href="#filepos487172"><span class="calibre32">101</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice"><span class="calibre10"><span class="calibre5">http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice</span></span></a><span class="calibre10"> for an overview of the hash array mapped trie implementation in Clojure’s </span><span class="calibre10"><tt class="calibre22">PersistentHashMap</tt></span><span class="calibre10"> class.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos510750"></a><a href="#filepos487366"><span class="calibre32">102</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation"><span class="calibre10"><span class="calibre5">http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation</span></span></a><span class="calibre10"> for an overview of the implementation in Clojure’s </span><span class="calibre10"><tt class="calibre22">PersistentVector</tt></span><span class="calibre10"> class.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos511345"></a><a href="#filepos495022"><span class="calibre32">103</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">As we said at the start of this section, old revisions of transient collections </span><span class="calibre10"><span class="italic">must not</span></span><span class="calibre10"> be relied upon; we’re simply illustrating here that transient collections are quite mutable and have semantics that run counter to persistent collections.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos511826"></a><a href="#filepos496249"><span class="calibre32">104</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">When confronted with a performance problem, allocations are generally the first thing to profile in a Clojure program.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos512129"></a><a href="#filepos498267"><span class="calibre32">105</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Other core Clojure functions use transients under the covers when they can as well, including </span><span class="calibre10"><tt class="calibre22">frequencies</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">group-by</tt></span><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos512539"></a><a href="#filepos502217"><span class="calibre32">106</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Thus the exclamation point to indicate that </span><span class="calibre10"><tt class="calibre22">persistent!</tt></span><span class="calibre10"> is a destructive operation.</span></p><div class="mbppagebreak"></div><p id="filepos512813" class="calibre6"><span class="calibre4"><span class="bold">Metadata</span></span></p><p id="filepos512882" class="calibre18">Metadata is data about other data. Metadata has many other names and takes many forms in other languages:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Type declarations and access modifiers (like <tt class="calibre22">private</tt>, <tt class="calibre22">protected</tt>, and so on) are metadata about the values, variables, and functions with which they are associated.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Java annotations are metadata about classes, methods, method arguments, and so on.</blockquote></li></ul><p class="calibre18">While metadata in Clojure <span class="italic">is</span> used for these particular purposes,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos513649"></a><a href="#filepos517563"><span class="calibre32">107</span></a><span class="calibre32">]</span></small></sup> it is a much more generalized facility that you can use in your applications and with your data.</p><p class="calibre18">Metadata can be attached to any Clojure data structure, sequence, record, symbol, or reference type, and always takes the form of a map. There is a convenient reader syntax for declaratively attaching metadata to a value literal:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def a ^{:created (System/currentTimeMillis)}<br class="calibre33"/>        [1 2 3])<br class="calibre33"/>;= #'user/a<br class="calibre33"/>(meta a)<br class="calibre33"/>;= {:created 1322065198169}</tt></span></blockquote><p class="calibre23">As a convenience, metadata that contains only slots whose keys are keywords and whose value is Boolean <tt class="calibre22">true</tt> can be provided in a short form, and can be additively “stacked” onto the next value being read:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(meta ^:private [1 2 3])<br class="calibre33"/>;= {:private true}<br class="calibre33"/>(meta ^:private ^:dynamic [1 2 3])<br class="calibre33"/>;= {:dynamic true, :private true}</tt></span></blockquote><p class="calibre23">There are <tt class="calibre22">with-meta</tt><a id="filepos514884"></a> and <tt class="calibre22">vary-meta</tt><a id="filepos514914"></a> functions that will update metadata associated with a given value:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def b (with-meta a (assoc (meta a)<br class="calibre33"/>                      :modified (System/currentTimeMillis))))<br class="calibre33"/>;= #'user/b<br class="calibre33"/>(meta b)<br class="calibre33"/>;= {:modified 1322065210115, :created 1322065198169}<br class="calibre33"/>(def b (vary-meta a assoc :modified (System/currentTimeMillis)))<br class="calibre33"/>;= #'user/b<br class="calibre33"/>(meta b)<br class="calibre33"/>;= {:modified 1322065229972, :created 1322065198169}</tt></span></blockquote><p class="calibre23">While <tt class="calibre22">with-meta</tt> replaces a value’s metadata, <tt class="calibre22">vary-meta</tt> updates the metadata map that is already in place based on the update function (<tt class="calibre22">assoc</tt> above) and additional arguments to that function.</p><p class="calibre18">Remember, though, that metadata is data <span class="italic">about</span> other data. In other words, changing a value’s metadata does not impact things like how the value prints or its equality (or inequality) with other values:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(= a b)<br class="calibre33"/>;= true<br class="calibre33"/>a<br class="calibre33"/>;= [1 2 3]<br class="calibre33"/>b<br class="calibre33"/>;= [1 2 3]<br class="calibre33"/>(= ^{:a 5} 'any-value<br class="calibre33"/>   ^{:b 5} 'any-value)<br class="calibre33"/>;= true</tt></span></blockquote><p class="calibre23">Of course, values that have metadata attached are just as immutable as those that don’t; so, operations that “modify” data structures return new data structures that retain the original metadata:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(meta (conj a 500))<br class="calibre33"/>;= {:created 1319481540825}</tt></span></blockquote><p class="calibre23">This is far more useful compared to the handling of application-level metadata in other languages, where such information must be carefully kept isolated from the “real” data in an application, lest it improperly affect equality comparisons or not get carried along into updated values and aggregates. We already saw that things like creation and modification times can be held in metadata; consider also the tracking of provenance of data loaded from different sources, such as an authoritative database and a cache. We can decorate values representing data from these sources with different metadata without impacting their equality, and then use the metadata to determine how to treat those values: for example, what to do with requests to update a value loaded from the database versus a value loaded from cache.</p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos517563"></a><a href="#filepos513649"><span class="calibre32">107</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="#filepos1324665"><span class="calibre10"><span class="calibre5">Type Hinting for Performance</span></span></a><span class="calibre10"> for how metadata is used to provide type information to Clojure’s compiler, </span><a href="#filepos735003"><span class="calibre10"><span class="calibre5">Vars</span></span></a><span class="calibre10"> for how metadata attached to vars can set access policy and concurrency semantics, and </span><a href="#filepos1389148"><span class="calibre10"><span class="calibre5">Annotations</span></span></a><span class="calibre10"> for how metadata is used to apply Java annotations to Clojure types.</span></p><div class="mbppagebreak"></div><p id="filepos518281" class="calibre6"><span class="calibre4"><span class="bold">Putting Clojure’s Collections to Work</span></span></p><p class="calibre18">Why are data structures so important? In <span class="italic">The Mythical Man-Month</span>, Frederick Brooks says:</p><blockquote class="calibre35"><span class="calibre10"><span class="italic">Show me your flowchart and conceal your tables, and I shall continue to be mystified. Show me your tables, and I won’t usually need your flowchart; it’ll be obvious.</span></span></blockquote><p class="calibre23">Two decades later, Eric Raymond modernized it into:</p><blockquote class="calibre35"><span class="calibre10"><span class="italic">Show me your code and conceal your data structures, and I shall continue to be mystified. Show me your data structures, and I won’t usually need your code; it’ll be obvious.</span></span></blockquote><p class="calibre23">The way you structure and model your data determines the shape of your code; hence, you cannot write good functional Clojure code if you persist with old habits, modeling everything out of arrays, dedicated objects, and the occasional map.</p><p class="calibre18">Modeling data well in Clojure puts the focus on values (and particularly composite values), natural identifiers, and sets and maps. The mindset to adopt is akin to the one for relational<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos519614"></a><a href="#filepos587799"><span class="calibre32">108</span></a><span class="calibre32">]</span></small></sup> modeling. However, what constitutes a value is highly context-dependent: thanks to composite values, a value can be hierarchical, so it’s up to the developer to define the granularity at which relationships are maintained.</p><p id="filepos519938" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Identifiers and Cycles</span></span></span></p><p id="filepos520050" class="calibre18">Natural identifiers are opposed to synthetic or surrogate identifiers, where the latter are usually strings or an artificially generated number, akin to sequences or autoincrements in databases or object references themselves in most object-oriented languages. Thus, synthetic identifiers are by definition artifacts of incidental complexity.</p><p class="calibre18">Without those middlemen, there is no need to maintain a canonical mapping of <span class="italic">things</span> to their <span class="italic">IDs</span>: either the “things” are different and, as values, are enough to identify themselves, or they are not. As a bonus, eliminating synthetic identifiers means that different threads or even processes no longer need to communicate to assign unique identifiers to chunks of data, because you can derive natural identifiers from the data at hand.</p><p class="calibre18">The debate of the respective virtues of synthetic keys versus natural keys <a id="filepos521013"></a>is not new, but is still very much alive when it comes to database schema design. The arguments for synthetic identifiers revolve around two preoccupations: that data is going to survive the process that created it (and the rules it embodies), and that data is hard to refactor. The implication is that synthetic identifiers are of little use for in-process or otherwise application-level computation.</p><p class="calibre18">A typical example of unnecessary synthetic identifiers is the distinct states generated by parsers or regular expression engines. This generally involves mechanically numbering each parser or lexer state, while in Clojure you can construct complex valued states that fully describe themselves in a semantically significant way. Computing transitions from a state can then be done with a simple function, taking only the actual state as argument. In contrast to typical practice, there’s no need to pass a separate mapping of states-as-numbers to data defining those states; <span class="italic">just the data is enough</span>.</p><p class="calibre18">You can still number <a id="filepos522113"></a>states later on for efficiency reasons, but the two important lessons are that:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">You are not required to.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">You can perform the numbering or renaming in a separate step, cleanly separating concerns and complexities. This means that you can readily maintain multiple sets of synthetic identifiers if necessary, as is often required when working with data owned or affected by multiple interacting systems.</blockquote></li></ol><p class="calibre18">The only taboo in this picture is cycles: the only reasonable way to introduce them is through identifiers and indirection. Similarly, no cycles also means no back-references.</p><p class="calibre18"><span class="bold">Cycles, values, and identities</span>. Let’s suppose we have an immutable tree node (e.g., a DOM node) that has <tt class="calibre22">:parent-node</tt> and <tt class="calibre22">:children</tt> slots. What happens to these slots when you “update” (create a new version of) this node? If you don’t change the values <a id="filepos523278"></a>under <tt class="calibre22">:parent-node</tt> and <tt class="calibre22">:children</tt>, then a roundtrip through these properties will get you back…to the old, unmodified value of the node, not the new one! Quite a problematic situation, one that must force you to modify the parent and child nodes to point to the updated node.</p><p class="calibre18">However, to be correct, this update must be propagated to all the nodes of the tree. One way out might be to use reference types, which we discuss in detail in <a href="#filepos627984"><span class="calibre5">State and Identity</span></a>, for those properties. But this results in your tree no longer being an immutable value, and nodes will need to grow special logic to keep all those mutable references coherent. Welcome back to spaghetti mutations and incidental complexity!</p><p class="calibre18">Most of the time, cycles <a id="filepos524142"></a>(a.k.a. back-references)<a id="filepos524173"></a> are built into data structures for navigational purposes. Such cases are covered by paths or <span class="italic">zippers</span>, which we explore in <a href="#filepos569560"><span class="calibre5">Navigation, Update, and Zippers</span></a>. The rest of the time, you’ll have to add an indirection layer to introduce cycles.</p><p id="filepos524486" class="calibre18">This indirection layer can be plain reference types or IDs (used to look up into an index, usually a map). It may feel cumbersome at times, but breaking cycles in such a fashion forces you to ask important questions about which pieces of data are pure values and which deserve their own identifiers—and what those identifiers are for.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos524885"></a><a href="#filepos588124"><span class="calibre32">109</span></a><span class="calibre32">]</span></small></sup> Those questions and their answers will save you time later when you share your data outside of your application, by sending it to the network, to the disk, to a database, or expose it as a service of some kind.</p><p id="filepos525195" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Thinking Different: From Imperative to Functional</span></span></span></p><p class="calibre18">We have already argued against numeric indices <a id="filepos525409"></a>and promoted the use of sequences instead. However, despite being a nice abstraction, sequences are still linear and by themselves won’t help you to think differently about problems and how to effectively solve them with Clojure data structures. You need to fully embrace programming with values, and use them to their fullest in order to get the most out of Clojure.</p><p id="filepos525789" class="calibre23"><span class="calibre53"><span class="bold">Revisiting a classic: Conway’s Game of Life</span></span></p><p id="filepos525895" class="calibre18">Conway’s Game of Life (<a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life"><span class="calibre5">https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life</span></a>) is the sort of algorithm that seems to beg for arrays. We will implement its rules here; first, in a traditional manner—the board will be a vector of vectors with each item being either <tt class="calibre22">:on</tt> or <tt class="calibre22">nil</tt>—and later in a more Clojure-idiomatic fashion, without the complexity (and restrictions) of indices.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn empty-board<br class="calibre33"/>  "Creates a rectangular empty board of the specified width<br class="calibre33"/>   and height."<br class="calibre33"/>  [w h]<br class="calibre33"/>  (vec (repeat w (vec (repeat h nil)))))</tt></span></blockquote><p class="calibre23">Now that we can create an empty board, we need to add some living cells to it:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn populate<br class="calibre33"/>  "Turns :on each of the cells specified as [y, x] coordinates."<br class="calibre33"/>  [board living-cells]<br class="calibre33"/>  (reduce (fn [board coordinates]<br class="calibre33"/>            (assoc-in board coordinates :on))<br class="calibre33"/>          board<br class="calibre33"/>          living-cells))<br class="calibre33"/><br class="calibre33"/>(def glider (populate (empty-board 6 6) #{[2 0] [2 1] [2 2] [1 2] [0 1]}))<br class="calibre33"/><br class="calibre33"/>(pprint glider)<br class="calibre33"/>; [[nil :on nil nil nil nil]<br class="calibre33"/>;  [nil nil :on nil nil nil]<br class="calibre33"/>;  [:on :on :on nil nil nil]<br class="calibre33"/>;  [nil nil nil nil nil nil]<br class="calibre33"/>;  [nil nil nil nil nil nil]<br class="calibre33"/>;  [nil nil nil nil nil nil]]</tt></span></blockquote><p class="calibre23">Now for the real meat of it: an <tt class="calibre22">indexed-step</tt> function,<a id="filepos527718"></a> which takes a board’s state, returning its successor according to the game’s rules:</p><p id="filepos527817" class="calibre23"></p><p class="calibre23"><span class="italic">Example 3-6. Implementation and helpers for indexed-step</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(defn neighbours<br class="calibre33"/>  [[x y]]<br class="calibre33"/>  (for [dx [-1 0 1] dy [-1 0 1] :when (not= 0 dx dy)]<br class="calibre33"/>    [(+ dx x) (+ dy y)]))<br class="calibre33"/><br class="calibre33"/>(defn count-neighbours<br class="calibre33"/>  [board loc]<br class="calibre33"/>  (count (filter #(get-in board %) (neighbours loc))))  </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/><br class="calibre33"/>(defn indexed-step<br class="calibre33"/>  "Yields the next state of the board, using indices to determine neighbors,<br class="calibre33"/>   liveness, etc."<br class="calibre33"/>  [board]<br class="calibre33"/>  (let [w (count board)<br class="calibre33"/>        h (count (first board))]<br class="calibre33"/>    (loop [new-board board x 0 y 0]<br class="calibre33"/>      (cond<br class="calibre33"/>        (&gt;= x w) new-board<br class="calibre33"/>        (&gt;= y h) (recur new-board (inc x) 0)<br class="calibre33"/>        :else<br class="calibre33"/>          (let [new-liveness<br class="calibre33"/>                 (case (count-neighbours board [x y])<br class="calibre33"/>                   2 (get-in board [x y])<br class="calibre33"/>                   3 :on<br class="calibre33"/>                   nil)]<br class="calibre33"/>            (recur (assoc-in new-board [x y] new-liveness) x (inc y)))))))</tt></span></p><p class="calibre23"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Note that, because <tt class="calibre22">count-neighbours</tt> uses <tt class="calibre22">get-in</tt>—built on top of <tt class="calibre22">get</tt>, which as we have seen, returns <tt class="calibre22">nil</tt> for unknown indices—it will not throw any index-related errors.</blockquote><p class="calibre13">Let’s see how well this works:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(-&gt; (iterate indexed-step glider) (nth 8) pprint)<br class="calibre33"/>; [[nil nil nil nil nil nil]<br class="calibre33"/>;  [nil nil nil nil nil nil]<br class="calibre33"/>;  [nil nil nil :on nil nil]<br class="calibre33"/>;  [nil nil nil nil :on nil]<br class="calibre33"/>;  [nil nil :on :on :on nil]<br class="calibre33"/>;  [nil nil nil nil nil nil]]</tt></span></blockquote><p class="calibre23">We now have a functioning implementation of Conway’s Game of Life, with a nice glider there!</p><p class="calibre18">Let’s see how you can rework this solution to avoid indices. The first step is to get rid of manual iteration. Each <tt class="calibre22">loop</tt><a id="filepos530441"></a> is replaced by a <tt class="calibre22">reduce</tt><a id="filepos530481"></a> over a range:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn indexed-step2<br class="calibre33"/>  [board]<br class="calibre33"/>  (let [w (count board)<br class="calibre33"/>        h (count (first board))]<br class="calibre33"/>    (reduce<br class="calibre33"/>      (fn [new-board x]<br class="calibre33"/>        (reduce<br class="calibre33"/>          (fn [new-board y]<br class="calibre33"/>            (let [new-liveness<br class="calibre33"/>                   (case (count-neighbours board [x y])<br class="calibre33"/>                     2 (get-in board [x y])<br class="calibre33"/>                     3 :on<br class="calibre33"/>                     nil)]<br class="calibre33"/>              (assoc-in new-board [x y] new-liveness)))<br class="calibre33"/>          new-board (range h)))<br class="calibre33"/>      board (range w))))</tt></span></blockquote><p class="calibre23">Nested reductions can always be collapsed to make code less noisy:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn indexed-step3<br class="calibre33"/>  [board]<br class="calibre33"/>  (let [w (count board)<br class="calibre33"/>        h (count (first board))]<br class="calibre33"/>    (reduce<br class="calibre33"/>      (fn [new-board [x y]]<br class="calibre33"/>        (let [new-liveness<br class="calibre33"/>               (case (count-neighbours board [x y])<br class="calibre33"/>                 2 (get-in board [x y])<br class="calibre33"/>                 3 :on<br class="calibre33"/>                 nil)]<br class="calibre33"/>           (assoc-in new-board [x y] new-liveness)))<br class="calibre33"/>      board (for [x (range h) y (range w)] [x y]))))</tt></span></blockquote><p class="calibre23">Now we have a <tt class="calibre22">loop</tt>-less version that nevertheless still uses indices.</p><p class="calibre18">It has been said and repeated that sequences replace indices, but our <tt class="calibre22">count-neighbours</tt> and <tt class="calibre22">neighbours</tt> functions depend heavily on indices to compute and access the neighbourhood of a cell. How can we express the concept of neighbourhood with sequences and without relying upon indices?</p><p class="calibre18">If we were working in only one dimension, it would be easy; just use <tt class="calibre22">partition</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(partition 3 1 (range 5))<br class="calibre33"/>;= ((0 1 2) (1 2 3) (2 3 4))</tt></span></blockquote><p class="calibre23">The result of <tt class="calibre22">partition</tt><a id="filepos532963"></a> here can be seen as a sequence of the items 1, 2, and 3 along with their neighbours. The only problem is that this code only create “windows” around items which have enough neighbours: entries for 0 and 4 and their neighbours are missing! We can fix this by padding the original collection:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(partition 3 1 (concat [nil] (range 5) [nil]))<br class="calibre33"/>;= ((nil 0 1) (0 1 2) (1 2 3) (2 3 4) (3 4 nil))</tt></span></blockquote><p class="calibre23">Let’s factor this into a <tt class="calibre22">window</tt> function:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn window<br class="calibre33"/>  "Returns a lazy sequence of 3-item windows centered around each item of coll."<br class="calibre33"/>  [coll]<br class="calibre33"/>  (partition 3 1 (concat [nil] coll [nil])))</tt></span></blockquote><p class="calibre23">Now, how can we make the transition to two dimensions? Well, the trick is that when we apply this <tt class="calibre22">window</tt> function to a collection of <tt class="calibre22">n</tt> rows, we get <tt class="calibre22">n</tt> triples of 3 rows and each triple of 3 rows (of length <tt class="calibre22">m</tt>) can be transformed in a sequence of <tt class="calibre22">m</tt> triples; formally speaking this is a <span class="italic">transposition</span>. Applying <tt class="calibre22">window</tt> again to such a sequence yields a sequence of triples of triples, we can readily create 3 by 3 windows around each item.</p><p class="calibre18">Let’s look at the code:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn cell-block<br class="calibre33"/>  "Creates a sequences of 3x3 windows from a triple of 3 sequences."<br class="calibre33"/>  [[left mid right]]<br class="calibre33"/>  (window (map vector<br class="calibre33"/>            (or left (repeat nil)) mid (or right (repeat nil)))))</tt></span></blockquote><p class="calibre23">The two <tt class="calibre22">or</tt> forms are there to replace the <tt class="calibre22">nil</tt> padding generated by <tt class="calibre22">window</tt> with repeating sequences of <tt class="calibre22">nil</tt>, because <tt class="calibre22">map</tt> stops as soon as one of its argument is empty.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos535042"></a><a href="#filepos588677"><span class="calibre32">110</span></a><span class="calibre32">]</span></small></sup> We can simplify this code by allowing <tt class="calibre22">window</tt> to take an optional <tt class="calibre22">pad</tt> argument:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn window<br class="calibre33"/>  "Returns a lazy sequence of 3-item windows centered<br class="calibre33"/>   around each item of coll, padded as necessary with<br class="calibre33"/>   pad or nil."<br class="calibre33"/>  ([coll] (window nil coll))<br class="calibre33"/>  ([pad coll]<br class="calibre33"/>   (partition 3 1 (concat [pad] coll [pad]))))<br class="calibre33"/><br class="calibre33"/>(defn cell-block<br class="calibre33"/>  "Creates a sequences of 3x3 windows from a triple of 3 sequences."<br class="calibre33"/>  [[left mid right]]<br class="calibre33"/>  (window (map vector left mid right)))</tt></span></blockquote><p class="calibre23">We need to compute the liveness of the cell at the center of a block; that should probably be factored out as well, this time using destructuring to concisely separate a cell block into its constituent parts:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn liveness<br class="calibre33"/>  "Returns the liveness (nil or :on) of the center cell for<br class="calibre33"/>   the next step."<br class="calibre33"/>  [block]<br class="calibre33"/>  (let [[_ [_ center _] _] block]<br class="calibre33"/>    (case (- (count (filter #{:on} (apply concat block)))<br class="calibre33"/>             (if (= :on center) 1 0))<br class="calibre33"/>      2 center<br class="calibre33"/>      3 :on<br class="calibre33"/>      nil)))</tt></span></blockquote><p class="calibre23">So, at last, we can reexpress the <tt class="calibre22">indexed-step</tt> function, now depending strictly upon index-free helper functions:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn- step-row<br class="calibre33"/>  "Yields the next state of the center row."<br class="calibre33"/>  [rows-triple]<br class="calibre33"/>  (vec (map liveness (cell-block rows-triple))))<br class="calibre33"/><br class="calibre33"/>(defn index-free-step<br class="calibre33"/>  "Yields the next state of the board."<br class="calibre33"/>  [board]<br class="calibre33"/>  (vec (map step-row (window (repeat nil) board))))</tt></span></blockquote><p class="calibre23">Even though <tt class="calibre22">index-free-step</tt> depends upon strictly index-free helper functions, it is equivalent to <tt class="calibre22">indexed-step</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(= (nth (iterate indexed-step glider) 8)<br class="calibre33"/>   (nth (iterate index-free-step glider) 8))<br class="calibre33"/>;= true</tt></span></blockquote><p class="calibre23">Each step along the way may be simple, but the path from an “imperative” solution to a “sequential” one may be mind-bending the first couple of times you travel it.</p><p class="calibre18"><span class="bold">Getting to the next level</span>. The problem with what we’ve done so far is that it stays close to the spirit of the original <span class="italic">implementation</span>. However, there’s a way to find a far more elegant approach. For this to happen, we have to take a deep breath, step back, and really examine the rules for the Game of Life.<a id="filepos538102"></a></p><blockquote class="calibre35"><span class="calibre10"><span class="italic">At each step in time, the following transitions occur:</span></span></blockquote><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17"><span class="calibre10"><span class="italic">Any live cell with fewer than two live neighbours dies, as if caused by under-population.</span></span></blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17"><span class="calibre10"><span class="italic">Any live cell with two or three live neighbours lives on to the next generation.</span></span></blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17"><span class="calibre10"><span class="italic">Any live cell with more than three live neighbours dies, as if by overcrowding.</span></span></blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17"><span class="calibre10"><span class="italic">Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.</span></span></blockquote></li></ul><p class="calibre23">This expression of the rules does not mention rows, columns, or indices. It only talks about cells and neighbours; to be more precise, it talks about living cells, neighbours, and dead cells that are in the vicinity of living cells. Hence, the two main concepts are living cells and neighborhood: dead cells are neighbour cells that are not alive, so they can be derived from <span class="italic">neighbourhood</span> and <span class="italic">living cells</span>.</p><p class="calibre18">If we stick to these two concepts, <span class="italic">the only state of the world is the set of living cells</span>. To generate each successive state, we simply have to first compute all living cells’ neighbours and then count how many times a given “neighbour cell” occurs (it occurs as many times as it has living neighbours).</p><p class="calibre18">If we try to translate this to Clojure, we end with:</p><p id="filepos540008" class="calibre23"></p><p class="calibre23"><span class="italic">Example 3-7. An elegant implementation of Conway’s Game of Life</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(defn step<br class="calibre33"/> "Yields the next state of the world"<br class="calibre33"/> [cells]<br class="calibre33"/> (set (for [[loc n] (frequencies (mapcat neighbours cells))<br class="calibre33"/>            :when (or (= n 3) (and (= n 2) (cells loc)))]<br class="calibre33"/>        loc)))</tt></span></p><p class="calibre13">And that’s all! Only our original <tt class="calibre22">neighbours</tt> helper function is needed; no indexed, vector-of-vectors board, no limit to the size of the board for that matter, and the representation of the world is sparse—only the coordinates of living cells are represented explicitly.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos540832"></a><a href="#filepos589180"><span class="calibre32">111</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">Let’s try this new <tt class="calibre22">step</tt> on a glider pattern; the state of the world isn’t a board anymore—just a set of the locations of living cells—but we can reuse the <tt class="calibre22">populate</tt> function to produce a delimited board that is easily visualized:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(-&gt;&gt; (iterate step #{[2 0] [2 1] [2 2] [1 2] [0 1]}) </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  (drop 8)<br class="calibre33"/>  first<br class="calibre33"/>  (populate (empty-board 6 6))<br class="calibre33"/>  pprint)<br class="calibre33"/>; [[nil nil nil nil nil nil]<br class="calibre33"/>;  [nil nil nil nil nil nil]<br class="calibre33"/>;  [nil nil nil :on nil nil]<br class="calibre33"/>;  [nil nil nil nil :on nil]<br class="calibre33"/>;  [nil nil :on :on :on nil]<br class="calibre33"/>;  [nil nil nil nil nil nil]]</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Starting with the same glider pattern as before, we can see it drift by one unit every four steps as expected.</blockquote><p class="calibre18">An interesting point is that the <tt class="calibre22">step</tt> in <a href="#filepos540008"><span class="calibre5">Example 3-7</span></a> uses the <tt class="calibre22">neighbours</tt> previously defined for the imperative <tt class="calibre22">indexed-step</tt> in <a href="#filepos527817"><span class="calibre5">Example 3-6</span></a>. However, in the context of this solution, <tt class="calibre22">neighbours</tt> is <span class="italic">not</span> dealing with numerical indices into a concrete data structure anymore, but with coordinates: the <tt class="calibre22">[x y]</tt> pairs are opaque identifiers with regard to <tt class="calibre22">step</tt> while in the original imperative <tt class="calibre22">indexed-step</tt>, those pairs where built from indices by <tt class="calibre22">indexed-step</tt> itself.</p><p class="calibre18">Therefore, <tt class="calibre22">neighbours</tt> is now the sole part of this algorithm that cares about the content of the cell identifiers. As such, it defines the topology of the grid. By tweaking <tt class="calibre22">neighbours</tt>, this code can be made to support finite grids, torus grids, hexgrids, N-dimensional grids, and so on, all without changing <tt class="calibre22">step</tt>. By letting go of our imperative mindset, we are left a much better separation of concerns and a clear solution that is very close to the expression of the problem that happens to be more generic.</p><p class="calibre18">We can easily make something really generic out of this <tt class="calibre22">step</tt>: a higher-order function, <tt class="calibre22">stepper</tt>, which acts as a factory for <tt class="calibre22">step</tt> functions.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn stepper<br class="calibre33"/>  "Returns a step function for Life-like cell automata.<br class="calibre33"/>   neighbours takes a location and return a sequential collection<br class="calibre33"/>   of locations. survive? and birth? are predicates on the number<br class="calibre33"/>   of living neighbours."<br class="calibre33"/>  [neighbours birth? survive?]<br class="calibre33"/>  (fn [cells]<br class="calibre33"/>    (set (for [[loc n] (frequencies (mapcat neighbours cells))<br class="calibre33"/>               :when (if (cells loc) (survive? n) (birth? n))]<br class="calibre33"/>           loc))))</tt></span></blockquote><p class="calibre23">Our <tt class="calibre22">step</tt> implementation is equivalent to the function returned by <tt class="calibre22">(stepper neighbours #{3} #{2 3})</tt>. This <tt class="calibre22">stepper</tt> HOF can accommodate different liveness rules and topologies as previously mentioned (hexagonal, 3D, finite, infinite, spherical, torus, mobius, and so on). For example, the Life-like automaton H.B2/S34 (with a hexagonal grid, birth for 2, survive when 3 or 4) is simply implemented as:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn hex-neighbours<br class="calibre33"/>  [[x y]]<br class="calibre33"/>  (for [dx [-1 0 1] dy (if (zero? dx) [-2 2] [-1 1])]<br class="calibre33"/>    [(+ dx x) (+ dy y)]))<br class="calibre33"/><br class="calibre33"/>(def hex-step (stepper hex-neighbours #{2} #{3 4}))<br class="calibre33"/><br class="calibre33"/>;= ; this configuration is an oscillator of period 4<br class="calibre33"/>(hex-step #{[0 0] [1 1] [1 3] [0 4]})<br class="calibre33"/>;= #{[1 -1] [2 2] [1 5]}<br class="calibre33"/>(hex-step *1)<br class="calibre33"/>;= #{[1 1] [2 4] [1 3] [2 0]}<br class="calibre33"/>(hex-step *1)<br class="calibre33"/>;= #{[1 -1] [0 2] [1 5]}<br class="calibre33"/>(hex-step *1)<br class="calibre33"/>;= #{[0 0] [1 1] [1 3] [0 4]}</tt></span></blockquote><p class="calibre23">So the four-line long <tt class="calibre22">stepper</tt><a id="filepos545424"></a> function is effectively a generic factory for all Life-like cell automata. This was possible not by getting rid of indices (since our sequence-based implementation wasn’t generic) but by profoundly changing the data structures to use sets, natural identifiers, and maps (the frequency map). It is because of this focus on sets and natural identifiers that this solution can be said to be “relational.”</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">There </span><span class="calibre10"><span class="italic">is</span></span><span class="calibre10"> a difference between </span><span class="calibre10"><tt class="calibre22">step</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">indexed-step</tt></span><span class="calibre10"> besides the generic use of data structures instead of concrete indices: the latter acts on a (finite) rectangular grid, while the former acts on an (infinite) planar grid. However, we can easily recreate </span><span class="calibre10"><tt class="calibre22">index-step</tt></span><span class="calibre10"> with </span><span class="calibre10"><tt class="calibre22">stepper</tt></span><span class="calibre10"> as well, assuming </span><span class="calibre10"><tt class="calibre22">w</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">h</tt></span><span class="calibre10"> are globally or locally bound to the width and height of the desired finite grid:</span><a id="filepos546783"></a></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(stepper #(filter (fn [[i j]] (and (&lt; -1 i w) (&lt; -1 j h)))<br class="calibre33"/>            (neighbours %)) #{2 3} #{3})</tt></span></blockquote><p id="filepos547026" class="calibre25"><span class="calibre53"><span class="bold">Maze generation</span></span></p><p id="filepos547102" class="calibre18">Let’s study another example: Wilson’s maze generation algorithm.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos547233"></a><a href="#filepos589487"><span class="calibre32">112</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">Wilson’s algorithm is a carving algorithm; it takes a fully walled “maze” and carves an actual maze out of it by removing some walls. Its principle is:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">Randomly pick a location and mark it as <span class="italic">visited</span>.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Randomly pick a location that isn’t <span class="italic">visited</span> yet—if there’s none, return the maze.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Perform a random walk starting from the newly picked location until you stumble on a location that is <span class="italic">visited</span>—if you pass through a location more than once during the random walk, always remember the direction you take to leave it.</blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17">Mark all the locations of the random walk as <span class="italic">visited</span>, and remove walls according to the last known “exit direction.”</blockquote></li><li value="5" class="calibre16"><blockquote class="calibre17">Repeat from 2.</blockquote></li></ol><p class="calibre18">Generally, maze algorithms use a matrix to represent the maze, and each item of this matrix is a bitset indicating which walls are still up. The astute reader may twitch at the idea that in such a setup, as the state of a wall is stored twice: once in each location on each side of it.</p><p class="calibre18">Wilson’s algorithm further requires you to remember the exit direction for each location, a source of further complexity when you try to cram everything into the bitset or “location state.” These are some reasons why Wilson’s algorithm is regarded as complex to implement; however, equipped with Clojure and “relational” modeling, we can minimize and eliminate much of that complexity with the help of sets, maps, and natural identifiers!</p><p class="calibre18">If we study the outline of this algorithm, we spot several entities: locations, the <span class="italic">visited</span> state, the maze itself, random walks, and exit directions. Let’s see how to best represent them in Clojure.</p><p class="calibre18">At this point it should come to no surprise that a location should simply be represented by a vector of its coordinates, <tt class="calibre22">[x y]</tt>.</p><p class="calibre18">If a location is reduced to its coordinates, how do you store that additional visited state? The answer is easy: this state is stored outside of locations because it does not belong in them; a location is just a (natural) identifier. Hence a <span class="italic">visited set</span> of locations is maintained.</p><p class="calibre18">The maze itself is made of walls, and a wall is between two locations, so a wall should be a pair of locations; <tt class="calibre22">[[0 0] [1 0]]</tt> would then denote the wall between the locations <tt class="calibre22">[0 0]</tt> and <tt class="calibre22">[1 0]</tt>. The problem is that <tt class="calibre22">[[1 0] [0 0]]</tt> represents the same wall. Since we are indifferent to the order of the locations in the pair, we should store them in a collection that is not ordered…like a set. <tt class="calibre22">#{[0 0] [1 0]}</tt> is thus a unique natural identifier for a single wall. A maze is a bunch of walls, and so naturally can be represented as a set of walls!<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos550744"></a><a href="#filepos590001"><span class="calibre32">113</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">The representation of the walk is an easy one: a walk is just a sequence of locations. Here, <span class="italic">sequence</span> is used in its broadest sense: any sequential type fits the bill, including seqs, but vectors or lists would do as well.</p><p class="calibre18">Last, exit directions: an exit direction is from the exited location to the newly entered location, thus a direction is a pair of locations <tt class="calibre22">[from to]</tt>—unlike walls, the order of locations matters, so vectors are used.</p><p class="calibre18">Now that we have defined our data structures, we can jump to the code:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn maze<br class="calibre33"/>  "Returns a random maze carved out of walls; walls is a set of<br class="calibre33"/>   2-item sets #{a b} where a and b are locations.<br class="calibre33"/>   The returned maze is a set of the remaining walls."<br class="calibre33"/>  [walls]<br class="calibre33"/>  (let [paths (reduce (fn [index [a b]]                               </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>                        (merge-with into index {a [b] b [a]}))<br class="calibre33"/>                {} (map seq walls))                                   </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>        start-loc (rand-nth (keys paths))]                            </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>    (loop [walls walls<br class="calibre33"/>           unvisited (disj (set (keys paths)) start-loc)]             </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>      (if-let [loc (when-let [s (seq unvisited)] (rand-nth s))]       </tt></span><a></a><img src="images/00001.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>        (let [walk (iterate (comp rand-nth paths) loc)                </tt></span><a></a><img src="images/00015.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>              steps (zipmap (take-while unvisited walk) (next walk))] </tt></span><a></a><img src="images/00061.jpg" class="calibre36"/><img src="images/00016.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>          (recur (reduce disj walls (map set steps))                  </tt></span><a></a><img src="images/00052.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>            (reduce disj unvisited (keys steps))))<br class="calibre33"/>        walls))))</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">paths</tt> is an index (map) from locations to adjacent locations (as vectors, see <img src="images/00015.jpg" class="calibre36"/>).</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">(map seq walls)</tt> turns walls into sequences so that they can be destructured by <tt class="calibre22">[a b]</tt>.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos554454"></a><a href="#filepos590376"><span class="calibre32">114</span></a><span class="calibre32">]</span></small></sup></blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">By construction, <tt class="calibre22">(keys path)</tt> contains all the locations, so <tt class="calibre22">rand-nth</tt> returns a random starting location for the walk.</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">Instead of maintaining the <span class="italic">visited set</span>, we are using its complement, the <span class="italic">unvisited set</span>, because writing the code with <span class="italic">visited set</span> was a bit more complex; see <img src="images/00001.jpg" class="calibre36"/> and <img src="images/00061.jpg" class="calibre36"/>.</blockquote><p class="calibre23"><img src="images/00001.jpg" class="calibre36"/></p><blockquote class="calibre37">This call to <tt class="calibre22">seq</tt> serves two purposes: ensuring the set is not empty and providing a sequential view so <tt class="calibre22">rand-nth</tt> may be used. If <span class="italic">visited</span> locations had been used instead of <span class="italic">unvisited</span>, <tt class="calibre22">(seq unvisited)</tt> would need to be replaced by <tt class="calibre22">(seq (remove visited (keys paths)))</tt>.</blockquote><p class="calibre23"><img src="images/00015.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">(iterate (comp rand-nth paths) loc)</tt> generates an infinite random walk: it takes a location, applies <tt class="calibre22">paths</tt> on it to get the vector of adjacent locations and <tt class="calibre22">rand-nth</tt> to pick one. If <tt class="calibre22">paths</tt> had returned sets instead of a sequential type (like a vector), then <tt class="calibre22">(comp rand-nth seq paths)</tt> would have been necessary instead.</blockquote><p class="calibre23"><img src="images/00061.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">(take-while unvisited walk)</tt> is the part of the random walk until (but not including) a visited location. <tt class="calibre22">(take-while unvisited walk)</tt> would be <tt class="calibre22">(take-while (complement visited) walk)</tt> if the code had been written with <tt class="calibre22">visited</tt>.</blockquote><p class="calibre23"><img src="images/00016.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">(next walk)</tt> is infinite, but <tt class="calibre22">(take-while unvisited walk)</tt> is not, so <tt class="calibre22">zipmap</tt> only looks at the <span class="italic">n</span> first items of <tt class="calibre22">(next walk)</tt> (where <span class="italic">n</span> is <tt class="calibre22">(count (take-while unvisited walk))</tt>). The <span class="italic">n</span> first items of <tt class="calibre22">(next walk)</tt> is thus the random walk without the start location and including the first <span class="italic">visited</span> location. Since the two sequences are shifted by one, each key-value pair is going to be a <span class="italic">direction</span>. Creating a map out of these pairs will only retain the most recent direction for a given key, and therefore the last exit direction. <span class="italic">Entries of the resulting map are the last exit directions</span> for each location of the random walk.</blockquote><p class="calibre23"><img src="images/00052.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">(map set steps)</tt> turn the directions (entries) into walls (sets) that we remove from the maze.</blockquote><p class="calibre18">To test this nice implementation, we need two utility functions: <tt class="calibre22">grid</tt>, which creates a fully walled maze, and <tt class="calibre22">draw</tt>, which renders the maze (in this case, to a Swing <tt class="calibre22">JFrame</tt>):</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn grid<br class="calibre33"/>  [w h]<br class="calibre33"/>  (set (concat<br class="calibre33"/>         (for [i (range (dec w)) j (range h)] #{[i j] [(inc i) j]})<br class="calibre33"/>         (for [i (range w) j (range (dec h))] #{[i j] [i (inc j)]}))))<br class="calibre33"/><br class="calibre33"/>(defn draw<br class="calibre33"/>  [w h maze]<br class="calibre33"/>  (doto (javax.swing.JFrame. "Maze")<br class="calibre33"/>    (.setContentPane<br class="calibre33"/>      (doto (proxy [javax.swing.JPanel] []<br class="calibre33"/>              (paintComponent [^java.awt.Graphics g]<br class="calibre33"/>                (let [g (doto ^java.awt.Graphics2D (.create g)<br class="calibre33"/>                          (.scale 10 10)<br class="calibre33"/>                          (.translate 1.5 1.5)<br class="calibre33"/>                          (.setStroke (java.awt.BasicStroke. 0.4)))]<br class="calibre33"/>                  (.drawRect g -1 -1 w h)<br class="calibre33"/>                  (doseq [[[xa ya] [xb yb]] (map sort maze)]<br class="calibre33"/>                    (let [[xc yc] (if (= xa xb)<br class="calibre33"/>                                    [(dec xa) ya]<br class="calibre33"/>                                    [xa (dec ya)])]<br class="calibre33"/>                      (.drawLine g xa ya xc yc))))))<br class="calibre33"/>        (.setPreferredSize (java.awt.Dimension.<br class="calibre33"/>                             (* 10 (inc w)) (* 10 (inc h))))))<br class="calibre33"/>    .pack<br class="calibre33"/>    (.setVisible true)))<br class="calibre33"/><br class="calibre33"/><br class="calibre33"/>(draw 40 40 (maze (grid 40 40)))</tt></span></blockquote><p class="calibre69"><img src="images/00026.jpg" class="calibre76"/></p><blockquote class="calibre77"></blockquote><blockquote class="calibre39"><span class="calibre10"><span class="bold">THE TRUE WILSON’S ALGORITHM</span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Actually, we fibbed: </span><span class="calibre10"><tt class="calibre22">maze</tt></span><span class="calibre10"> is not exactly an implementation of Wilson’s algorithm.</span><a id="filepos560334"></a></blockquote><blockquote class="calibre17"><span class="calibre10">In our code, when the random walk reaches a location already in the graph (maze), we add a whole tree constituted by all the locations visited during the random walk instead of just the branch of this tree going from the starting point to the end location. Obviously, our algorithm is faster since it adds more locations to the maze at once. However, the selling point of Wilson’s algorithm is that each maze has the same probability to be generated.</span></blockquote><blockquote class="calibre17"><span class="calibre10">Empirical measures (looking at the maze distribution over samples generated by both Wilson’s and our algorithms) hint that this property still holds in our variant, but we haven’t proved it formally and we haven’t computed its time complexity. This is left as an exercise to the reader.<sup class="calibre58"><small class="calibre31"><span class="calibre32">[</span><a id="filepos561257"></a><a href="#filepos590659"><span class="calibre32">115</span></a><span class="calibre32">]</span></small></sup></span></blockquote><blockquote class="calibre17"><span class="calibre10">The interesting story behind this patent lie is that we literally stumbled on this algorithm: it was just easier to write in Clojure, it was begging to be written.</span></blockquote><blockquote class="calibre17"><span class="calibre10">A true implementation of the Wilson’s algorithm is not very different, it’s only two extra lines:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(defn wmaze<br class="calibre33"/>  "The original Wilson's algorithm."<br class="calibre33"/>  [walls]<br class="calibre33"/>  (let [paths (reduce (fn [index [a b]]<br class="calibre33"/>                        (merge-with into index {a [b] b [a]}))<br class="calibre33"/>                {} (map seq walls))<br class="calibre33"/>        start-loc (rand-nth (keys paths))]<br class="calibre33"/>    (loop [walls walls unvisited (disj (set (keys paths)) start-loc)]<br class="calibre33"/>      (if-let [loc (when-let [s (seq unvisited)] (rand-nth s))]<br class="calibre33"/>        (let [walk (iterate (comp rand-nth paths) loc)<br class="calibre33"/>              steps (zipmap (take-while unvisited walk) (next walk))<br class="calibre33"/>              walk (take-while identity (iterate steps loc)) </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre21"><tt class="calibre22"><br class="calibre33"/>              steps (zipmap walk (next walk))]               </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre21"><tt class="calibre22"><br class="calibre33"/>          (recur (reduce disj walls (map set steps))<br class="calibre33"/>            (reduce disj unvisited (keys steps))))<br class="calibre33"/>        walls))))</tt></span></blockquote><blockquote class="calibre38"><img src="images/00011.jpg" class="calibre36"/><span class="calibre10">
</span></blockquote><blockquote class="calibre37"><span class="calibre10">Retraces only one “branch” of the random walk, by starting over at </span><span class="calibre10"><tt class="calibre22">loc</tt></span><span class="calibre10">.</span></blockquote><blockquote class="calibre35"><img src="images/00007.jpg" class="calibre36"/><span class="calibre10">
</span></blockquote><blockquote class="calibre37"><span class="calibre10">Turns this path into a map of </span><span class="calibre10"><tt class="calibre22">[from-loc to-loc]</tt></span><span class="calibre10"> entries.</span></blockquote><blockquote class="calibre17"><span class="calibre10">Formally speaking, Wilson’s algorithm generates random spanning trees of graphs. In the original paper,<sup class="calibre58"><small class="calibre31"><span class="calibre32">[</span><a id="filepos564020"></a><a href="#filepos590884"><span class="calibre32">116</span></a><span class="calibre32">]</span></small></sup> the pseudocode, despite being imperative, uses sets and maps—but relies on synthetic identifiers (nodes are numbered). This implementation is still succinct and clear but has been forgotten by most programmers of maze generators.</span></blockquote><p class="calibre50">As a bonus, you may have noticed that, like <tt class="calibre22">step</tt> previously, <tt class="calibre22">maze</tt> is oblivious to what constitutes a location.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos564559"></a><a href="#filepos591399"><span class="calibre32">117</span></a><span class="calibre32">]</span></small></sup> Consequently, <tt class="calibre22">maze</tt> works for any topology: hexagonal, N-dimensional, and so on. As an example of this genericity here is the grid generation and the rendering code for hexagonal mazes:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn hex-grid<br class="calibre33"/>  [w h]<br class="calibre33"/>  (let [vertices (set (for [y (range h) x (range (if (odd? y) 1 0) (* 2 w) 2)]<br class="calibre33"/>                        [x y]))<br class="calibre33"/>        deltas [[2 0] [1 1] [-1 1]]]<br class="calibre33"/>    (set (for [v vertices d deltas f [+ -]<br class="calibre33"/>               :let [w (vertices (map f v d))]<br class="calibre33"/>               :when w] #{v w}))<br class="calibre33"/><br class="calibre33"/>(defn- hex-outer-walls<br class="calibre33"/>  [w h]<br class="calibre33"/>  (let [vertices (set (for [y (range h) x (range (if (odd? y) 1 0) (* 2 w) 2)]<br class="calibre33"/>                        [x y]))<br class="calibre33"/>        deltas [[2 0] [1 1] [-1 1]]]<br class="calibre33"/>    (set (for [v vertices d deltas f [+ -]<br class="calibre33"/>               :let [w (map f v d)]<br class="calibre33"/>               :when (not (vertices w))] #{v (vec w)}))<br class="calibre33"/><br class="calibre33"/>(defn hex-draw<br class="calibre33"/>  [w h maze]<br class="calibre33"/>  (doto (javax.swing.JFrame. "Maze")<br class="calibre33"/>    (.setContentPane<br class="calibre33"/>      (doto (proxy [javax.swing.JPanel] []<br class="calibre33"/>              (paintComponent [^java.awt.Graphics g]<br class="calibre33"/>                (let [maze (into maze (hex-outer-walls w h))<br class="calibre33"/>                      g (doto ^java.awt.Graphics2D (.create g)<br class="calibre33"/>                          (.scale 10 10)<br class="calibre33"/>                          (.translate 1.5 1.5)<br class="calibre33"/>                          (.setStroke (java.awt.BasicStroke. 0.4<br class="calibre33"/>                                        java.awt.BasicStroke/CAP_ROUND<br class="calibre33"/>                                        java.awt.BasicStroke/JOIN_MITER)))<br class="calibre33"/>                      draw-line (fn [[[xa ya] [xb yb]]]<br class="calibre33"/>                                  (.draw g<br class="calibre33"/>                                    (java.awt.geom.Line2D$Double.<br class="calibre33"/>                                      xa (* 2 ya) xb (* 2 yb))))]<br class="calibre33"/>                  (doseq [[[xa ya] [xb yb]] (map sort maze)]<br class="calibre33"/>                    (draw-line<br class="calibre33"/>                      (cond<br class="calibre33"/>                        (= ya yb) [[(inc xa) (+ ya 0.4)] [(inc xa) (- ya 0.4)]]<br class="calibre33"/>                        (&lt; ya yb) [[(inc xa) (+ ya 0.4)] [xa (+ ya 0.6)]]<br class="calibre33"/>                        :else [[(inc xa) (- ya 0.4)] [xa (- ya 0.6)]]))))))<br class="calibre33"/>        (.setPreferredSize (java.awt.Dimension.<br class="calibre33"/>                             (* 20 (inc w)) (* 20 (+ 0.5 h))))))<br class="calibre33"/>    .pack<br class="calibre33"/>    (.setVisible true)))<br class="calibre33"/><br class="calibre33"/>(hex-draw 40 40 (maze (hex-grid 40 40)))</tt></span></blockquote><p class="calibre69"><img src="images/00018.jpg" class="calibre78"/></p><p class="calibre13">Porting <tt class="calibre22">maze</tt> to Java, Python, or Ruby is doable, but the result would be brittle since it would rely on mutable objects as values;<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos568461"></a><a href="#filepos591729"><span class="calibre32">118</span></a><span class="calibre32">]</span></small></sup> on such a limited example it may be fine, but on a large project it is difficult to marshal enough discipline to enforce. Alternatively, you can program defensively, and perform deep copies of input data—although this would incur inefficiencies at the module’s boundaries. Those languages are <span class="italic">viscous</span> toward this solution while Clojure is <span class="italic">viscous</span> toward imperative solutions, insofar as its defaults and foundational capabilities enable implementations like these relative to other languages.</p><p class="calibre18">Generally, when you find the code you are writing painful or awkward, you are most certainly fighting the language, working against its grain. Chances are that in such cases you’ll be able to find a more pleasant solution by rethinking your data structures. As Brooks’s quote said, code follows from data modeling, so pleasant Clojure code flows from good data representation, which so often implies natural composite identifiers, sets, and maps.<a id="filepos569549"></a></p><p id="filepos569560" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Navigation, Update, and Zippers</span></span></span></p><p id="filepos569681" class="calibre18">Since immutability precludes back references, you cannot rely on them to navigate trees. A typical functional solution to this problem is <span class="italic">zippers</span>, an implementation of which can be found in the <tt class="calibre22">clojure.zip</tt> namespace.</p><p class="calibre18">A zipper is not unlike Ariadne’s thread, which helped Theseus to find his way out of the Labyrinth after having killed the Minotaur:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos570142"></a><a href="#filepos592070"><span class="calibre32">119</span></a><span class="calibre32">]</span></small></sup> essentially, it is a stack of all nodes and node children we traverse. It is therefore a kind of cursor, both a navigation and an editing mechanism. You can move a zipper, examine the current node and position and update the tree at its current position, and then run back through your traversal path to obtain a reconstituted tree. And, just like Clojure’s collections, zippers are persistent and immutable, so moving or updating a zipper returns a new zipper and does not modify the original or the tree it is operating upon.</p><p id="filepos570771" class="calibre23"><span class="calibre53"><span class="bold">Manipulating zippers</span></span></p><p class="calibre18"><tt class="calibre22">clojure.zip</tt>
<a id="filepos570901"></a>provides a generic <tt class="calibre22">zipper</tt> factory function and three more specialized ones: <tt class="calibre22">seq-zip</tt> for nested sequences, <tt class="calibre22">vector-zip</tt> for nested vectors, and <tt class="calibre22">xml-zip</tt> for XML data represented as per <tt class="calibre22">clojure.xml</tt>. We’ll see later how to define a custom zipper; for now, our examples will use zippers created by <tt class="calibre22">vector-zip</tt>.</p><p class="calibre18">The basic functions to move a zipper are <tt class="calibre22">up</tt> (toward the root), <tt class="calibre22">down</tt> (toward the leaves), and <tt class="calibre22">left</tt> and <tt class="calibre22">right</tt> to move along siblings. There are also <tt class="calibre22">prev</tt> and <tt class="calibre22">next</tt>, which perform depth-first traversals, and <tt class="calibre22">leftmost</tt> and <tt class="calibre22">rightmost</tt> to move to the first or last sibling (but will not move the zipper if it is already at one extreme).</p><p class="calibre18">To examine the current position/node, <tt class="calibre22">clojure.zip</tt>’s functions include <tt class="calibre22">node</tt>, <tt class="calibre22">branch?</tt>, <tt class="calibre22">children</tt>, <tt class="calibre22">lefts</tt>, <tt class="calibre22">rights</tt>, and <tt class="calibre22">root</tt>, which respectively return: the current node, whether the current node is a branch,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos572031"></a><a href="#filepos592440"><span class="calibre32">120</span></a><span class="calibre32">]</span></small></sup> the child nodes (for branches), and all of the left and right siblings of the current nodes. <tt class="calibre22">root</tt> is key when modifying a tree with zippers, since it is the only way to get an updated tree changed to cumulatively reflect all of the modifications made by the zipper since its creation.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(require '[clojure.zip :as z])<br class="calibre33"/><br class="calibre33"/>(def v [[1 2 [3 4]] [5 6]])<br class="calibre33"/>;= #'user/v<br class="calibre33"/>(-&gt; v z/vector-zip z/node)<br class="calibre33"/>;= [[1 2 [3 4]] [5 6]]<br class="calibre33"/>(-&gt; v z/vector-zip z/down z/node)<br class="calibre33"/>;= [1 2 [3 4]]<br class="calibre33"/>(-&gt; v z/vector-zip z/down z/right z/node)<br class="calibre33"/>;= [5 6]</tt></span></blockquote><p class="calibre23">You can <tt class="calibre22">remove</tt> the current node, <tt class="calibre22">replace</tt> it with another, <tt class="calibre22">insert</tt> a child node at the front, or <tt class="calibre22">append</tt> it to the rear. More generally, you can <tt class="calibre22">edit</tt> a node. <tt class="calibre22">edit</tt> uses the uniform update model: in addition to the zipper, it takes a function ƒ and extra arguments; the current node is then replaced by the result of applying ƒ to itself and the extra arguments.</p><p class="calibre18">You can also create a new node based on the current position of a zipper with <tt class="calibre22">make-node</tt>. However, this node won’t be added to the final tree; for this to happen, you have to use one the above functions.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(-&gt; v z/vector-zip z/down z/right (z/replace 56) z/node)<br class="calibre33"/>;= 56<br class="calibre33"/>(-&gt; v z/vector-zip z/down z/right (z/replace 56) z/root)       </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= [[1 2 [3 4]] 56]<br class="calibre33"/>(-&gt; v z/vector-zip z/down z/right z/remove z/node)             </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= 4<br class="calibre33"/>(-&gt; v z/vector-zip z/down z/right z/remove z/root)<br class="calibre33"/>;= [[1 2 [3 4]]]<br class="calibre33"/>(-&gt; v z/vector-zip z/down z/down z/right (z/edit * 42) z/root) </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= [[1 84 [3 4]] [5 6]]</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">z/vector-zip</tt> and <tt class="calibre22">z/root</tt> together act like boundaries of a “transaction.”</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">z/remove</tt> moves the zipper to the previous location in a depth-first walk.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">The <tt class="calibre22">2</tt> node is multiplied by 42.</blockquote><p class="calibre18">That’s nearly<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos575209"></a><a href="#filepos592749"><span class="calibre32">121</span></a><span class="calibre32">]</span></small></sup> all that is to know about the zipper API. We can now study how we can create custom zippers, and see how it can help us in our mazes.</p><p id="filepos575442" class="calibre23"><span class="calibre53"><span class="bold">Custom zippers</span></span></p><p id="filepos575517" class="calibre18">Zippers are in general created using the <tt class="calibre22">zipper</tt> function, which accepts three functions, followed by the root node of the structure to which the zipper will be applied:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">A predicate that returns true if a node <span class="italic">can</span> have children.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">A function that, given a branch node, returns a seq of its children.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">A function that returns a new branch node, given an existing node and a seq of children.</blockquote></li></ul><p class="calibre18">Let’s try to implement a zipper for a custom data schema: vectors representing HTML elements. The first item is the tag name, the second may be the attributes map, and the remaining ones are children, including text nodes as strings. Hence <tt class="calibre22">[:h1 "zipper"]</tt> and <tt class="calibre22">[:a {:href "http://clojure.org/"} "Clojure"]</tt> are both valid nodes. This schema is just irregular enough to make its <tt class="calibre22">zipper</tt> implementation interesting:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn html-zip [root]<br class="calibre33"/>  (z/zipper<br class="calibre33"/>    vector?<br class="calibre33"/>    (fn [[tagname &amp; xs]]<br class="calibre33"/>      (if (map? (first xs)) (next xs) xs))<br class="calibre33"/>    (fn [[tagname &amp; xs] children]<br class="calibre33"/>      (into (if (map? (first xs)) [tagname (first xs)] [tagname])<br class="calibre33"/>        children))<br class="calibre33"/>    root))</tt></span></blockquote><p class="calibre23">On top of generic zipper functions, we can create helper domain-specific functions such as <tt class="calibre22">wrap</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn wrap<br class="calibre33"/>  "Wraps the current node in the specified tag and attributes."<br class="calibre33"/>  ([loc tag]<br class="calibre33"/>    (z/edit loc #(vector tag %)))<br class="calibre33"/>  ([loc tag attrs]<br class="calibre33"/>    (z/edit loc #(vector tag attrs %))))<br class="calibre33"/><br class="calibre33"/>(def h [:body [:h1 "Clojure"]<br class="calibre33"/>              [:p "What a wonderful language!"]])<br class="calibre33"/>;= #'user/h<br class="calibre33"/>(-&gt; h html-zip z/down z/right z/down (wrap :b) z/root)<br class="calibre33"/>;= [:body [:h1 "Clojure"] [:p [:b "What a wonderful language!"]]]</tt></span></blockquote><p class="calibre23">Creating custom zippers for nested data structures is not difficult. However, we can also create read-only<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos578150"></a><a href="#filepos593066"><span class="calibre32">122</span></a><span class="calibre32">]</span></small></sup> zippers on hierarchical data stored in a nonhierarchical manner—for example, like the mazes we created in <a href="#filepos547026"><span class="calibre5">Maze generation</span></a>. In such cases, the key is that the arguments to <tt class="calibre22">zipper</tt> are closures over the data structure, and nodes are the natural identifiers into that data structure.</p><p id="filepos578595" class="calibre23"><span class="calibre53"><span class="bold">Ariadne’s zipper</span></span></p><p id="filepos578674" class="calibre18">Speaking of mazes and epic adventures, what about literally using a zipper as Ariadne’s thread and helping Theseus use it to keep track of his traversal of the labyrinth?</p><p class="calibre18">To set the stage, we need a labyrinth:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def labyrinth (maze (grid 10 10)))</tt></span></blockquote><p class="calibre23">But this labyrinth is full of walls while we are only interested in passages—or missing walls:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def labyrinth (let [g (grid 10 10)] (reduce disj g (maze g))))</tt></span></blockquote><p class="calibre23">Let’s add the characters:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def theseus (rand-nth (distinct (apply concat labyrinth))))<br class="calibre33"/>(def minotaur (rand-nth (distinct (apply concat labyrinth))))</tt></span></blockquote><p class="calibre23"><tt class="calibre22">[(rand-int 10) (rand-int 10)]</tt> would have been effective but at the cost of introducing coupling between the <tt class="calibre22">labyrinth</tt> definition and the characters’ locations.</p><p class="calibre18">At first glance, it may seem that a location is enough to identify the position of Theseus while he’s searching for the minotaur. However, that’s not enough: we have to remember where we came from so we can distinguish between the passages leading to new unvisited rooms and the one Theseus just came out from. We need a direction, which is best represented as a pair of locations.</p><p class="calibre18">So, our Ariadne’s zipper is going to have directions as nodes:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn ariadne-zip<br class="calibre33"/>  [labyrinth loc]<br class="calibre33"/>  (let [paths (reduce (fn [index [a b]]<br class="calibre33"/>                        (merge-with into index {a [b] b [a]}))<br class="calibre33"/>                {} (map seq labyrinth))<br class="calibre33"/>        children (fn [[from to]]<br class="calibre33"/>                   (seq (for [loc (paths to)                    </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>                              :when (not= loc from)]<br class="calibre33"/>                          [to loc])))]<br class="calibre33"/>    (z/zipper (constantly true)                                 </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>      children<br class="calibre33"/>      nil                                                       </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>      [nil loc])))                                              </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">zipper</tt> documentation requires the <tt class="calibre22">children</tt> function passed as argument to return a <span class="italic">seq</span> and not any sequential type, so <tt class="calibre22">seq</tt> should be called on its return value.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">We use <tt class="calibre22">(constantly true)</tt> as our branch predicate, since all locations potentially lead to other ones.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">nil</tt> is provided as the node factory function, since this zipper is purely navigational: it can’t perform updates.</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">[nil loc]</tt> is the initial direction, the root of Theseus’s exploration.</blockquote><p class="calibre18">Now we just have to perform a depth-first walk of the maze to find the path to the Minotaur:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(-&gt;&gt; theseus<br class="calibre33"/>     (ariadne-zip labyrinth)<br class="calibre33"/>     (iterate z/next)<br class="calibre33"/>     (filter #(= minotaur (second (z/node %))))<br class="calibre33"/>     first z/path<br class="calibre33"/>     (map second))<br class="calibre33"/>([3 9] [4 9] [4 8] [4 7] [4 6] [5 7] [5 6] [5 5] [5 4]<br class="calibre33"/> [5 8] [6 8] [6 7] [6 6] [6 5] [7 6] [8 6] [9 6] [9 5]<br class="calibre33"/> [9 4] [9 3] [9 2] [9 1] [9 0] [8 2] [8 1] [8 0] [7 0]<br class="calibre33"/> [6 0] [7 1] [7 2] [6 2] [6 1] [5 1] [4 1] [4 0] [5 0]<br class="calibre33"/> [3 0] [4 2] [5 2] [3 2] [3 3] [4 3] [4 4] [4 5] [3 5])</tt></span></blockquote><p class="calibre23">After the minotaur is slaughtered, Theseus can thus find his way back to his starting point!</p><p class="calibre18">We can visualize the whole story; the first step is modifying <tt class="calibre22">draw</tt> to accommodate an extra argument: the actual path from Theseus to the Minotaur.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn draw<br class="calibre33"/>  [w h maze path]<br class="calibre33"/>  (doto (javax.swing.JFrame. "Maze")<br class="calibre33"/>   (.setContentPane<br class="calibre33"/>     (doto (proxy [javax.swing.JPanel] []<br class="calibre33"/>             (paintComponent [^java.awt.Graphics g]<br class="calibre33"/>               (let [g (doto ^java.awt.Graphics2D (.create g)<br class="calibre33"/>                         (.scale 10 10)<br class="calibre33"/>                         (.translate 1.5 1.5)<br class="calibre33"/>                         (.setStroke (java.awt.BasicStroke. 0.4)))]<br class="calibre33"/>                 (.drawRect g -1 -1 w h)<br class="calibre33"/>                 (doseq [[[xa ya] [xb yb]] (map sort maze)]<br class="calibre33"/>                   (let [[xc yc] (if (= xa xb)<br class="calibre33"/>                                   [(dec xa) ya]<br class="calibre33"/>                                   [xa (dec ya)])]<br class="calibre33"/>                     (.drawLine g xa ya xc yc)))<br class="calibre33"/>                 (.translate g -0.5 -0.5)<br class="calibre33"/>                 (.setColor g java.awt.Color/RED)<br class="calibre33"/>                 (doseq [[[xa ya] [xb yb]] path] </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>                   (.drawLine g xa ya xb yb)))))<br class="calibre33"/>       (.setPreferredSize (java.awt.Dimension.<br class="calibre33"/>                             (* 10 (inc w)) (* 10 (inc h))))))<br class="calibre33"/>   .pack<br class="calibre33"/>   (.setVisible true)))</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">The <tt class="calibre22">path</tt> is expected to be a collection of location pairs, so it differs from the path previously computed where only the locations were returned thanks to the <tt class="calibre22">(map second)</tt> step.</blockquote><p class="calibre18">Now we can tell the whole mythical story, narrated and visualized in Clojure:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [w 40, h 40<br class="calibre33"/>      grid (grid w h)<br class="calibre33"/>      walls (maze grid)<br class="calibre33"/>      labyrinth (reduce disj grid walls)<br class="calibre33"/>      places (distinct (apply concat labyrinth))<br class="calibre33"/>      theseus (rand-nth places)<br class="calibre33"/>      minotaur (rand-nth places)<br class="calibre33"/>      path (-&gt;&gt; theseus<br class="calibre33"/>             (ariadne-zip labyrinth)<br class="calibre33"/>             (iterate z/next)<br class="calibre33"/>             (filter #(= minotaur (first (z/node %))))<br class="calibre33"/>             first z/path rest)] </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  (draw w h walls path))</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">A <tt class="calibre22">rest</tt> replaces the <tt class="calibre22">(map second)</tt> because the first pair of locations is irregular from initializing <tt class="calibre22">ariadne-zip</tt> with <tt class="calibre22">[nil theseus]</tt>.<a id="filepos587550"></a></blockquote><blockquote class="calibre39"><img src="images/00029.jpg" class="calibre79"/></blockquote><br class="calibre33"/><hr class="calibre34"/><p class="calibre80"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos587799"></a><a href="#filepos519614"><span class="calibre32">108</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">The </span><span class="calibre10"><tt class="calibre22">clojure.set</tt></span><span class="calibre10"> namespace is an implementation of the relational algebra’s operators.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos588124"></a><a href="#filepos524885"><span class="calibre32">109</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">This questioning about identifying the identities of a system and their boundaries is closely related to the concerns of </span><span class="calibre10"><span class="italic">domain-driven design</span></span><span class="calibre10">, explored in </span><span class="calibre10"><span class="italic">Domain-Driven Design: Tackling Complexity in the Heart of Software</span></span><span class="calibre10"> (Addison-Wesley Professional) by Eric Evans.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos588677"></a><a href="#filepos535042"><span class="calibre32">110</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">In other words, the result of a </span><span class="calibre10"><tt class="calibre22">map</tt></span><span class="calibre10"> is as long as the shortest of its arguments; so if one of the arguments is </span><span class="calibre10"><tt class="calibre22">nil</tt></span><span class="calibre10"> or empty, </span><span class="calibre10"><tt class="calibre22">map</tt></span><span class="calibre10"> will return an empty sequence.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos589180"></a><a href="#filepos540832"><span class="calibre32">111</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">This is on par with array processing languages such as APL or J, despite the implementation being fundamentally different.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos589487"></a><a href="#filepos547233"><span class="calibre32">112</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">For those interested in maze generators, there is a great illustrated blog post series by Jamis Buck at </span><a href="http://weblog.jamisbuck.org/2011/2/7/maze-generation-algorithm-recap"><span class="calibre10"><span class="calibre5">http://weblog.jamisbuck.org/2011/2/7/maze-generation-algorithm-recap</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos590001"></a><a href="#filepos550744"><span class="calibre32">113</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">A maze is then a set of two-item sets of locations. Don’t let data structure vertigo makes your head spin: don’t look into the depth of the nesting, think about only one level at a time.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos590376"></a><a href="#filepos554454"><span class="calibre32">114</span></a><span class="calibre32">] </span></small></sup><span class="calibre10"><tt class="calibre22">[&amp; [a b]]</tt></span><span class="calibre10"> is able to directly destructure sets but feels hacky.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos590659"></a><a href="#filepos561257"><span class="calibre32">115</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">We are interested in the answers though!</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos590884"></a><a href="#filepos564020"><span class="calibre32">116</span></a><span class="calibre32">] </span></small></sup><span class="calibre10"><span class="italic">Generating Random Spanning Trees More Quickly than the Cover Time</span></span><span class="calibre10"> by David Bruce Wilson </span><a href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.47.8598"><span class="calibre10"><span class="calibre5">http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.47.8598</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos591399"></a><a href="#filepos564559"><span class="calibre32">117</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">As long as it’s not a </span><span class="calibre10"><tt class="calibre22">nil</tt></span><span class="calibre10"> or a </span><span class="calibre10"><tt class="calibre22">false</tt></span><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos591729"></a><a href="#filepos568461"><span class="calibre32">118</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">This could be mitigated with extensive use of </span><span class="calibre10"><tt class="calibre22">freeze</tt></span><span class="calibre10"> in Ruby or unmodifiable wrappers as found in Java.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos592070"></a><a href="#filepos570142"><span class="calibre32">119</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="https://en.wikipedia.org/wiki/Ariadne"><span class="calibre10"><span class="calibre5">https://en.wikipedia.org/wiki/Ariadne</span></span></a><span class="calibre10"> for the mythology.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos592440"></a><a href="#filepos572031"><span class="calibre32">120</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">A branch is a node that </span><span class="calibre10"><span class="italic">may</span></span><span class="calibre10"> have children: a branch can have no children.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos592749"></a><a href="#filepos575209"><span class="calibre32">121</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">We didn’t mention </span><span class="calibre10"><tt class="calibre22">end?</tt></span><span class="calibre10"> to test when the end of a depth-first walk is reached.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos593066"></a><a href="#filepos578150"><span class="calibre32">122</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Read-write is possible but more complex.</span></p><div class="mbppagebreak"></div><p id="filepos593244" class="calibre6"><span class="calibre4"><span class="bold">In Summary</span></span></p><p class="calibre18">Clojure’s collection abstractions and data structure implementations sit at the very heart of the language and dictate its capabilities, character, and worldview more than nearly anything else. Understanding their semantics, mechanics, and idiomatic usage allows you to wring the most out of functional programming within Clojure on a daily basis, and enables you to better understand all the other parts of Clojure that depend upon them.<a id="filepos593783"></a></p><div class="mbppagebreak"></div><p id="filepos593810" class="calibre6"><span class="calibre2"><span class="bold">Chapter 4. Concurrency and Parallelism</span></span></p><p id="filepos593911" class="calibre13">Writing multithreaded programs is one of the most difficult tasks many programmers will face. They are difficult to reason about, and often exhibit nondeterministic behavior: a typical program that utilizes concurrency facilities will sometimes yield different results given the same inputs, a result of ill-defined execution order that can additionally produce race conditions and deadlocks. Some of these conditions are hard to detect, and none of them are easy to debug.</p><p class="calibre18">Most languages give us paltry few resources to cope with the cognitive burden of concurrency. Threads and locks, in all their forms, are often the only real tools at our disposal, and we are often victims of how difficult they are to use properly and efficiently. In which order should locks be acquired and released? Does a reader have to acquire a lock to read a value another thread might be writing to? How can multithreaded programs that rely upon locks be comprehensively tested? Complexity spirals out of control in a hurry; meanwhile, you are left debugging a race condition that only occurs in production or a deadlock that happens on <span class="italic">this</span> machine, but not <span class="italic">that</span> one.</p><p class="calibre18">Considering how low-level they are, the continued reliance upon threads, locks, and pale derivatives as the sole “user-facing” solution to the varied complexities of concurrency is a remarkable contrast to the never-ending stampede of activity seen over the years in developing more effective and less error-prone abstractions. Clojure’s response to this has many facets:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">As we discussed in <a href="#filepos215673"><span class="calibre5">Chapter 2</span></a>, minimize the amount of mutable state in your programs, with the help of immutable values and collections with reliable semantics and efficient operations.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">When you do need to manage changing state over time and in conjunction with concurrent threads of execution, isolate that state and constrain the ways in which that state can be changed. This is the basis of Clojure’s <span class="italic">reference types</span>, which we’ll discuss shortly.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">When you absolutely have no other choice—and are willing to shrug off the benefits of the semantic guarantees of Clojure’s reference types—make it straightforward to drop back to bare locks, threads, and the high-quality concurrency APIs provided by Java.</blockquote></li></ol><p class="calibre18">Clojure provides no silver bullet that makes concurrent programming instantly trivial, but it does provide some novel and now battle-tested tools to makes it far more tractable and reliable.</p><p id="filepos596870" class="calibre6"><span class="calibre4"><span class="bold">Shifting Computation Through Time and Space</span></span></p><p id="filepos596974" class="calibre18">Clojure provides a number of entities—delays, futures, and promises—that encapsulate discrete use cases for controlling when and how computations are performed. While only futures are solely concerned with concurrency, they are all often used to help implement specific concurrent semantics and mechanics.</p><p id="filepos597315" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Delays</span></span></span></p><p class="calibre18">A <span class="italic">delay</span> is a construct that suspends some body of code, evaluating it only upon demand, when it is <tt class="calibre22">deref</tt><a id="filepos597559"></a>erenced:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def d (delay (println "Running...")<br class="calibre33"/>              :done!))<br class="calibre33"/>;= #'user/d<br class="calibre33"/>(deref d)<br class="calibre33"/>; Running...<br class="calibre33"/>;= :done!</tt></span></blockquote><blockquote id="filepos597825" class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">The </span><span class="calibre10"><tt class="calibre22">deref</tt></span><span class="calibre10"> abstraction is defined by Clojure’s </span><span class="calibre10"><tt class="calibre22">clojure.lang.IDeref</tt></span><span class="calibre10"> interface; any type that implements it acts as a container for a value. It may be dereferenced, either via </span><span class="calibre10"><tt class="calibre22">deref</tt></span><span class="calibre10">, or the corresponding reader syntax, </span><a id="filepos598386"></a><span class="calibre10"><tt class="calibre22">@</tt></span><span class="calibre10">.<sup class="calibre58"><small class="calibre31"><span class="calibre32">[</span><a id="filepos598476"></a><a href="#filepos616526"><span class="calibre32">123</span></a><span class="calibre32">]</span></small></sup> Many Clojure entities are dereferenceable, including delays, futures, promises, and all reference types, atoms, refs, agents, and vars. We talk about them all in this chapter.</span></blockquote><p class="calibre25">You can certainly accomplish the same sort of thing just by using functions:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def a-fn (fn []<br class="calibre33"/>            (println "Running...")<br class="calibre33"/>            :done!))<br class="calibre33"/>;= #'user/a-fn<br class="calibre33"/>(a-fn)<br class="calibre33"/>; Running...<br class="calibre33"/>;= :done!</tt></span></blockquote><p class="calibre23">However, delays provide a couple of compelling advantages.</p><p class="calibre18">Delays only evaluate their body of code <span class="italic">once</span>, caching the return value. Thus, subsequent accesses using <tt class="calibre22">deref</tt> will return instantly, and not reevaluate that code:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos599483"></a><a href="#filepos617141"><span class="calibre32">124</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">@d<br class="calibre33"/>;= :done!</tt></span></blockquote><p class="calibre23">A corollary to this is that multiple threads can safely attempt to dereference a delay for the first time; all of them will block until the delay’s code is evaluated (only once!), and a value is available.</p><p class="calibre18">When you may want to provide a value that contains some expensive-to-produce or optional data, you can use delays as useful (if crude) optimization mechanisms, where the end “user” of the value can opt into the costs associated with that data.</p><p id="filepos600202" class="calibre23"></p><p class="calibre23"><span class="italic">Example 4-1. Offering opt-in computation with a delay</span><a id="filepos600324"></a></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(defn get-document<br class="calibre33"/>  [id]<br class="calibre33"/>  ; ... do some work to retrieve the identified document's metadata ...<br class="calibre33"/>  {:url "http://www.mozilla.org/about/manifesto.en.html"<br class="calibre33"/>   :title "The Mozilla Manifesto"<br class="calibre33"/>   :mime "text/html"<br class="calibre33"/>   :content (delay (slurp "http://www.mozilla.org/about/manifesto.en.html"))}) </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #'user/get-document<br class="calibre33"/>(def d (get-document "some-id"))<br class="calibre33"/>;= #'user/d<br class="calibre33"/>d<br class="calibre33"/>;= {:url "http://www.mozilla.org/about/manifesto.en.html",<br class="calibre33"/>;=  :title "The Mozilla Manifesto",<br class="calibre33"/>;=  :mime "text/html",<br class="calibre33"/>;=  :content #&lt;Delay@2efb541d: :pending&gt;}                                      </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/></p><p class="calibre23"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">We can use <tt class="calibre22">delay</tt> to cheaply suspend some potentially costly code or optional data.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">That <tt class="calibre22">delay</tt>’s code will remain unevaluated until we (or our code’s caller) opt to dereference its value.</blockquote><p class="calibre13">Some parts of our program may be perfectly satisfied with the metadata <a id="filepos601955"></a>associated with a document and not require its content at all, and so can avoid the costs associated with retrieving that content. On the other hand, other parts of our application may absolutely require the content, and still others might make use of it <span class="italic">if it is already available</span>. This latter use case is made possible with <tt class="calibre22">realized?</tt><a id="filepos602313"></a>, which polls a delay to see if its value has been materialized yet:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(realized? (:content d))<br class="calibre33"/>;= false<br class="calibre33"/>@(:content d)<br class="calibre33"/>;= "&lt;!DOCTYPE html&gt;&lt;html&gt;..."<br class="calibre33"/>(realized? (:content d))<br class="calibre33"/>;= true</tt></span></blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Note that </span><span class="calibre10"><tt class="calibre22">realized?</tt></span><span class="calibre10"> may also be used with futures, promises, and lazy sequences.</span></blockquote><p class="calibre25"><tt class="calibre22">realized?</tt> allows you to immediately use data provided by a delay that has already been dereferenced, but perhaps opt out of forcing the evaluation of a delay if you know that doing so will be too expensive an operation than you’re willing to allow at that point in time and can do without its eventual value.</p><p id="filepos603325" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Futures</span></span></span></p><p id="filepos603422" class="calibre18">Before getting to more sophisticated topics like reference types, Clojure programmers often start off asking, “How do I start a new thread and run some code in it?” Now, you can use the JVM’s native threads if you <span class="italic">have</span> to (see <a href="#filepos826361"><span class="calibre5">Using Java’s Concurrency Primitives</span></a>), but Clojure provides a kinder, gentler option in futures.</p><p class="calibre18">A Clojure <span class="italic">future</span> evaluates a body of code in another thread:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos603976"></a><a href="#filepos617433"><span class="calibre32">125</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def long-calculation (future (apply + (range 1e8))))<br class="calibre33"/>;= #'user/long-calculation</tt></span></blockquote><p class="calibre23"><tt class="calibre22">future</tt> returns immediately, allowing the current thread of execution (such as your REPL) to carry on. The result of evaluation will be retained by the future, which you can obtain by dereferencing it:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">@long-calculation<br class="calibre33"/>;= 4999999950000000</tt></span></blockquote><p class="calibre23">Just like a delay, dereferencing a future will block if the code it is evaluating has not completed yet; thus, this expression will block the REPL for five seconds before returning:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">@(future (Thread/sleep 5000) :done!)<br class="calibre33"/>;= :done!</tt></span></blockquote><p class="calibre23">Also like delays, futures retain the value their body of code evaluated to, so subsequent accesses via <tt class="calibre22">deref</tt><a id="filepos605116"></a> will return that value immediately.</p><p class="calibre18">Unlike delays, you can provide a timeout and a “timeout value” when dereferencing a future, the latter being what <tt class="calibre22">deref</tt> will return if the specified timeout is reached:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos605407"></a><a href="#filepos617772"><span class="calibre32">126</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(deref (future (Thread/sleep 5000) :done!)<br class="calibre33"/>       1000<br class="calibre33"/>       :impatient!)<br class="calibre33"/>;= :impatient!</tt></span></blockquote><p class="calibre23">Futures are often used as a device to simplify the usage of APIs that perform some concurrent aspect to their operation. For example, say we knew that all users of the <tt class="calibre22">get-document</tt> function from <a href="#filepos600202"><span class="calibre5">Example 4-1</span></a> would need the <tt class="calibre22">:content</tt> value. Our first impulse might be to synchronously retrieve the document’s <tt class="calibre22">:content</tt> within the scope of the <tt class="calibre22">get-document</tt> call, but this would make every caller wait until that content is retrieved fully, even if the caller doesn’t need the content immediately. Instead, we can use a future for the value of <tt class="calibre22">:content</tt>; this starts the retrieval of the content in another thread right away, allowing the caller to get back to work without blocking on that I/O. When the <tt class="calibre22">:content</tt> value is later dereferenced for use, it is likely to block for less time (if any), since the content retrieval had already been in motion.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn get-document<br class="calibre33"/>  [id]<br class="calibre33"/>  ; ... do some work to retrieve the identified document's metadata ...<br class="calibre33"/>  {:url "http://www.mozilla.org/about/manifesto.en.html"<br class="calibre33"/>   :title "The Mozilla Manifesto"<br class="calibre33"/>   :mime "text/html"<br class="calibre33"/>   :content (future (slurp "http://www.mozilla.org/about/manifesto.en.html"))}) </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">The only change from <a href="#filepos600202"><span class="calibre5">Example 4-1</span></a> is replacing <tt class="calibre22">delay</tt> with <tt class="calibre22">future</tt>.</blockquote><p class="calibre18">This requires no change on the part of clients (since they continue to be interested only in dereferencing the value of <tt class="calibre22">:content</tt>), but if callers are likely to always require that data, this small change can prove to be a significant improvement in throughput.</p><p class="calibre18">Futures carry a couple of advantages compared to starting up a native thread to run some code:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">Clojure futures are evaluated within a thread pool that is shared with potentially blocking agent actions (which we discuss in <a href="#filepos768750"><span class="calibre5">Agents</span></a>). This pooling of resources can make futures more efficient than creating native threads as needed.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Using <tt class="calibre22">future</tt> is much more concise than setting up and starting a native thread.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Clojure futures (the value returned by <tt class="calibre22">future</tt>) are instances of <tt class="calibre22">java.util.concurrent.Future</tt>, which can make it easier to interoperate with Java APIs that expect them.</blockquote></li></ol><p id="filepos608843" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Promises</span></span></span></p><p id="filepos608941" class="calibre18">Promises share many of the mechanics of delays and futures: a promise may be dereferenced with an optional timeout, dereferencing a promise will block until it has a value to provide, and a promise will only ever have one value. However, promises are distinct from delays and futures insofar as they are not created with any code or function that will eventually define its value:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def p (promise))<br class="calibre33"/>;= #'user/p</tt></span></blockquote><p class="calibre23"><tt class="calibre22">promise</tt> is initially a barren container; at some later point in time, the promise may be fulfilled by having a value <tt class="calibre22">deliver</tt>ed to it:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(realized? p)<br class="calibre33"/>;= false<br class="calibre33"/>(deliver p 42)<br class="calibre33"/>;= #&lt;core$promise$reify__1707@3f0ba812: 42&gt;<br class="calibre33"/>(realized? p)<br class="calibre33"/>;= true<br class="calibre33"/>@p<br class="calibre33"/>;= 42</tt></span></blockquote><p class="calibre23">Thus, a promise is similar to a one-time, single-value pipe: data is inserted at one end via <tt class="calibre22">deliver</tt> and retrieved at the other end by <tt class="calibre22">deref</tt>. Such things are sometimes called <span class="italic">dataflow variables</span><a id="filepos610167"></a> and are the building blocks of <span class="italic">declarative concurrency</span><a id="filepos610236"></a>. This is a strategy where relationships between concurrent processes are explicitly defined such that derivative results are calculated on demand as soon as their inputs are available, leading to deterministic behavior. A simple example would involve three promises:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def a (promise))<br class="calibre33"/>(def b (promise))<br class="calibre33"/>(def c (promise))</tt></span></blockquote><p class="calibre23">We can specify how these promises are related by creating a future that uses (yet to be delivered) values from some of the promises in order to calculate the value to be delivered to another:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(future<br class="calibre33"/>  (deliver c (+ @a @b))<br class="calibre33"/>  (println "Delivery complete!"))</tt></span></blockquote><p class="calibre23">In this case, the value of <tt class="calibre22">c</tt> will not be delivered until both <tt class="calibre22">a</tt> and <tt class="calibre22">b</tt> are available (i.e., <tt class="calibre22">realized?</tt>); until that time, the future that will <tt class="calibre22">deliver</tt> the value to <tt class="calibre22">c</tt> will block on dereferencing <tt class="calibre22">a</tt> and <tt class="calibre22">b</tt>. Note that attempting to dereference <tt class="calibre22">c</tt> (without a timeout) with the promises in this state will block your REPL thread indefinitely.</p><p class="calibre18">In most cases of dataflow programming, other threads will be at work doing whatever computation that will eventually result in the delivery of values to <tt class="calibre22">a</tt> and <tt class="calibre22">b</tt>. We can short-circuit the process by delivering values from the REPL;<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos611821"></a><a href="#filepos618069"><span class="calibre32">127</span></a><span class="calibre32">]</span></small></sup> as soon as both <tt class="calibre22">a</tt> and <tt class="calibre22">b</tt> have values, the future will unblock on dereferencing them and will be able to deliver the final value to <tt class="calibre22">c</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(deliver a 15)<br class="calibre33"/>;= #&lt;core$promise$reify__5727@56278e83: 15&gt;<br class="calibre33"/>(deliver b 16)<br class="calibre33"/>; Delivery complete!<br class="calibre33"/>;= #&lt;core$promise$reify__5727@47ef7de4: 16&gt;<br class="calibre33"/>@c<br class="calibre33"/>;= 31</tt></span></blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">PROMISES DON’T DETECT CYCLIC DEPENDENCIES</span></span></span></blockquote><blockquote id="filepos612543" class="calibre17"><span class="calibre10">This means that </span><span class="calibre10"><tt class="calibre22">(deliver p @p)</tt></span><span class="calibre10">, where </span><span class="calibre10"><tt class="calibre22">p</tt></span><span class="calibre10"> is a promise, will block indefinitely.</span></blockquote><blockquote class="calibre17"><span class="calibre10">However, such blocked promises are not locked down, and the situation can be resolved:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(def a (promise))<br class="calibre33"/>(def b (promise))<br class="calibre33"/>(future (deliver a @b))  </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre21"><tt class="calibre22"><br class="calibre33"/>(future (deliver b @a))<br class="calibre33"/>(realized? a)            </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre21"><tt class="calibre22"><br class="calibre33"/>;= false<br class="calibre33"/>(realized? b)<br class="calibre33"/>;= false<br class="calibre33"/>(deliver a 42)           </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre21"><tt class="calibre22"><br class="calibre33"/>;= #&lt;core$promise$reify__5727@6156f1b0: 42&gt;<br class="calibre33"/>@a<br class="calibre33"/>;= 42<br class="calibre33"/>@b<br class="calibre33"/>;= 42</tt></span></blockquote><blockquote class="calibre38"><img src="images/00011.jpg" class="calibre36"/><span class="calibre10">
</span></blockquote><blockquote class="calibre37"><span class="calibre10">Futures are used there to not block the REPL.</span></blockquote><blockquote class="calibre35"><img src="images/00007.jpg" class="calibre36"/><span class="calibre10">
</span></blockquote><blockquote class="calibre37"><span class="calibre10"><tt class="calibre22">a</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">b</tt></span><span class="calibre10"> are not delivered yet.</span></blockquote><blockquote class="calibre35"><img src="images/00003.jpg" class="calibre36"/><span class="calibre10">
</span></blockquote><blockquote class="calibre37"><span class="calibre10">Delivering </span><span class="calibre10"><tt class="calibre22">a</tt></span><span class="calibre10"> allows the blocked deliveries to resume—obviously </span><span class="calibre10"><tt class="calibre22">(deliver a @b)</tt></span><span class="calibre10"> is going to fail (to return </span><span class="calibre10"><tt class="calibre22">nil</tt></span><span class="calibre10">) but </span><span class="calibre10"><tt class="calibre22">(deliver b @a)</tt></span><span class="calibre10"> proceeds happily.</span></blockquote><p class="calibre25">An immediately practical application of promises is in easily making callback-based APIs synchronous. Say you have a function that takes another function as a callback:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn call-service<br class="calibre33"/>  [arg1 arg2 callback-fn]<br class="calibre33"/>  ; ...perform service call, eventually invoking callback-fn with results...<br class="calibre33"/>  (future (callback-fn (+ arg1 arg2) (- arg1 arg2))))</tt></span></blockquote><p class="calibre23">Using this function’s results in a synchronous body of code requires providing a callback, and then using any number of different (relatively unpleasant) techniques to wait for the callback to be invoked with the results. Alternatively, you can write a simple wrapper on top of the asynchronous, callback-based API that uses a promise’s blocking behavior on <tt class="calibre22">deref</tt> to enforce the synchronous semantics for you. Assuming for the moment that all of the asynchronous functions you’re interested in take the callback as their last argument, this can be implemented as a general-purpose higher-order function:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn sync-fn<br class="calibre33"/>  [async-fn]<br class="calibre33"/>  (fn [&amp; args]<br class="calibre33"/>    (let [result (promise)]<br class="calibre33"/>      (apply async-fn (conj (vec args) #(deliver result %&amp;)))<br class="calibre33"/>      @result)))<br class="calibre33"/><br class="calibre33"/>((sync-fn call-service) 8 7)<br class="calibre33"/>;= (15 1)</tt></span></blockquote><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos616526"></a><a href="#filepos598476"><span class="calibre32">123</span></a><span class="calibre32">] </span></small></sup><span class="calibre10"><tt class="calibre22">@foo</tt></span><span class="calibre10"> is nearly always preferred to </span><span class="calibre10"><tt class="calibre22">(deref foo)</tt></span><span class="calibre10">, except when using </span><span class="calibre10"><tt class="calibre22">deref</tt></span><span class="calibre10"> with higher-order functions (to, for example, dereference all of the delays in a sequence) or using </span><span class="calibre10"><tt class="calibre22">deref</tt></span><span class="calibre10">’s timeout feature, available only with promises and futures.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos617141"></a><a href="#filepos599483"><span class="calibre32">124</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">And, therefore, not cause any potential side effects associated with the code provided to create the delay.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos617433"></a><a href="#filepos603976"><span class="calibre32">125</span></a><span class="calibre32">] </span></small></sup><span class="calibre10"><tt class="calibre22">future-call</tt></span><span class="calibre10"> is also available if you happen to have a zero-argument function you’d like to have called in another thread.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos617772"></a><a href="#filepos605407"><span class="calibre32">126</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">This option is not available when using the </span><span class="calibre10"><tt class="calibre22">@</tt></span><span class="calibre10"> reader sugar.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos618069"></a><a href="#filepos611821"><span class="calibre32">127</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Which, technically, </span><span class="calibre10"><span class="italic">is</span></span><span class="calibre10"> in another thread!</span></p><div class="mbppagebreak"></div><p id="filepos618299" class="calibre6"><span class="calibre4"><span class="bold">Parallelism on the Cheap</span></span></p><p id="filepos618384" class="calibre18">We’ll be examining all of Clojure’s flexible concurrency facilities in a bit, one of which—agents—can be used to orchestrate very efficient parallelization of workloads. However, sometimes you may find yourself wanting to parallelize some operation with as little ceremony as possible.</p><blockquote class="calibre38"></blockquote><blockquote class="calibre39"><span class="calibre10"><span class="bold">PARALLELISM VERSUS CONCURRENCY</span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Lest our discussion of concurrency and parallelism lead you to think they are the same thing, let’s disentangle the two notions.</span><a id="filepos619072"></a></blockquote><blockquote class="calibre17"><span class="calibre10"><span class="italic">Concurrency</span></span><span class="calibre10"> is the coordination of multiple, usually interleaved threads of execution that are accessing or modifying some shared state.</span></blockquote><blockquote class="calibre17"><span class="calibre10"><span class="italic">Parallelism</span></span><span class="calibre10"> involves state as well, but usually in the inverse. Being an optimization technique used to efficiently utilize all of the available resources (usually computational, but sometimes other resources, like bandwidth) to improve the performance of an operation, approaches to parallelization generally aim to maximize the window of exclusive access to state (or, often, chunks of state) so as to minimize coordination overhead. Rather than involving interleaved threads of execution, the multiple evaluations of a parallelized operation run simultaneously—sometimes on different CPU cores, other times on different physical machines entirely.</span></blockquote><p class="calibre50">The flexibility of Clojure’s seq abstraction<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos620192"></a><a href="#filepos627715"><span class="calibre32">128</span></a><span class="calibre32">]</span></small></sup> makes implementing many routines in terms of processing sequences very easy. For example, say we had a function that uses a regular expression to find and return phone numbers found within other strings:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn phone-numbers<br class="calibre33"/>  [string]<br class="calibre33"/>  (re-seq #"(\d{3})[\.-]?(\d{3})[\.-]?(\d{4})" string))<br class="calibre33"/>;= #'user/phone-numbers<br class="calibre33"/>(phone-numbers " Sunil: 617.555.2937, Betty: 508.555.2218")<br class="calibre33"/>;= (["617.555.2937" "617" "555" "2937"] ["508.555.2218" "508" "555" "2218"])</tt></span></blockquote><p class="calibre23">Simple enough, and applying it to any seq of strings is easy, fast, and effective. These seqs could be loaded from disk using <tt class="calibre22">slurp</tt> and <tt class="calibre22">file-seq</tt>, or be coming in as messages from a message queue, or be the results obtained by retrieving large chunks of text from a database. To keep things simple, we can dummy up a seq of 100 strings, each about 1MB in size, suffixed with some phone numbers:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def files (repeat 100<br class="calibre33"/>                   (apply str<br class="calibre33"/>                     (concat (repeat 1000000 \space)<br class="calibre33"/>                             "Sunil: 617.555.2937, Betty: 508.555.2218"))))</tt></span></blockquote><p class="calibre23">Let’s see how fast we can get all of the phone numbers from all of these “files”:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(time (dorun (map phone-numbers files)))  </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>; "Elapsed time: 2460.848 msecs"</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">We’re using <tt class="calibre22">dorun</tt><a id="filepos622257"></a> here to fully realize the lazy seq produced by <tt class="calibre22">map</tt> and simultaneously release the results of that realization since we don’t want to have all of the found phone numbers printed to the REPL.</blockquote><p class="calibre18">This is parallelizable though, and trivially so. There is a cousin of <tt class="calibre22">map</tt>—<tt class="calibre22">pmap</tt><a id="filepos622604"></a> – that will parallelize the application of a function across a sequence of values, returning a lazy seq of results just like <tt class="calibre22">map</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(time (dorun (pmap phone-numbers files)))  </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>; "Elapsed time: 1277.973 msecs"</tt></span></blockquote><p class="calibre23">Run on a dual-core machine, this roughly doubles the throughput compared to the use of <tt class="calibre22">map</tt> in the prior example; for this particular task and dataset, roughly a 4x improvement could be expected on a four-core machine, and so on. Not bad for a single-character change to a function name! While this might look magical, it’s not; <tt class="calibre22">pmap</tt> is simply using a number of futures—calibrated to suit the number of CPU cores available—to spread the computation involved in evaluating <tt class="calibre22">phone-numbers</tt> for each file across each of those cores.</p><p class="calibre18">This works for many operations, but you still must use <tt class="calibre22">pmap</tt> judiciously. There <span class="italic">is</span> a degree of overhead associated with parallelizing operations like this. If the operation being parallelized does not have a significant enough runtime, that overhead will dominate the real work being performed; this can make a naive application of <tt class="calibre22">pmap</tt>
<span class="italic">slower</span>
<a id="filepos624031"></a>than the equivalent use of <tt class="calibre22">map</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def files (repeat 100000<br class="calibre33"/>                   (apply str<br class="calibre33"/>                     (concat (repeat 1000 \space)<br class="calibre33"/>                             "Sunil: 617.555.2937, Betty: 508.555.2218"))))<br class="calibre33"/><br class="calibre33"/>(time (dorun (map phone-numbers files)))<br class="calibre33"/>; "Elapsed time: 2649.807 msecs"<br class="calibre33"/>(time (dorun (pmap phone-numbers files)))<br class="calibre33"/>; "Elapsed time: 2772.794 msecs"</tt></span></blockquote><p class="calibre23">The only change we’ve made here is to the data: each string is now around 1K in size instead of 1MB in size. Even though the total amount of work is the same (there are more “files”), the parallelization overhead outstrips the gains we get from putting each evaluation of <tt class="calibre22">phone-numbers</tt> onto a different future/core. Because of this overhead, it is very common to see speedups of something less than Nx (where <tt class="calibre22">N</tt> is the number of CPU cores available) when using <tt class="calibre22">pmap</tt>. The lesson is clear: use <tt class="calibre22">pmap</tt> when the operation you’re performing is parallelizable in the first place, and is significant enough for each value in the seq that its workload will eclipse the process coordination inherent in its parallelization. Trying to force <tt class="calibre22">pmap</tt> into service where it’s not warranted can be disastrous.</p><p class="calibre18">There is often a workaround for such scenarios, however. You can often efficiently parallelize a relatively trivial operation by <span class="italic">chunking</span><a id="filepos625701"></a> your dataset so that each unit of parallelized work is larger. In the above example, the unit of work is just 1K of text; however, we can take steps to ensure that the unit of work is larger, so that each value processed by <tt class="calibre22">pmap</tt> is a seq of 250 1K strings, thus boosting the work done per future dispatch and cutting down on the parallelization overhead:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(time (-&gt;&gt; files<br class="calibre33"/>        (partition-all 250)<br class="calibre33"/>        (pmap (fn [chunk] (doall (map phone-numbers chunk))))  </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>        (apply concat)<br class="calibre33"/>        dorun))<br class="calibre33"/>; "Elapsed time: 1465.138 msecs"</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">map</tt> will return a lazy seq, so we use <tt class="calibre22">doall</tt><a id="filepos626736"></a> to force the realization of that lazy seq within the scope of the function provided to <tt class="calibre22">pmap</tt>. Otherwise, <tt class="calibre22">phone-numbers</tt> would never be called at all in parallel, leaving the work of applying it to each string to whatever process might have consumed the lazy seq later.</blockquote><p class="calibre18">By changing the chunk size of our workload, we’ve regained the benefits of parallelization even though our per-operation computation complexity dropped substantially when applied to many more smaller strings.</p><p class="calibre18">Two other parallelism constructs are built on top of <tt class="calibre22">pmap</tt>: <tt class="calibre22">pcalls</tt> and <tt class="calibre22">pvalues</tt>. The former evaluates any number of no-arg functions provided as arguments, returning a lazy sequence of their return values; the latter is a macro that does the same, but for any number of expressions.</p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos627715"></a><a href="#filepos620192"><span class="calibre32">128</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Which we discussed in </span><a href="#filepos354167"><span class="calibre10"><span class="calibre5">Sequences</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos627984" class="calibre6"><span class="calibre4"><span class="bold">State and Identity</span></span></p><p id="filepos628063" class="calibre18">In Clojure, there is a clear distinction between <span class="italic">state</span> and <span class="italic">identity</span>. These concepts are almost universally conflated; we can see that conflation in its full glory here:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">class Person {<br class="calibre33"/>    public String name;<br class="calibre33"/>    public int age;<br class="calibre33"/>    public boolean wearsGlasses;<br class="calibre33"/><br class="calibre33"/>    public Person (String name, int age, boolean wearsGlasses) {<br class="calibre33"/>      this.name = name;<br class="calibre33"/>      this.age = age;<br class="calibre33"/>      this.wearsGlasses = wearsGlasses;<br class="calibre33"/>    }<br class="calibre33"/>}<br class="calibre33"/><br class="calibre33"/>Person sarah = new Person("Sarah", 25, false);</tt></span></blockquote><p class="calibre23">Nothing particularly odd, right? Just a Java class<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos628932"></a><a href="#filepos634920"><span class="calibre32">129</span></a><span class="calibre32">]</span></small></sup> with some fields, of which we can create instances. Actually, the problems here are legion.</p><p class="calibre18">We have established a reference to a <tt class="calibre22">Person</tt>, meant to represent <tt class="calibre22">"Sarah"</tt>, who is apparently 25 years old. Over time, Sarah has existed in many different states: Sarah as a child, as a teenager, as an adult. At each point in time—say, last Tuesday at 11:07 a.m.—Sarah has precisely <span class="italic">one</span> state, and each state in time is inviolate. It makes absolutely no sense to talk about changing one of Sarah’s states. Her characteristics last Tuesday don’t change on Wednesday; her state may change from one point in time to another, but that doesn’t modify what she was previously.</p><p class="calibre18">Unfortunately, this <tt class="calibre22">Person</tt> class and low-level references (really, just pointers) provided by most languages are ill-suited to representing even this trivial—we might say fundamental—concept. If Sarah is to turn 26 years old, our only option is to clobber the particular state we have available:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos630128"></a><a href="#filepos635285"><span class="calibre32">130</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">sarah.age++;</tt></span></blockquote><p class="calibre23">Even worse, what happens when a particular change in Sarah’s state has to modify multiple attributes?</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">sarah.age++;<br class="calibre33"/>sarah.wearsGlasses = true;</tt></span></blockquote><p class="calibre23">At any point in time between the execution of these two lines of code, Sarah’s age has been incremented, but she does not yet wear glasses. For some period of time (technically, an indeterminate period of time given the way modern processor architectures and language runtimes operate), Sarah may exist in an inconsistent state that is factually and perhaps semantically impossible, depending on our object model. This is the stuff that race conditions are made of, and a key motivator of deadlock-prone locking strategies.</p><p class="calibre18">Note that we can even change this <tt class="calibre22">sarah</tt> object to represent a completely different person:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">sarah.name = "John";</tt></span></blockquote><p class="calibre23">This is troublesome. The <tt class="calibre22">sarah</tt> object does not represent a single state of Sarah, nor even the concept of Sarah as an identity. Rather, it’s an unholy amalgam of the two. More generally, we cannot make any reliable statements about prior states of a <tt class="calibre22">Person</tt> reference, particular instances of <tt class="calibre22">Person</tt> are liable to change at any time (of particular concern in programs with concurrent threads of execution), and not only is it easy to put instances into inconsistent states, <span class="italic">it is the default</span>.</p><p class="calibre18"><span class="bold">The Clojure approach</span>. What we really want to be able to say is that Sarah has an <span class="italic">identity</span> that represents her; not her at any particular point in time, but her as a logical entity throughout time. Further, we want to be able to say that that identity can have a particular <span class="italic">state</span> at any point in time, but that each state transition does not change history; thinking back to <a href="#filepos221848"><span class="calibre5">On the Importance of Values</span></a> and the contrast between mutable objects and immutable values, this characterization of state would seem to carry many practical benefits as well as being semantically more sound. After all, in addition to wanting to ensure that a state of some identity is never internally inconsistent (something guaranteed by using immutable values), we may very well want to be able to easily and safely refer to Sarah as she was last Tuesday or last year.</p><p class="calibre18">Unlike most objects, Clojure data structures are immutable. This makes them ideal for representing state:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def sarah {:name "Sarah" :age 25 :wears-glasses? false})<br class="calibre33"/>;= #'user/sarah</tt></span></blockquote><p class="calibre23">The map we store in the <tt class="calibre22">sarah</tt> var is one state of Sarah at some point in time. Because the map is immutable, we can be sure that any code that holds a reference to that map will be able to safely use it for all time regardless of what changes are made to other versions of it or to the state held by the var. The var itself is one of Clojure’s <span class="italic">reference types</span><a id="filepos633601"></a>, essentially a container with defined concurrency and change semantics that can hold any value, and be used as a stable identity. So, we can say that Sarah is represented by the <tt class="calibre22">sarah</tt> var, the state of which may change over time according to the var’s semantics.</p><p class="calibre18">This is just a glimpse of how Clojure treats identity and state and how they relate over time as distinct concepts worthy of our attention.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos634088"></a><a href="#filepos635617"><span class="calibre32">131</span></a><span class="calibre32">]</span></small></sup> The rest of this chapter will be devoted to exploring the mechanics of that treatment. In large part, this will consist of exploring Clojure’s four reference types, each of which implement different yet well-defined semantics for changing state over time. Along with Clojure’s emphasis on immutable values, these reference types and their semantics make it possible to design concurrent programs that take maximum advantage of the increasingly capable hardware we have available to us, while eliminating entire categories of bugs and failure conditions that would otherwise go with the territory of dealing with bare threads and locks.</p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos634920"></a><a href="#filepos628932"><span class="calibre32">129</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Note that this discussion is by no means limited to Java. Many—really, nearly all—other languages conflate state and identity, including Ruby, Python, C#, Perl, PHP, and so on.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos635285"></a><a href="#filepos630128"><span class="calibre32">130</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Don’t get hung up on the lack of accessors and such; whether you work with fields or getters and setters has no impact on the semantics involved.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos635617"></a><a href="#filepos634088"><span class="calibre32">131</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Rich Hickey gave a talk in 2009 on the ideas of identity, state, and time and how they informed the design of Clojure. We highly recommend you watch the video of that talk: </span><a href="http://www.infoq.com/presentations/Are-We-There-Yet-Rich-Hickey"><span class="calibre10"><span class="calibre5">http://www.infoq.com/presentations/Are-We-There-Yet-Rich-Hickey</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos636143" class="calibre6"><span class="calibre4"><span class="bold">Clojure Reference Types</span></span></p><p id="filepos636227" class="calibre18">Identities are represented in Clojure using four reference types: <tt class="calibre22">var</tt>s, <tt class="calibre22">ref</tt>s, <tt class="calibre22">agent</tt>s, and <tt class="calibre22">atom</tt>s. All of these are very different in certain ways, but let’s first talk about what they have in common.</p><p class="calibre18">At their most fundamental level, references are just boxes that hold a value, where that value can be changed by certain functions (different for each reference type):</p><p class="calibre51"><img src="images/00041.jpg" class="calibre81"/></p><p class="calibre13">All references always contain <span class="italic">some</span> value (even if that value is <tt class="calibre22">nil</tt>); accessing one is always done using <tt class="calibre22">deref</tt> or <tt class="calibre22">@</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">@(atom 12)<br class="calibre33"/>;= 12<br class="calibre33"/>@(agent {:c 42})<br class="calibre33"/>;= {:c 42}<br class="calibre33"/>(map deref [(agent {:c 42}) (atom 12) (ref "http://clojure.org") (var +)])<br class="calibre33"/>;= ({:c 42} 12 "http://clojure.org" #&lt;core$_PLUS_ clojure.core$_PLUS_@65297549&gt;)</tt></span></blockquote><p class="calibre23">Dereferencing will return a <span class="italic">snapshot</span> of the state of a reference when <tt class="calibre22">deref</tt> was invoked. This doesn’t mean there’s copying of any sort when you obtain a snapshot, simply that the returned state—assuming you’re using immutable values for reference state, like Clojure’s collections—is inviolate, but that the reference’s state at later points in time may be different.</p><p class="calibre18">One critical guarantee of <tt class="calibre22">deref</tt><a id="filepos637839"></a> within the context of Clojure’s reference types is that <tt class="calibre22">deref</tt>
<span class="italic">will never block</span>, regardless of the change semantics of the reference type being dereferenced or the operations being applied to it in other threads of execution. Similarly, dereferencing a reference type will never interfere with other operations. This is in contrast with delays, promises, and futures—which can block on <tt class="calibre22">deref</tt> if their value is not yet realized—and most concurrency primitives in other languages, where readers are often blocked by writers and vice versa.</p><p class="calibre18">“Setting” the value of a reference type is a more nuanced affair. Each reference type has its own semantics for managing change, and each type has its own family of functions for applying changes according to those semantics. Talking about those semantics and their corresponding functions will form the bulk of the rest of our discussion.</p><p class="calibre18">In addition to all being dereferenceable, all reference types:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">May be decorated with metadata (see <a href="#filepos512813"><span class="calibre5">Metadata</span></a>). Rather than using <tt class="calibre22">with-meta</tt> or <tt class="calibre22">vary-meta</tt>, metadata on reference types may only be changed with <tt class="calibre22">alter-meta!</tt>, which modifies a reference’s metadata in-place.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos639324"></a><a href="#filepos640105"><span class="calibre32">132</span></a><span class="calibre32">]</span></small></sup></blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Can notify functions you specify when the their state changes; these functions are called <span class="italic">watches</span>, which we discuss in <a href="#filepos655851"><span class="calibre5">Watches</span></a>.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Can enforce constraints on the state they hold, potentially aborting change operations, using <span class="italic">validator</span> functions (see <a href="#filepos663915"><span class="calibre5">Validators</span></a>).</blockquote></li></ul><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos640105"></a><a href="#filepos639324"><span class="calibre32">132</span></a><span class="calibre32">] </span></small></sup><span class="calibre10"><tt class="calibre22">atom</tt></span><span class="calibre10">, </span><span class="calibre10"><tt class="calibre22">ref</tt></span><span class="calibre10">, and </span><span class="calibre10"><tt class="calibre22">agent</tt></span><span class="calibre10"> all accept an optional </span><span class="calibre10"><tt class="calibre22">:meta</tt></span><span class="calibre10"> keyword argument, allowing you to provide an initial metadata map when creating those references.</span></p><div class="mbppagebreak"></div><p id="filepos640580" class="calibre6"><span class="calibre4"><span class="bold">Classifying Concurrent Operations</span></span></p><p class="calibre18">In thinking about Clojure’s reference types, we’ll repeatedly stumble across a couple of key concepts that can be used to characterize concurrent operations. Taken together, they can help us think clearly about how each type is best used.</p><p class="calibre18"><span class="bold">Coordination</span>. <a id="filepos640998"></a>A <span class="italic">coordinated</span> operation is one where multiple actors must cooperate (or, at a minimum, be properly sequestered so as to not interfere with each other) in order to yield correct results. A classic example is any banking transaction: a process that aims to transfer monies from one account to another must ensure that the credited account not reflect an increased balance prior to the debited account reflecting a decreased balance, and that the transaction fail entirely if the latter has insufficient funds. Along the way, many other processes may provoke similar transactions involving the same accounts. Absent methods to coordinate the changes, some accounts could reflect incorrect balances for some periods, and transactions that should have failed (or should have succeeded) would succeed (or fail) improperly.</p><p class="calibre18">In contrast, an <span class="italic">uncoordinated</span> operation <a id="filepos641907"></a>is one where multiple actors cannot impact each other negatively because their contexts are separated.  For example, two different threads of execution can safely write to two different files on disk with no possibility of interfering with each other.</p><p class="calibre18"><span class="bold">Synchronization</span>. <span class="italic">Synchronous</span>
<a id="filepos642242"></a>operations are those where the caller’s thread of execution waits or blocks or sleeps until it may have exclusive access to a given context, whereas <span class="italic">asynchronous</span> operations are those that can be started or scheduled without blocking the initiating thread of execution.</p><p class="calibre18">Just these two concepts (or, four, if you count their duals) are sufficient to fully characterize many (if not most) concurrent operations you might encounter. Given that, it makes sense that Clojure’s reference types were designed to implement the semantics necessary to address permutations of these concepts, and that they can be conveniently classified according to the types of operations for which each is suited:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos643014"></a><a href="#filepos646358"><span class="calibre32">133</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre51"><img src="images/00046.jpg" class="calibre82"/></p><p class="calibre13">When choosing which reference type(s) to use for a given problem, keep this classification in mind; if you can characterize a particular problem using it, then the most appropriate reference type will be obvious.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">You’ll notice that none of Clojure’s reference types are slated as implementing coordinated and asynchronous semantics. This combination of characteristics is more common in distributed systems, such as eventually consistent databases where changes are only guaranteed to be merged into a unified model over time. In contrast, Clojure is fundamentally interested in addressing in-process concurrency and parallelism.</span><a id="filepos644078"></a></blockquote><blockquote class="calibre83"></blockquote><blockquote class="calibre39"><span class="calibre10"><span class="bold">A DEMONSTRATION UTILITY</span></span></blockquote><blockquote class="calibre17"><span class="calibre10">In order to demonstrate concurrency understandably, we’ll be using a couple of helpers in this chapter’s examples. </span><span class="calibre10"><tt class="calibre22">futures</tt></span><span class="calibre10"> is a macro that produces code that creates </span><span class="calibre10"><tt class="calibre22">n</tt></span><span class="calibre10"> futures for each expression provided to the macro to be evaluated:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(defmacro futures<br class="calibre33"/>  [n &amp; exprs]<br class="calibre33"/>  (vec (for [_ (range n)<br class="calibre33"/>             expr exprs]<br class="calibre33"/>         `(future ~expr))))</tt></span></blockquote><blockquote class="calibre35"><span class="calibre10">This gives us an easy way to evaluate expressions on different threads. However, </span><span class="calibre10"><tt class="calibre22">futures</tt></span><span class="calibre10"> forms will themselves evaluate to a vector of the created futures. This could be handy in other contexts, but we’ll always want to wait for all of the futures to complete, so we can be sure our expressions have all finished evaluating. So, another helper, </span><span class="calibre10"><tt class="calibre22">wait-futures</tt></span><span class="calibre10">, will provide the same capabilities as </span><span class="calibre10"><tt class="calibre22">futures</tt></span><span class="calibre10">, but will always return </span><span class="calibre10"><tt class="calibre22">nil</tt></span><span class="calibre10"> and will block our REPL until the futures are all realized:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(defmacro wait-futures<br class="calibre33"/>  [&amp; args]<br class="calibre33"/>  `(doseq [f# (futures ~@args)]<br class="calibre33"/>     @f#))</tt></span></blockquote><blockquote class="calibre35"><span class="calibre10">We’ve not talked much about macros yet, so it’s okay if you don’t quite understand how these helpers work; don’t worry, we’ll discuss macros in detail in </span><a href="#filepos831506"><span class="calibre10"><span class="calibre5">Chapter 5</span></span></a><span class="calibre10">.</span></blockquote><br class="calibre33"/><hr class="calibre34"/><p class="calibre25"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos646358"></a><a href="#filepos643014"><span class="calibre32">133</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Vars do not fit into this particular classification; their primary mode of change is thread-local, and thus are orthogonal to notions of coordination or synchronization.</span></p><div class="mbppagebreak"></div><p id="filepos646665" class="calibre6"><span class="calibre4"><span class="bold">Atoms</span></span></p><p id="filepos646731" class="calibre18">Atoms are the most basic reference type; they are identities that implement synchronous, uncoordinated, atomic <span class="italic">compare-and-set</span><a id="filepos646892"></a> modification. Thus, operations that modify the state of atoms block until the modification is complete, and each modification is isolated—on their own, there is no way to orchestrate the modification of two atoms.</p><p class="calibre18">Atoms are created using <tt class="calibre22">atom</tt>. <tt class="calibre22">swap!</tt><a id="filepos647200"></a> is the most common modification operation used with them, which sets the value of an atom to the result of applying some function to the atom’s value and any additional arguments provided to <tt class="calibre22">swap!</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def sarah (atom {:name "Sarah" :age 25 :wears-glasses? false}))<br class="calibre33"/>;= #'user/sarah<br class="calibre33"/>(swap! sarah update-in [:age] + 3)                          </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= {:age 28, :wears-glasses? false, :name "Sarah"}          </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Here, when <tt class="calibre22">swap!</tt> returns, the value held by the <tt class="calibre22">sarah</tt> atom will have been set to the result of <tt class="calibre22">(update-in @sarah [:age] + 3)</tt>.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">swap!</tt> always returns the new value that was swapped into the atom.</blockquote><p class="calibre18">Atoms are the minimum we need to do right by Sarah: every modification of an atom occurs atomically, so it’s safe to apply any function or composition of functions to an atom’s value. You can be sure that no other threads of execution will ever see an atom’s contents in an inconsistent or partially applied state:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(swap! sarah (comp #(update-in % [:age] inc)<br class="calibre33"/>                   #(assoc % :wears-glasses? true)))<br class="calibre33"/>;= {:age 29, :wears-glasses? true, :name "Sarah"}</tt></span></blockquote><p class="calibre23">One thing you must keep in mind when using <tt class="calibre22">swap!</tt> is that, because atoms use compare-and-set semantics, if the atom’s value changes before your <tt class="calibre22">update</tt> function returns (as a result of action by another thread of execution), <tt class="calibre22">swap!</tt> will retry, calling your update function again with the atom’s newer value. <tt class="calibre22">swap!</tt> will continue to retry the compare-and-set until it succeeds:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def xs (atom #{1 2 3}))<br class="calibre33"/>;= #'user/xs<br class="calibre33"/>(wait-futures 1 (swap! xs (fn [v]<br class="calibre33"/>                            (Thread/sleep 250)<br class="calibre33"/>                            (println "trying 4")<br class="calibre33"/>                            (conj v 4)))<br class="calibre33"/>                (swap! xs (fn [v]<br class="calibre33"/>                            (Thread/sleep 500)<br class="calibre33"/>                            (println "trying 5")<br class="calibre33"/>                            (conj v 5))))<br class="calibre33"/>;= nil<br class="calibre33"/>; trying 4<br class="calibre33"/>; trying 5    </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>; trying 5<br class="calibre33"/>@xs<br class="calibre33"/>;= #{1 2 3 4 5}</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">The thread of execution that aimed to <tt class="calibre22">conj</tt>
<tt class="calibre22">5</tt> into the set held in <tt class="calibre22">xs</tt> ended up retrying the application of the function passed to <tt class="calibre22">swap!</tt>; while it was sleeping, the other thread was able to modify the atom (<tt class="calibre22">conj</tt>ing <tt class="calibre22">4</tt> into the set), so the compare-and-set failed the first time.</blockquote><p class="calibre18">We can visualize the retry semantics of <tt class="calibre22">swap!</tt> like so:</p><blockquote class="calibre47"></blockquote><blockquote class="calibre39"><img src="images/00051.jpg" class="calibre84"/></blockquote><blockquote class="calibre57"><span class="calibre10"><span class="italic"><span class="calibre7">Figure 4-1. Interaction of conflicting swap! operations on a shared atom</span></span></span></blockquote><p class="calibre50">If the value of atom <tt class="calibre22">a</tt> changes between the time when function <tt class="calibre22">g</tt> is invoked and the time when it returns a new value for <tt class="calibre22">a</tt> (<tt class="calibre22">a<sub class="calibre85"><small class="calibre31"><span class="calibre32">1</span></small></sub></tt> and <tt class="calibre22">a<sub class="calibre85"><small class="calibre31"><span class="calibre32">2</span></small></sub></tt>, respectively), <tt class="calibre22">swap!</tt> will discard that new value and reevaluate the call with the latest available state of <tt class="calibre22">a</tt>. This will continue until the return value of <tt class="calibre22">g</tt> can be set on <tt class="calibre22">a</tt> as the immediate successor of the state of <tt class="calibre22">a</tt> with which it was invoked.</p><p class="calibre18">There is no way to constrain <tt class="calibre22">swap!</tt>’s retry semantics; given this, the function you provide to <tt class="calibre22">swap!</tt>
<span class="italic">must</span> be pure, or things will surely go awry in hard-to-predict ways.</p><p class="calibre18">Being a synchronous reference type, functions that change atom values do not return until they have completed:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def x (atom 2000))<br class="calibre33"/>;= #'user/x<br class="calibre33"/>(swap! x #(Thread/sleep %))     </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">This expression takes at least two seconds to return.</blockquote><p class="calibre18">A “bare” <tt class="calibre22">compare-and-set!</tt> operation is also provided for use with atoms, if you already think you know what the value of the atom being modified is; it returns <tt class="calibre22">true</tt> only if the atom’s value was changed:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(compare-and-set! xs :wrong "new value")<br class="calibre33"/>;= false<br class="calibre33"/>(compare-and-set! xs @xs "new value")<br class="calibre33"/>;= true<br class="calibre33"/>@xs<br class="calibre33"/>;= "new value"</tt></span></blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10"><tt class="calibre22">compare-and-set!</tt></span><span class="calibre10"> does </span><span class="calibre10"><span class="italic">not</span></span><span class="calibre10"> use value semantics; it requires that the value in the atom be identical<sup class="calibre58"><small class="calibre31"><span class="calibre32">[</span><a id="filepos653877"></a><a href="#filepos654854"><span class="calibre32">134</span></a><span class="calibre32">]</span></small></sup> to the expected value provided to it as its second argument:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(def xs (atom #{1 2}))<br class="calibre33"/>;= #'user/xs<br class="calibre33"/>(compare-and-set! xs #{1 2} "new value")<br class="calibre33"/>;= false</tt></span></blockquote><p class="calibre25">Finally, there is a “nuclear option”: if you want to set the state of an atom without regard for what it contains currently, there is <tt class="calibre22">reset!</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(reset! xs :y)<br class="calibre33"/>;= :y<br class="calibre33"/>@xs<br class="calibre33"/>;= :y</tt></span></blockquote><p class="calibre23">Now that we know about atoms, this is a good time to look at two facilities that all reference types support, since some later examples will use them.</p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos654854"></a><a href="#filepos653877"><span class="calibre32">134</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">As defined by </span><span class="calibre10"><tt class="calibre22">identical?</tt></span><span class="calibre10">; see </span><a href="#filepos1576207"><span class="calibre10"><span class="calibre5">Object Identity (identical?)</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos655203" class="calibre6"><span class="calibre4"><span class="bold">Notifications and Constraints</span></span></p><p id="filepos655293" class="calibre18">We already learned about one common operation in <a href="#filepos636143"><span class="calibre5">Clojure Reference Types</span></a>—dereferencing—which allows us to obtain the current value of a reference regardless of its particular type. There are certain other common things you’ll sometimes want to do with every type of reference that involve being able to monitor or validate state changes as they happen. All of Clojure’s reference types provide hooks for these, in the form of <span class="italic">watches</span> and <span class="italic">validators</span>.</p><p id="filepos655851" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Watches</span></span></span></p><p id="filepos655948" class="calibre18">Watches are functions that are called whenever the state of a reference has changed. If you are familiar with the “observer” design pattern, you will recognize the applicable use cases immediately, although watches are decidedly more general: a watch can be registered with any reference type, and all watches are functions—there are no special interfaces that must be implemented, and the notification machinery is provided for you.</p><p class="calibre18">All reference types start off with no watches, but they can be registered and removed at any time. A watch function must take four arguments: a key, the reference that’s changed (an atom, ref, agent, or var), the old state of the reference, and its new state:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn echo-watch                                         </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  [key identity old new]<br class="calibre33"/>  (println key old "=&gt;" new))<br class="calibre33"/>;= #'user/echo-watch<br class="calibre33"/>(def sarah (atom {:name "Sarah" :age 25}))<br class="calibre33"/>;= #'user/sarah<br class="calibre33"/>(add-watch sarah :echo echo-watch)<br class="calibre33"/>;= #&lt;Atom@418bbf55: {:name "Sarah", :age 25}&gt;<br class="calibre33"/>(swap! sarah update-in [:age] inc)<br class="calibre33"/>; :echo {:name Sarah, :age 25} =&gt; {:name Sarah, :age 26}<br class="calibre33"/>;= {:name "Sarah", :age 26}<br class="calibre33"/>(add-watch sarah :echo2 echo-watch)                      </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #&lt;Atom@418bbf55: {:name "Sarah", :age 26}&gt;<br class="calibre33"/>(swap! sarah update-in [:age] inc)                       </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>; :echo {:name Sarah, :age 26} =&gt; {:name Sarah, :age 27}<br class="calibre33"/>; :echo2 {:name Sarah, :age 26} =&gt; {:name Sarah, :age 27}<br class="calibre33"/>;= {:name "Sarah", :age 27}</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Our watch function prints to stdout every time the atom’s state may have changed.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">If we add the same watch function under a new key…</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">It’ll now be called twice for each state change.</blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Watch functions are called synchronously on the same thread that effected the reference’s state change in question. This means that, by the time your watch function has been called, the reference it is attached to could have been updated </span><span class="calibre10"><span class="italic">again</span></span><span class="calibre10"> from another thread of execution. Thus, you should rely only on the “old” and “new” values passed to the watch function, rather than dereferencing the host ref, agent, atom, or var.</span></blockquote><p class="calibre25">The key you provide to <tt class="calibre22">add-watch</tt><a id="filepos659522"></a> can be used to remove the watch later on:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(remove-watch sarah :echo2)<br class="calibre33"/>;= #&lt;Atom@418bbf55: {:name "Sarah", :age 27}&gt;<br class="calibre33"/>(swap! sarah update-in [:age] inc)<br class="calibre33"/>; :echo {:name Sarah, :age 27} =&gt; {:name Sarah, :age 28}<br class="calibre33"/>;= {:name "Sarah", :age 28}</tt></span></blockquote><p class="calibre23">Note that watches on a reference type are called whenever the reference’s state has been modified, but this does not guarantee that the state is <span class="italic">different</span>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(reset! sarah @sarah)<br class="calibre33"/>; :echo {:name Sarah, :age 28} =&gt; {:name Sarah, :age 28}<br class="calibre33"/>;= {:name "Sarah", :age 28}</tt></span></blockquote><p class="calibre23">Thus, it’s common for watch functions to check if the old and new states of the watched reference are equal before proceeding.</p><p class="calibre18">Generally speaking, watches are a great mechanism for triggering the propagation of local changes to other references or systems as appropriate. For example, they make it dead easy to keep a running log of a reference’s history:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def history (atom ()))<br class="calibre33"/><br class="calibre33"/>(defn log-&gt;list<br class="calibre33"/>  [dest-atom key source old new]<br class="calibre33"/>  (when (not= old new)<br class="calibre33"/>    (swap! dest-atom conj new)))<br class="calibre33"/><br class="calibre33"/>(def sarah (atom {:name "Sarah", :age 25}))<br class="calibre33"/>;= #'user/sarah<br class="calibre33"/>(add-watch sarah :record (partial log-&gt;list history))  </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #&lt;Atom@5143f787: {:age 25, :name "Sarah"}&gt;<br class="calibre33"/>(swap! sarah update-in [:age] inc)<br class="calibre33"/>;= {:age 26, :name "Sarah"}<br class="calibre33"/>(swap! sarah update-in [:age] inc)<br class="calibre33"/>;= {:age 27, :name "Sarah"}<br class="calibre33"/>(swap! sarah identity)                                 </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= {:age 27, :name "Sarah"}<br class="calibre33"/>(swap! sarah assoc :wears-glasses? true)<br class="calibre33"/>;= {:age 27, :wears-glasses? true, :name "Sarah"}<br class="calibre33"/>(swap! sarah update-in [:age] inc)<br class="calibre33"/>;= {:age 28, :wears-glasses? true, :name "Sarah"}<br class="calibre33"/>(pprint @history)<br class="calibre33"/>;= ;= nil<br class="calibre33"/>;= ; ({:age 28, :wears-glasses? true, :name "Sarah"}<br class="calibre33"/>;= ;  {:age 27, :wears-glasses? true, :name "Sarah"}<br class="calibre33"/>;= ;  {:age 27, :name "Sarah"}<br class="calibre33"/>;= ;  {:age 26, :name "Sarah"})</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">We use <tt class="calibre22">partial</tt> here to bind in the atom to which the watch function will always log history.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">Since <tt class="calibre22">identity</tt> always returns its sole argument unchanged, this <tt class="calibre22">swap!</tt> will result in a state change in the reference, but the old and new states will be equal. <tt class="calibre22">log-&gt;list</tt> only adds an entry if the new state is different, so this “repeated” state will not appear in the history.</blockquote><p class="calibre18">Depending on how clever you get in your use of watches, you can also make the behavior of the watch function vary depending upon the key it’s registered under. A simple example would be a watch function that logged changes, not to an in-memory sink but to a database identified by its registered key:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn log-&gt;db<br class="calibre33"/>  [db-id identity old new]<br class="calibre33"/>  (when (not= old new)<br class="calibre33"/>    (let [db-connection (get-connection db-id)]<br class="calibre33"/>      ...)))<br class="calibre33"/><br class="calibre33"/>(add-watch sarah "jdbc:postgresql://hostname/some_database" log-&gt;db)</tt></span></blockquote><p class="calibre23">We’ll combine watches with refs and agents to great effect in <a href="#filepos790173"><span class="calibre5">Persisting reference states with an agent-based write-behind log</span></a>.<a id="filepos663904"></a></p><p id="filepos663915" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Validators</span></span></span></p><p id="filepos664015" class="calibre18">Validators enable you to constrain a reference’s state however you like. A validator is a function of a single argument that is invoked just before any <span class="italic">proposed</span> new state is installed into a reference. If the validator returns logically false or throws an exception, then the state change is aborted with an exception.</p><p class="calibre18">A proposed change is the result of any change function you attempt to apply to a reference. For example, the map of <tt class="calibre22">sarah</tt> that has had its <tt class="calibre22">:age</tt> slot incremented, but before <tt class="calibre22">swap!</tt> installs that updated state into the reference. It is at this point that a validator function—if any has been set on the affected reference—has a chance to veto it.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def n (atom 1 :validator pos?))<br class="calibre33"/>;= #'user/n<br class="calibre33"/>(swap! n + 500)<br class="calibre33"/>;= 501<br class="calibre33"/>(swap! n - 1000)<br class="calibre33"/>;= #&lt;IllegalStateException java.lang.IllegalStateException: Invalid reference state&gt;</tt></span></blockquote><p class="calibre23">Because validator functions take a single argument, you can readily use any applicable predicate you might have available already, like <tt class="calibre22">pos?</tt>.</p><p class="calibre18">While all reference types may have a validator associated with them, atoms, refs, and agents may be <span class="italic">created</span> with them by providing the validator function as a <tt class="calibre22">:validator</tt> option to <tt class="calibre22">atom</tt>, <tt class="calibre22">ref</tt>, or <tt class="calibre22">agent</tt>. To add a validator to a var, or to change the validator associated with an atom, ref, or agent, you can use the <tt class="calibre22">set-validator!</tt> function:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def sarah (atom {:name "Sarah" :age 25}))<br class="calibre33"/>;= #'user/sarah<br class="calibre33"/>(set-validator! sarah :age)<br class="calibre33"/>;= nil<br class="calibre33"/>(swap! sarah dissoc :age)<br class="calibre33"/>;= #&lt;IllegalStateException java.lang.IllegalStateException: Invalid reference state&gt;</tt></span></blockquote><p class="calibre23">You can make the message included in the thrown exception more helpful by ensuring that the validator you use throws its own exception, instead of simply returning <tt class="calibre22">false</tt> or <tt class="calibre22">nil</tt> upon a validation failure:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos666330"></a><a href="#filepos667834"><span class="calibre32">135</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(set-validator! sarah #(or (:age %)          </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>                       (throw (IllegalStateException. "People must have `:age`s!"))))<br class="calibre33"/>;= nil<br class="calibre33"/>(swap! sarah dissoc :age)<br class="calibre33"/>;= #&lt;IllegalStateException java.lang.IllegalStateException: People must have `:age`s!&gt;</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Remember that validators must return a logically true value, or the state change will be vetoed. In this case, if we implemented the validator using, for example, <tt class="calibre22">#(when-not (:age %) (throw ...))</tt>, the validator would return <tt class="calibre22">nil</tt> when the state <span class="italic">did</span> have an <tt class="calibre22">:age</tt> slot, thus causing an unintentional validation failure.</blockquote><p class="calibre18">While validators are very useful in general, they hold a special status with regard to refs, as we’ll learn about next and in particular in <a href="#filepos701002"><span class="calibre5">Enforcing local consistency by using validators</span></a>.<a id="filepos667730"></a></p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos667834"></a><a href="#filepos666330"><span class="calibre32">135</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Alternatively, you can use a library like Slingshot to throw </span><span class="calibre10"><span class="italic">values</span></span><span class="calibre10">, instead of encoding useful information in a paltry string: </span><a href="https://github.com/scgilardi/slingshot"><span class="calibre10"><span class="calibre5">https://github.com/scgilardi/slingshot</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos668316" class="calibre6"><span class="calibre4"><span class="bold">Refs</span></span></p><p id="filepos668381" class="calibre18">Refs are Clojure’s coordinated reference type. Using them, you can ensure that multiple identities can participate in overlapping, concurrently applied operations with:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">No possibility of the involved refs ever being in an observable inconsistent state</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">No possibility of race conditions among the involved refs</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">No manual use of locks, monitors, or other low-level synchronization primitives</blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17">No possibility of deadlocks</blockquote></li></ul><p class="calibre18">This is made possible by Clojure’s implementation of <span class="italic">software transactional memory</span>, which is used to manage all change applied to state held by refs.</p><p id="filepos669439" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Software Transactional Memory</span></span></span></p><p id="filepos669558" class="calibre18">In general terms, software transactional memory (STM) is any method of coordinating multiple concurrent modifications to a shared set of storage locations. Doing this in nearly any other language means you have to take on the management of locks yourself, accepting all that comes along with them. STM offers an alternative.</p><p class="calibre18">Just as garbage collection has largely displaced the need for manual memory management—eliminating a wide range of subtle and not-so-subtle bugs associated with it in the process—so has STM often been characterized as providing the same kind of systematic simplification of another error-prone programming practice, manual lock management. In both instances, using a proven, automated solution to address what is otherwise an error-prone manual activity both frees you from having to develop expertise in low-level details unrelated to your domain, and often produces end results with more desirable runtime characteristics than those attainable by experts in those low-level details.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos670665"></a><a href="#filepos729702"><span class="calibre32">136</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">Clojure’s STM is implemented using techniques that have been relied upon by database management systems for decades.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos670945"></a><a href="#filepos730272"><span class="calibre32">137</span></a><span class="calibre32">]</span></small></sup> As the name implies, each change to a set of refs has transactional semantics that you are sure to be familiar with from your usage of databases; each STM transaction ensures that changes to refs are made:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17"><span class="italic">Atomically</span>, so that all the changes associated with a transaction are applied, or none are.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17"><span class="italic">Consistently</span>, so that a transaction will fail if the changes to affected refs do not satisfy their respective constraints.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">In <span class="italic">isolation</span>, so that an in-process transaction does not affect the states of involved refs as observed from within other transactions or other threads of execution in general.</blockquote></li><a id="filepos671982"></a></ol><p class="calibre18">Clojure’s STM therefore satisfies the A, C, and I properties of ACID (<a href="https://en.wikipedia.org/wiki/ACID"><span class="calibre5">https://en.wikipedia.org/wiki/ACID</span></a>), as you may understand it from the database world. The “D” property, durability, is not something that the STM is concerned with since it is purely an in-memory implementation.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos672423"></a><a href="#filepos730846"><span class="calibre32">138</span></a><span class="calibre32">]</span></small></sup></p><p id="filepos672522" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">The Mechanics of Ref Change</span></span></span></p><p id="filepos672639" class="calibre18">With that background out of the way, let’s see what refs can do for us. Earlier in <a href="#filepos640580"><span class="calibre5">Classifying Concurrent Operations</span></a>, we talked about banking transactions being an example of an operation that requires coordination among multiple identities and threads of execution. While this is true, banking is perhaps an overwrought example when it comes to demonstrating transactional semantics. It might be more enlightening (and entertaining!) to explore refs and Clojure’s STM as an ideal foundation for implementing a multiplayer game engine.</p><p class="calibre18">While some problems are rightfully described as “embarrassingly parallel” because of their potential to be parallelized given suitable facilities, we can say that multiplayer games <a id="filepos673478"></a>are embarrassingly concurrent: the datasets involved are often massive, and it’s possible to have hundreds or thousands of independent players each provoking changes that must be applied in a coordinated, consistent fashion so as to ensure the game’s rules are reliably enforced.</p><p class="calibre18">Our “game”<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos673849"></a><a href="#filepos731274"><span class="calibre32">139</span></a><span class="calibre32">]</span></small></sup> will be in the fantasy/role-playing genre, the sort that contains classes like wizards and rangers and bards. Given that, we’ll represent each player’s character as a ref holding a map, which will contain all of the data relevant to the player’s character’s class and abilities. Regardless of their class, all characters will have a minimal set of attributes:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">:name</tt>, the character’s name within the game.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">:health</tt>, a number indicating the character’s physical well-being. When <tt class="calibre22">:health</tt> drops to <tt class="calibre22">0</tt>, that character will be dead.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">:items</tt>, the set of equipment that a character is carrying.</blockquote></li></ul><p class="calibre18">Of course, specific character classes will have their own attributes. <tt class="calibre22">character</tt> is a function that implements all this, with default values for <tt class="calibre22">:items</tt> and <tt class="calibre22">:health</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn character<br class="calibre33"/>  [name &amp; {:as opts}]<br class="calibre33"/>  (ref (merge {:name name :items #{} :health 500}<br class="calibre33"/>              opts)))</tt></span></blockquote><p class="calibre23">With this available, we can now define some actual characters that different players could control:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos675544"></a><a href="#filepos731678"><span class="calibre32">140</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def smaug (character "Smaug" :health 500 :strength 400 :items (set (range 50)))) </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>(def bilbo (character "Bilbo" :health 100 :strength 100))<br class="calibre33"/>(def gandalf (character "Gandalf" :health 75 :mana 750))</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">We’ve created <tt class="calibre22">smaug</tt> with a set of items; here, just integers, which might correspond to item IDs within a static map or external database.</blockquote><p class="calibre18">In a game like this, if Bilbo and Gandalf were to defeat Smaug in a battle, they would be able to “loot” Smaug of the items he’s carrying. Without getting into gameplay details, all this means is that we want to take some item from Smaug and transfer it to another character. This transfer needs to occur so that the item being transferred is only in one place at a time from the perspective of any outside observers.</p><p class="calibre18">Enter Clojure’s STM and transactions. <tt class="calibre22">dosync</tt><a id="filepos676907"></a> establishes the scope of a transaction.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos676989"></a><a href="#filepos732268"><span class="calibre32">141</span></a><span class="calibre32">]</span></small></sup><span class="italic">All modifications of refs must occur within a transaction</span><a id="filepos677149"></a>, the processing of which happens synchronously. That is, the thread that initiates a transaction will “block” on that transaction completing before proceeding in its execution.</p><p class="calibre18">Similar to atoms’ <tt class="calibre22">swap!</tt>, if two transactions attempt to make a conflicting change to one or more shared refs, one of them will retry. Whether two concurrently applied transactions are in conflict depends entirely upon which functions are used to modify refs shared between those transactions. There are three such functions—<tt class="calibre22">alter</tt>, <tt class="calibre22">commute</tt>, and <tt class="calibre22">ref-set</tt>—each of which has different semantics when it comes to producing (or avoiding) conflict.</p><p class="calibre18">With all that said, how do we implement looting of items among characters in our game? The <tt class="calibre22">loot</tt> function transfers one value from <tt class="calibre22">(:items @from)</tt> to <tt class="calibre22">(:items @to)</tt> transactionally, assuming each is a set,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos678146"></a><a href="#filepos732915"><span class="calibre32">142</span></a><span class="calibre32">]</span></small></sup> and returns the new state of <tt class="calibre22">from</tt>:</p><p id="filepos678289" class="calibre23"></p><p class="calibre23"><span class="italic">Example 4-2. loot</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(defn loot<br class="calibre33"/>  [from to]<br class="calibre33"/>  (dosync<br class="calibre33"/>    (when-let [item (first (:items @from))]         </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>      (alter to update-in [:items] conj item)<br class="calibre33"/>      (alter from update-in [:items] disj item))))</tt></span></p><p class="calibre23"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">If <tt class="calibre22">(:items @from)</tt> is empty, <tt class="calibre22">first</tt> will return <tt class="calibre22">nil</tt>, the body of <tt class="calibre22">when-let</tt> will remain unevaluated, the transaction will be a no-op, and <tt class="calibre22">loot</tt> itself will return <tt class="calibre22">nil</tt>.</blockquote><p class="calibre13">Again, assuming Smaug is dead, we can cause Bilbo and Gandalf to loot his items:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(wait-futures 1<br class="calibre33"/>              (while (loot smaug bilbo))<br class="calibre33"/>              (while (loot smaug gandalf)))<br class="calibre33"/>;= nil<br class="calibre33"/>@smaug<br class="calibre33"/>;= {:name "Smaug", :items #{}, :health 500}<br class="calibre33"/>@bilbo<br class="calibre33"/>;= {:name "Bilbo", :items #{0 44 36 13 ... 16}, :health 500}<br class="calibre33"/>@gandalf<br class="calibre33"/>;= {:name "Gandalf", :items #{32 4 26 ... 15}, :health 500}</tt></span></blockquote><p class="calibre23">Right, so Gandalf and Bilbo have now taken all of Smaug’s items. The important point to notice is that the <tt class="calibre22">bilbo</tt> and <tt class="calibre22">gandalf</tt> characters divvied up Smaug’s loot from different futures (therefore, threads), and that all the looting occurred atomically: no items are unaccounted for, no item references were duplicated, and at no point was an item owned by multiple characters.</p><p id="filepos680233" class="calibre23"></p><p class="calibre23"><span class="italic">Example 4-3. Verifying the consistency of loot</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(map (comp count :items deref) [bilbo gandalf])  </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= (21 29)<br class="calibre33"/>(filter (:items @bilbo) (:items @gandalf))       </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= ()</tt></span></p><p class="calibre23"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">If these counts were to add up to anything other than <tt class="calibre22">50</tt> (the original number of items held by Smaug), or…</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">…if Gandalf ended up with any items that Bilbo also held, then the effect of our <tt class="calibre22">loot</tt> transactions would have been cumulatively inconsistent.</blockquote><p class="calibre13">This was accomplished without the manual management of locks, and this process will scale to accommodate transactions involving far more refs and far more interleaving transactions applied by far more separate threads of execution.</p><p id="filepos681623" class="calibre23"><span class="calibre53"><span class="bold">Understanding alter</span></span></p><p class="calibre18"><tt class="calibre22">loot</tt><a id="filepos681744"></a> uses <tt class="calibre22">alter</tt>, which is similar to <tt class="calibre22">swap!</tt> insofar as it takes a ref, a function ƒ, and additional arguments to that function. When <tt class="calibre22">alter</tt> returns, the <span class="italic">in-transaction value</span> of the ref in question will have been changed to the return of a call to ƒ, with the ref’s value as the first argument, followed by all of the additional arguments to <tt class="calibre22">alter</tt>.</p><p class="calibre18">The notion of an in-transaction value is an important one. All the functions that modify the state of a ref actually operate on a speculative timeline for the ref’s state, which starts for each ref when it is first <span class="italic">modified</span>. All later ref access and modification works on this separate timeline, which only exists and can only be accessed from within the transaction. When control flow is to exit a transaction, the STM attempts to commit it. In the optimistic case, this will result in the in-transaction, speculative states of each affected ref being installed as the refs’ new shared, non-transaction state, fully visible to the rest of the world. However, depending upon the semantics of the operation(s) used to establish those in-transaction values, any change made to the refs’ state outside of the transaction <span class="italic">may</span> conflict with the transaction’s modifications, resulting in the transaction being restarted from scratch.</p><p class="calibre18">Throughout this process, any thread of execution that is solely <span class="italic">reading</span> (i.e., dereferencing) refs involved in a transaction can do so without being blocked or waiting in any circumstance. Further, until a given transaction commits successfully, its changes will not affect the state of refs seen by readers outside of that transaction, including readers operating within the scope of entirely different transactions.</p><p class="calibre18">The unique semantic of <tt class="calibre22">alter</tt><a id="filepos683645"></a> is that, when the transaction is to be committed, the value of the ref outside of the transaction must be the same as it was prior to the first in-transaction application of <tt class="calibre22">alter</tt>. Otherwise, the transaction is restarted from the beginning with the new observed values of the refs involved.</p><p class="calibre18">This dynamic can be visualized as the interaction between two transactions, <tt class="calibre22">t<sub class="calibre85"><small class="calibre31"><span class="calibre32">1</span></small></sub></tt> and <tt class="calibre22">t<sub class="calibre85"><small class="calibre31"><span class="calibre32">2</span></small></sub></tt>, which both affect some shared ref <tt class="calibre22">a</tt> using <tt class="calibre22">alter</tt>:</p><blockquote id="filepos684255" class="calibre47"></blockquote><blockquote class="calibre39"><img src="images/00059.jpg" class="calibre86"/></blockquote><blockquote class="calibre57"><span class="calibre10"><span class="italic"><span class="calibre7">Figure 4-2. Interaction of transactions using alter, with conflict on a shared ref</span></span></span></blockquote><p class="calibre50">Even though <tt class="calibre22">t<sub class="calibre85"><small class="calibre31"><span class="calibre32">1</span></small></sub></tt> starts before <tt class="calibre22">t<sub class="calibre85"><small class="calibre31"><span class="calibre32">2</span></small></sub></tt>, its attempt to commit changes to <tt class="calibre22">a</tt> fails because <tt class="calibre22">t<sub class="calibre85"><small class="calibre31"><span class="calibre32">2</span></small></sub></tt> has already modified it in the interim: the current state of <tt class="calibre22">a</tt> (<tt class="calibre22">a<sub class="calibre85"><small class="calibre31"><span class="calibre32">2</span></small></sub></tt>) is different than the state of <tt class="calibre22">a</tt> (<tt class="calibre22">a<sub class="calibre85"><small class="calibre31"><span class="calibre32">1</span></small></sub></tt>) when it was first modified within <tt class="calibre22">t<sub class="calibre85"><small class="calibre31"><span class="calibre32">1</span></small></sub></tt>. This conflict aborts the commit of any and all in-transaction modifications to refs affected by <tt class="calibre22">t<sub class="calibre85"><small class="calibre31"><span class="calibre32">1</span></small></sub></tt> (e.g., <tt class="calibre22">x</tt>, <tt class="calibre22">y</tt>, <tt class="calibre22">z</tt>, …). <tt class="calibre22">t<sub class="calibre85"><small class="calibre31"><span class="calibre32">1</span></small></sub></tt> then restarts, using up-to-date values for all of the refs it touches.</p><p class="calibre18">Depicted and described this way, you can think of Clojure’s STM as a process that optimistically attempts to reorder concurrent change operations so they are applied serially. Unsurprisingly, the same semantics are found in the database world as well, often called <span class="italic">serializable snapshot isolation</span><a id="filepos685958"></a> (<a href="https://en.wikipedia.org/wiki/Serializability"><span class="calibre5">https://en.wikipedia.org/wiki/Serializability</span></a>).</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">A transaction’s effects will not be committed to the refs involved if </span><a id="filepos686366"></a><span class="calibre10"><span class="italic">any</span></span><span class="calibre10"> conflicts exist at commit time. That is, just a single contested ref change is enough to cause a transaction to retry, even if 100 other ref changes could be committed cleanly.</span></blockquote><p id="filepos686617" class="calibre25"><span class="calibre53"><span class="bold">Minimizing transaction conflict with commute</span></span></p><p id="filepos686722" class="calibre18">Because it makes no assumptions about the reorderability of the modifications made to affected refs, <tt class="calibre22">alter</tt> is the safest mechanism for effecting ref change. However, there <span class="italic">are</span> situations where the modifications being made to refs can be reordered safely; in such contexts, <tt class="calibre22">commute</tt> can be used in place of <tt class="calibre22">alter</tt>, potentially minimizing conflicts and transaction retries and therefore maximizing total throughput.</p><p class="calibre18">As its name hints, <tt class="calibre22">commute</tt> has to do with <span class="italic">commutative</span> functions (<a href="https://en.wikipedia.org/wiki/Commutative_property"><span class="calibre5">https://en.wikipedia.org/wiki/Commutative_property</span></a>)—those whose arguments may be reordered without impacting results, such as <tt class="calibre22">+</tt>, <tt class="calibre22">*</tt>, <tt class="calibre22">clojure.set/union</tt>…—but it doesn’t mandate that the functions passed to it be commutative. What really matters is that the function applications performed using <tt class="calibre22">commute</tt> are reorderable without violating program semantics. It follows that in such cases, it is the final result of all commutable function applications that matters, and not any intermediate results.</p><p class="calibre18">For example, although division is not commutative, it may be often used with <tt class="calibre22">commute</tt> when you are not concerned with intermediate results:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(= (/ (/ 120 3) 4) (/ (/ 120 4) 3))<br class="calibre33"/>;= true</tt></span></blockquote><p class="calibre23">Thus, <tt class="calibre22">commute</tt> can be used when the functional composition is commutative for the functions involved:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(= ((comp #(/ % 3) #(/ % 4)) 120) ((comp #(/ % 4) #(/ % 3)) 120))<br class="calibre33"/>;= true</tt></span></blockquote><p class="calibre23">Generally, <tt class="calibre22">commute</tt> should only be used to apply changes to ref states where reordering of that application is acceptable.</p><p class="calibre18"><tt class="calibre22">commute</tt> differs from <tt class="calibre22">alter</tt> in two ways. First, the value returned by <tt class="calibre22">alter</tt> on a ref will be the committed value of this ref; in other words, the in-transaction value is the eventual committed value. On the other hand, the in-transaction value produced by <tt class="calibre22">commute</tt> is not guaranteed to be the eventual committed value, because the <tt class="calibre22">commute</tt>d function will be applied again at commit time with the latest value for the <tt class="calibre22">commute</tt>d ref.</p><p class="calibre18">Second, a change made to a ref by using <tt class="calibre22">commute</tt> will <span class="italic">never</span> cause a conflict, and therefore never cause a transaction to retry. This obviously has potentially significant performance and throughput implications: transaction retries are fundamentally rework and time that a thread is “blocked” waiting for a transaction to complete successfully instead of moving on to its next task.</p><p class="calibre18">We can demonstrate this very directly. Given some ref <tt class="calibre22">x</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def x (ref 0))<br class="calibre33"/>;= #'user/x</tt></span></blockquote><p class="calibre23">We’ll beat on it with 10,000 transactions that do some small amount of work (just obtaining the sum of some integers), and then <tt class="calibre22">alter</tt>
<tt class="calibre22">x</tt>’s value:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(time (wait-futures 5<br class="calibre33"/>                    (dotimes [_ 1000]<br class="calibre33"/>                      (dosync (alter x + (apply + (range 1000)))))<br class="calibre33"/>                    (dotimes [_ 1000]<br class="calibre33"/>                      (dosync (alter x - (apply + (range 1000)))))))<br class="calibre33"/>; "Elapsed time: 1466.621 msecs"</tt></span></blockquote><p class="calibre23">At least some of the time taken to process these transactions was spent in retries, thus forcing the resumming of the integer sequence. However, the operations used with <tt class="calibre22">alter</tt> here (addition and subtraction) can safely be used with <tt class="calibre22">commute</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(time (wait-futures 5<br class="calibre33"/>                    (dotimes [_ 1000]<br class="calibre33"/>                      (dosync (commute x + (apply + (range 1000)))))<br class="calibre33"/>                    (dotimes [_ 1000]<br class="calibre33"/>                      (dosync (commute x - (apply + (range 1000)))))))<br class="calibre33"/>; "Elapsed time: 818.41 msecs"</tt></span></blockquote><p class="calibre23">Even though it applies the change function to the ref’s value twice—once to set the in-transaction value (so <tt class="calibre22">x</tt> would have an updated value if we were to refer to it again later in the transaction), and once again at commit-time to make the “real” change to the (potentially modified) value of <tt class="calibre22">x</tt>—our cumulative runtime is cut nearly in half because <tt class="calibre22">commute</tt> will never retry.</p><p class="calibre18"><tt class="calibre22">commute</tt> is not magic though: it needs to be used judiciously, or it can produce invalid results. Let’s see what happens if we carelessly use <tt class="calibre22">commute</tt> instead of <tt class="calibre22">alter</tt> in the <tt class="calibre22">loot</tt> function from <a href="#filepos678289"><span class="calibre5">Example 4-2</span></a>:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 4-4. A flawed-loot function that uses commute</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(defn flawed-loot<br class="calibre33"/>  [from to]<br class="calibre33"/>  (dosync<br class="calibre33"/>    (when-let [item (first (:items @from))]<br class="calibre33"/>      (commute to update-in [:items] conj item)<br class="calibre33"/>      (commute from update-in [:items] disj item))))</tt></span></p><p class="calibre13">Let’s reset our characters and see what our new looting function does:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def smaug (character "Smaug" :health 500 :strength 400 :items (set (range 50))))<br class="calibre33"/>(def bilbo (character "Bilbo" :health 100 :strength 100))<br class="calibre33"/>(def gandalf (character "Gandalf" :health 75 :mana 750))<br class="calibre33"/><br class="calibre33"/>(wait-futures 1<br class="calibre33"/>              (while (flawed-loot smaug bilbo))<br class="calibre33"/>              (while (flawed-loot smaug gandalf)))<br class="calibre33"/>;= nil<br class="calibre33"/>(map (comp count :items deref) [bilbo gandalf])<br class="calibre33"/>;= (5 48)<br class="calibre33"/>(filter (:items @bilbo) (:items @gandalf))<br class="calibre33"/>;= (18 32 1)</tt></span></blockquote><p class="calibre23">Using the same checks from <a href="#filepos680233"><span class="calibre5">Example 4-3</span></a>, we can see that <tt class="calibre22">flawed-loot</tt> has produced some problems: Bilbo has 5 items while Gandalf has 48 (with <tt class="calibre22">18</tt>, <tt class="calibre22">32</tt>, and <tt class="calibre22">1</tt> being the three duplicated items), a situation that should never happen since Smaug started with 50.</p><p class="calibre18">What went wrong? In three instances, the same value was pulled from Smaug’s set of <tt class="calibre22">:items</tt> and <tt class="calibre22">conj</tt>ed into both Bilbo’s and Gandalf’s <tt class="calibre22">:items</tt>. This is prevented in the known-good implementation of <tt class="calibre22">loot</tt> because using <tt class="calibre22">alter</tt> properly guarantees that the in-transaction and committed values will be identical.</p><p class="calibre18">In this peculiar case, we <span class="italic">can</span> safely use <tt class="calibre22">commute</tt> to add the looted item to the recipient’s set (since the order in which items are added to the set is of no importance); it is the removal of the looted item from its source that requires the use of <tt class="calibre22">alter</tt>:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 4-5. A fixed-loot function that uses both commute and alter</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(defn fixed-loot<br class="calibre33"/>  [from to]<br class="calibre33"/>  (dosync<br class="calibre33"/>    (when-let [item (first (:items @from))]<br class="calibre33"/>      (commute to update-in [:items] conj item)<br class="calibre33"/>      (alter from update-in [:items] disj item))))<br class="calibre33"/><br class="calibre33"/>(def smaug (character "Smaug" :health 500 :strength 400 :items (set (range 50))))<br class="calibre33"/>(def bilbo (character "Bilbo" :health 100 :strength 100))<br class="calibre33"/>(def gandalf (character "Gandalf" :health 75 :mana 750))<br class="calibre33"/><br class="calibre33"/>(wait-futures 1<br class="calibre33"/>              (while (fixed-loot smaug bilbo))<br class="calibre33"/>              (while (fixed-loot smaug gandalf)))<br class="calibre33"/>;= nil<br class="calibre33"/>(map (comp count :items deref) [bilbo gandalf])<br class="calibre33"/>;= (24 26)<br class="calibre33"/>(filter (:items @bilbo) (:items @gandalf))<br class="calibre33"/>;= ()</tt></span></p><p class="calibre13">On the other hand, <tt class="calibre22">commute</tt> is perfect for other functions in our game. For example, <tt class="calibre22">attack</tt> and <tt class="calibre22">heal</tt> functions are just going to be incrementing and decrementing various character attributes, so such changes can be made safely using <tt class="calibre22">commute</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn attack<br class="calibre33"/>  [aggressor target]<br class="calibre33"/>  (dosync<br class="calibre33"/>    (let [damage (* (rand 0.1) (:strength @aggressor))]<br class="calibre33"/>      (commute target update-in [:health] #(max 0 (- % damage))))))<br class="calibre33"/><br class="calibre33"/>(defn heal<br class="calibre33"/>  [healer target]<br class="calibre33"/>  (dosync<br class="calibre33"/>    (let [aid (* (rand 0.1) (:mana @healer))]<br class="calibre33"/>      (when (pos? aid)<br class="calibre33"/>        (commute healer update-in [:mana] - (max 5 (/ aid 5)))<br class="calibre33"/>        (commute target update-in [:health] + aid)))))</tt></span></blockquote><p class="calibre23">With a couple of additional functions, we can simulate a player taking some action within our game:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 4-6. Player-simulation functions</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(def alive? (comp pos? :health))<br class="calibre33"/><br class="calibre33"/>(defn play<br class="calibre33"/>  [character action other]<br class="calibre33"/>  (while (and (alive? @character)<br class="calibre33"/>              (alive? @other)<br class="calibre33"/>              (action character other))<br class="calibre33"/>    (Thread/sleep (rand-int 50))))      </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/></p><p class="calibre23"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Surely no one can spam a particular action more than 20 times a second!</blockquote><p class="calibre13">Now we can have duels:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(wait-futures 1<br class="calibre33"/>              (play bilbo attack smaug)<br class="calibre33"/>              (play smaug attack bilbo))<br class="calibre33"/>;= nil<br class="calibre33"/>(map (comp :health deref) [smaug bilbo])  </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= (488.80755445030337 -12.0394908759935)</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">All by his lonesome, Bilbo understandably cannot hold his own against Smaug.</blockquote><p class="calibre18">…or, “epic” battles:</p><p id="filepos698232" class="calibre23"></p><p class="calibre23"><span class="italic">Example 4-7. A battle between three characters</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(dosync                            </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  (alter smaug assoc :health 500)<br class="calibre33"/>  (alter bilbo assoc :health 100))<br class="calibre33"/><br class="calibre33"/>(wait-futures 1<br class="calibre33"/>              (play bilbo attack smaug)<br class="calibre33"/>              (play smaug attack bilbo)<br class="calibre33"/>              (play gandalf heal bilbo))<br class="calibre33"/>;= nil<br class="calibre33"/>(map (comp #(select-keys % [:name :health :mana]) deref) [smaug bilbo gandalf]) </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= ({:health 0, :name "Smaug"}<br class="calibre33"/>;=  {:health 853.6622368542827, :name "Bilbo"}<br class="calibre33"/>;=  {:mana -2.575955687302212, :health 75, :name "Gandalf"})</tt></span></p><p class="calibre23"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Just resetting our characters back to full health.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">Bilbo can ably take down Smaug as long as Gandalf is healing him throughout the course of the fight.<a id="filepos699750"></a></blockquote><p id="filepos699770" class="calibre13"><span class="calibre53"><span class="bold">Clobbering ref state with ref-set</span></span></p><p class="calibre18"><tt class="calibre22">ref-set</tt><a id="filepos699908"></a> will set the in-transaction state of a ref to the given value:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(dosync (ref-set bilbo {:name "Bilbo"}))<br class="calibre33"/>;= {:name "Bilbo"}</tt></span></blockquote><p class="calibre23">Just like <tt class="calibre22">alter</tt>, <tt class="calibre22">ref-set</tt> will provoke a retry of the surrounding transaction if the affected ref’s state changes prior to commit-time. Said differently, <tt class="calibre22">ref-set</tt><a id="filepos700353"></a> is semantically equivalent to using <tt class="calibre22">alter</tt> with a function that returns a constant value:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(dosync (alter bilbo (constantly {:name "Bilbo"})))<br class="calibre33"/>; {:name "Bilbo"}</tt></span></blockquote><p class="calibre23">Since this change is made without reference to the current value of the ref, it is quite easy to change a ref’s value in a way that is consistent with regard to the STM’s transactional guarantees, but that violates application-level contracts. Thus, <tt class="calibre22">ref-set</tt> is generally used only to reinitialize refs’ state to starting values.</p><p id="filepos701002" class="calibre23"><span class="calibre53"><span class="bold">Enforcing local consistency by using validators</span></span></p><p id="filepos701110" class="calibre18">If you’ll notice, Bilbo has a <span class="italic">very</span> high <tt class="calibre22">:health</tt> value at the end of <a href="#filepos698232"><span class="calibre5">Example 4-7</span></a>. Indeed, there is no limit to how high a character’s <tt class="calibre22">:health</tt> can go, as a results of heals or other restorative actions.</p><p class="calibre18">These sorts of games generally do not allow a character’s health to exceed a particular level. However, from both a technical and management perspective—especially given a large team or codebase—it may be too onerous to guarantee that every function that might increase a character’s health would not produce a health “overage.” Such functions may, as part of their own semantics, attempt to avoid such an illegal condition, but we must be able to protect the integrity of our model separately. Maintaining local consistency like this—the C in “ACID”—in the face of concurrent changes is the job of validators.</p><p class="calibre18">We talked about validators already in <a href="#filepos663915"><span class="calibre5">Validators</span></a>. Their use and semantics with refs is entirely the same as with other reference types, but their interaction with the STM is particularly convenient: if a validator function signals an invalid state, the exception that is thrown (just like any other exception thrown within a transaction) causes the current transaction itself to fail.</p><p class="calibre18">With this in mind, we should refactor our game’s implementation details a bit. First, <tt class="calibre22">character</tt> should be changed so that:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">A common set of validators is added to every character.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Additional validators can be provided for each character, so as to enforce constraints related to a character’s class, level, or other status in the game:</blockquote></li></ol><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn- enforce-max-health                                           </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  [{:keys [name health]}]<br class="calibre33"/>  (fn [character-data]<br class="calibre33"/>    (or (&lt;= (:health character-data) health)<br class="calibre33"/>      (throw (IllegalStateException. (str name " is already at max health!"))))))<br class="calibre33"/><br class="calibre33"/>(defn character<br class="calibre33"/>  [name &amp; {:as opts}]<br class="calibre33"/>  (let [cdata (merge {:name name :items #{} :health 500}<br class="calibre33"/>                     opts)<br class="calibre33"/>        cdata (assoc cdata :max-health (:health cdata))             </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>        validators (list* (enforce-max-health name (:health cdata)) </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>                          (:validators cdata))]<br class="calibre33"/>    (ref (dissoc cdata :validators)<br class="calibre33"/>      :validator #(every? (fn [v] (v %)) validators))))          </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">enforce-max-health</tt> returns a function that accepts a character’s <span class="italic">potential</span> new state, throwing an exception if the new <tt class="calibre22">:health</tt> attribute is above the character’s original health level.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">We record the character’s initial <tt class="calibre22">:health</tt> as their <tt class="calibre22">:max-health</tt>, which will come in handy later.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">In addition to always ensuring that a character’s maximum health is never exceeded, it is easy to allow individual characters to be created with their own additional set of validator functions…</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">…which can be easily rolled into the validation of their containing refs.</blockquote><p class="calibre18">Now, no character can ever be healed past his original health level:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def bilbo (character "Bilbo" :health 100 :strength 100))<br class="calibre33"/>;= #'user/bilbo<br class="calibre33"/>(heal gandalf bilbo)<br class="calibre33"/>;= #&lt;IllegalStateException java.lang.IllegalStateException: Bilbo is already at max <br class="calibre33"/>    health!&gt;</tt></span></blockquote><p class="calibre23">One limitation of validators is that they are strictly <span class="italic">local</span>; that is, their charter does not extend past ensuring that the next state held by a reference satisfies the constraints they check:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(dosync (alter bilbo assoc-in [:health] 95))<br class="calibre33"/>;= {:max-health 100, :strength 100, :name "Bilbo", :items #{}, :health 95, :xp 0}<br class="calibre33"/>(heal gandalf bilbo)<br class="calibre33"/>;= #&lt;IllegalStateException java.lang.IllegalStateException: Bilbo is already at max <br class="calibre33"/>    health!&gt;</tt></span></blockquote><p class="calibre23">Here, Bilbo’s <tt class="calibre22">:health</tt> is set just short of his <tt class="calibre22">:max-health</tt>, so he really should be heal-able. However, the implementation of <tt class="calibre22">heal</tt> does not yet take <tt class="calibre22">:max-health</tt> into account, and there is no way for the relevant validator to “tweak” Bilbo’s new state to suit its constraints—in this case, to make his <tt class="calibre22">:health</tt> the lesser of his <tt class="calibre22">:max-health</tt> or the sum of his current <tt class="calibre22">:health</tt> and Gandalf’s <tt class="calibre22">heal</tt> amount. If validators <span class="italic">were</span> allowed to make changes like this, then it would be difficult to avoid introducing inconsistency into the refs modified within a transaction. Validators exist solely to maintain invariants within your model.</p><p class="calibre18">A tweak to <tt class="calibre22">heal</tt> is warranted to ensure that “partial” heals are possible, up to a character’s maximum health:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn heal<br class="calibre33"/>  [healer target]<br class="calibre33"/>  (dosync<br class="calibre33"/>    (let [aid (min (* (rand 0.1) (:mana @healer))<br class="calibre33"/>                   (- (:max-health @target) (:health @target)))]<br class="calibre33"/>      (when (pos? aid)<br class="calibre33"/>        (commute healer update-in [:mana] - (max 5 (/ aid 5)))<br class="calibre33"/>        (alter target update-in [:health] + aid)))))</tt></span></blockquote><p class="calibre23">Now <tt class="calibre22">heal</tt> will improve a character’s health <span class="italic">up to</span> his maximum health, returning <tt class="calibre22">nil</tt> when the character’s health is already at that level:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(dosync (alter bilbo assoc-in [:health] 95))<br class="calibre33"/>;= {:max-health 100, :strength 100, :name "Bilbo", :items #{}, :health 95}<br class="calibre33"/>(heal gandalf bilbo)<br class="calibre33"/>;= {:max-health 100, :strength 100, :name "Bilbo", :items #{}, :health 100}<br class="calibre33"/>(heal gandalf bilbo)<br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre23">Note that our modification to <tt class="calibre22">target</tt> now potentially depends upon its prior state, so we use <tt class="calibre22">alter</tt> instead of <tt class="calibre22">commute</tt>. This isn’t strictly required: perhaps you would be happy enough to have the validator catch errant heals, which would happen only if some other concurrently applied transaction also increased the health of the target character. This points to a potential downside to how we’ve modeled our characters, as all-encompassing bags of state (maps in this case) held by a single ref: if concurrent transactions modify unrelated parts of that state using <tt class="calibre22">alter</tt>, a transaction will retry unnecessarily.<a id="filepos709570"></a><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos709612"></a><a href="#filepos733328"><span class="calibre32">143</span></a><span class="calibre32">]</span></small></sup></p><p id="filepos709711" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">The Sharp Corners of Software Transactional Memory</span></span></span></p><p id="filepos709851" class="calibre18">As we said at the beginning of this chapter, Clojure does not offer any silver bullet to solve the problem of concurrency. Its STM implementation may sometimes seem magical—and, compared to the typical alternatives involving manual lock management, it sorta is—but even the STM has its own sharp corners and rough edges of which you should be aware.</p><p id="filepos710236" class="calibre23"><span class="calibre53"><span class="bold">Side-effecting functions strictly verboten</span></span></p><p id="filepos710339" class="calibre18">The only operations that should ever be performed within the scope of a transaction are things that are safe to retry, which rules out many forms of I/O. For example, if you attempt to write to a file or database inside a <tt class="calibre22">dosync</tt><a id="filepos710604"></a> block, you will quite possibly end up writing the same data to the file or database multiple times.</p><p class="calibre18">Clojure can’t detect that you’re attempting to perform an unsafe operation inside a transaction; it will happily and silently retry those operations, perhaps with disastrous results. For this reason, Clojure provides an <tt class="calibre22">io!</tt> macro, which will throw an error if it is ever evaluated within a transaction. Thus, if you have a function that may be used within a transaction, you can wrap the side-effecting portion of its body in an <tt class="calibre22">io!</tt> form to help guard against accidentally calling unsafe code:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn unsafe<br class="calibre33"/>  []<br class="calibre33"/>  (io! (println "writing to database...")))<br class="calibre33"/>;= #'user/unsafe<br class="calibre33"/>(dosync (unsafe))<br class="calibre33"/>;= #&lt;IllegalStateException java.lang.IllegalStateException: I/O in transaction&gt;</tt></span></blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">As a corollary, operations on atoms should generally be considered side-effecting, insofar as </span><a id="filepos711862"></a><span class="calibre10"><tt class="calibre22">swap!</tt></span><span class="calibre10">, et al., do not participate in the STM’s transactional semantics. Thus, if a transaction is retried three times, and it contains a </span><span class="calibre10"><tt class="calibre22">swap!</tt></span><span class="calibre10"> call, </span><span class="calibre10"><tt class="calibre22">swap!</tt></span><span class="calibre10"> will be invoked three times and the affected atom will be modified three times…rarely what you want, unless you’re using an atom to count transaction retries.</span></blockquote><p class="calibre25">Note also that the values held by refs <span class="italic">must</span> be immutable.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos712487"></a><a href="#filepos734141"><span class="calibre32">144</span></a><span class="calibre32">]</span></small></sup> Clojure isn’t going to stop you from putting mutable objects into a ref, but things like retries and the usual foibles associated with mutability will likely result in undesirable effects:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def x (ref (java.util.ArrayList.)))<br class="calibre33"/>;= #'user/x<br class="calibre33"/>(wait-futures 2 (dosync (dotimes [v 5]<br class="calibre33"/>                          (Thread/sleep (rand-int 50))    </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>                          (alter x #(doto % (.add v))))))<br class="calibre33"/>;= nil<br class="calibre33"/>@x<br class="calibre33"/>;= #&lt;ArrayList [0, 0, 1, 0, 2, 3, 4, 0, 1, 2, 3, 4]&gt;      </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">The randomized <tt class="calibre22">sleep</tt> call ensures that the two transactions will overlap; at least one of them will retry, leading to…</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">…hopelessly flawed results.</blockquote><p id="filepos713926" class="calibre23"><span class="calibre53"><span class="bold">Minimize the scope of each transaction</span></span></p><p id="filepos714025" class="calibre18">Remember from the discussion around <a href="#filepos684255"><span class="calibre5">Figure 4-2</span></a> that the STM’s job is to ensure that all of the work encapsulated as transactions be applied to affected refs in a serial fashion, reordering that work and those ref state changes if necessary. This implies that, the shorter each transaction is, the easier it will be for the STM to schedule that transaction, thus leading to faster application and higher total throughput.</p><p class="calibre18">What happens if you have out-sized transactions, or transactions with a mix of scopes and scales? In general, the largest transactions will be delayed (along with whatever else the thread waiting on that transaction would otherwise be doing). Consider a bunch of transactions, all affecting some ref <tt class="calibre22">a</tt>:</p><p class="calibre51"><img src="images/00037.jpg" class="calibre87"/></p><p class="calibre13">Assuming each of them is <tt class="calibre22">alter</tt>ing <tt class="calibre22">a</tt>, the execution of those transactions will be retried until they can be applied serially. The longest-running transaction will end up being retried repeatedly, with the likely result that it will be delayed until a long enough slot opens up in the contended ref’s timeline for it to fit:</p><p class="calibre51"><img src="images/00063.jpg" class="calibre88"/></p><blockquote class="calibre89"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Remember that </span><span class="calibre10"><tt class="calibre22">commute</tt></span><a id="filepos715721"></a><span class="calibre10"> (discussed in </span><a href="#filepos686617"><span class="calibre10"><span class="calibre5">Minimizing transaction conflict with commute</span></span></a><span class="calibre10">) does not provoke change conflicts and retries. Therefore, if you can use it safely with the change functions applicable to your state’s domain, you will effectively sidestep any potential hazards associated with long-running transactions.</span></blockquote><p class="calibre25">Doing a lot of time-consuming computation can result in a long-running transaction, but so can retries prompted by contention over other refs. For example, the long-running transaction depicted above may be performing some complex computation, which may need to be restarted repeatedly due to contention over another ref. Thus, you should aim to minimize the scope of transactions in general as much as possible both in terms of the computational runtime involved and in the number of affected refs.</p><p class="calibre18"><span class="bold">Live lock</span>. <a id="filepos716741"></a>You might wonder: what happens if, particularly in times of heavy load, a large transaction <span class="italic">never</span> gets a chance to commit due to ref contention? This is called <span class="italic">live lock</span>, the STM equivalent to a deadlock, where the thread(s) driving the transactions involved are blocked indefinitely attempting to commit their respective transactions. Without suitable fallbacks,<a id="filepos717125"></a> and we’d be no better off than if we were manually managing locks and causing our own deadlocks!</p><p class="calibre18">Thankfully, Clojure’s STM does have a couple of fallbacks. The first is called <span class="italic">barging</span><a id="filepos717358"></a>, where an older transaction is allowed to proceed in certain circumstances, forcing newer transactions to retry. When barging fails to push through the older transaction in a reasonable amount of time, the STM will simply cause the offending transaction to fail:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def x (ref 0))<br class="calibre33"/>;= #'user/x<br class="calibre33"/>(dosync<br class="calibre33"/>  @(future (dosync (ref-set x 0)))<br class="calibre33"/>  (ref-set x 1))<br class="calibre33"/>;= #&lt;RuntimeException java.lang.RuntimeException:<br class="calibre33"/>;=   Transaction failed after reaching retry limit&gt;<br class="calibre33"/>@x<br class="calibre33"/>;= 0</tt></span></blockquote><p class="calibre23">The transaction running in the REPL <a id="filepos718069"></a>thread above always starts a new future, itself running a transaction that modifies the state of the contended ref. Dereferencing that future ensures that the REPL thread’s transaction waits until the future’s transaction has completed, thus ensuring a retry—and therefore the spawning of a new future, and so on.</p><p class="calibre18">Clojure’s STM will permit a transaction to retry only so many times before throwing an exception. An error thrown with a stack trace you can examine is infinitely better than an actual deadlock (or live lock), where the only solution is to forcibly kill the application’s process with little to no information about the problem’s locale.</p><p id="filepos718774" class="calibre23"><span class="calibre53"><span class="bold">Readers may retry</span></span></p><p id="filepos718852" class="calibre18">In the case of reference types, <tt class="calibre22">deref</tt> is guaranteed to never block. However, <span class="italic">inside a transaction</span>
<tt class="calibre22">deref</tt><a id="filepos719008"></a>erencing a ref may trigger a transaction retry!</p><p class="calibre18">This is because, if a new value is committed by another transaction since the beginning of the current transaction, the value of the ref <span class="italic">as of the start of the transaction</span> cannot be provided.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos719327"></a><a href="#filepos734626"><span class="calibre32">145</span></a><span class="calibre32">]</span></small></sup> Helpfully, the STM notices this problem and maintains a bounded history of the states of refs involved in a transaction, where the size of the history is incremented by each retry. This increases the chance that—at some point—the transaction won’t have to retry anymore because, while the ref is concurrently updated, the desired value is still present in the history.</p><p id="filepos719801" class="calibre18">History length can be queried (and tuned) with <tt class="calibre22">ref-history-count</tt><a id="filepos719902"></a>, <tt class="calibre22">ref-max-history</tt><a id="filepos719935"></a>, and <tt class="calibre22">ref-min-history</tt><a id="filepos719972"></a>. Minimum and maximum history sizes can also be specified when a ref is created by using the named arguments <tt class="calibre22">:min-history</tt> and <tt class="calibre22">:max-history</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(ref-max-history (ref "abc" :min-history 3 :max-history 30))<br class="calibre33"/>;= 30</tt></span></blockquote><p class="calibre23">This allows you to potentially tune a ref to suit expected workloads.</p><p class="calibre18">Retries on <tt class="calibre22">deref</tt> generally occur in the context of read-only transactions, which attempt to snapshot a lot of very active refs. We can visualize this behavior with a single ref and a slow reading transaction:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def a (ref 0))<br class="calibre33"/>(future (dotimes [_ 500] (dosync (Thread/sleep 200) (alter a inc))))<br class="calibre33"/>;= #&lt;core$future_call$reify__5684@10957096: :pending&gt;<br class="calibre33"/>@(future (dosync (Thread/sleep 1000) @a))<br class="calibre33"/>;= 28                    </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>(ref-history-count a)<br class="calibre33"/>;= 5</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">The read value being 28 means that the reader transaction has been able to complete before all the writers have been run.</blockquote><p class="calibre18">So, the <tt class="calibre22">a</tt> ref has grown its history to accommodate the needs of the slow reading transaction. What happens if the writes occur even faster?</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def a (ref 0))<br class="calibre33"/>(future (dotimes [_ 500] (dosync (Thread/sleep 20) (alter a inc))))<br class="calibre33"/>;= #&lt;core$future_call$reify__5684@10957096: :pending&gt;<br class="calibre33"/>@(future (dosync (Thread/sleep 1000) @a))<br class="calibre33"/>;= 500<br class="calibre33"/>(ref-history-count a)<br class="calibre33"/>;= 10</tt></span></blockquote><p class="calibre23">This time the history has been maxed out and the reader transaction has only been executed after all the writers. This means that the writers blocked the reader in the second transaction. If we relax the max history, the problem should be fixed:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def a (ref 0 :max-history 100))<br class="calibre33"/>(future (dotimes [_ 500] (dosync (Thread/sleep 20) (alter a inc))))<br class="calibre33"/>;= #&lt;core$future_call$reify__5684@10957096: :pending&gt;<br class="calibre33"/>@(future (dosync (Thread/sleep 1000) @a))<br class="calibre33"/>;= 500<br class="calibre33"/>(ref-history-count a)<br class="calibre33"/>;= 10</tt></span></blockquote><p class="calibre23">It didn’t work because by the time there’s enough history, the writers are done. So, the key is to set the minimum history to a good value:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def a (ref 0 :min-history 50 :max-history 100)) </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>(future (dotimes [_ 500] (dosync (Thread/sleep 20) (alter a inc))))<br class="calibre33"/>@(future (dosync (Thread/sleep 1000) @a))<br class="calibre33"/>;= 33</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">We choose 50 because the reader transaction is 50 times slower than the writer one.</blockquote><p class="calibre18">This time the reader transaction completes quickly and successfully with no retry!</p><p id="filepos723576" class="calibre23"><span class="calibre53"><span class="bold">Write skew</span></span></p><p id="filepos723647" class="calibre18">Clojure’s STM provides for the transactional consistency of ref state, but so far we’ve only seen that to be the case for refs that are modified by the transactions involved. If a ref isn’t modified by a transaction, but the consistency of that transaction’s changes depend upon the state of a ref that is read but not modified, there is no way for the STM to know about this through calls to <tt class="calibre22">alter</tt>, <tt class="calibre22">commute</tt>, and <tt class="calibre22">set-ref</tt>. If the read ref’s state happens to change mid-transaction, that transaction’s effects on other refs may end up being inconsistent with the read ref; this state of affairs is called <span class="italic">write skew</span>.</p><p class="calibre18">Such a circumstance is rare; generally, refs involved in a transaction are all being modified in some way. However, when that’s not the case, <tt class="calibre22">ensure</tt> may be used to prevent write skew: it is a way to dereference a ref such that that read will conflict with any modifications prompted by other transactions, causing retries as necessary.</p><p class="calibre18">An example of this within the game’s context might be the current amount of daylight. It’s safe to say that attacks made with the benefit of mid-day sun will be more successful than those made at night, so a modification to <tt class="calibre22">attack</tt> to take into consideration the current amount of daylight would make sense:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def daylight (ref 1))<br class="calibre33"/><br class="calibre33"/>(defn attack<br class="calibre33"/>  [aggressor target]<br class="calibre33"/>  (dosync<br class="calibre33"/>    (let [damage (* (rand 0.1) (:strength @aggressor) @daylight)]<br class="calibre33"/>      (commute target update-in [:health] #(max 0 (- % damage))))))</tt></span></blockquote><p class="calibre23">However, if the state of <tt class="calibre22">daylight</tt> is changed between the time it is read within a transaction and when that transaction commits its changes, those changes may be inconsistent. For example, a separate game process may shift <tt class="calibre22">daylight</tt> to reflect a sunset-appropriate amount of light (e.g., <tt class="calibre22">(dosync (ref-set daylight 0.3))</tt>). If <tt class="calibre22">attack</tt> is running while that change is being made, and uses the old value of <tt class="calibre22">daylight</tt>, more damage will be attributed to an attack action than is appropriate.</p><blockquote class="calibre47"></blockquote><blockquote class="calibre39"><img src="images/00057.jpg" class="calibre90"/></blockquote><blockquote class="calibre57"><span class="calibre10"><span class="italic"><span class="calibre7">Figure 4-3. Write skew, where state b<sub class="calibre74"><small class="calibre31"><span class="calibre32"><span class="italic"><span class="calibre7">2</span></span></span></small></sub> depends upon state read from a at some prior time</span></span></span></blockquote><p class="calibre50">Formally, if the state <tt class="calibre22">b<sub class="calibre85"><small class="calibre31"><span class="calibre32">2</span></small></sub></tt> that a transaction <tt class="calibre22">t<sub class="calibre85"><small class="calibre31"><span class="calibre32">1</span></small></sub></tt> writes to ref <tt class="calibre22">b</tt> depends upon the state of ref <tt class="calibre22">a</tt> at <tt class="calibre22">a<sub class="calibre85"><small class="calibre31"><span class="calibre32">1</span></small></sub></tt>, and <tt class="calibre22">t<sub class="calibre85"><small class="calibre31"><span class="calibre32">1</span></small></sub></tt> never writes to <tt class="calibre22">a</tt>, and another transaction <tt class="calibre22">t<sub class="calibre85"><small class="calibre31"><span class="calibre32">2</span></small></sub></tt> modifies <tt class="calibre22">a</tt> to hold some state <tt class="calibre22">a<sub class="calibre85"><small class="calibre31"><span class="calibre32">2</span></small></sub></tt> prior to <tt class="calibre22">t<sub class="calibre85"><small class="calibre31"><span class="calibre32">1</span></small></sub></tt> committing, then the world will be inconsistent: <tt class="calibre22">b<sub class="calibre85"><small class="calibre31"><span class="calibre32">2</span></small></sub></tt> corresponds with a past state <tt class="calibre22">a<sub class="calibre85"><small class="calibre31"><span class="calibre32">1</span></small></sub></tt>, not the current state <tt class="calibre22">a<sub class="calibre85"><small class="calibre31"><span class="calibre32">2</span></small></sub></tt>. This is write skew.</p><p class="calibre18">Simply changing <tt class="calibre22">attack</tt> to <tt class="calibre22">(ensure daylight)</tt> instead of dereferencing via <tt class="calibre22">@daylight</tt> will avoid this by guaranteeing that <tt class="calibre22">daylight</tt> will not change before the reading transaction commits successfully.</p><blockquote class="calibre47"></blockquote><blockquote class="calibre39"><img src="images/00019.jpg" class="calibre91"/></blockquote><blockquote class="calibre57"><span class="calibre10"><span class="italic"><span class="calibre7">Figure 4-4. Avoiding write skew using ensure</span></span></span></blockquote><p class="calibre50">When a transaction <tt class="calibre22">t<sub class="calibre85"><small class="calibre31"><span class="calibre32">1</span></small></sub></tt> reads a ref <tt class="calibre22">a</tt> using <tt class="calibre22">ensure</tt> instead of <tt class="calibre22">deref</tt>, any changes to that ref’s state by any other transaction <tt class="calibre22">t<sub class="calibre85"><small class="calibre31"><span class="calibre32">2</span></small></sub></tt> prior to <tt class="calibre22">t<sub class="calibre85"><small class="calibre31"><span class="calibre32">1</span></small></sub></tt> completing will retry until <tt class="calibre22">t<sub class="calibre85"><small class="calibre31"><span class="calibre32">1</span></small></sub></tt> has successfully committed. This will avoid write skew: the change to <tt class="calibre22">b</tt> will always be consistent with the latest state of <tt class="calibre22">a</tt>, even though <tt class="calibre22">t<sub class="calibre85"><small class="calibre31"><span class="calibre32">1</span></small></sub></tt> never changes the state of <tt class="calibre22">a</tt>.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">In terms of avoiding write skew, </span><span class="calibre10"><tt class="calibre22">(ensure a)</tt></span><span class="calibre10"> is semantically equivalent to </span><a id="filepos729109"></a><span class="calibre10"><tt class="calibre22">(alter a identity)</tt></span><span class="calibre10"> or </span><span class="calibre10"><tt class="calibre22">(ref-set a @a)</tt></span><span class="calibre10">—both effectively </span><span class="calibre10"><span class="italic">dummy writes</span></span><span class="calibre10">—which end up requiring that the read value persist until commit time. Compared to dummy writes, </span><span class="calibre10"><tt class="calibre22">ensure</tt></span><span class="calibre10"> will generally minimize the total number of transaction retries involving read-only refs.</span><a id="filepos729589"></a></blockquote><br class="calibre33"/><hr class="calibre34"/><p class="calibre25"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos729702"></a><a href="#filepos670665"><span class="calibre32">136</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Modern garbage collection implementations can enable programs to outperform alternatives written using manual memory management in many contexts; and, each time a new garbage collector implementation or optimization is added to the JVM, every program everywhere benefits from it without any involvement from individual programmers. The same dynamic has played out with Clojure’s STM.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos730272"></a><a href="#filepos670945"><span class="calibre32">137</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">In particular, </span><span class="calibre10"><span class="italic">multiversion concurrency control</span></span><span class="calibre10"> (often abbreviated </span><span class="calibre10"><span class="italic">MVCC</span></span><span class="calibre10">): </span><a href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control"><span class="calibre10"><span class="calibre5">https://en.wikipedia.org/wiki/Multiversion_concurrency_control</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos730846"></a><a href="#filepos672423"><span class="calibre32">138</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">We present a way to address durability of ref state with the help of agents in </span><a href="#filepos790173"><span class="calibre10"><span class="calibre5">Persisting reference states with an agent-based write-behind log</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos731274"></a><a href="#filepos673849"><span class="calibre32">139</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">We’re not game designers, and what we build here is obviously a contrivance, but there’s no reason the mechanisms we demonstrate here could not be utilized and extended to implement a thoroughly capable game engine.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos731678"></a><a href="#filepos675544"><span class="calibre32">140</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">In a real game engine, you would almost surely not use vars to hold characters; rather, it would make sense to use a single map containing all online players’ characters, itself held within a ref. As players were to go on- and offline, their characters would be </span><span class="calibre10"><tt class="calibre22">assoc</tt></span><span class="calibre10">ed and </span><span class="calibre10"><tt class="calibre22">dissoc</tt></span><span class="calibre10">ed from that map.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos732268"></a><a href="#filepos676989"><span class="calibre32">141</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Note that nested transaction scopes—either due to lexically nested </span><span class="calibre10"><tt class="calibre22">dosync</tt></span><span class="calibre10"> forms, or the joining of scopes in, for example, different functions thanks to the flow of execution—are joined into a single logical transaction that commits or retries as a unit when control flows out of the </span><span class="calibre10"><span class="italic">outermost</span></span><span class="calibre10">
</span><span class="calibre10"><tt class="calibre22">dosync</tt></span><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos732915"></a><a href="#filepos678146"><span class="calibre32">142</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Recall from </span><a href="#filepos405763"><span class="calibre10"><span class="calibre5">Set</span></span></a><span class="calibre10"> that </span><span class="calibre10"><tt class="calibre22">disj</tt></span><span class="calibre10"> returns a set that does not contain a given value.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos733328"></a><a href="#filepos709612"><span class="calibre32">143</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Determining ideal </span><span class="calibre10"><span class="italic">ref granularity</span></span><span class="calibre10"> for your particular model is an optimization step that you’ll have to figure through benchmarking, experimentation, and some degree of forethought. Always start with the simplest approach—all-encompassing values are just fine most of the time—only reaching for a more complicated solution when necessary. See </span><a href="http://clj-me.cgrand.net/2011/10/06/a-world-in-a-ref/"><span class="calibre10"><span class="calibre5">http://clj-me.cgrand.net/2011/10/06/a-world-in-a-ref/</span></span></a><span class="calibre10"> for one such potential direction.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos734141"></a><a href="#filepos712487"><span class="calibre32">144</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Or, at the very least, effectively mutable due to your usage of them. For example, it is possible to use a mutable Java list as the state of a ref with proper transactional semantics if you strictly copy-on-write when producing modified lists, but this is both bad form and almost always unnecessary.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos734626"></a><a href="#filepos719327"><span class="calibre32">145</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="#filepos723576"><span class="calibre10"><span class="calibre5">Write skew</span></span></a><span class="calibre10"> for more subtleties on the value returned by </span><span class="calibre10"><tt class="calibre22">deref</tt></span><span class="calibre10"> inside a transaction.</span></p><div class="mbppagebreak"></div><p id="filepos735003" class="calibre6"><span class="calibre4"><span class="bold">Vars</span></span></p><p id="filepos735068" class="calibre18">You’ve already used and worked with vars a great deal. Vars differ from Clojure’s other reference types in that their state changes <a id="filepos735232"></a>are not managed in time; rather, they provide a namespace-global identity <a id="filepos735313"></a>that can optionally be rebound to have a different value on a <span class="italic">per-thread</span> basis. We’ll explain this at length starting in <a href="#filepos744558"><span class="calibre5">Dynamic Scope</span></a>, but first let’s understand some of their fundamentals, since vars are used throughout Clojure, whether concurrency is a concern or not.</p><p class="calibre18">Evaluating a symbol in Clojure normally results in looking for a var with that name in the current namespace and dereferencing that var to obtain its value. But we can also obtain references to vars directly and manually dereference them:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">map<br class="calibre33"/>;= #&lt;core$map clojure.core$map@501d5ebc&gt;<br class="calibre33"/>#'map                               </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #'clojure.core/map<br class="calibre33"/>@#'map<br class="calibre33"/>;= #&lt;core$map clojure.core$map@501d5ebc&gt;</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Recall from <a href="#filepos189489"><span class="calibre5">Referring to Vars: var</span></a> that <tt class="calibre22">#'map</tt> is just reader sugar for <tt class="calibre22">(var map)</tt>.</blockquote><p id="filepos736662" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Defining Vars</span></span></span></p><p id="filepos736765" class="calibre18">Vars make up one of the fundamental building blocks of Clojure. As we mentioned in <a href="#filepos128989"><span class="calibre5">Defining Vars: def</span></a>, top level functions and values are all stored in vars, which are defined within the current namespace <a id="filepos737053"></a>using the <tt class="calibre22">def</tt> special form or one of its derivatives.</p><p class="calibre18">Beyond simply installing a var into the namespace with the given name, <tt class="calibre22">def</tt> copies the metadata<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos737292"></a><a href="#filepos766375"><span class="calibre32">146</span></a><span class="calibre32">]</span></small></sup> found on the symbol provided to name the new (or to-be-updated) var to the var itself. Particular metadata found on this symbol can modify the behavior and semantics of vars, which we’ll enumerate here.</p><p id="filepos737596" class="calibre23"><span class="calibre53"><span class="bold">Private vars</span></span></p><p id="filepos737669" class="calibre18">Private vars are a basic way to delineate parts of a library or API that are implementation-dependent or otherwise not intended to be accessed by external users. A private var:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">Can only be referred to using its fully qualified name when in another namespace.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Its value can only be accessed by manually deferencing the var.</blockquote></li></ol><p class="calibre18">A var is made private if the symbol that names it has a <tt class="calibre22">:private</tt> slot in its metadata map <a id="filepos738381"></a>with a <tt class="calibre22">true</tt> value. This is a private var, holding some useful constant value our code might need:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def ^:private everything 42)</tt></span></blockquote><p class="calibre23">Recall from <a href="#filepos512813"><span class="calibre5">Metadata</span></a> that this notation is equivalent to:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def ^{:private true} everything 42)</tt></span></blockquote><p class="calibre23">We can see that <tt class="calibre22">everything</tt> is available outside of its originating namespace only with some effort:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def ^:private everything 42)<br class="calibre33"/>;= #'user/everything<br class="calibre33"/>(ns other-namespace)<br class="calibre33"/>;= nil<br class="calibre33"/>(refer 'user)<br class="calibre33"/>;= nil<br class="calibre33"/>everything<br class="calibre33"/>;= #&lt;CompilerException java.lang.RuntimeException:<br class="calibre33"/>;=   Unable to resolve symbol: everything in this context, compiling:(NO_SOURCE_PATH:0)&gt;<br class="calibre33"/>@#'user/everything<br class="calibre33"/>;= 42</tt></span></blockquote><p class="calibre23">You can declare a private function by using the <tt class="calibre22">defn-</tt><a id="filepos739570"></a> form, which is entirely identical to the familiar <tt class="calibre22">defn</tt> form, except that it adds in the <tt class="calibre22">^:private</tt> metadata for you.</p><p id="filepos739715" class="calibre23"><span class="calibre53"><span class="bold">Docstrings</span></span></p><p id="filepos739786" class="calibre18">Clojure allows you to add documentation to top-level vars via <span class="italic">docstrings</span>, which are usually string literals that immediately follow the symbol that names the var:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def a<br class="calibre33"/>  "A sample value."<br class="calibre33"/>  5)<br class="calibre33"/>;= #'user/a<br class="calibre33"/>(defn b<br class="calibre33"/>  "A simple calculation using `a`."<br class="calibre33"/>  [c]<br class="calibre33"/>  (+ a c))<br class="calibre33"/>;= #'user/b<br class="calibre33"/>(doc a)<br class="calibre33"/>; -------------------------<br class="calibre33"/>; user/a<br class="calibre33"/>;   A sample value.<br class="calibre33"/>(doc b)<br class="calibre33"/>; -------------------------<br class="calibre33"/>; user/b<br class="calibre33"/>; ([c])<br class="calibre33"/>;   A simple calculation using `a`.</tt></span></blockquote><p class="calibre23">As you can see, docstrings are just more metadata on the var in question; <tt class="calibre22">def</tt> is doing a little bit of work behind the scenes to pick up the optional docstring and add it to the var’s metadata <a id="filepos740747"></a>as necessary:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(meta #'a)<br class="calibre33"/>;= {:ns #&lt;Namespace user&gt;, :name a, :doc "A sample value.",<br class="calibre33"/>;=  :line 1, :file "NO_SOURCE_PATH"}</tt></span></blockquote><p class="calibre23">This means that, if you want, you can add documentation to a var by specifying the <tt class="calibre22">:doc</tt> metadata explicitly, either when the var is defined, or even afterward by altering the var’s metadata:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def ^{:doc "A sample value."} a 5)<br class="calibre33"/>;= #'user/a<br class="calibre33"/>(doc a)<br class="calibre33"/>; -------------------------<br class="calibre33"/>; user/a<br class="calibre33"/>;   A sample value.<br class="calibre33"/>(alter-meta! #'a assoc :doc "A dummy value.")<br class="calibre33"/>;= {:ns #&lt;Namespace user&gt;, :name a, :doc "A dummy value.",<br class="calibre33"/>;=  :line 1, :file "NO_SOURCE_PATH"}<br class="calibre33"/>(doc a)<br class="calibre33"/>; -------------------------<br class="calibre33"/>; user/a<br class="calibre33"/>;   A dummy value.</tt></span></blockquote><p class="calibre23">This is a rare requirement, but can be very handy when writing var-defining macros.</p><p id="filepos741888" class="calibre23"><span class="calibre53"><span class="bold">Constants</span></span></p><p id="filepos741958" class="calibre18">It is common to need to define constant values, and using top level <tt class="calibre22">def</tt> forms to do so is typical. You can add <tt class="calibre22">^:const</tt><a id="filepos742122"></a> metadata <a id="filepos742139"></a>to a var’s name symbol in order to declare it as a constant to the compiler:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def ^:const everything 42)</tt></span></blockquote><p class="calibre23">While a nice piece of documentation on its own, <tt class="calibre22">^:const</tt> does have a functional impact: any references to a constant var aren’t resolved at runtime (as per usual); rather, the value held by the var is retained permanently by the code referring to the var when it is compiled. This provides a slight performance improvement for such references in hot sections of code, but more important, ensures that your constant actually <span class="italic">remains</span> constant, even if someone stomps on a var’s value.</p><p class="calibre18">This certainly isn’t what we’d like to have happen:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def max-value 255)<br class="calibre33"/>;= #'user/max-value<br class="calibre33"/>(defn valid-value?<br class="calibre33"/>  [v]<br class="calibre33"/>  (&lt;= v max-value))<br class="calibre33"/>;= #'user/valid-value?<br class="calibre33"/>(valid-value? 218)<br class="calibre33"/>;= true<br class="calibre33"/>(valid-value? 299)<br class="calibre33"/>;= false<br class="calibre33"/>(def max-value 500)    </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #'user/max-value<br class="calibre33"/>(valid-value? 299)<br class="calibre33"/>;= true</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">max-value</tt> is redefined, after which point <tt class="calibre22">valid-value?</tt> implements different semantics due to its reliance on our “constant.”</blockquote><p class="calibre18">We can prevent such mishaps using <tt class="calibre22">^:const</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def ^:const max-value 255)<br class="calibre33"/>;= #'user/max-value<br class="calibre33"/>(defn valid-value?<br class="calibre33"/>  [v]<br class="calibre33"/>  (&lt;= v max-value))<br class="calibre33"/>;= #'user/valid-value?<br class="calibre33"/>(def max-value 500)<br class="calibre33"/>;= #'user/max-value<br class="calibre33"/>(valid-value? 299)<br class="calibre33"/>;= false</tt></span></blockquote><p class="calibre23">Because <tt class="calibre22">max-value</tt> is declared <tt class="calibre22">^:const</tt>, its value is captured by the <tt class="calibre22">valid-value?</tt> function at compile-time. Any later modifications to <tt class="calibre22">max-value</tt> will have no effect upon the semantics of <tt class="calibre22">valid-value?</tt> until it is itself redefined.<a id="filepos744547"></a></p><p id="filepos744558" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Dynamic Scope</span></span></span></p><p id="filepos744661" class="calibre18">For the most part, Clojure is lexically scoped:<a id="filepos744736"></a> that is, names have values as defined by the forms that circumscribe their usage and the namespace within which they are evaluated. To demonstrate:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [a 1<br class="calibre33"/>      b 2]<br class="calibre33"/>  (println (+ a b))      </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  (let [b 3<br class="calibre33"/>        + -]<br class="calibre33"/>    (println (+ a b))))  </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= 3<br class="calibre33"/>;= -2</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">a</tt> and <tt class="calibre22">b</tt> are names of locals established by <tt class="calibre22">let</tt>; <tt class="calibre22">+</tt> and <tt class="calibre22">println</tt> are names of vars containing functions defined in the <tt class="calibre22">clojure.core</tt> namespace, which are available within our current namespace.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">The local <tt class="calibre22">b</tt> has been bound with a different value, as has <tt class="calibre22">+</tt>; since these definitions are more lexically local than the outer local binding of <tt class="calibre22">b</tt> and the original var named <tt class="calibre22">+</tt>, they shadow those original values when evaluated within this context.</blockquote><p class="calibre18">The exception to this rule is <span class="italic">dynamic scope</span>, a feature provided by vars. Vars have a <span class="italic">root binding</span><a id="filepos746359"></a>; this is the value bound to a var when it is defined using <tt class="calibre22">def</tt> or some derivative, and the one to which references to that var will evaluate in general. However, if you define a var to be <span class="italic">dynamic</span> (using <tt class="calibre22">^:dynamic</tt> metadata),<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos746650"></a><a href="#filepos766708"><span class="calibre32">147</span></a><span class="calibre32">]</span></small></sup> then the root binding can be overridden and shadowed on a per-thread basis using the <tt class="calibre22">binding</tt> form.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def ^:dynamic *max-value* 255)<br class="calibre33"/>;= #'user/*max-value*<br class="calibre33"/>(defn valid-value?<br class="calibre33"/>  [v]<br class="calibre33"/>  (&lt;= v *max-value*))<br class="calibre33"/>;= #'user/valid-value?<br class="calibre33"/>(binding [*max-value* 500]<br class="calibre33"/>  (valid-value? 299))<br class="calibre33"/>;= true</tt></span></blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Dynamic vars intended to be rebound with </span><span class="calibre10"><tt class="calibre22">binding</tt></span><span class="calibre10"> should be surrounded with asterisks — like </span><a id="filepos747535"></a><span class="calibre10"><tt class="calibre22">*this*</tt></span><span class="calibre10">—also known as “earmuffs.” This is merely a naming convention, but is helpful to alert a reader of some code that dynamic scope is possible.</span><a id="filepos747747"></a></blockquote><p class="calibre25">Here we are able to change the value of <tt class="calibre22">*max-value*</tt> outside of the lexical scope of its usage within <tt class="calibre22">valid-value?</tt> by using <tt class="calibre22">binding</tt>. This is only a thread-local change though; we can see that <tt class="calibre22">*max-value*</tt> retains its original value in other threads:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos748113"></a><a href="#filepos767096"><span class="calibre32">148</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(binding [*max-value* 500]<br class="calibre33"/>  (println (valid-value? 299))<br class="calibre33"/>  (doto (Thread. #(println "in other thread:" (valid-value? 299)))<br class="calibre33"/>    .start<br class="calibre33"/>    .join))<br class="calibre33"/>;= true<br class="calibre33"/>;= in other thread: false</tt></span></blockquote><p class="calibre23">Dynamic scope is used widely by libraries <a id="filepos748620"></a>and in Clojure itself<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos748683"></a><a href="#filepos767730"><span class="calibre32">149</span></a><span class="calibre32">]</span></small></sup> to provide or alter the default configuration of an API <a id="filepos748835"></a>without explicitly threading context through each function call. You can see very practical examples in both Chapters <a href="#filepos1819820"><span class="calibre5">15</span></a> and <a href="#filepos1757595"><span class="calibre5">14</span></a>, where dynamic scope is used to provide database configuration information to a library.</p><p class="calibre18"><span class="bold">Visualizing dynamic scope</span>. <a id="filepos749235"></a>To illustrate, consider a var: it has a root value, and for each thread, it <span class="italic">may</span> have any number of thread-local bindings, which stack up as nested dynamic scopes come into effect via <tt class="calibre22">binding</tt>.</p><blockquote class="calibre47"></blockquote><blockquote class="calibre48"><img src="images/00025.jpg" class="calibre92"/></blockquote><blockquote class="calibre47"><span class="calibre10"><span class="italic"><span class="calibre7">Figure 4-5. A var holding a single root value, and many thread-local stacks of thread-local bindings</span></span></span></blockquote><p class="calibre50">Only the heads of these stacks may be accessed (shown bolded above). Once a binding is established, the prior binding is shadowed for the duration of the dynamic scope put into place by <tt class="calibre22">binding</tt>. So within the innermost dynamic scope here, <tt class="calibre22">*var*</tt> (and therefore, <tt class="calibre22">(get-*var*)</tt>) will never evaluate to <tt class="calibre22">:root</tt>, <tt class="calibre22">:a</tt>, or <tt class="calibre22">:b</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def ^:dynamic *var* :root)<br class="calibre33"/>;= #'user/*var*<br class="calibre33"/>(defn get-*var* [] *var*)<br class="calibre33"/>;= #'user/get-*var*<br class="calibre33"/>(binding [*var* :a]<br class="calibre33"/>  (binding [*var* :b]<br class="calibre33"/>    (binding [*var* :c]<br class="calibre33"/>      (get-*var*))))<br class="calibre33"/>;= :c</tt></span></blockquote><p class="calibre23">Each level of dynamic scope pushes a new “frame” onto the stack for the var being bound:</p><blockquote class="calibre47"></blockquote><blockquote class="calibre48"><img src="images/00027.jpg" class="calibre93"/></blockquote><blockquote class="calibre47"><span class="calibre10"><span class="italic"><span class="calibre7">Figure 4-6. The effect of establishing a new thread-local binding for a var using binding</span></span></span></blockquote><blockquote class="calibre94"><span class="calibre10"><tt class="calibre22">(binding [*var* :a]<br class="calibre33"/>  (binding [*var* :b]<br class="calibre33"/>    (binding [*var* :c]<br class="calibre33"/>      (binding [*var* :d]<br class="calibre33"/>        (get-*var*)))))<br class="calibre33"/>;= :d</tt></span></blockquote><p class="calibre23">We’ve seen how dynamic scope can be used to control the behavior of functions at a distance, essentially allowing callers to provide an implicit argument to functions potentially many levels down in a call tree. The final piece of the puzzle is that dynamic scope can also work in reverse, to allow functions <a id="filepos751776"></a>to provide multiple side-channel return values to callers potentially many levels <span class="italic">up</span> in a call tree.</p><p class="calibre18">For example, while Clojure provides some incredibly convenient IO functions to simply retrieve the content of a URL (e.g., <tt class="calibre22">slurp</tt> and others in the <tt class="calibre22">clojure.java.io</tt> namespace), such methods provide no easy way to retrieve the corresponding HTTP response code when you require it (a necessary thing sometimes, especially when using various HTTP APIs). One option would be to <span class="italic">always</span> return the response code in addition to the URL’s content in a vector of <tt class="calibre22">[response-code url-content]</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn http-get<br class="calibre33"/>  [url-string]<br class="calibre33"/>  (let [conn (-&gt; url-string java.net.URL. .openConnection)<br class="calibre33"/>        response-code (.getResponseCode conn)]<br class="calibre33"/>    (if (== 404 response-code)<br class="calibre33"/>      [response-code]<br class="calibre33"/>      [response-code (-&gt; conn .getInputStream slurp)])))<br class="calibre33"/><br class="calibre33"/>(http-get "http://google.com/bad-url")<br class="calibre33"/>;= [404]<br class="calibre33"/>(http-get "http://google.com/")<br class="calibre33"/>;= [200 "&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;..."]</tt></span></blockquote><p class="calibre23">That’s not horrible, but as users of <tt class="calibre22">http-get</tt>, this approach forces us to deal with the response code for every call in every context, even if we aren’t interested in it.</p><p class="calibre18">As an alternative, we could use dynamic scope to establish a binding that <tt class="calibre22">http-get</tt> can set <span class="italic">only when we’re interested in the HTTP response code</span>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def ^:dynamic *response-code* nil)                                    </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/><br class="calibre33"/>(defn http-get<br class="calibre33"/>  [url-string]<br class="calibre33"/>  (let [conn (-&gt; url-string java.net.URL. .openConnection)<br class="calibre33"/>        response-code (.getResponseCode conn)]<br class="calibre33"/>    (when (thread-bound? #'*response-code*)                            </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>      (set! *response-code* response-code))                            </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>    (when (not= 404 response-code) (-&gt; conn .getInputStream slurp))))  </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/><br class="calibre33"/>(http-get "http://google.com")<br class="calibre33"/>;= "&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;..."<br class="calibre33"/>*response-code*<br class="calibre33"/>;= nil<br class="calibre33"/>(binding [*response-code* nil]<br class="calibre33"/>  (let [content (http-get "http://google.com/bad-url")]<br class="calibre33"/>    (println "Response code was:" *response-code*)<br class="calibre33"/>    ; ... do something with `content` if it is not nil ...<br class="calibre33"/>    ))<br class="calibre33"/>;= Response code was: 404<br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">We define a new var, <tt class="calibre22">*response-code*</tt>; users of <tt class="calibre22">http-get</tt> opt into accessing the response code it obtains by binding this var.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">We use <tt class="calibre22">thread-bound?</tt> to check if the caller of <tt class="calibre22">http-get</tt> has established a thread-local binding on <tt class="calibre22">*response-code*</tt>. If not, we do nothing with it.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">set!</tt> is used to <span class="italic">change</span> the value of the current thread-local binding on <tt class="calibre22">*response-code*</tt> so that the caller can access that value as desired.</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">Now that <tt class="calibre22">http-get</tt> can use the optional dynamic scope around <tt class="calibre22">*response-code*</tt> to communicate auxiliary information to its callers, it can simply return the string content loaded from the URL instead of the compound vector of <tt class="calibre22">[response-code url-content]</tt> (assuming the URL is not <tt class="calibre22">404</tt>).</blockquote><p class="calibre18">Again, to illustrate:</p><p class="calibre51"><img src="images/00028.jpg" class="calibre95"/></p><p class="calibre13">Because <tt class="calibre22">set!</tt><a id="filepos756706"></a> acts on a var’s binding by replacing the current thread-local value, a caller within the dynamic scope established by <tt class="calibre22">binding</tt>—whether a direct one or one 50 frames up the call stack—can access that new value without it having been threaded back through the return values of all the intervening function calls. This works for any number of vars, any number of bindings, and any number or type of <tt class="calibre22">set!</tt>-ed values, including functions. Such flexibility enables simple API extensions like auxiliary returns as we’ve demonstrated here, up to more elaborate and powerful things like non-local return mechanisms.</p><p class="calibre18"><span class="bold">Dynamic scope propagates through Clojure-native concurrency forms</span>. <a id="filepos757451"></a>The thread-local nature of dynamic scope is useful—it allows a particular execution context to remain isolated from others—but without mitigation, it would cause undue difficulty when using Clojure facilities that by necessity move computation from one thread to another. Thankfully, Clojure does propagate dynamic var bindings across <a id="filepos757797"></a>threads—called <span class="italic">binding conveyance</span><a id="filepos757846"></a>—when using agents (via <tt class="calibre22">send</tt> and <tt class="calibre22">send-off</tt>), futures, as well as <tt class="calibre22">pmap</tt><a id="filepos757950"></a> and its variants:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(binding [*max-value* 500]<br class="calibre33"/>  (println (valid-value? 299))<br class="calibre33"/>  @(future (valid-value? 299)))<br class="calibre33"/>; true<br class="calibre33"/>;= true</tt></span></blockquote><p class="calibre23">Even though <tt class="calibre22">valid-value?</tt> is invoked on a separate thread than the one that originally set up the dynamic scope via <tt class="calibre22">binding</tt>, <tt class="calibre22">future</tt> propagates that scope across to the other thread for the duration of its operation.</p><p class="calibre18">Note that, while <tt class="calibre22">pmap</tt> does support binding conveyance, the same does <span class="italic">not</span> hold true for lazy seqs in general:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(binding [*max-value* 500]<br class="calibre33"/>  (map valid-value? [299]))<br class="calibre33"/>;= (false)</tt></span></blockquote><p class="calibre23">The workaround here is to ensure that you push the dynamic scope required for each step in the lazy seq into the code that will actually be evaluated when values in the seq are to be realized:<a id="filepos759026"></a></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(map #(binding [*max-value* 500]<br class="calibre33"/>        (valid-value? %))<br class="calibre33"/>     [299])<br class="calibre33"/>;= (true)</tt></span></blockquote><p id="filepos759240" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Vars Are Not Variables</span></span></span></p><p id="filepos759352" class="calibre18">Vars should <span class="italic">not</span> be confused with variables in other languages. Coming from a language like Ruby, where code usually looks like this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">def foo<br class="calibre33"/>  x = 123<br class="calibre33"/>  y = 456<br class="calibre33"/>  x = x + y<br class="calibre33"/>end</tt></span></blockquote><p class="calibre23">It’s incredibly tempting for new Clojure users to try to write code like this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn never-do-this []<br class="calibre33"/>  (def x 123)<br class="calibre33"/>  (def y 456)<br class="calibre33"/>  (def x (+ x y)<br class="calibre33"/>  x))</tt></span></blockquote><p class="calibre23">This is very poor form in Clojure. But, what’s the worst that could happen?</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def x 80)<br class="calibre33"/>;= #'user/x<br class="calibre33"/>(defn never-do-this []<br class="calibre33"/>  (def x 123)<br class="calibre33"/>  (def y 456)<br class="calibre33"/>  (def x (+ x y))<br class="calibre33"/>  x)<br class="calibre33"/>;= #'user/never-do-this<br class="calibre33"/>(never-do-this)<br class="calibre33"/>;= 579<br class="calibre33"/>x                         </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= 579</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">“Waitaminute, I declared <tt class="calibre22">x</tt> to be <tt class="calibre22">80</tt> at the start!”</blockquote><p class="calibre18"><tt class="calibre22">def</tt> always defines <span class="italic">top level</span> vars—it is <span class="italic">not</span> an assignment operation affecting some local scope. <tt class="calibre22">x</tt> and <tt class="calibre22">y</tt> in this example are globally accessible throughout your namespace, and will clobber any other <tt class="calibre22">x</tt> and <tt class="calibre22">y</tt> vars already in your namespace.</p><p class="calibre18">With the exception of dynamic scope, vars are fundamentally intended to hold constant values from the time they are defined until the termination of your application, REPL, etc. Use one of Clojure’s other reference types for identities that provide useful and proper semantics for changing state in place, if that is what you are looking for. Define a var to hold one of those, and use the appropriate function (<tt class="calibre22">swap!</tt>, <tt class="calibre22">alter</tt>, <tt class="calibre22">send</tt>, <tt class="calibre22">send-off</tt>, et al.) to modify the state of those identities.</p><p class="calibre18"><span class="bold">Changing a var’s Root Binding</span>. <a id="filepos761802"></a>Despite our various warnings against using vars as variables as understood in other languages, there is value in mutating their root bindings occasionally and with great care. To change a var’s root binding as a function of its current value, there’s <tt class="calibre22">alter-var-root</tt><a id="filepos762087"></a>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def x 0)<br class="calibre33"/>;= #'user/x<br class="calibre33"/>(alter-var-root #'x inc)<br class="calibre33"/>;= 1</tt></span></blockquote><p class="calibre23">When the var in question contains a function, this provides a superset of the functionality found in most aspect-oriented programming frameworks. Concrete examples in that vein are provided in <a href="#filepos1682627"><span class="calibre5">Aspect-Oriented Programming</span></a> and <a href="#filepos1252908"><span class="calibre5">Building mixed-source projects</span></a>.</p><p class="calibre18">You can also temporarily change the root binding of a bunch of vars with <tt class="calibre22">with-redefs</tt><a id="filepos762780"></a>, which will restore the vars’ root bindings upon exiting its scope; this can be very useful in testing, for mocking out functions or values that depend upon environment-specific context. See <a href="#filepos1698179"><span class="calibre5">Mocking</span></a> for an example.</p><p id="filepos763063" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Forward Declarations</span></span></span></p><p id="filepos763173" class="calibre18">You can opt not to provide a value for a var; in this case, the var is considered “unbound,” and dereferencing it will return a placeholder object:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def j)<br class="calibre33"/>;= #'user/j<br class="calibre33"/>j<br class="calibre33"/>;= #&lt;Unbound Unbound: #'user/j&gt;</tt></span></blockquote><p class="calibre23">This is useful for when you need to refer to a var that you haven’t defined a value for yet. This can happen when implementing certain types of algorithms that benefit from alternating recursion—or, you may simply want to have the implementation of a function to come after where it is used as a matter of style or in an attempt to call attention to primary or public API points. Clojure compiles and evaluates forms in the order presented in your source files, so any vars you refer to must at least be declared prior to those references. Assuming such vars’ values are only required at runtime (e.g., if they are placeholders for functions), then you can redefine those vars later with their actual values. This called a <span class="italic">forward declaration</span>.</p><p class="calibre18">In such cases, the <tt class="calibre22">declare</tt><a id="filepos764376"></a> macro is somewhat more idiomatic. Using it instead of <tt class="calibre22">def</tt> alone makes explicit your intention to define an unbound var (rather than leaving open the possibility that you simply forgot to provide a value), and it allows you to define many unbound vars in a single expression:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(declare complex-helper-fn other-helper-fn)                    </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/><br class="calibre33"/>(defn public-api-function<br class="calibre33"/>  [arg1 arg2]<br class="calibre33"/>  ...<br class="calibre33"/>  (other-helper-fn arg1 arg2 (complex-helper-fn arg1 arg2))    </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/><br class="calibre33"/>(defn- complex-helper-fn                                       </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  [arg1 arg2]<br class="calibre33"/>  ...)<br class="calibre33"/><br class="calibre33"/>(defn- other-helper-fn<br class="calibre33"/>  [arg1 arg2 arg3]<br class="calibre33"/>  ...)</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">We declare our helper functions’ vars before they are referred to.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">Now we can put our primary/public API near the top of our source file and refer to our helper functions freely.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">We properly define our helper functions later on in the source file.<a id="filepos766262"></a></blockquote><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos766375"></a><a href="#filepos737292"><span class="calibre32">146</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="#filepos512813"><span class="calibre10"><span class="calibre5">Metadata</span></span></a><span class="calibre10"> for a primer on metadata in Clojure.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos766708"></a><a href="#filepos746650"><span class="calibre32">147</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Attempting to use </span><span class="calibre10"><tt class="calibre22">binding</tt></span><span class="calibre10"> on a var that is not </span><span class="calibre10"><tt class="calibre22">:dynamic</tt></span><span class="calibre10"> will result in an exception being thrown.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos767096"></a><a href="#filepos748113"><span class="calibre32">148</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Please excuse the momentary slew of Java interop; it is necessary to use a native thread in order to demonstrate this characteristics of dynamic vars. See </span><a href="#filepos826361"><span class="calibre10"><span class="calibre5">Using Java’s Concurrency Primitives</span></span></a><span class="calibre10"> and </span><a href="#filepos1274079"><span class="calibre10"><span class="calibre5">Chapter 9</span></span></a><span class="calibre10"> for explanations of what’s going on here.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos767730"></a><a href="#filepos748683"><span class="calibre32">149</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Examples include </span><span class="calibre10"><tt class="calibre22">*warn-on-reflection*</tt></span><span class="calibre10"> as detailed in </span><a href="#filepos1324665"><span class="calibre10"><span class="calibre5">Type Hinting for Performance</span></span></a><span class="calibre10"> and </span><a href="#filepos1599929"><span class="calibre10"><span class="calibre5">Type errors and warnings</span></span></a><span class="calibre10">. </span><span class="calibre10"><tt class="calibre22">*out*</tt></span><span class="calibre10">, </span><span class="calibre10"><tt class="calibre22">*in*</tt></span><span class="calibre10">, and </span><span class="calibre10"><tt class="calibre22">*err*</tt></span><span class="calibre10">, and indirect usages of </span><span class="calibre10"><tt class="calibre22">binding</tt></span><span class="calibre10">, like </span><span class="calibre10"><tt class="calibre22">with-precision</tt></span><span class="calibre10"> are discussed in </span><a href="#filepos1570537"><span class="calibre10"><span class="calibre5">Scale and Rounding Modes for Arbitrary-Precision Decimals Ops</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos768750" class="calibre6"><span class="calibre4"><span class="bold">Agents</span></span></p><p id="filepos768817" class="calibre18">Agents are an uncoordinated, asynchronous reference type. This means that changes to an agent’s state are independent of changes to other agents’ states, and that all such changes are made away from the thread of execution that schedules them. Agents further possess two characteristics that uniquely separate them from atoms and refs:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">I/O and other side-effecting functions may be safely used in conjunction with agents.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Agents are STM-aware, so that they may be safely used in the context of retrying transactions.</blockquote></li></ol><p class="calibre18">Agent state may be altered via two functions, <tt class="calibre22">send</tt><a id="filepos769687"></a> and <tt class="calibre22">send-off</tt><a id="filepos769716"></a>. They follow the same pattern as other reference state change functions, accepting another function that will determine the agent’s new state that accepts as arguments the agent’s current state along with optional additional arguments to pass to the function.</p><p class="calibre18">Taken together, each function <tt class="calibre22">+</tt> optional set of arguments passed to <tt class="calibre22">send</tt> or <tt class="calibre22">send-off</tt> is called an agent <span class="italic">action</span>, and each agent maintains a queue of actions. Both <tt class="calibre22">send</tt> and <tt class="calibre22">send-off</tt> return immediately after queueing the specified action, each of which are evaluated serially, in the order in which they are “sent,” on one of many threads dedicated to the evaluation of agent actions. The result of each evaluation is installed as the agent’s new state.</p><p class="calibre18">The sole difference between <tt class="calibre22">send</tt> and <tt class="calibre22">send-off</tt> is the type of action that may be provided to each. Actions queued using <tt class="calibre22">send</tt> are evaluated within a fixed-size thread pool that is configured to not exceed the parallelizability of the current hardware.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos770870"></a><a href="#filepos820889"><span class="calibre32">150</span></a><span class="calibre32">]</span></small></sup><span class="italic">Thus, </span><tt class="calibre22"><span class="italic">send</span></tt><span class="italic"> must never be used for actions that might perform I/O or other blocking operations</span>, lest the blocking action prevent other nonblocking, CPU-bound actions from fully utilizing that resource.</p><p class="calibre18">In contrast, actions queued using <tt class="calibre22">send-off</tt> are evaluated within an unbounded thread pool (incidentally, the same one used by futures), which allows any number of potentially blocking, non-CPU-bound actions to be evaluated concurrently.</p><p class="calibre18">Knowing all this, we can get a picture of how agents work in general:</p><blockquote id="filepos771577" class="calibre47"></blockquote><blockquote class="calibre39"><img src="images/00045.jpg" class="calibre96"/></blockquote><blockquote class="calibre57"><span class="calibre10"><span class="italic"><span class="calibre7">Figure 4-7. Queueing and evaluation of agent actions resulting in state changes</span></span></span></blockquote><p class="calibre50">Actions are queued for an agent using either <tt class="calibre22">send</tt> or <tt class="calibre22">send-off</tt> (represented in <a href="#filepos771577"><span class="calibre5">Figure 4-7</span></a> as different-colored units of work). The agent applies its state to those actions in order, performing that evaluation on a thread from the pool associated with the function used to queue the action. So, if the black actions are CPU-bound, then threads <tt class="calibre22">t<sub class="calibre85"><small class="calibre31"><span class="calibre32">2</span></small></sub></tt> and <tt class="calibre22">t<sub class="calibre85"><small class="calibre31"><span class="calibre32">3</span></small></sub></tt> are from the dedicated, fixed-size <tt class="calibre22">send</tt> thread pool,<a id="filepos772608"></a> and <tt class="calibre22">t<sub class="calibre85"><small class="calibre31"><span class="calibre32">9</span></small></sub></tt> and <tt class="calibre22">t<sub class="calibre85"><small class="calibre31"><span class="calibre32">18</span></small></sub></tt> are from the unbounded <tt class="calibre22">send-off</tt> thread pool. The return value of each action becomes the agent’s new state.</p><blockquote class="calibre38"></blockquote><blockquote class="calibre39"><span class="calibre10"><span class="bold">AGENTS DO NOT CORRESPOND TO THREADS</span></span></blockquote><blockquote id="filepos773046" class="calibre17"><span class="calibre10">There is no connection between the number of agents created by a program and the number of live threads created to service those agents. Rather, the number of live threads related to agents is determined largely by the number of </span><span class="calibre10"><span class="italic">concurrently processed</span></span><span class="calibre10"> actions dispatched using </span><span class="calibre10"><tt class="calibre22">send-off</tt></span><span class="calibre10">: because those are the only actions that can utilize an unbounded thread pool, they are the only actions that can prompt the creation of a new system thread. Remember that agent actions are serialized, so in order to force the creation of 100 threads (for example), you would need to have a minimum of 100 agents, each concurrently evaluating a </span><span class="calibre10"><tt class="calibre22">send-off</tt></span><span class="calibre10"> action.</span></blockquote><blockquote class="calibre17"><span class="calibre10">This implies two things:</span></blockquote><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17"><span class="calibre10">You can create as many agents as memory allows.<sup class="calibre58"><small class="calibre31"><span class="calibre32">[</span><a id="filepos774231"></a><a href="#filepos821288"><span class="calibre32">151</span></a><span class="calibre32">]</span></small></sup></span></blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17"><span class="calibre10">The number of concurrent actions dispatched using </span><span class="calibre10"><tt class="calibre22">send</tt></span><span class="calibre10"> is essentially unlimited, but the number of threads dedicated to processing such actions is capped, so again, memory is the only bottleneck.</span></blockquote></li></ol><p class="calibre50">While the semantics of agents may be subtle, using them is extraordinarily easy:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def a (agent 500))                            </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #'user/a<br class="calibre33"/>(send a range 1000)                            </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #&lt;Agent@53d2f8be: 500&gt;<br class="calibre33"/>@a<br class="calibre33"/>;= (500 501 502 503 504 ... 999)</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">An agent is created with an initial value of <tt class="calibre22">500</tt>.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">We <tt class="calibre22">send</tt> an action to the agent, consisting of the <tt class="calibre22">range</tt> function and an additional argument <tt class="calibre22">1000</tt>; in another thread, the agent’s value will be set to the result of <tt class="calibre22">(range @a 1000)</tt>.</blockquote><p class="calibre18">Both <tt class="calibre22">send</tt> and <tt class="calibre22">send-off</tt> return the agent involved. When sending actions in the REPL,<a id="filepos776120"></a> it is possible that you’ll see the result of the sent action’s evaluation immediately in the printing of the agent; depending on the complexity of the action and how quickly it can be scheduled to be evaluated, it may be complete by the time the REPL has a chance to print the agent returned from <tt class="calibre22">send</tt> or <tt class="calibre22">send-off</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def a (agent 0))<br class="calibre33"/>;= #'user/a<br class="calibre33"/>(send a inc)<br class="calibre33"/>;= #&lt;Agent@65f7bb1f: 1&gt;</tt></span></blockquote><p class="calibre23">On the other hand, you may find yourself needing the result of a pending action’s evaluation, and polling the agent for the result would be daft. You can block on an agent(s) completing evaluation of all actions sent from your current thread using <tt class="calibre22">await</tt><a id="filepos776945"></a>:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos776988"></a><a href="#filepos821625"><span class="calibre32">152</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def a (agent 5000))<br class="calibre33"/>(def b (agent 10000))<br class="calibre33"/><br class="calibre33"/>(send-off a #(Thread/sleep %))<br class="calibre33"/>;= #&lt;Agent@da7d7b5: 5000&gt;<br class="calibre33"/>(send-off b #(Thread/sleep %))<br class="calibre33"/>;= #&lt;Agent@c0cd75b: 10000&gt;<br class="calibre33"/>@a                              </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= 5000<br class="calibre33"/>(await a b)                     </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= nil<br class="calibre33"/>@a                              </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">The function sent to <tt class="calibre22">a</tt> will take five seconds to complete, so its value has not been updated yet.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">We can use <tt class="calibre22">await</tt> to block until all of the actions sent to the passed agents from this thread have completed. This particular call will block for up to 10 seconds, since that is how long the function sent to <tt class="calibre22">b</tt> will take to evaluate.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">After <tt class="calibre22">await</tt> has returned, the sent actions will have been evaluated, and the agent(s) values will have been updated. Note that another action could have modified <tt class="calibre22">a</tt>’s value before you dereference it!</blockquote><p class="calibre18"><tt class="calibre22">await-for</tt><a id="filepos779048"></a> does the same but allows you to provide a timeout.</p><p id="filepos779110" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Dealing with Errors in Agent Actions</span></span></span></p><p id="filepos779236" class="calibre18">Because agent actions are run asynchronously, an exception <a id="filepos779323"></a>thrown in the course of their evaluation cannot be dealt with in the same thread of execution that dispatches the offending action. By default, encountering an error will cause an agent to fail silently: you’ll still be able to dereference its last state, but further actions will fail to queue up:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def a (agent nil))<br class="calibre33"/>;= #'user/a<br class="calibre33"/>(send a (fn [_] (throw (Exception. "something is wrong"))))<br class="calibre33"/>;= #&lt;Agent@3cf71b00: nil&gt;<br class="calibre33"/>a<br class="calibre33"/>;= #&lt;Agent@3cf71b00 FAILED: nil&gt;<br class="calibre33"/>(send a identity)                                           </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #&lt;Exception java.lang.Exception: something is wrong&gt;</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Attempting to send an action to a failed agent <a id="filepos780416"></a>will return the exception that caused the failure. If you explicitly want to check for an error, you should use <tt class="calibre22">agent-error</tt>, which will return the exception or <tt class="calibre22">nil</tt> if the provided agent isn’t in a failed state.</blockquote><p class="calibre18">A failed agent can be salvaged with <tt class="calibre22">restart-agent</tt>, which will reset the agent’s state to the provided value and enable it to receive actions again. An optional flag to <tt class="calibre22">restart-agent</tt>, <tt class="calibre22">:clear-actions</tt>, will clear any pending actions on the agent. Otherwise those pending actions will be attempted immediately.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(restart-agent a 42)<br class="calibre33"/>;= 42<br class="calibre33"/>(send a inc)                                                       </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #&lt;Agent@5f2308c9: 43&gt;<br class="calibre33"/>(reduce send a (for [x (range 3)]                                  </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>                 (fn [_] (throw (Exception. (str "error #" x))))))<br class="calibre33"/>;= #&lt;Agent@5f2308c9: 43&gt;<br class="calibre33"/>(agent-error a)<br class="calibre33"/>;= #&lt;Exception java.lang.Exception: error #0&gt;<br class="calibre33"/>(restart-agent a 42)<br class="calibre33"/>;= 42<br class="calibre33"/>(agent-error a)                                                    </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #&lt;Exception java.lang.Exception: error #1&gt;<br class="calibre33"/>(restart-agent a 42 :clear-actions true)                           </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= 42<br class="calibre33"/>(agent-error a)<br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Restarting <a id="filepos782645"></a>an agent will reset its failed status and allow it to receive actions again.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">However, if an agent’s queue contains other actions that will cause further errors…</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">…then <tt class="calibre22">restart-agent</tt> would need to be called once per erroring action.</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">Adding the <tt class="calibre22">:clear-actions</tt> option to a <tt class="calibre22">restart-agent</tt> call will clear the agent’s queue prior to resetting its failed status, ensuring that any doomed actions in the queue will not immediately fail the agent.</blockquote><p class="calibre18">This default error-handling mode—<a id="filepos783650"></a>where agents drop into a failed status and need to be resuscitated again—is most useful when you can rely upon manual intervention, usually via a REPL.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos783845"></a><a href="#filepos822097"><span class="calibre32">153</span></a><span class="calibre32">]</span></small></sup> More flexible and potentially hands-off error handling can be had by changing the defaults for each agent as appropriate.</p><p id="filepos784066" class="calibre23"><span class="calibre53"><span class="bold">Agent error handlers and modes</span></span></p><p id="filepos784157" class="calibre18">The default behavior where an error causes an agent to enter a failed status is one of two failure modes supported by agents. <tt class="calibre22">agent</tt> accepts an <tt class="calibre22">:error-mode</tt> option of <tt class="calibre22">:fail</tt> (the default) or <tt class="calibre22">:continue</tt><a id="filepos784418"></a>;<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos784461"></a><a href="#filepos822515"><span class="calibre32">154</span></a><span class="calibre32">]</span></small></sup> an agent with a failure mode of <tt class="calibre22">:continue</tt> will simply ignore an error thrown by the evaluation of an agent action, carrying on with processing any actions in its queue and receiving new actions without difficulty:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def a (agent nil :error-mode :continue))<br class="calibre33"/>;= #'user/a<br class="calibre33"/>(send a (fn [_] (throw (Exception. "something is wrong"))))<br class="calibre33"/>;= #&lt;Agent@44a5b703: nil&gt;<br class="calibre33"/>(send a identity)<br class="calibre33"/>;= #&lt;Agent@44a5b703: nil&gt;</tt></span></blockquote><p class="calibre23">This makes <tt class="calibre22">restart-agent</tt> unnecessary, but dropping errors on the floor by default and without any possible intervention is generally not a good idea. Thus, the <tt class="calibre22">:continue</tt> error mode is almost always paired with an error handler, a function of two arguments (the agent, and the precipitating error) that is called any time an agent action throws an exception; an error handler can be specified for an agent by using the <tt class="calibre22">:error-handler</tt> option:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos785649"></a><a href="#filepos822813"><span class="calibre32">155</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def a (agent nil<br class="calibre33"/>              :error-mode :continue<br class="calibre33"/>              :error-handler (fn [the-agent exception]<br class="calibre33"/>                               (.println System/out (.getMessage exception)))))<br class="calibre33"/>;= #'user/a<br class="calibre33"/>(send a (fn [_] (throw (Exception. "something is wrong"))))<br class="calibre33"/>;= #&lt;Agent@bb07c59: nil&gt;<br class="calibre33"/>; something is wrong<br class="calibre33"/>(send a identity)<br class="calibre33"/>:= #&lt;Agent@bb07c59: nil&gt;</tt></span></blockquote><p class="calibre23">Of course, far more sophisticated things can be done within an <tt class="calibre22">:error-handler</tt><a id="filepos786463"></a> function beyond simply dumping information about the exception to the console: some data in the application may be changed to avoid the error, an action or other operation might be retried, or the agent’s <tt class="calibre22">:error-mode</tt> can be switched back to <tt class="calibre22">:fail</tt> if you know that shutting down the agent is the only safe course of action:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(set-error-handler! a (fn [the-agent exception]<br class="calibre33"/>                        (when (= "FATAL" (.getMessage exception))<br class="calibre33"/>                          (set-error-mode! the-agent :fail))))<br class="calibre33"/>;= nil<br class="calibre33"/>(send a (fn [_] (throw (Exception. "FATAL"))))<br class="calibre33"/>;= #&lt;Agent@6fe546fd: nil&gt;<br class="calibre33"/>(send a identity)<br class="calibre33"/>;= #&lt;Exception java.lang.Exception: FATAL&gt;</tt></span></blockquote><p id="filepos787357" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">I/O, Transactions, and Nested Sends</span></span></span></p><p id="filepos787482" class="calibre18">Unlike refs and atoms, it is perfectly safe to use agents to coordinate I/O and perform other blocking operations. This makes them a vital piece of any complete application that use refs and Clojure’s STM to maintain program state over time. Further, thanks to their semantics, agents are often an ideal construct for simplifying asynchronous processing involving I/O even if refs are not involved at all.</p><p class="calibre18">Because agents serialize all actions sent to them, they provide a natural synchronization <a id="filepos788039"></a>point for necessarily side-effecting operations. You can set up an agent to hold as its state a handle to some context—an <tt class="calibre22">OutputStream</tt><a id="filepos788191"></a> to a file or network socket, a connection to a database, a pipe to a message queue, etc.—and you can be sure that actions sent to that agent will each have exclusive access to that context for the duration of their evaluation. This makes it easy to integrate the Clojure sphere—including refs and atoms—which generally aims to minimize side effects with the rest of the world that demands them.</p><p class="calibre18">You might wonder how agents could possibly be used from within STM transactions.<a id="filepos788711"></a> Sending an agent action is a side-effecting operation, and so would seem to be just as susceptible to unintended effects due to transaction restarts as other side-effecting operations like applying change operations to atoms or writing to a file. Thankfully, this is not the case.</p><p class="calibre18">Agents are integrated into Clojure’s STM implementation such that actions dispatched using <tt class="calibre22">send</tt> and <tt class="calibre22">send-off</tt> from within the scope of a transaction will be held in reserve until that transaction is successfully committed. This means that, even if a transaction retries 100 times, a sent action is only dispatched once, and that all of the actions sent during the course of a transaction’s runtime will be queued at once after the transaction commits. Similarly, calls to <tt class="calibre22">send</tt> and <tt class="calibre22">send-off</tt> made within the scope of evaluation of an agent action—called a <span class="italic">nested send</span><a id="filepos789644"></a>—are also held until the action has completed. In both cases, sent actions held pending the completion of an action evaluation or STM transaction may be discarded entirely if a validator aborts the state change associated with either.</p><p class="calibre18">To illustrate these semantics and see what they enable, let’s take a look at a couple of examples that use agents to simplify the coordination of I/O operations in conjunction with refs and the STM, and as part of a parallelized I/O-heavy workload.</p><p id="filepos790173" class="calibre23"><span class="calibre53"><span class="bold">Persisting reference states with an agent-based write-behind log</span></span></p><p id="filepos790298" class="calibre18">The game <a id="filepos790335"></a>we developed in <a href="#filepos672522"><span class="calibre5">The Mechanics of Ref Change</span></a>
<a id="filepos790441"></a>using refs to maintain character state in the face of relentlessly concurrent player activity proved the capabilities of Clojure’s STM in such an environment. However, any game like this, especially those providing multiplayer capabilities, will track and store player activity and the impact it has on their characters. Of course, we wouldn’t want to stuff any kind of logging, persistence, or other I/O into the core game engine: any persistence we want to perform may itself end up being inconsistent because of transaction restarts.</p><p class="calibre18">The simplest way to address this is to use watchers and agents to implement a write-behind log for characters in the game. First, let’s set up the agents that will hold our output sinks; for this example, we’ll assume that all such agents will contain <tt class="calibre22">java.io.Writer</tt>s, the Java interface that defines the API of character output streams:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(require '[clojure.java.io :as io])<br class="calibre33"/><br class="calibre33"/>(def console (agent *out*))<br class="calibre33"/>(def character-log (agent (io/writer "character-states.log" :append true)))</tt></span></blockquote><p class="calibre23">One of these agents contains <tt class="calibre22">*out*</tt> (itself an instance of <tt class="calibre22">Writer</tt>), the other a <tt class="calibre22">Writer</tt> that drains to a <span class="italic">character-states.log</span> file in the current directory. These <tt class="calibre22">Writer</tt> instances will have content written to them by an agent action, <tt class="calibre22">write</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn write<br class="calibre33"/>  [^java.io.Writer w &amp; content]<br class="calibre33"/>  (doseq [x (interpose " " content)]<br class="calibre33"/>    (.write w (str x)))<br class="calibre33"/>  (doto w<br class="calibre33"/>    (.write "\n")<br class="calibre33"/>    .flush))</tt></span></blockquote><p class="calibre23"><tt class="calibre22">write</tt> takes as its first argument a <tt class="calibre22">Writer</tt> (the state of one of the agents it will be queued for), and any number of other values to write to it. It writes each value separated by a space, then a newline, and then flushes the <tt class="calibre22">Writer</tt> so outputted content will actually hit the disk or console rather than get caught up in any buffers that might be in use by the <tt class="calibre22">Writer</tt>.</p><p class="calibre18">Finally, we need a function that will add a watcher to any reference type, which we’ll use to connect our character refs with the agents that hold the <tt class="calibre22">Writer</tt> instances:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn log-reference<br class="calibre33"/>  [reference &amp; writer-agents]<br class="calibre33"/>  (add-watch reference :log<br class="calibre33"/>             (fn [_ reference old new]<br class="calibre33"/>               (doseq [writer-agent writer-agents]<br class="calibre33"/>                 (send-off writer-agent write new)))))</tt></span></blockquote><p class="calibre23">Every time the reference’s state changes, its new state will be sent along with our <tt class="calibre22">write</tt> function to each of the agents provided to <tt class="calibre22">log-reference</tt>. All we need to do now is add the watcher for each of the characters for which we want to log state changes, and fire up a battle:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def smaug (character "Smaug" :health 500 :strength 400))<br class="calibre33"/>(def bilbo (character "Bilbo" :health 100 :strength 100))<br class="calibre33"/>(def gandalf (character "Gandalf" :health 75 :mana 1000))<br class="calibre33"/><br class="calibre33"/>(log-reference bilbo console character-log)<br class="calibre33"/>(log-reference smaug console character-log)<br class="calibre33"/><br class="calibre33"/>(wait-futures 1<br class="calibre33"/>              (play bilbo attack smaug)<br class="calibre33"/>              (play smaug attack bilbo)<br class="calibre33"/>              (play gandalf heal bilbo))<br class="calibre33"/><br class="calibre33"/>; {:max-health 500, :strength 400, :name "Smaug", :items #{}, :health 490.052618}<br class="calibre33"/>; {:max-health 100, :strength 100, :name "Bilbo", :items #{}, :health 61.5012391}<br class="calibre33"/>; {:max-health 100, :strength 100, :name "Bilbo", :items #{}, :health 100.0}      </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>; {:max-health 100, :strength 100, :name "Bilbo", :items #{}, :health 67.3425151}<br class="calibre33"/>; {:max-health 100, :strength 100, :name "Bilbo", :items #{}, :health 100.0}<br class="calibre33"/>; {:max-health 500, :strength 400, :name "Smaug", :items #{}, :health 480.990141}<br class="calibre33"/>; ...</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">You can see the healing effects of Gandalf made concrete each time Bilbo’s <tt class="calibre22">:health</tt> goes up in the log.</blockquote><p class="calibre18">You’ll find this same content in the <span class="italic">character-states.log</span> file as well. Fundamentally, we’re logging <a id="filepos795425"></a>states to the console and a file because they’re the most accessible sinks; this approach will work just as well if you were to stream updates to a database, message queue, and so on.</p><p class="calibre18">Using a watcher like this gives us the opportunity to make each state change to our characters’ refs durable (e.g., by writing them to disk or to a database) without modifying the functions used to implement those changes.</p><p class="calibre18">In order to track and persist in-transaction information—like the amount of each attack and heal, who did what to whom, and so on—we just need to dispatch a <tt class="calibre22">write</tt> action to our writer agents within the body of any function that makes a change we might want to persist:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn attack<br class="calibre33"/>  [aggressor target]<br class="calibre33"/>  (dosync<br class="calibre33"/>    (let [damage (* (rand 0.1) (:strength @aggressor) (ensure daylight))]<br class="calibre33"/>      (send-off console write<br class="calibre33"/>        (:name @aggressor) "hits" (:name @target) "for" damage)<br class="calibre33"/>      (commute target update-in [:health] #(max 0 (- % damage))))))<br class="calibre33"/><br class="calibre33"/>(defn heal<br class="calibre33"/>  [healer target]<br class="calibre33"/>  (dosync<br class="calibre33"/>    (let [aid (min (* (rand 0.1) (:mana @healer))<br class="calibre33"/>                   (- (:max-health @target) (:health @target)))]<br class="calibre33"/>      (when (pos? aid)<br class="calibre33"/>        (send-off console write<br class="calibre33"/>          (:name @healer) "heals" (:name @target) "for" aid)<br class="calibre33"/>        (commute healer update-in [:mana] - (max 5 (/ aid 5)))<br class="calibre33"/>        (alter target update-in [:health] + aid)))))<br class="calibre33"/><br class="calibre33"/>(dosync<br class="calibre33"/>  (alter smaug assoc :health 500)<br class="calibre33"/>  (alter bilbo assoc :health 100))<br class="calibre33"/>; {:max-health 100, :strength 100, :name "Bilbo", :items #{}, :health 100}<br class="calibre33"/>; {:max-health 500, :strength 400, :name "Smaug", :items #{}, :health 500}<br class="calibre33"/><br class="calibre33"/>(wait-futures 1<br class="calibre33"/>              (play bilbo attack smaug)<br class="calibre33"/>              (play smaug attack bilbo)<br class="calibre33"/>              (play gandalf heal bilbo))<br class="calibre33"/>; {:max-health 500, :strength 400, :name "Smaug", :items #{}, :health 497.414581}<br class="calibre33"/>; Bilbo hits Smaug for 2.585418463393845<br class="calibre33"/>; {:max-health 100, :strength 100, :name "Bilbo", :items #{}, :health 66.6262521}<br class="calibre33"/>; Smaug hits Bilbo for 33.373747881474934<br class="calibre33"/>; {:max-health 500, :strength 400, :name "Smaug", :items #{}, :health 494.667477}<br class="calibre33"/>; Bilbo hits Smaug for 2.747103668676348<br class="calibre33"/>; {:max-health 100, :strength 100, :name "Bilbo", :items #{}, :health 100.0}<br class="calibre33"/>; Gandalf heals Bilbo for 33.37374788147494<br class="calibre33"/>; ...</tt></span></blockquote><p class="calibre23">The end result of composing these small pieces together with our character refs is a fire-and-forget persistence mechanism <a id="filepos798550"></a>that is safe to use in conjunction with the retries that are inevitable when using atoms and transactions over refs. We wrote to the console and a logfile to keep the example simple, but you can just as easily write ref state updates to a database. In any case, this demonstrates how, just as with the general usage of atoms and refs, even things like sharing I/O resources within a concurrent environment can be done without touching a single low-level lock and taking on the risks inherent in their management.<a id="filepos799069"></a></p><p id="filepos799080" class="calibre23"><span class="calibre53"><span class="bold">Using agents to parallelize workloads</span></span></p><p id="filepos799178" class="calibre18">It may initially seem unnecessary or inconvenient to have to segregate agent actions into two sorts. However, without the separation between blocking and nonblocking actions, agents would lose their ability to efficiently utilize the resources needed to service the different kinds of workloads—CPU, disk I/O, network throughput, and so on.</p><p class="calibre18">For example, say our application was dedicated to processing messages pulled from a queue; reading messages from the queue would likely be a blocking operation due to waiting on the network if the queue was not in-process, and depending on the semantics of the queue, waiting for work to be available. However, processing each message is likely to be CPU-bound.</p><p class="calibre18">This sounds a lot like a web crawler.<a id="filepos800010"></a> Agents make building one that is efficient and flexible quite easy. The one we’ll build here will be extraordinarily basic,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos800178"></a><a href="#filepos823117"><span class="calibre32">156</span></a><span class="calibre32">]</span></small></sup> but it will demonstrate how agents can be used to orchestrate and parallelize potentially very complicated workloads.</p><p class="calibre18">First, we need some basic functions for working with the content of web pages we crawl. <tt class="calibre22">links-from</tt> takes a base URL and that URL’s HTML content, returning a seq of the links found within that content; <tt class="calibre22">words-from</tt> takes some HTML content and extracts its text, returning a seq of the words found therein, converted to lowercase:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(require '[net.cgrand.enlive-html :as enlive])<br class="calibre33"/>(use '[clojure.string :only (lower-case)])<br class="calibre33"/>(import '(java.net URL MalformedURLException))<br class="calibre33"/><br class="calibre33"/>(defn- links-from<br class="calibre33"/>  [base-url html]<br class="calibre33"/>  (remove nil? (for [link (enlive/select html [:a])]<br class="calibre33"/>                 (when-let [href (-&gt; link :attrs :href)]<br class="calibre33"/>                   (try<br class="calibre33"/>                     (URL. base-url href)<br class="calibre33"/>                     ; ignore bad URLs<br class="calibre33"/>                     (catch MalformedURLException e))))))<br class="calibre33"/><br class="calibre33"/>(defn- words-from<br class="calibre33"/>  [html]<br class="calibre33"/>  (let [chunks (-&gt; html<br class="calibre33"/>                 (enlive/at [:script] nil)<br class="calibre33"/>                 (enlive/select [:body enlive/text-node]))]<br class="calibre33"/>    (-&gt;&gt; chunks<br class="calibre33"/>      (mapcat (partial re-seq #"\w+"))<br class="calibre33"/>      (remove (partial re-matches #"\d+"))<br class="calibre33"/>      (map lower-case))))</tt></span></blockquote><p class="calibre23">This code uses Enlive, a web templating and scraping library that we discuss in detail in <a href="#filepos1958790"><span class="calibre5">Enlive: Selector-Based HTML Transformation</span></a>, but its details aren’t key to our main focus, the use of agents to soak up all of the resources we have to maximize crawling throughput.</p><p class="calibre18">There will be three pools of state associated with our web crawler:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">One of Java’s thread-safe queues will hold URLs that are yet to be crawled, which we’ll call <tt class="calibre22">url-queue</tt>. Then, for each page we retrieve, we will…</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Find all of the links in the page so as to crawl them later; these will all be added to a set held within an atom called <tt class="calibre22">crawled-urls</tt>, and URLs we haven’t visited yet will be queued up in <tt class="calibre22">url-queue</tt>. Finally…</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">We’ll extract all of the text of each page, which will be used to maintain a count of cumulative word frequencies observed throughout the crawl. This count will be stored in a map of words to their respective counts, held in an atom called <tt class="calibre22">word-freqs</tt>:</blockquote></li></ol><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def url-queue (LinkedBlockingQueue.))<br class="calibre33"/>(def crawled-urls (atom #{}))<br class="calibre33"/>(def word-freqs (atom {}))</tt></span></blockquote><p class="calibre23">We’ll set up a bunch of agents in order to fully utilize all the resources we have available,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos803761"></a><a href="#filepos823508"><span class="calibre32">157</span></a><span class="calibre32">]</span></small></sup> but we need to think through what state they’ll hold and what actions will be used to transition those states. In many cases, it is useful to think about agent state and the actions applied to it as forming a finite state machine; we’ve already walked through the workflow of our crawler, but we should formalize it.</p><blockquote id="filepos804181" class="calibre47"></blockquote><blockquote class="calibre39"><img src="images/00054.jpg" class="calibre97"/></blockquote><blockquote class="calibre57"><span class="calibre10"><span class="italic"><span class="calibre7">Figure 4-8. A web crawler’s primary state transitions</span></span></span></blockquote><p class="calibre50">The state of an agent at each point in this process should be obvious: prior to retrieving a URL, an agent will need a URL to retrieve (or some source of such URLs); prior to scraping, an agent will need a page’s content to scrape; and, prior to updating the cumulative crawler state, it will need the results of scraping. Since we don’t have very many potential states, we can simplify things for ourselves by allowing each action implementing these transitions to indicate the <span class="italic">next</span> action (transition) that should be applied to an agent.</p><p class="calibre18">To see what this looks like, let’s define our set of agents; their initial state, corresponding with the initial state preceding the “Retrieve URL” transition in <a href="#filepos804181"><span class="calibre5">Figure 4-8</span></a>, is a map containing the queue from which the next URL may be retrieved, and the next transition itself, a function we’ll call <tt class="calibre22">get-url</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(declare get-url)<br class="calibre33"/><br class="calibre33"/>(def agents (set (repeatedly 25 #(agent {::t #'get-url :queue url-queue})))) </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Our agents’ state will always have a <tt class="calibre22">::t</tt> slot,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos806063"></a><a href="#filepos823996"><span class="calibre32">158</span></a><span class="calibre32">]</span></small></sup> mapped to the next function that implements the next transition.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos806258"></a><a href="#filepos824393"><span class="calibre32">159</span></a><span class="calibre32">]</span></small></sup></blockquote><p class="calibre18">The three transitions shown in <a href="#filepos804181"><span class="calibre5">Figure 4-8</span></a> are implemented by three agent actions: <tt class="calibre22">get-url</tt>, <tt class="calibre22">process</tt>, and <tt class="calibre22">handle-results</tt>.</p><p class="calibre18"><tt class="calibre22">get-url</tt> will wait on a queue (remember, each of our agents has <tt class="calibre22">url-queue</tt> as its initial value) for URLs to crawl. It will leave the state of the agent set to a map containing the URL it pulls off the queue and its content:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(declare run process handle-results)           </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/><br class="calibre33"/>(defn ^::blocking get-url<br class="calibre33"/>  [{:keys [^BlockingQueue queue] :as state}]<br class="calibre33"/>  (let [url (as-url (.take queue))]<br class="calibre33"/>    (try<br class="calibre33"/>      (if (@crawled-urls url)                  </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>        state<br class="calibre33"/>        {:url url<br class="calibre33"/>         :content (slurp url)<br class="calibre33"/>         ::t #'process})<br class="calibre33"/>      (catch Exception e<br class="calibre33"/>        ;; skip any URL we failed to load<br class="calibre33"/>        state)<br class="calibre33"/>      (finally (run *agent*)))))</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">We’ll show <tt class="calibre22">run</tt> and explain what it’s doing in a little bit.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">If we’ve already crawled the URL pulled off the queue (or if we encounter an error while loading the URL’s content), we leave the agent’s state untouched. This implementation detail in our finite state machine adds a cycle to it where <tt class="calibre22">get-url</tt> will sometimes be invoked on a single agent multiple times before it transitions states.</blockquote><p class="calibre18"><tt class="calibre22">process</tt> will parse a URL’s content, using the <tt class="calibre22">links-from</tt> and <tt class="calibre22">words-from</tt> functions to obtain the URL’s content’s links and build a map containing the frequencies of each word found in the content. It will leave the state of the agent set to a map containing these values as well as the originating URL:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn process<br class="calibre33"/>  [{:keys [url content]}]<br class="calibre33"/>  (try<br class="calibre33"/>    (let [html (enlive/html-resource (java.io.StringReader. content))]<br class="calibre33"/>      {::t #'handle-results<br class="calibre33"/>       :url url<br class="calibre33"/>       :links (links-from url html)<br class="calibre33"/>       :words (reduce (fn [m word]<br class="calibre33"/>                        (update-in m [word] (fnil inc 0)))            </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>                      {}<br class="calibre33"/>                      (words-from html))})<br class="calibre33"/>    (finally (run *agent*))))</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">The <tt class="calibre22">:words</tt> map associates found words with their count within the retrieved page, which we produce by reducing a map through the seq of those words. <tt class="calibre22">fnil</tt> is a HOF that returns a function that uses some default value(s) (here, <tt class="calibre22">0</tt>) in place of any <tt class="calibre22">nil</tt> arguments when calling the function provided to <tt class="calibre22">fnil</tt>; this keeps us from having to explicitly check if the value in the words map is <tt class="calibre22">nil</tt>, and returning <tt class="calibre22">1</tt> if so.</blockquote><p class="calibre18"><tt class="calibre22">handle-results</tt> will update our three key pieces of state: adding the just-crawled URL to <tt class="calibre22">crawled-urls</tt>, pushing each of the newfound links onto <tt class="calibre22">url-queue</tt>, and merging the URL’s content’s word frequency map with our cumulative <tt class="calibre22">word-freqs</tt> map. <tt class="calibre22">handle-results</tt> returns a state map containing <tt class="calibre22">url-queue</tt> and the <tt class="calibre22">get-url</tt> transition, thus leaving the agent in its original state.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn ^::blocking handle-results<br class="calibre33"/>  [{:keys [url links words]}]<br class="calibre33"/>  (try<br class="calibre33"/>    (swap! crawled-urls conj url)<br class="calibre33"/>    (doseq [url links]<br class="calibre33"/>      (.put url-queue url))<br class="calibre33"/>    (swap! word-freqs (partial merge-with +) words)<br class="calibre33"/><br class="calibre33"/>    {::t #'get-url :queue url-queue}<br class="calibre33"/>    (finally (run *agent*))))</tt></span></blockquote><p class="calibre23">You may have noticed that each of the functions we’ll use as agent actions has a <tt class="calibre22">try</tt> form with a <tt class="calibre22">finally</tt> clause that contains a sole call to <tt class="calibre22">run</tt> with <tt class="calibre22">*agent*</tt> as its sole argument.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos811582"></a><a href="#filepos825096"><span class="calibre32">160</span></a><span class="calibre32">]</span></small></sup> We didn’t define <tt class="calibre22">*agent*</tt> anywhere; usually unbound, it is a var provided by Clojure that, within the scope of the evaluation of an agent action, is bound to the <span class="italic">current agent</span>. So, <tt class="calibre22">(run *agent*)</tt> in each of these actions is calling <tt class="calibre22">run</tt> with a single argument, the agent that is evaluating the action.</p><p class="calibre18">This is a common idiom used with agents that allow them to run continuously. In our web crawler’s case, <tt class="calibre22">run</tt> is a function that queues up the next transition function to be applied to an agent based on that agent’s <tt class="calibre22">::t</tt> state. If each action already knows which transition function should be applied next, why add a level of indirection in calling <tt class="calibre22">run</tt>? Two reasons:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">While it is reasonable to expect each function used as an agent action to know what the next transition should be given the new agent state it is returning, there’s no way for it to know whether that next transition is a blocking action or not. This is something that is best left up to the transitions themselves (and their informed authors); thus, <tt class="calibre22">run</tt> will use the presence (or, absence) of <tt class="calibre22">::blocking</tt> metadata on each transition to determine whether to use <tt class="calibre22">send</tt> or <tt class="calibre22">send-off</tt> to dispatch transition functions.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos813141"></a><a href="#filepos825439"><span class="calibre32">161</span></a><span class="calibre32">]</span></small></sup></blockquote></li><a id="filepos813254"></a><li value="2" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">run</tt> can check to see if the agent has been marked as being paused—a condition indicated simply by the presence of a logically true <tt class="calibre22">::paused</tt> value in the agent’s metadata.</blockquote></li></ol><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 4-8. run, the web crawler’s “main loop”</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(defn paused? [agent] (::paused (meta agent)))<br class="calibre33"/><br class="calibre33"/>(defn run<br class="calibre33"/>  ([] (doseq [a agents] (run a)))<br class="calibre33"/>  ([a]<br class="calibre33"/>    (when (agents a)<br class="calibre33"/>      (send a (fn [{transition ::t :as state}]<br class="calibre33"/>                (when-not (paused? *agent*)<br class="calibre33"/>                  (let [dispatch-fn (if (-&gt; transition meta ::blocking)<br class="calibre33"/>                                      send-off<br class="calibre33"/>                                      send)]<br class="calibre33"/>                    (dispatch-fn *agent* transition)))<br class="calibre33"/>                state)))))</tt></span></p><p class="calibre13"><tt class="calibre22">run</tt> doubles as a way to start all of our (unpaused) agents when called with no arguments.</p><p class="calibre18">The pausing capability is particularly important, as we wouldn’t want to have the crawler run without interruption. With the use of metadata to indicate that <tt class="calibre22">run</tt> should not dispatch the next transition for an agent’s state, <tt class="calibre22">pause</tt> and <tt class="calibre22">restart</tt> give us a way to pause or restart the agents’ operation just from changing their metadata:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn pause<br class="calibre33"/>  ([] (doseq [a agents] (pause a)))<br class="calibre33"/>  ([a] (alter-meta! a assoc ::paused true)))<br class="calibre33"/><br class="calibre33"/>(defn restart<br class="calibre33"/>  ([] (doseq [a agents] (restart a)))<br class="calibre33"/>  ([a]<br class="calibre33"/>    (alter-meta! a dissoc ::paused)<br class="calibre33"/>    (run a)))</tt></span></blockquote><p class="calibre23">Now we can crawl some web pages! We’ll want to run the crawler repeatedly from a fresh state, so it will be handy to have a testing function that will reset the crawler state. <tt class="calibre22">test-crawler</tt> does this, as well as adding a starting URL to <tt class="calibre22">url-queue</tt>, and letting the agents run for just 60 seconds so we can make some informal throughput comparisons:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn test-crawler<br class="calibre33"/>  "Resets all state associated with the crawler, adds the given URL to the<br class="calibre33"/>   url-queue, and runs the crawler for 60 seconds, returning a vector<br class="calibre33"/>   containing the number of URLs crawled, and the number of URLs<br class="calibre33"/>   accumulated through crawling that have yet to be visited."<br class="calibre33"/>  [agent-count starting-url]<br class="calibre33"/>  (def agents (set (repeatedly agent-count <br class="calibre33"/>                     #(agent {::t #'get-url :queue url-queue}))))  </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  (.clear url-queue)<br class="calibre33"/>  (swap! crawled-urls empty)<br class="calibre33"/>  (swap! word-freqs empty)<br class="calibre33"/>  (.add url-queue starting-url)<br class="calibre33"/>  (run)<br class="calibre33"/>  (Thread/sleep 60000)<br class="calibre33"/>  (pause)<br class="calibre33"/>  [(count @crawled-urls) (count url-queue)])</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">We warned you against redefining vars within the body of a function in <a href="#filepos759240"><span class="calibre5">Vars Are Not Variables</span></a>, but this may be one of the few contexts where doing so is okay: a function that is never called outside of the REPL, used solely for experimentation and testing.</blockquote><p class="calibre18">To establish a baseline, let’s first try it with a single agent, using the BBC’s news page as a crawl root:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(test-crawler 1 "http://www.bbc.co.uk/news/")<br class="calibre33"/>;= [86 14598]</tt></span></blockquote><p class="calibre23">Eighty-six pages crawled in a minute. Surely we can do better; let’s use 25 agents, which will parallelize both the blocking retrieval workload as well as the CPU-bound scraping and text processing workload:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(test-crawler 25 "http://www.bbc.co.uk/news/")<br class="calibre33"/>;= [670 81775]</tt></span></blockquote><p class="calibre23">Not bad, 670 pages crawled in 60 seconds, a very solid order of magnitude gained simply by tweaking the number of agents being applied to the problem.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos818208"></a><a href="#filepos825997"><span class="calibre32">162</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">Let’s check on the word frequencies being calculated. We can get a selection of the most and least common terms with their frequencies quite easily:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(-&gt;&gt; (sort-by val @word-freqs)<br class="calibre33"/>  reverse<br class="calibre33"/>  (take 10))<br class="calibre33"/>;= (["the" 23083] ["to" 14308] ["of" 11243] ["bbc" 10969] ["in" 9473]<br class="calibre33"/>;=  ["a" 9214] ["and" 8595] ["for" 5203] ["is" 4844] ["on" 4364])<br class="calibre33"/>(-&gt;&gt; (sort-by val @word-freqs)<br class="calibre33"/>  (take 10))<br class="calibre33"/>;= (["relieved" 1] ["karim" 1] ["gnome" 1] ["brummell" 1] ["mccredie" 1]<br class="calibre33"/>;=  ["ensinar" 1] ["estrictas" 1] ["arap" 1] ["forcibly" 1] ["kitchin" 1])</tt></span></blockquote><p class="calibre23">Looks like we have a fully functioning crawler that does some marginally interesting work. It’s surely not optimal—as we’ve said, it’s quite basic, and would need a variety of subtle enhancements in order to be used at scale, but the foundation is clearly there.</p><p class="calibre18">Now, remember what we were saying earlier in this section, that the division of agent actions into those that may block (due to I/O or other wait conditions) and those that won’t (i.e., CPU-bound processing) enables the maximal utilization of all of the resources at our disposal. We can test this; for example, by marking <tt class="calibre22">process</tt> as a blocking operation, we will ensure that it is always sent to agents using <tt class="calibre22">send-off</tt>, and thus handled using the unbounded thread pool:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(alter-meta! #'process assoc ::blocking true)<br class="calibre33"/>;= {:arglists ([{:keys [url content]}]), :ns #&lt;Namespace user&gt;, <br class="calibre33"/>;=  :name process, :user/blocking true}</tt></span></blockquote><p class="calibre23">The practical effect of this is that all of the HTML parsing, searching for links, and text processing associated with the word frequency calculations will happen without limit.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(test-crawler 25 "http://www.bbc.co.uk/news/")<br class="calibre33"/>;= [573 80576]</tt></span></blockquote><p class="calibre23">This actually has a negative impact on throughput—approaching 15 percent overall—as now there can be up to 25 active (and hungry) agents contending for CPU cores, which can cumulatively slow our CPU-bound workload.<a id="filepos820785"></a></p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos820889"></a><a href="#filepos770870"><span class="calibre32">150</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">For example, a two-core CPU will have a </span><span class="calibre10"><tt class="calibre22">send</tt></span><span class="calibre10"> thread pool configured to contain a maximum of four threads, a four-core CPU will have a pool of eight threads, etc.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos821288"></a><a href="#filepos774231"><span class="calibre32">151</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Many thousands of agents may be created without strain with a default heap configuration; millions may be created by tweaking the JVM’s heap settings.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos821625"></a><a href="#filepos776988"><span class="calibre32">152</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">It is an implementation detail—and so may change in the future—but you can call </span><span class="calibre10"><tt class="calibre22">(.getQueueCount some-agent)</tt></span><span class="calibre10"> in order to check the current size of an </span><span class="calibre10"><tt class="calibre22">some-agent</tt></span><span class="calibre10">’s action queue.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos822097"></a><a href="#filepos783845"><span class="calibre32">153</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">That is, via a REPL connected to your environment, wherever it may be; see </span><a href="#filepos1502723"><span class="calibre10"><span class="calibre5">Debugging, Monitoring, and Patching Production in the REPL</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos822515"></a><a href="#filepos784461"><span class="calibre32">154</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">You can change an agent’s error mode with </span><span class="calibre10"><tt class="calibre22">set-error-mode!</tt></span><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos822813"></a><a href="#filepos785649"><span class="calibre32">155</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">You can change an agent’s error handler with </span><span class="calibre10"><tt class="calibre22">set-error-handler!</tt></span><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos823117"></a><a href="#filepos800178"><span class="calibre32">156</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">And not very well-behaved, especially insofar as it doesn’t throttle connections, a key point of politeness when crawling web content. Our apologies to the BBC for (ab)using them as an example crawl root!</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos823508"></a><a href="#filepos803761"><span class="calibre32">157</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Another shortcoming of our basic web crawler: at nearly any scale, a useful web crawler would use a message queue and suitable database instead of maintaining all state in memory. This thankfully does not affect the semantics of our example, which could be adapted to use such things with relative ease.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos823996"></a><a href="#filepos806063"><span class="calibre32">158</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">We use a namespaced keyword to avoid any potential naming clashes with other parts of state that might be added to the agents, if this crawler implementation were to ever be extended outside of its own namespace.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos824393"></a><a href="#filepos806258"><span class="calibre32">159</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Depending on the range of states that are to be held by your agents, sending a multimethod or protocol function to them can be an elegant, efficient option to discriminate between a number of different potential agent state transitions. We talk about multimethods and protocols in </span><a href="#filepos1073489"><span class="calibre10"><span class="calibre5">Chapter 7</span></span></a><span class="calibre10"> and </span><a href="#filepos948323"><span class="calibre10"><span class="calibre5">Protocols</span></span></a><span class="calibre10">, respectively.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos825096"></a><a href="#filepos811582"><span class="calibre32">160</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">We’ve repeated this pattern in three functions at this point; any more, and it would be a no-brainer to write a macro that would eliminate that boilerplate.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos825439"></a><a href="#filepos813141"><span class="calibre32">161</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">This metadata access explains in part why we’re using the functions’ vars to denote transitions instead of the functions themselves. Beyond that, using vars helps make it easier to modify the behavior of the web crawler; see </span><a href="#filepos1518975"><span class="calibre10"><span class="calibre5">Limitations to Redefining Constructs</span></span></a><span class="calibre10"> for why.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos825997"></a><a href="#filepos818208"><span class="calibre32">162</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Of course, your specific results will vary greatly depending upon the CPU power you have available and the speed and latency of your Internet connection; however, the relative improvement from 1 to 25 agents should be similar.</span></p><div class="mbppagebreak"></div><p id="filepos826361" class="calibre6"><span class="calibre4"><span class="bold">Using Java’s Concurrency Primitives</span></span></p><p id="filepos826459" class="calibre18">Now that we’ve done a deep dive into Clojure’s extensive concurrency and state-management features, it’s worth pointing out that Java’s native threads, primitive lock mechanisms, and its own very useful concurrency libraries—especially the <tt class="calibre22">java.util.concurrent.*</tt><a id="filepos826768"></a> packages—are quite usable in Clojure. In particular, the latter are used extensively in the implementation of Clojure’s own concurrency primitives, but Clojure does not wrap or subsume them, so you should learn about them and use them as appropriate in your applications.</p><p class="calibre18">We’ve not yet explored all the mechanics of Clojure’s Java interoperability—we’ll get to that in <a href="#filepos1274079"><span class="calibre5">Chapter 9</span></a>—but the examples we show here should be basic enough for you to understand before you dig into that.</p><p class="calibre18">Java defines a couple of key interfaces—<tt class="calibre22">java.lang.Runnable</tt><a id="filepos827457"></a> and <tt class="calibre22">java.util.concurrent.Callable</tt><a id="filepos827507"></a>—which are implemented by Clojure functions that take no parameters. This means you can pass no-arg Clojure functions to any Java API that requires an object that implements one of these interfaces, including native <tt class="calibre22">Thread</tt>s:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(.start (Thread. #(println "Running...")))<br class="calibre33"/>;= Running...<br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre23">The <tt class="calibre22">java.util.concurrent.*</tt><a id="filepos827981"></a> packages offer a number of concurrency facilities that are used in the implementation of Clojure’s own features, many of which you should take advantage when appropriate. We already demonstrated the operation of one type of thread-safe queue implementation in <a href="#filepos799080"><span class="calibre5">Using agents to parallelize workloads</span></a>, <tt class="calibre22">LinkedBlockingQueue</tt>; there are many others like it but with subtle yet important differences in semantics and performance. Then there are thread pools,<a id="filepos828505"></a> thread-safe concurrent data structures (a better fallback than the vanilla, e.g., <tt class="calibre22">java.util.HashMap</tt> if your Clojure program needs to share a mutable-in-place data structure with some Java code), and special-purpose objects like <tt class="calibre22">CountDownLatch</tt>, which allow you block a thread (or future, or agent action dispatched with <tt class="calibre22">send-off</tt>) until some number of other events have occurred.</p><p class="calibre18">If you would like to know how to use these facilities effectively and develop a thorough understanding of concurrency at the lower levels of the JVM, we recommend <span class="italic">Java Concurrency in Practice</span> by Goetz, et al.</p><p id="filepos829168" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Locking</span></span></span></p><p id="filepos829265" class="calibre18">Even given all of the (safer) concurrency primitives provided by Clojure, you may still occasionally need a primitive lock, often when working with mutable Java entities such as arrays. Of course, once you make this decision, you’re on your own: you are no longer benefiting from the defined semantics that those primitives guarantee. In any case, you can use the <tt class="calibre22">locking</tt> macro to obtain and hold a lock on a given object for the duration of execution within the body of the <tt class="calibre22">locking</tt> form.</p><p class="calibre18">So, this Clojure code:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn add<br class="calibre33"/>  [some-list value]<br class="calibre33"/>  (locking some-list<br class="calibre33"/>    (.add some-list value)))</tt></span></blockquote><p class="calibre23">is equivalent to this code in Java, Ruby, and Python, respectively:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">// Java<br class="calibre33"/>public static void add (java.util.List someList, Object value) {<br class="calibre33"/>    synchronized (someList) {<br class="calibre33"/>        someList.add(value);<br class="calibre33"/>    }<br class="calibre33"/>}<br class="calibre33"/><br class="calibre33"/><br class="calibre33"/># Ruby<br class="calibre33"/>require 'thread'<br class="calibre33"/>m = Mutex.new<br class="calibre33"/><br class="calibre33"/>def add (list, value)<br class="calibre33"/>    m.synchronize do<br class="calibre33"/>        list &lt;&lt; value<br class="calibre33"/>    end<br class="calibre33"/>end<br class="calibre33"/><br class="calibre33"/><br class="calibre33"/># Python<br class="calibre33"/>import threading<br class="calibre33"/>lock = threading.Lock()<br class="calibre33"/>def add (list, value):<br class="calibre33"/>    lock.acquire()<br class="calibre33"/>    list.append(value)<br class="calibre33"/>    lock.release()</tt></span></blockquote><div class="mbppagebreak"></div><p id="filepos830923" class="calibre6"><span class="calibre4"><span class="bold">Final Thoughts</span></span></p><p class="calibre18">Concurrent programming is hard, and many popular programming languages are set up in such a way to make it harder. By having a clear separation of identity and state, promoting immutability, and offering built-in constructs for safe multithreaded programming, Clojure goes a long way to making concurrent programming easier and more accessible.<a id="filepos831370"></a></p><div class="mbppagebreak"></div><p id="filepos831397" class="calibre6"><span class="calibre4"><span class="bold">Part II. Building Abstractions</span></span></p><div class="mbppagebreak"></div><p id="filepos831506" class="calibre6"><span class="calibre2"><span class="bold">Chapter 5. Macros</span></span></p><p id="filepos831586" class="calibre13">Historically, Lisps have been described as “programmable programming languages.” This description fits Clojure, and a large part of the reason for that is macros. Macros allow a programmer to extend the Clojure language in ways that are difficult or impossible in most other languages.</p><p class="calibre18">A programming language is a means for building abstractions. Instead of doing tedious manual work, a programmer can write code once and treat that code as a reusable unit. Code can be executed repeatedly in a loop; or, code can be grouped as a unit and given a name as a function; or, using conditionals, the same code can do different things in different circumstances.</p><p class="calibre18">It should be clear that some languages offer more powerful means of abstraction than others. Imagine for a moment a programming language without loops. Such a language might be usable, but unrolling all loops by hand would be incredibly tedious. Similarly, a language without functions might be able to do anything any other Turing-complete language can do, but code would have to be repeated over and over.</p><p class="calibre18">In short, when a language lacks proper means of abstraction, the result is boilerplate and repetition, both signs of fundamental weaknesses in that language. Macros are powerful because they give you a way to define entirely new levels of abstraction within the language itself. Macros are the ultimate tool for eliminating boilerplate and growing a programming language up to meet your needs.</p><p id="filepos833173" class="calibre6"><span class="calibre4"><span class="bold">What Is a Macro?</span></span></p><p id="filepos833250" class="calibre18">Macros allow you to control the Clojure compiler. Within their scope, they can be used to effect subtle syntactic tweaks or to upend the language’s rules of physics. Where Java might be “C++ without guns, knives, and clubs,”<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos833543"></a><a href="#filepos850336"><span class="calibre32">163</span></a><span class="calibre32">]</span></small></sup> and languages like Ruby and Python might provide a reasonable yet well-defined arsenal, Clojure’s macros allow you to build any weapon you want and have it feel like it came with the language as a built-in armament.</p><p class="calibre18">The key to understanding macros is to keep clear in your mind the distinction between <span class="italic">runtime</span> and <span class="italic">compile time</span>.</p><p class="calibre18">As you learned in <a href="#filepos76368"><span class="calibre5">The Reader</span></a>, Clojure source code is read by the Clojure reader, which produces Clojure data structures from textual Clojure code—the very same Clojure data structures you have access to in your own code. For example, from the string <tt class="calibre22">"(foo [bar] :baz 123)"</tt>, the reader yields a list containing a symbol, a vector containing a symbol, a keyword, and an integer. This property, where a language’s code is represented using its own data structures, is called <span class="italic">homoiconicity</span><a id="filepos834605"></a>, and is critical in enabling macros.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos834684"></a><a href="#filepos850605"><span class="calibre32">164</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">Normally these data structures are then <span class="italic">evaluated</span>. Each type of data has particular rules that govern its evaluation:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Many literals evaluate to themselves (e.g., integers, strings, keywords, vectors).</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Symbols resolve to a value in a var from some namespace.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Lists denote calls, either to functions, special forms, or macros.</blockquote></li></ul><p class="calibre18">It is between the <span class="italic">read</span> and <span class="italic">evaluation</span> steps where compilation <a id="filepos835574"></a>happens and macros occupy a privileged status compared to functions. Whereas function calls in source code carry through to the compiled representation of that code where arguments are evaluated and passed to the function as parameters yielding some result at runtime, <span class="italic">macros are called by the compiler</span> with their unevaluated data structures as arguments and must return a Clojure data structure that can itself be evaluated. For example, if <tt class="calibre22">foo</tt> is a function, then</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(foo a b)</tt></span></blockquote><p class="calibre23">compiles down to a runtime invocation of the <tt class="calibre22">foo</tt> function with the two values named by <tt class="calibre22">a</tt> and <tt class="calibre22">b</tt>, whereas if <tt class="calibre22">bar</tt> is a macro, then</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(bar a b)</tt></span></blockquote><p class="calibre23"><tt class="calibre22">bar</tt> is called by the Clojure compiler with two arguments, the <span class="italic">symbols</span>
<tt class="calibre22">a</tt> and <tt class="calibre22">b</tt>—<span class="italic">not</span> the values they name.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos836655"></a><a href="#filepos850951"><span class="calibre32">165</span></a><span class="calibre32">]</span></small></sup><tt class="calibre22">bar</tt> can choose to evaluate those symbols in the same way as they normally are, or it can implement its own semantics, and it can do all this using all of Clojure’s facilities and all of the data and functions defined thus far: macros are not limited to a subset of the language. In any case, <tt class="calibre22">bar</tt> must return to the compiler a Clojure data structure that will be used in its place. This is recursive, as a macro can return a Clojure data structure that includes other macro calls as well; this continues for each expression until it is no longer a macro call.</p><blockquote class="calibre47"></blockquote><blockquote class="calibre48"><img src="images/00039.jpg" class="calibre98"/></blockquote><blockquote class="calibre47"><span class="calibre10"><span class="italic"><span class="calibre7">Figure 5-1. The Clojure compilation model</span></span></span></blockquote><p class="calibre50">Macros being a tool of abstraction, each macro call generally produces code with a larger footprint than the macro call itself. Thus, this process of replacing macro calls with the code they produce is called <span class="italic">macroexpansion</span><a id="filepos837955"></a>. As we first said in <a href="#filepos37449"><span class="calibre5">The Clojure REPL</span></a>, all Clojure code is always compiled, even at the REPL, and macroexpansion is a critical and inseparable part of compilation.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">The compilation process ensures that any macro calls are replaced wholesale with their expansions long before a program’s runtime; thus, </span><span class="calibre10"><span class="italic">macros are only ever evaluated at compile time</span></span><span class="calibre10">.</span></blockquote><p id="filepos838619" class="calibre25"><span class="calibre19"><span class="bold"><span class="calibre5">What Macros Are Not</span></span></span></p><p id="filepos838728" class="calibre18">Writing code that manipulates code is not a unique feature of Clojure, or Lisps in general. However, not all code-manipulating systems are created equal.</p><p class="calibre18">For example, C has a preprocessor, which does textual substitution of source code with other source code at compile time. Such textual macro systems are fundamentally less capable than Lisp-style macros, due to their reliance upon string processing rather than working with code as structured data. Some of the same weaknesses are evident in textual code evaluation mechanisms such as Ruby’s <tt class="calibre22">eval</tt>, which we contrast with Clojure macros in <a href="#filepos846315"><span class="calibre5">Macros Versus Ruby eval</span></a>.</p><p class="calibre18">Similarly, facilities providing <span class="italic">code generation</span><a id="filepos839556"></a> are not equivalent to macros. These generally take a high-level representation, say, a formal grammar or a description of an object model, and produce a body of code that implements it. While these systems are often useful, they often suffer from a discrete compilation step (whereas macros are folded into the same compilation process as all other Clojure code), siloed data models (whereas macros just use regular Clojure data structures), and noncomposability (whereas macros can readily be used in conjunction with each other).</p><p class="calibre18">Finally, there are a number of languages that provide compiler APIs,<a id="filepos840195"></a> allowing you to modify code written in that language. Examples here include Java’s annotation processors, Groovy’s AST builders, Template Haskell, and Scala’s compiler plug-ins. These are very powerful systems that do allow you to build syntactic abstractions and optimizations similar to what Clojure’s macros support. While there are many potential points of contrast, the most striking is that these systems are by definition exposing an internal API and language data model that is generally far removed from its originating source code. Clojure being homoiconic makes the interface and model of macros as simple as working with Clojure data structures.</p><p id="filepos840872" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">What Can Macros Do that Functions Cannot?</span></span></span></p><p id="filepos841003" class="calibre18">It may be difficult to understand at first the power or utility of macros. A simple example should make it clear.</p><p class="calibre18">Java was first released in 1996. Eight years later, in Java 5, enhanced <tt class="calibre22">for</tt> loops were added to the language, a useful addition long in the making. This lets you replace fairly verbose code like this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">for (int i = 0; i &lt; collection.size(); i++) {<br class="calibre33"/>    SomeType var = (SomeType)collection.get(i);<br class="calibre33"/>    ...<br class="calibre33"/>}</tt></span></blockquote><p class="calibre23">with a more concise alternative:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">for (SomeType var : collection) {<br class="calibre33"/>    ...<br class="calibre33"/>}</tt></span></blockquote><p class="calibre23">These kinds of changes to a language are important. The enhanced <tt class="calibre22">for</tt> loop in Java reduces complexity and eliminates possibilities for error: using enhanced <tt class="calibre22">for</tt>, it’s impossible to exceed an array bounds, or accidentally iterate <tt class="calibre22">i</tt> starting from 1 instead of 0.</p><p class="calibre18">As programmers, we can look at a particular usage of the enhanced <tt class="calibre22">for</tt> syntax and mechanically transform the code into an equivalent loop using the old <tt class="calibre22">for</tt> syntax. The name of the loop variable and the collection to iterate over are the only important things here. The rest—tracking indices, bounds-checking, etc.—is just boilerplate.</p><p class="calibre18">So why didn’t anyone add enhanced <tt class="calibre22">for</tt> to Java sooner? The problem is that Java lacks the expressive power to let you write code to do so. Enhanced <tt class="calibre22">for</tt> can’t be a normal method call, and methods are the only tool at your disposal in Java. Methods can’t set up bindings for local variables outside the scope of the method itself. Methods can’t conditionally execute their arguments—their arguments are always evaluated, and the resulting values are passed to the method. It would be possible to create something that behaved similar to enhanced <tt class="calibre22">for</tt> in Java, but it certainly wouldn’t look or feel anything like what shipped with Java 5.</p><p class="calibre18">Adding enhanced <tt class="calibre22">for</tt> to Java requires a change at the compiler level, and the average user does not have the knowledge or ability to make that change. So what did Java developers do for those first eight years without this helpful language feature? They lived without it.</p><p class="calibre18">In contrast, <span class="italic">any</span> Clojure programmer, in matter of minutes and in a few lines of unprivileged Clojure code, can write a macro to add an imperative looping construct to Clojure that is similar to Java 5’s enhanced <tt class="calibre22">for</tt>:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos843853"></a><a href="#filepos851517"><span class="calibre32">166</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defmacro foreach [[sym coll] &amp; body]<br class="calibre33"/>  `(loop [coll# ~coll]<br class="calibre33"/>     (when-let [[~sym &amp; xs#] (seq coll#)]<br class="calibre33"/>       ~@body<br class="calibre33"/>       (recur xs#))))<br class="calibre33"/>;= #'user/foreach<br class="calibre33"/>(foreach [x [1 2 3]]<br class="calibre33"/>  (println x))<br class="calibre33"/>; 1<br class="calibre33"/>; 2<br class="calibre33"/>; 3</tt></span></blockquote><p class="calibre23">Functions are excellent tools of abstraction, but there are certain things they simply cannot do because they are only called at runtime and have no access to the compiler; in this case, there is no way to lift an unevaluated body of code (our <tt class="calibre22">println</tt> call) into a looping construct by relying upon functions alone. In short, macros allow a Clojure programmer to add new language constructs to the language.</p><p class="calibre18"><span class="bold">Built-ins versus macros</span>. Compared to most languages, Clojure’s set of built-in operators—<a id="filepos844947"></a>called <span class="italic">special forms</span><a id="filepos844981"></a>—is very small. Recall that the complete list (see <a href="#filepos121508"><span class="calibre5">Special Forms</span></a>) contained only 16 items.</p><p class="calibre18">There are a lot of things missing from that list that we might expect to find there. Where are iteration constructs like <tt class="calibre22">while</tt>, <tt class="calibre22">for</tt>, and <tt class="calibre22">doseq</tt>? Defining constructs like <tt class="calibre22">defn</tt>, <tt class="calibre22">defmacro</tt>, <tt class="calibre22">defrecord</tt>? Conditionals like <tt class="calibre22">when</tt>, <tt class="calibre22">cond</tt>, and <tt class="calibre22">condp</tt>? All of these are fundamental to our everyday experience as Clojure programmers.</p><p class="calibre18">Perhaps surprisingly, those are all macros. If they didn’t exist, you could write them yourself in plain Clojure, without coordinating with or convincing the language’s authors. This is in stark contrast to many languages, where the thought of writing your own loop or conditional construct is pure fantasy. Of course, this generalizes to very application- and domain-specific requirements, where a syntactic tweak can make all the difference in making the language itself more suitable for your particular needs. Thus, macros blur the line between what is “built in” to the language and what is user-defined; because the latter have the same status as the former, the distinction loses much of its meaning.</p><p id="filepos846315" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Macros Versus Ruby eval</span></span></span></p><p id="filepos846428" class="calibre18">At a glance, macros may seem similar to <tt class="calibre22">eval</tt> in Ruby.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos846553"></a><a href="#filepos852062"><span class="calibre32">167</span></a><span class="calibre32">]</span></small></sup><tt class="calibre22">eval</tt> in Ruby is a built-in function that executes code at runtime. Ruby also has <tt class="calibre22">class_eval</tt> and <tt class="calibre22">instance_eval</tt>, which similarly execute code at runtime, in different contexts.</p><p class="calibre18">In Ruby, we could write this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">x = 123<br class="calibre33"/>code = "puts VAR"<br class="calibre33"/>code.sub!(/VAR/, 'x')<br class="calibre33"/>eval code</tt></span></blockquote><p class="calibre23">And this would print 123. We’ve created code as a string, manipulated that code, and executed it.</p><p class="calibre18">One important distinction between macros and <tt class="calibre22">eval</tt> is that <tt class="calibre22">eval</tt> executes at <span class="italic">runtime</span>. This means, for example, that errors that would normally be caught at compile time are impossible to catch in <tt class="calibre22">eval</tt>ed code. Consider:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">code = &lt;&lt;END<br class="calibre33"/>  def foo<br class="calibre33"/>    puts "foo!       # oops, forgot a closing quote<br class="calibre33"/>  end<br class="calibre33"/>END<br class="calibre33"/><br class="calibre33"/>if(rand(2) == 0)<br class="calibre33"/>  eval code<br class="calibre33"/>end</tt></span></blockquote><p class="calibre23">Half the time, this code will compile and run without error, because our code string is never evaled. The other half of the time, we’ll get an error at runtime.</p><p class="calibre18">By contrast, Clojure macros are compiled at compile time. A similar error <a id="filepos848091"></a>would be caught in Clojure immediately; because macros are just more Clojure code, so attempting to use improper syntax will fail in the reader. For example, this code will never even get to the point of being compiled, never mind used:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defmacro foo []<br class="calibre33"/>  `(if (= 0 (rand-int 2))<br class="calibre33"/>     (println "foo!)))     ;; oops, forgot a closing quote<br class="calibre33"/>;= #&lt;Exception java.lang.Exception: EOF while reading string&gt;</tt></span></blockquote><p class="calibre23">Another difference between macros and Ruby’s <tt class="calibre22">eval</tt> is apparent as soon as we try to manipulate our code. With Ruby <tt class="calibre22">eval</tt>, our code is a <tt class="calibre22">String</tt>. This <tt class="calibre22">String</tt> is structureless; to manipulate it, we are limited to the tools that work with <tt class="calibre22">String</tt>s: regular expressions, concatenation, and substringing.</p><p class="calibre18">In contrast, Clojure macros don’t operate over structureless strings. Since Clojure is homoiconic, they deal directly with Clojure <a id="filepos849177"></a>data structures like lists, vectors, symbols, and so on.</p><p class="calibre18">Manipulation of source code in <tt class="calibre22">String</tt>s is fragile and error-prone. And errors are not caught until the code is evaled, making the process dangerous. Thus, it’s common to hear strong caveats in the Ruby world against ever using <tt class="calibre22">eval</tt> at all, and rightly so.</p><p class="calibre18">So, this monstrosity would be considered very poor form in Ruby:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">&gt;&gt; def print_sym(x)<br class="calibre33"/>&gt;&gt;   code = "p(" + x + ".to_sym)"<br class="calibre33"/>&gt;&gt; end<br class="calibre33"/>nil<br class="calibre33"/>&gt;&gt; eval print_sym "\"foo\""<br class="calibre33"/>:foo<br class="calibre33"/>nil</tt></span></blockquote><p class="calibre23">while this Clojure equivalent is just fine:<a id="filepos849987"></a></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defmacro print-keyword [x]<br class="calibre33"/>  `(println (keyword ~x)))<br class="calibre33"/>;= #'user/print-keyword<br class="calibre33"/>(print-keyword "foo")<br class="calibre33"/>; :foo<br class="calibre33"/>;= nil</tt></span></blockquote><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos850336"></a><a href="#filepos833543"><span class="calibre32">163</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">This quotation is often attributed to James Gosling, the original architect of Java.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos850605"></a><a href="#filepos834684"><span class="calibre32">164</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">We talked about homoiconicity at some length in </span><a href="#filepos69475"><span class="calibre10"><span class="calibre5">Homoiconicity</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos850951"></a><a href="#filepos836655"><span class="calibre32">165</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">The Clojure compiler knows to treat macro calls differently than calls of functions or special forms because of the implementation detail that macros are themselves functions with a bit of metadata hanging off of them identifying them as such. You can see this by inspecting the metadata of a macro’s var, such as </span><span class="calibre10"><tt class="calibre22">(meta #'or)</tt></span><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos851517"></a><a href="#filepos843853"><span class="calibre32">166</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">This </span><span class="calibre10"><tt class="calibre22">foreach</tt></span><span class="calibre10"> macro is purely illustrative; Clojure already provides a superset of functionality offered by Java’s enhanced imperative looping in </span><span class="calibre10"><tt class="calibre22">doseq</tt></span><span class="calibre10">, in addition to </span><span class="calibre10"><tt class="calibre22">for</tt></span><span class="calibre10">, its functional counterpart.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos852062"></a><a href="#filepos846553"><span class="calibre32">167</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Or Python, or JavaScript, or PHP, or Perl, or really any other language the allows you to evaluate a string containing code.</span></p><div class="mbppagebreak"></div><p id="filepos852324" class="calibre6"><span class="calibre4"><span class="bold">Writing Your First Macro</span></span></p><p id="filepos852409" class="calibre18">Let’s write a silly macro that does something that a function could never do. Suppose in a quest to annoy our coworkers, we want to write all of the symbols in our code in reverse. Our goal is to write this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(reverse-it (nltnirp "foo"))</tt></span></blockquote><p class="calibre23">and have Clojure end up evaluating this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(println "foo")</tt></span></blockquote><p class="calibre23">It should be apparent that this would be impossible to do in a language like Java without altering the Java parser or compiler. But in Clojure, thanks to macros, we can do it easily.</p><p class="calibre18">Our <tt class="calibre22">reverse-it</tt> macro receives source code as its arguments in the form of Clojure data structures. All we have to do is locate all of the symbols, fetch the symbols’ <tt class="calibre22">String</tt> “names,” reverse those strings and return new symbols in their place.</p><p class="calibre18"><tt class="calibre22">clojure.walk</tt> provides a handy function <tt class="calibre22">postwalk</tt><a id="filepos853535"></a>, which lets us recursively walk a series of nested lists and do something to certain elements. This fits our requirements nicely:</p><p id="filepos853676" class="calibre23"></p><p class="calibre23"><span class="italic">Example 5-1. reverse-it, a symbol-reversing macro</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(require '(clojure [string :as str]<br class="calibre33"/>                   [walk :as walk]))<br class="calibre33"/><br class="calibre33"/>(defmacro reverse-it<br class="calibre33"/>  [form]                                            </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  (walk/postwalk #(if (symbol? %)                   </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>                    (symbol (str/reverse (name %))) </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>                    %)<br class="calibre33"/>                 form))</tt></span></p><p class="calibre23"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Our macro takes a single argument, named <tt class="calibre22">form</tt> here.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">It uses the <tt class="calibre22">postwalk</tt> function to recursively apply the given anonymous function to every element in <tt class="calibre22">form</tt>.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">That anonymous function replaces all symbols in <tt class="calibre22">form</tt> with symbols that have a reversed name, but leaves the rest of the elements in <tt class="calibre22">form</tt> untouched.</blockquote><p class="calibre13">And now we can write absurdities<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos855596"></a><a href="#filepos856769"><span class="calibre32">168</span></a><span class="calibre32">]</span></small></sup> like this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(reverse-it<br class="calibre33"/>  (qesod [gra (egnar 5)]<br class="calibre33"/>    (nltnirp (cni gra))))<br class="calibre33"/>; 1<br class="calibre33"/>; 2<br class="calibre33"/>; 3<br class="calibre33"/>; 4<br class="calibre33"/>; 5<br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre23">because after expanding the macro, Clojure sees normal, familiar code:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(macroexpand-1 '(reverse-it<br class="calibre33"/>                  (qesod [gra (egnar 5)]<br class="calibre33"/>                    (nltnirp (cni gra)))))<br class="calibre33"/>;= (doseq [arg (range 5)]<br class="calibre33"/>;=   (println (inc arg)))</tt></span></blockquote><p class="calibre23">We’re using the <tt class="calibre22">macroexpand-1</tt><a id="filepos856456"></a> function here to see what code our macro call is providing to the Clojure compiler. The <tt class="calibre22">macroexpand</tt> family of functions are key tools used in testing and debugging macros, which we’ll discuss next.</p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos856769"></a><a href="#filepos855596"><span class="calibre32">168</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">While </span><span class="calibre10"><tt class="calibre22">reverse-it</tt></span><span class="calibre10"> provides a striking demonstration of one type of possible syntactic transformation made possible by macros, actually using something like it would surely be considered evil.</span></p><div class="mbppagebreak"></div><p id="filepos857150" class="calibre6"><span class="calibre4"><span class="bold">Debugging Macros</span></span></p><p id="filepos857227" class="calibre18">Macros can be notoriously difficult to debug. Clojure helpfully catches a variety of compile-time errors, but care must be taken to use the power that macros offer without being snared by their traps.</p><p class="calibre18">Consider what happens when referring to a var that isn’t yet defined. In a function, this will trigger a compile-time error:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn oops [arg] (frobnicate arg))<br class="calibre33"/>;= #&lt;CompilerException java.lang.Exception:<br class="calibre33"/>;=   Unable to resolve symbol: frobnicate in this context (NO_SOURCE_FILE:1)&gt;</tt></span></blockquote><p class="calibre23">Sadly, we can define a similar macro without any warning:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defmacro oops [arg] `(frobnicate ~arg))<br class="calibre33"/>;= #'user/oops</tt></span></blockquote><p class="calibre23">Trying to use this macro will produce an error when it is <span class="italic">used</span>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(oops 123)<br class="calibre33"/>;= #&lt;CompilerException java.lang.IllegalStateException:<br class="calibre33"/>;=   Var user/frobnicate is unbound. (NO_SOURCE_FILE:0)&gt;</tt></span></blockquote><p class="calibre23">What happened? Remember that macros execute at <span class="italic">compile time</span>. At compile time, Clojure doesn’t (and can’t) know if the symbol <tt class="calibre22">frobnicate</tt> will refer to a var that has a defined value at runtime or not. The macro sees and returns only lists, symbols, and other data structures. Whether those symbols are valid when the code produced by the macro is executed is not for the macro to decide. This can make debugging macros tricky, but we have a couple of tools at our disposal.</p><p id="filepos858993" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Macroexpansion</span></span></span></p><p id="filepos859097" class="calibre18">The most fundamental tool in debugging macros is <tt class="calibre22">macroexpand-1</tt>.<a id="filepos859197"></a> This function takes a data structure (in debugging contexts, often a quoted macro form) and taps into the Clojure compiler to return the code—which, remember, is just a data structure—that will be executed in its place if it were to be evaluated. Here we can see that the <tt class="calibre22">oops</tt> macro invoked with an integer will return a list with two elements, the namespaced <tt class="calibre22">frobnicate</tt> symbol (referring to a nonexistent var) and the integer argument:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(macroexpand-1 '(oops 123))<br class="calibre33"/>;= (user/frobnicate 123)</tt></span></blockquote><p class="calibre23"><tt class="calibre22">macroexpand-1</tt> only expands the macro once. Remember that macroexpansion can happen many times if a macro returns code that itself contains macro calls; if your macro produces another macro call, and you want to continue expanding until the top level form is no longer a macro, use <tt class="calibre22">macroexpand</tt> instead.</p><p class="calibre18">Because so many core facilities in Clojure are themselves macros, <tt class="calibre22">macroexpand-1</tt> is often quite helpful in avoiding a verbose and unclear macro expansion. Going back to the <tt class="calibre22">reverse-it</tt> macro that we defined in <a href="#filepos853676"><span class="calibre5">Example 5-1</span></a>, we can readily see the difference between <tt class="calibre22">macroexpand-1</tt> and <tt class="calibre22">macroexpand</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(macroexpand-1 '(reverse-it<br class="calibre33"/>                  (qesod [gra (egnar 5)]<br class="calibre33"/>                    (nltnirp (cni gra)))))<br class="calibre33"/>;= (doseq [arg (range 5)]<br class="calibre33"/>;=   (println (inc arg)))<br class="calibre33"/><br class="calibre33"/>(pprint (macroexpand '(reverse-it<br class="calibre33"/>                        (qesod [gra (egnar 5)]<br class="calibre33"/>                          (nltnirp (cni gra))))))<br class="calibre33"/>; (loop*<br class="calibre33"/>;  [seq_1647<br class="calibre33"/>;   (clojure.core/seq (range 5))<br class="calibre33"/>;   chunk_1648<br class="calibre33"/>;   nil<br class="calibre33"/>;   count_1649<br class="calibre33"/>;   (clojure.core/int 0)<br class="calibre33"/>;   i_1650<br class="calibre33"/>;   (clojure.core/int 0)]<br class="calibre33"/>;  (if<br class="calibre33"/>;   (clojure.core/&lt; i_1650 count_1649)<br class="calibre33"/>;   (clojure.core/let<br class="calibre33"/>;    [arg (.nth chunk_1648 i_1650)]<br class="calibre33"/>;    (do (println (inc arg)))<br class="calibre33"/>;    (recur<br class="calibre33"/>;     seq_1647<br class="calibre33"/>;     chunk_1648<br class="calibre33"/>;     count_1649<br class="calibre33"/>;     (clojure.core/unchecked-inc i_1650)))<br class="calibre33"/>;   (clojure.core/when-let<br class="calibre33"/>;    [seq_1647 (clojure.core/seq seq_1647)]<br class="calibre33"/>;    (if<br class="calibre33"/>;     (clojure.core/chunked-seq? seq_1647)<br class="calibre33"/>;     (clojure.core/let<br class="calibre33"/>;      [c__3798__auto__ (clojure.core/chunk-first seq_1647)]<br class="calibre33"/>;      (recur<br class="calibre33"/>;       (clojure.core/chunk-rest seq_1647)<br class="calibre33"/>;       c__3798__auto__<br class="calibre33"/>;       (clojure.core/int (clojure.core/count c__3798__auto__))<br class="calibre33"/>;       (clojure.core/int 0)))<br class="calibre33"/>;     (clojure.core/let<br class="calibre33"/>;      [arg (clojure.core/first seq_1647)]<br class="calibre33"/>;      (do (println (inc arg)))<br class="calibre33"/>;      (recur<br class="calibre33"/>;       (clojure.core/next seq_1647)<br class="calibre33"/>;       nil<br class="calibre33"/>;       (clojure.core/int 0)<br class="calibre33"/>;       (clojure.core/int 0)))))))</tt></span></blockquote><p class="calibre23"><tt class="calibre22">reverse-it</tt> returns a <tt class="calibre22">doseq</tt> form, itself a macro that is based upon the <tt class="calibre22">loop</tt> special form, whose full macroexpansion is lengthy. In most cases, you will find that you only need to see the “top level” expansion of a macro, making <tt class="calibre22">macroexpand-1</tt> far preferable.</p><p class="calibre18"><span class="bold">Completely expanding macros</span>. Neither <tt class="calibre22">macroexpand</tt> nor <tt class="calibre22">macroexpand-1</tt> expand nested forms.<a id="filepos863117"></a> For example, here we attempt to macroexpand a <tt class="calibre22">cond</tt> form, which emits an <tt class="calibre22">if</tt> call, with the “else” branch itself consisting of a <tt class="calibre22">cond</tt> form that will remain unexpanded:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(macroexpand '(cond a b c d))<br class="calibre33"/>;= (if a b (clojure.core/cond c d))</tt></span></blockquote><p class="calibre23">Being able to obtain the complete expansion of a macro can be very helpful. In many cases, the <tt class="calibre22">clojure.walk/macroexpand-all</tt> function fills that need:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(require '[clojure.walk :as w])<br class="calibre33"/><br class="calibre33"/>(w/macroexpand-all '(cond a b c d))<br class="calibre33"/>;= (if a b (if c d nil))</tt></span></blockquote><p class="calibre23"><tt class="calibre22">macroexpand-all</tt><a id="filepos863945"></a> is useful, but it is fundamentally a simple hack that only partially emulates the full macroexpansion performed by the compiler. For example, it does not handle special forms precisely right:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(w/macroexpand-all ''(when x a))<br class="calibre33"/>;= (quote (if x (do a)))</tt></span></blockquote><p class="calibre23">That expression should expand into <tt class="calibre22">(quote (when x a))</tt>—macroexpansion shouldn’t progress past the <tt class="calibre22">quote</tt> special form. Similarly, <tt class="calibre22">macroexpand-all</tt> does not support the implicit <tt class="calibre22">&amp;env</tt> and <tt class="calibre22">&amp;form</tt> arguments, which we discuss in full in <a href="#filepos905889"><span class="calibre5">The Implicit Arguments: &amp;env and &amp;form</span></a>, along with an improved <tt class="calibre22">macroexpand</tt> variant that can support those implicit arguments.</p><div class="mbppagebreak"></div><p id="filepos864832" class="calibre6"><span class="calibre4"><span class="bold">Syntax</span></span></p><p id="filepos864899" class="calibre18">Since macros return Clojure data structures, we will often want to return lists to represent further calls, either of functions, special forms, or other macros. Therefore, we need tools to build these lists. It’s perfectly acceptable to use the simplest tool in our toolbox, the <tt class="calibre22">list</tt><a id="filepos865221"></a> function:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defmacro hello<br class="calibre33"/>  [name]<br class="calibre33"/>  (list 'println name))<br class="calibre33"/><br class="calibre33"/>(macroexpand '(hello "Brian"))<br class="calibre33"/>;= (println "Brian")</tt></span></blockquote><p class="calibre23">However, for more complex macros that return something more than a simple flat list, this quickly becomes unwieldy. This is how the source code for the standard macro <tt class="calibre22">while</tt> would look, written in this manner:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defmacro while<br class="calibre33"/>  [test &amp; body]<br class="calibre33"/>  (list 'loop []<br class="calibre33"/>    (concat (list 'when test) body)<br class="calibre33"/>      '(recur)))</tt></span></blockquote><p class="calibre23">The gist of this macro is lost in all the calls to <tt class="calibre22">list</tt> and <tt class="calibre22">concat</tt>.</p><p class="calibre18">Therefore, Clojure offers some syntactic sugar for working with lists and interpolating named values into them. Using this sugar, the <tt class="calibre22">while</tt> macro<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos866299"></a><a href="#filepos875100"><span class="calibre32">169</span></a><span class="calibre32">]</span></small></sup> is much more readable:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defmacro while<br class="calibre33"/>  [test &amp; body]<br class="calibre33"/>  `(loop []<br class="calibre33"/>     (when ~test<br class="calibre33"/>       ~@body<br class="calibre33"/>       (recur))))</tt></span></blockquote><p class="calibre23">This macro uses three tools: <tt class="calibre22">syntax-quote</tt>,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos866780"></a><a href="#filepos875357"><span class="calibre32">170</span></a><span class="calibre32">]</span></small></sup><tt class="calibre22">unquote</tt>, and <tt class="calibre22">splicing-unquote</tt>. This syntax is not intrinsic to macros. You can use it in functions or other code as well, but because macros deal so heavily with lists, macros are the place you’ll use these the most.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos867147"></a><a href="#filepos875721"><span class="calibre32">171</span></a><span class="calibre32">]</span></small></sup></p><p id="filepos867246" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">quote Versus syntax-quote</span></span></span></p><p id="filepos867361" class="calibre18">You should be familiar with the <tt class="calibre22">quote</tt> special form already, which returns its arguments unevaluated. As a shortcut, we can write <tt class="calibre22">(quote (a b))</tt> as <tt class="calibre22">'(a b)</tt>, both of which evaluate to a list with two elements, the symbols <tt class="calibre22">a</tt> and <tt class="calibre22">b</tt>.</p><p class="calibre18">Clojure contains another form of quoting. <span class="italic">Syntax-quoting</span><a id="filepos867755"></a> looks similar to quoting, except it uses a backtick (<tt class="calibre22">`</tt>) instead.</p><p class="calibre18">There are two differences between <tt class="calibre22">quote</tt> and <tt class="calibre22">syntax-quote</tt>. First, the latter fully qualifies unqualified symbols with the current namespace:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def foo 123)<br class="calibre33"/>;= #'user/foo<br class="calibre33"/>[foo (quote foo) 'foo `foo]<br class="calibre33"/>;= [123 foo foo user/foo]</tt></span></blockquote><p class="calibre23">The syntax-quoted <tt class="calibre22">`foo</tt> (the last “foo” in the vector) results in the namespaced symbol <tt class="calibre22">user/foo</tt> because it was evaluated in the <tt class="calibre22">user</tt> namespace. In another namespace, <tt class="calibre22">`foo</tt> will be read as a symbol qualified to that other namespace.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(in-ns 'bar)<br class="calibre33"/><br class="calibre33"/>`foo<br class="calibre33"/>;= bar/foo</tt></span></blockquote><p class="calibre23">However, if the symbol is namespace-aliased or is known to refer to a var from another namespace, syntax-quote qualifies it with the corresponding namespace.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(ns baz (:require [user :as u]))<br class="calibre33"/><br class="calibre33"/>`map<br class="calibre33"/>;= clojure.core/map<br class="calibre33"/>`u/foo<br class="calibre33"/>;= user/foo<br class="calibre33"/>`foo<br class="calibre33"/>;= baz/foo</tt></span></blockquote><p class="calibre23">This default qualification of symbols is critical for ensuring that a macro does not produce code that inadvertently refers to or redefines an already-named value within the context where it is used. This is called macro <span class="italic">hygiene</span>, and is discussed in <a href="#filepos881435"><span class="calibre5">Hygiene</span></a>.</p><p class="calibre18">The second difference between quoting and syntax-quoting is that syntax-quoting allows <span class="italic">unquoting</span>: some elements of the list can be selectively <span class="italic">unquoted</span>, causing them to be evaluated within the scope of the syntax-quoted form.</p><p id="filepos869714" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">unquote and unquote-splicing</span></span></span></p><p id="filepos869832" class="calibre18">When building a skeleton of source code in a macro, it’s common to create lists where some elements need to be evaluated and some should not. One way of doing this—painful if it were your only option—is to use <tt class="calibre22">list</tt><a id="filepos870089"></a> and individually syntax-quote each element in the list that needs to be quoted, leaving the others unquoted.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(list `map `println [foo])<br class="calibre33"/>;= (clojure.core/map clojure.core/println [123])</tt></span></blockquote><p class="calibre23">A shorter and more readable option is to syntax-quote the entire list, and then <span class="italic">unquote</span> only those elements you would like to have evaluated in-place. This is done via <tt class="calibre22">~</tt>.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">`(map println [~foo])<br class="calibre33"/>;= (clojure.core/map clojure.core/println [123])<br class="calibre33"/><br class="calibre33"/>`(map println ~[foo])<br class="calibre33"/>;= (clojure.core/map clojure.core/println [123])</tt></span></blockquote><p class="calibre23">Note that compared to the explicit <tt class="calibre22">list</tt> version, the syntax-quoted form looks identical to how we’d write the form unquoted, with additional <tt class="calibre22">`</tt> and <tt class="calibre22">~</tt> added.</p><p class="calibre18">Note also the second example: unquoting a list or vector unquotes the entire form. This can be used to evaluate function calls inside syntax-quoted forms:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">`(println ~(keyword (str foo)))<br class="calibre33"/>;= (clojure.core/println :123)</tt></span></blockquote><p class="calibre23">Another common case is starting with a list of forms and unpacking the <span class="italic">contents</span> of another list into the first. Again, the most straightforward version using <tt class="calibre22">list</tt> and <tt class="calibre22">concat</tt><a id="filepos871646"></a> is pretty awkward:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [defs '((def x 123)<br class="calibre33"/>             (def y 456))]<br class="calibre33"/>  (concat (list 'do) defs))<br class="calibre33"/>;= (do (def x 123) (def y 456))</tt></span></blockquote><p class="calibre23">The <tt class="calibre22">unquote-splicing</tt> operator <a id="filepos871990"></a><tt class="calibre22">~@</tt><a id="filepos872008"></a> is a better option, and does the concatenation for you.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [defs '((def x 123)<br class="calibre33"/>             (def y 456))]<br class="calibre33"/>  `(do ~@defs))<br class="calibre33"/>;= (do (def x 123) (def y 456))</tt></span></blockquote><p class="calibre23">Here the elements within the list <tt class="calibre22">defs</tt> are spliced into the surrounding <tt class="calibre22">syntax-quote</tt>d list.<a id="filepos872445"></a> This is a very common idiom in writing macros. For example, a macro that accepts multiple forms as a “code body” will often look like this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defmacro foo<br class="calibre33"/>  [&amp; body]<br class="calibre33"/>  `(do-something ~@body))<br class="calibre33"/><br class="calibre33"/>(macroexpand-1 '(foo (doseq [x (range 5)]<br class="calibre33"/>                       (println x))<br class="calibre33"/>                     :done))<br class="calibre33"/>;= (user/do-something<br class="calibre33"/>;=   (doseq [x (range 5)]<br class="calibre33"/>;=     (println x))<br class="calibre33"/>;=   :done)</tt></span></blockquote><p class="calibre23">The rest argument <tt class="calibre22">body</tt> holds a sequential collection of the parameters to the macro, and then <tt class="calibre22">~@body</tt> in the macro unpacks that list into the surrounding context.</p><p class="calibre18"><tt class="calibre22">syntax-quote</tt> combined with <tt class="calibre22">unquote</tt> and <tt class="calibre22">unquote-splicing</tt> allow you to treat Clojure data structures—and therefore Clojure code that you may return from macros—as templates: you can form a skeleton of a form with <tt class="calibre22">syntax-quote</tt>, and then selectively fill in key parameterized parts of that skeleton with values and evaluated expressions thanks to the <tt class="calibre22">unquote</tt> syntaxes.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10"><tt class="calibre22">syntax-quote</tt></span><span class="calibre10">, </span><span class="calibre10"><tt class="calibre22">unquote</tt></span><span class="calibre10">, and </span><span class="calibre10"><tt class="calibre22">unquote-splicing</tt></span><span class="calibre10"> aren’t magic: they are functions in Clojure’s standard library that are swapped in by the reader in place of their various syntaxes, </span><span class="calibre10"><tt class="calibre22">`</tt></span><span class="calibre10">, </span><span class="calibre10"><tt class="calibre22">~</tt></span><span class="calibre10">, and </span><span class="calibre10"><tt class="calibre22">~@</tt></span><span class="calibre10">. You can take a look at what is going under the hood by quoting a </span><span class="calibre10"><tt class="calibre22">syntax-quote</tt></span><span class="calibre10">d expression to suppress </span><span class="calibre10"><span class="italic">its</span></span><span class="calibre10"> evaluation:</span><a id="filepos874628"></a></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">'`(map println ~[foo])<br class="calibre33"/>;= (clojure.core/seq<br class="calibre33"/>;=   (clojure.core/concat<br class="calibre33"/>;=     (clojure.core/list (quote clojure.core/map))<br class="calibre33"/>;=     (clojure.core/list (quote clojure.core/println))<br class="calibre33"/>;=     (clojure.core/list [foo])))</tt></span></blockquote><br class="calibre33"/><hr class="calibre34"/><p class="calibre25"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos875100"></a><a href="#filepos866299"><span class="calibre32">169</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Shown here exactly as it is implemented in Clojure’s standard library.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos875357"></a><a href="#filepos866780"><span class="calibre32">170</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Similar facilities are called “backquote” or “quasi-quote” in other Lisps. The term “syntax-quote” was coined by Rich Hickey to distinguish it from those alternatives.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos875721"></a><a href="#filepos867147"><span class="calibre32">171</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">For example, we use </span><span class="calibre10"><tt class="calibre22">syntax-quote</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">unquote</tt></span><span class="calibre10"> outside of the scope of a macro in </span><a href="#filepos935751"><span class="calibre10"><span class="calibre5">In Detail: -&gt; and -&gt;&gt;</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos876175" class="calibre6"><span class="calibre4"><span class="bold">When to Use Macros</span></span></p><p id="filepos876254" class="calibre18">Macros are clearly a powerful tool, but with that power inevitably comes responsibility—and a list of caveats.</p><p class="calibre18">Macros operate at compile time. This means they are not first-class citizens of a running Clojure program like functions are. A macro has no access to runtime information, such as the current runtime values of a var. A macro sees only unevaluated data structures read from source code.</p><p class="calibre18">Consider a simple function that returns a greeting. It’s possible to write this as either a function or a macro:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn fn-hello [x]<br class="calibre33"/>  (str "Hello, " x "!"))<br class="calibre33"/><br class="calibre33"/>(defmacro macro-hello [x]<br class="calibre33"/>  `(str "Hello, " ~x "!"))</tt></span></blockquote><p class="calibre23">These appear to behave similarly in some usages:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(fn-hello "Brian")<br class="calibre33"/>;= "Hello, Brian!"<br class="calibre33"/>(macro-hello "Brian")<br class="calibre33"/>;= "Hello, Brian!"</tt></span></blockquote><p class="calibre23">But they behave very differently in different contexts:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(map fn-hello ["Brian" "Not Brian"])<br class="calibre33"/>;= ("Hello, Brian!" "Hello, Not Brian!")<br class="calibre33"/>(map macro-hello ["Brian" "Not Brian"])<br class="calibre33"/>;= #&lt;CompilerException java.lang.RuntimeException:<br class="calibre33"/>;=   Can't take value of a macro: #'user/macro-hello, compiling:(NO_SOURCE_PATH:1)&gt;</tt></span></blockquote><p class="calibre23">This latter usage of <tt class="calibre22">macro-hello</tt> breaks because we are attempting to apply the macro’s value at runtime. They functionally don’t exist at runtime,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos878061"></a><a href="#filepos880976"><span class="calibre32">172</span></a><span class="calibre32">]</span></small></sup> they can’t be composed or passed as values, and therefore it makes no sense to <tt class="calibre22">map</tt> a macro across a collection of values as we attempted to do above.</p><p class="calibre18">To use macros in such contexts, we would need to wrap their usage in an enclosing <tt class="calibre22">fn</tt> or anonymous function literal. This brings the macro’s application back to compile time, when the enclosing function is compiled. This will generally lead to some awkward situations where passing a function value would be far simpler and idiomatic:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(map #(macro-hello %) ["Brian" "Not Brian"])<br class="calibre33"/>;= ("Hello, Brian!" "Hello, Not Brian!")</tt></span></blockquote><p class="calibre23">An alternative to awkward wrapping in <tt class="calibre22">fn</tt> or <tt class="calibre22">#(...)</tt> would be to try to maintain clean-looking code by introducing another macro that would be a wrapper for <tt class="calibre22">map</tt>. This is a rabbit-hole though, as macros encourage more macros: the more macros you write, the more macros you need to solve the issue of their being unavailable at runtime, and therefore not suitable for use in many functional programming idioms that call for passing higher-order functions around.</p><p class="calibre18">There are two lessons here, one minor and one more substantial. First, a macro is convenient or powerful in one context (compilation), but can make life difficult in another (runtime); consider splitting the core functionality out of your macro’s implementation and keeping it in its own function. The macro can simply delegate to it at compile time, but if you need to leverage its capabilities in a setting that benefits from a simple function, that route is readily available to you.</p><p class="calibre18">Second, and more important, <span class="italic">macros should be used only when you need your own language constructs</span>; it follows that they shouldn’t be used where a function can be as effective. Macros are our only solution if we need:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Special evaluation semantics</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Customized syntax for frequent patterns or domain-specific notation</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">To gain ground by precomputing intermediate data at compile time</blockquote></li></ul><p class="calibre18">On the other hand, we should also always ask ourselves whether there’s a function-based (that is, not requiring special evaluation rules and therefore macros) way to achieve the same goal.</p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos880976"></a><a href="#filepos878061"><span class="calibre32">172</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">This isn’t entirely true, as we show in </span><a href="#filepos910571"><span class="calibre10"><span class="calibre5">“Testing and debugging &amp;env usage”</span></span></a><span class="calibre10">…but as you’ll see there, using macros at runtime is messy, an unsupported implementation detail, and generally not worth the trouble.</span></p><div class="mbppagebreak"></div><p id="filepos881435" class="calibre6"><span class="calibre4"><span class="bold">Hygiene</span></span></p><p id="filepos881503" class="calibre18">Traditionally, one of the biggest potential problems in writing macros is generating code that interacts with other code improperly. Clojure has safeguards in place that other Lisps lack, but there is still potential for error.</p><p class="calibre18">Code generated by a macro will often be embedded in other code, and often will have user-defined code embedded within it. In either case, some set of symbols is likely already bound to values by the user of the macro. It’s possible for a macro to set up its own bindings that collide with those of the outer or inner context of the macro-users code, which can create bugs that are very difficult to identify. Macros that avoid these sorts of issues are called <span class="italic">hygienic macros</span><a id="filepos882274"></a>.</p><p class="calibre18">Consider a macro with an implementation that requires a let-bound value. The name we choose is irrelevant to the user of our macro and should be invisible to him, but we do have to choose <span class="italic">some</span> name. Naively, we might try <tt class="calibre22">x</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defmacro unhygienic<br class="calibre33"/>      [&amp; body]<br class="calibre33"/>      `(let [x :oops]<br class="calibre33"/>         ~@body))<br class="calibre33"/>;= #'user/unhygenic<br class="calibre33"/>(unhygienic (println "x:" x))<br class="calibre33"/>;= #&lt;CompilerException java.lang.RuntimeException:<br class="calibre33"/>;=   Can't let qualified name: user/x, compiling:(NO_SOURCE_PATH:1)&gt;</tt></span></blockquote><p class="calibre23">Clojure is smart enough not to let this code compile. As we explored in <a href="#filepos867246"><span class="calibre5">quote Versus syntax-quote</span></a>, all bare symbols are namespace-qualified within a <tt class="calibre22">syntax-quote</tt>d form. We can see the impact in this case if we check the expansion of our macro:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(macroexpand-1 `(unhygienic (println "x:" x)))<br class="calibre33"/>;= (clojure.core/let [user/x :oops]<br class="calibre33"/>;=   (clojure.core/println "x:" user/x))</tt></span></blockquote><p class="calibre23">References to <tt class="calibre22">x</tt> are expanded to <tt class="calibre22">user/x</tt>, but <tt class="calibre22">let</tt> requires that names for new bindings be unqualified symbols, so this macro will always yield code that emits a compilation error. We could improperly “avoid” this problem via some clever quoting and unquoting:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defmacro still-unhygienic<br class="calibre33"/>  [&amp; body]<br class="calibre33"/>  `(let [~'x :oops]                 </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>     ~@body))<br class="calibre33"/>;= #'user/still-unhygenic<br class="calibre33"/>(still-unhygienic (println "x:" x))<br class="calibre33"/>; x: :oops<br class="calibre33"/>;= nil<br class="calibre33"/>(macroexpand-1 '(still-unhygienic<br class="calibre33"/>                  (println "x:" x)))<br class="calibre33"/>;= (clojure.core/let [x :oops]<br class="calibre33"/>;=   (println "x:" x))</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">~'x</tt> is using unquote (<tt class="calibre22">~</tt>) to force the use of the specified explicitly namespace-unqualified symbol <tt class="calibre22">x</tt> as the name of the <tt class="calibre22">let</tt>-bound value.</blockquote><p class="calibre18">This will at least run, but we’ve introduced a major bug into our code. The problem is that the name <tt class="calibre22">x</tt>, which our macro is defining within a local scope, may collide with local bindings either outside or inside of the code emitted by the macro. Consider a simple breaking usage of this macro:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [x :this-is-important]<br class="calibre33"/>  (still-unhygienic<br class="calibre33"/>    (println "x:" x)))<br class="calibre33"/>; x: :oops</tt></span></blockquote><p class="calibre23">Here we’re already using the name <tt class="calibre22">x</tt> for another local value, but the <tt class="calibre22">let</tt> form emitted by the macro silently clobbers <tt class="calibre22">x</tt> with its own value within that scope. A user of this macro might never know this is happening without reading its source code.</p><p class="calibre18">Thankfully, Clojure provides a simple mechanism for avoiding naming collisions like this in code emitted by macros, and it involves less work than the improper “solution” previously.</p><p id="filepos885897" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Gensyms to the Rescue</span></span></span></p><p id="filepos886008" class="calibre18">When setting up a binding in a macro, we’d like to dynamically generate a name that will never collide with a name outside the macro’s scope or inside of bodies of code provided as arguments to our macro. Fortunately, Clojure has a mechanism and a simple syntax for generating such names: <span class="italic">gensyms</span>. The <tt class="calibre22">gensym</tt> function returns a symbol that is guaranteed to be unique. Every time it’s called, it returns a new symbol.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(gensym)<br class="calibre33"/>;= G__2386<br class="calibre33"/>(gensym)<br class="calibre33"/>;= G__2391</tt></span></blockquote><p class="calibre23"><tt class="calibre22">gensym</tt> also accepts an argument: a string used as a prefix of the generated symbol.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(gensym "sym")<br class="calibre33"/>;= sym2396<br class="calibre33"/>(gensym "sym")<br class="calibre33"/>;= sym2402</tt></span></blockquote><p class="calibre23">You can use <tt class="calibre22">gensym</tt> whenever you like if you need a unique symbol, but its primary role is in helping us write hygienic macros:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defmacro hygienic<br class="calibre33"/>  [&amp; body]<br class="calibre33"/>  (let [sym (gensym)]          </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>    `(let [~sym :macro-value]  </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>       ~@body)))<br class="calibre33"/>;= #'user/hygienic<br class="calibre33"/>(let [x :important-value]<br class="calibre33"/>  (hygienic (println "x:" x)))<br class="calibre33"/>; x: :important-value<br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Now instead of the macro specifying the name to use for the new local binding, it takes a guaranteed-unique symbol from <tt class="calibre22">gensym</tt>…</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">…and uses <tt class="calibre22">syntax-unquote</tt> to place it in the code form returned from the macro.</blockquote><p class="calibre18">Now our code is safe. The choice of <tt class="calibre22">x</tt> for <span class="italic">our</span> local binding has no chance of colliding with the macro-generated local binding that is using the <tt class="calibre22">gensym</tt>-generated name.</p><p class="calibre18">Gensyms in macros are common enough that there is a shorthand way of using them. Any symbol ending in <tt class="calibre22">#</tt> inside a <tt class="calibre22">syntax-quote</tt> form will be expanded automatically into a gensym, and will expand to the same gensym every time it appears. This is called an <span class="italic">auto-gensym</span><a id="filepos888772"></a>, and the following code is equivalent to the previous definition of <tt class="calibre22">hygienic</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defmacro hygienic<br class="calibre33"/>  [&amp; body]<br class="calibre33"/>  `(let [x# :macro-value]<br class="calibre33"/>     ~@body))</tt></span></blockquote><p class="calibre23"><tt class="calibre22">x#</tt> in the syntax-quoted form will be transformed into something like <tt class="calibre22">x__3507__auto__</tt> in the expanded macro.</p><p class="calibre18">Inside a single syntax-quoted form, all occurrences of a given gensym expand to the same actual symbol:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">`(x# x#)<br class="calibre33"/>;= (x__1447__auto__ x__1447__auto__)</tt></span></blockquote><p class="calibre23">This allows the same syntax-quoted form to contain multiple usages of the same gensym, identified by an easily recognizable name within the macro’s source code.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defmacro auto-gensyms<br class="calibre33"/>  [&amp; numbers]<br class="calibre33"/>  `(let [x# (rand-int 10)]                                  </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>     (+ x# ~@numbers)))                                     </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #'user/auto-gensyms<br class="calibre33"/>(auto-gensyms 1 2 3 4 5)<br class="calibre33"/>;= 22<br class="calibre33"/>(macroexpand-1 '(auto-gensyms 1 2 3 4 5))                   </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= (clojure.core/let [x__570__auto__ (clojure.core/rand-int 10)]<br class="calibre33"/>;=   (clojure.core/+ x__570__auto__ 1 2 3 4 5))</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">We use an auto-gensym <tt class="calibre22">x#</tt> to establish a local binding within the body of code provided by the macro.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">We refer to that gensymed local binding by the same <tt class="calibre22">x#</tt> name.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">Macroexpanding our usage of the macro shows that each usage of the auto-gensym has been replaced with a unique symbol, guaranteed to not clash with any of our other named bindings.</blockquote><p class="calibre18">However, you need to keep in mind that auto-gensyms are only the same within the same syntax-quoted form:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">[`x# `x#]<br class="calibre33"/>;= [x__1450__auto__ x__1451__auto__]</tt></span></blockquote><p class="calibre23">This means that code such as this reimplementation of <tt class="calibre22">doto</tt>, which tries to use the same auto-gensym in multiple syntax-quoted forms:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defmacro our-doto [expr &amp; forms]<br class="calibre33"/>  `(let [obj# ~expr]                     </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>     ~@(map (fn [[f &amp; args]]<br class="calibre33"/>              `(~f obj# ~@args)) forms)  </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>     obj#))</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Usage #1 of <tt class="calibre22">obj#</tt>, in one syntax-quoted form.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">Usage #2 of <tt class="calibre22">obj#</tt>, in another syntax-quoted form, this one within the unquote-splicing form. These will yield two different gensyms, though we are intending to refer to the same let-bound value in each.</blockquote><p class="calibre18">is going to fail:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(our-doto "It works"<br class="calibre33"/>  (println "I can't believe it"))<br class="calibre33"/>;= #&lt;CompilerException java.lang.RuntimeException:<br class="calibre33"/>;=   Unable to resolve symbol: obj__1456__auto__ in this context,<br class="calibre33"/>;=   compiling:(NO_SOURCE_PATH:1)&gt;</tt></span></blockquote><p class="calibre23">because the two <tt class="calibre22">obj#</tt> auto-gensyms are within the scope of two different syntax-quote forms. In a case like this, we’ll need to resort to using <tt class="calibre22">gensym</tt> manually again:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defmacro our-doto [expr &amp; forms]<br class="calibre33"/>  (let [obj (gensym "obj")]<br class="calibre33"/>    `(let [~obj ~expr]<br class="calibre33"/>       ~@(map (fn [[f &amp; args]]<br class="calibre33"/>                `(~f ~obj ~@args)) forms) </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>       ~obj)))</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">At this point this syntax quote is pretty useless and should be replaced by <tt class="calibre22">(list* f obj args)</tt>.</blockquote><p class="calibre18">And now it works:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(our-doto "It works"<br class="calibre33"/>  (println "I can't believe it")<br class="calibre33"/>  (println "I still can't believe it"))<br class="calibre33"/>; It works I can't believe it<br class="calibre33"/>; It works I still can't believe it<br class="calibre33"/>;= "It works"</tt></span></blockquote><p id="filepos894757" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Letting the User Pick Names</span></span></span></p><p id="filepos894874" class="calibre18">If your macro needs to set up a binding that <span class="italic">is</span> visible to the caller of the macro, we still need to pick a name for this binding, and we still need to worry about hygiene.</p><p class="calibre18">We could choose a name and document the macro as always using this name. This is rarely a good idea, but it does happen. If your macro expands to code that interacts with Java, for example, you could document the macro as always setting up a binding for the symbol <tt class="calibre22">this</tt>.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos895427"></a><a href="#filepos899878"><span class="calibre32">173</span></a><span class="calibre32">]</span></small></sup> A macro that deliberately “leaks” a name in this way is said to be <span class="italic">anaphoric</span>,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos895646"></a><a href="#filepos900511"><span class="calibre32">174</span></a><span class="calibre32">]</span></small></sup> a characteristic that is generally avoided, since users of such macros must consistently remember which symbols <a id="filepos895854"></a>are implicitly used to name locals within their scope.</p><p class="calibre18">An easier and generally far saner thing to do is let the user select the symbol(s) to use for bindings. Because macros don’t evaluate their arguments, it’s easy for the user to pass a symbol to the macro, which can be used within the generated code:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defmacro with<br class="calibre33"/>  [name &amp; body]<br class="calibre33"/>  `(let [~name 5]<br class="calibre33"/>     ~@body))<br class="calibre33"/>;= #'user/with<br class="calibre33"/>(with bar (+ 10 bar))<br class="calibre33"/>;= 15<br class="calibre33"/>(with foo (+ 40 foo))<br class="calibre33"/>;= 45</tt></span></blockquote><p id="filepos896511" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Double Evaluation</span></span></span></p><p id="filepos896618" class="calibre18">A common and insidious problem with macros is known as <span class="italic">double evaluation</span>. It is insidious because we likely won’t spot the problem in many cases. Double evaluation arises when an argument to the macro appears twice (or more) in the expansion. Consider the <tt class="calibre22">spy</tt> macro:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defmacro spy [x]<br class="calibre33"/>  `(do<br class="calibre33"/>     (println "spied" '~x ~x)<br class="calibre33"/>     ~x))</tt></span></blockquote><p class="calibre23">This macro prints the value of the provided expression and returns it. It will behave as we expect as long as <tt class="calibre22">x</tt> yields a constant value. But as soon as <tt class="calibre22">x</tt> becomes computationally expensive and/or relies on side effects, we’ll get surprising results:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(spy 2)<br class="calibre33"/>; spied 2 2<br class="calibre33"/>;= 2<br class="calibre33"/>(spy (rand-int 10))<br class="calibre33"/>; spied (rand-int 10) 9<br class="calibre33"/>;= 7</tt></span></blockquote><p class="calibre23">In the first case everything works fine because <tt class="calibre22">2</tt> is a constant value. In the second case, <tt class="calibre22">(rand-int 10)</tt> is called twice within the code emitted by the macro, yielding different results each time. This behavior is obvious if you look at the macro expansion:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(macroexpand-1 '(spy (rand-int 10)))<br class="calibre33"/>;= (do (println (rand-int 10))<br class="calibre33"/>;=   (rand-int 10))</tt></span></blockquote><p class="calibre23">This would be a <span class="italic">serious</span> issue if we were using a <tt class="calibre22">launch-missiles</tt> function here instead of the more innocuous <tt class="calibre22">rand-int</tt>. To avoid this problem, the rule is to always introduce a local (generally an auto-gensym) when a macro argument appears more than once in the expansion:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos898487"></a><a href="#filepos900858"><span class="calibre32">175</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defmacro spy [x]<br class="calibre33"/>  `(let [x# ~x]<br class="calibre33"/>     (println "spied" '~x x#)<br class="calibre33"/>     x#))<br class="calibre33"/><br class="calibre33"/>(macroexpand-1 '(spy (rand-int 10)))<br class="calibre33"/>;= (let [x__725__auto__ (rand-int 10)]<br class="calibre33"/>;=   (println x__725__auto__ '(rand-int 10))<br class="calibre33"/>;=   x__725__auto__)</tt></span></blockquote><p class="calibre23">This will ensure that the provided expression is never evaluated more than once:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(spy (rand-int 10))<br class="calibre33"/>; spied (rand-int 10) 9<br class="calibre33"/>;= 9</tt></span></blockquote><p class="calibre23">Double-evaluation, even when worked around, is a <span class="italic">code smell</span> that may hint to your macro expansion doing some work that could be extracted into a function.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn spy-helper [expr value]<br class="calibre33"/>  (println expr value)<br class="calibre33"/>  value)<br class="calibre33"/><br class="calibre33"/>(defmacro spy [x]<br class="calibre33"/>  `(spy-helper '~x ~x))</tt></span></blockquote><p class="calibre23">In this case, there’s no need to introduce the auto-gensym local.<a id="filepos899774"></a></p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos899878"></a><a href="#filepos895427"><span class="calibre32">173</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">This is the case for </span><span class="calibre10"><tt class="calibre22">proxy</tt></span><span class="calibre10">, and it’s a rare exception to the rule that in Clojure names are always picked by the user. Another exception is the </span><span class="calibre10"><tt class="calibre22">defmacro</tt></span><span class="calibre10"> macro itself! See the discussion of </span><span class="calibre10"><tt class="calibre22">&amp;env</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">&amp;form</tt></span><span class="calibre10"> later in this chapter.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos900511"></a><a href="#filepos895646"><span class="calibre32">174</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="#filepos1811316"><span class="calibre10"><span class="calibre5">Removing Boilerplate</span></span></a><span class="calibre10"> for some examples of anaphoric macros.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos900858"></a><a href="#filepos898487"><span class="calibre32">175</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">To be more precise, when a macro argument appears more than once in a code branch.</span></p><div class="mbppagebreak"></div><p id="filepos901078" class="calibre6"><span class="calibre4"><span class="bold">Common Macro Idioms and Patterns</span></span></p><p id="filepos901171" class="calibre18">Talking about <span class="italic">macro patterns</span> might seem oxymoronic, since macros themselves should eliminate the last remaining patterns.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos901362"></a><a href="#filepos905706"><span class="calibre32">176</span></a><span class="calibre32">]</span></small></sup> Rather than proscribe boilerplate here, let’s put the focus on some style points that will help your macros be more Clojure-idiomatic.</p><p class="calibre18"><span class="bold">Require that new local bindings be specified in a vector</span>. <a id="filepos901692"></a>When a macro is to introduce a new local scope with bound names, it should expect to receive those names along with their initializers in a vector, often as the first argument to the macro. This helps to match the idiom established by core forms and macros in Clojure, including <tt class="calibre22">let</tt>, <tt class="calibre22">if-let</tt>, <tt class="calibre22">for</tt>, <tt class="calibre22">with-open</tt>, and so on:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [a 42<br class="calibre33"/>      b "abc"]<br class="calibre33"/>  ...)<br class="calibre33"/><br class="calibre33"/>(if-let [x (test)]<br class="calibre33"/>  then<br class="calibre33"/>  else)<br class="calibre33"/><br class="calibre33"/>(with-open [in (input-stream ...)<br class="calibre33"/>            out (output-stream ...)]<br class="calibre33"/>  ...)<br class="calibre33"/><br class="calibre33"/>(for [x (range 10)<br class="calibre33"/>      y (range x)]<br class="calibre33"/>  [x y])</tt></span></blockquote><p class="calibre23"><tt class="calibre22">for</tt> is an interesting example because the initializing expressions are not the values that are going to be set in the local names: <tt class="calibre22">x</tt> is not going to hold the value of <tt class="calibre22">(range 10)</tt> but successively all the values of <tt class="calibre22">(range 10)</tt>. Thus you should always remember that <span class="italic">the initializers are not required to be the values</span>.</p><p class="calibre18"><span class="bold">Don’t be clever when defining vars</span>. <a id="filepos902956"></a>There are a number of macros in Clojure that define vars, all of which are based on <tt class="calibre22">def</tt> or some macro derivative. If you’re going to write such a macro, keep a few things in mind so that your macro’s var-defining semantics are aligned with user expectations for such things:</p><p class="calibre23">Macros that define a var should have a name that starts with <tt class="calibre22">def</tt>.</p><blockquote class="calibre17">This will align your macro with other var-defining macros like <tt class="calibre22">defn</tt>, <tt class="calibre22">defn-</tt>, <tt class="calibre22">defmacro</tt>, and so on. The <tt class="calibre22">def</tt> prefix is a cue to your user that the macro will intern a new var, and that it should be used as a top-level form.</blockquote><p class="calibre23">Accept the name of the var as the first argument.</p><blockquote class="calibre17">Order of arguments aside, implicitly generated var names are clever, but they require users to understand the implementation of your macro—decidedly counter to their objective as instruments of abstraction.</blockquote><p class="calibre23">Define one var per macro form.</p><blockquote class="calibre17">As a corollary to the generally bad practice of defining vars with generated or implied names, don’t define more than one var per macro form. Just as you would find it confusing if <tt class="calibre22">def</tt> or <tt class="calibre22">defn</tt> were to define multiple vars, your users will find it confusing if your macro defines multiple vars. The one exception to this is if the code your macro generates needs something defined in a separate (private!) var that users will not have to access or generally know about.</blockquote><p class="calibre18"><span class="bold">No complex behavior should be locked inside macros</span>. Macros should ideally be a thin layer on top of existing functions (or other macros)—or should be easily replicable by these. This goes back to our prior discussion in <a href="#filepos876175"><span class="calibre5">When to Use Macros</span></a>.</p><p class="calibre18">There are a variety of counterexamples, including the <tt class="calibre22">for</tt> macro, where macros have a very complex expansion. However, <tt class="calibre22">for</tt> doesn’t do anything that cannot be replicated by a combination of <tt class="calibre22">map</tt>, <tt class="calibre22">filter</tt>, <tt class="calibre22">mapcat</tt>, <tt class="calibre22">fn</tt>, and <tt class="calibre22">let</tt>. The complexity in the <tt class="calibre22">for</tt> expansion is only accountable to optimization and syntactic objectives: it does not hide or lock away any piece of exclusive functionality.</p><p class="calibre18">Macros should delegate most of their work to functions and keep only for them what can’t be more easily done in functions: controlling evaluation.</p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos905706"></a><a href="#filepos901362"><span class="calibre32">176</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">The others having been captured in functions.</span></p><div class="mbppagebreak"></div><p id="filepos905889" class="calibre6"><span class="calibre4"><span class="bold">The Implicit Arguments: &amp;env and &amp;form</span></span></p><p id="filepos905996" class="calibre18">Earlier in <a href="#filepos894757"><span class="calibre5">Letting the User Pick Names</span></a>, we mentioned that the <tt class="calibre22">defmacro</tt> macro itself is one of the rare anaphoric macros in Clojure. <tt class="calibre22">defmacro</tt> introduces two implicit local bindings: <tt class="calibre22">&amp;env</tt> and <tt class="calibre22">&amp;form</tt>.</p><p id="filepos906323" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">&amp;env</span></span></span></p><p class="calibre18"><tt class="calibre22">&amp;env</tt><a id="filepos906466"></a> contains a map whose keys are the names<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos906548"></a><a href="#filepos932938"><span class="calibre32">177</span></a><span class="calibre32">]</span></small></sup> of all the current locals (the values of this map are unspecified). It may be useful for debugging purposes:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defmacro spy-env []<br class="calibre33"/>  (let [ks (keys &amp;env)]<br class="calibre33"/>    `(prn (zipmap '~ks [~@ks]))))<br class="calibre33"/><br class="calibre33"/>(let [x 1 y 2]<br class="calibre33"/>  (spy-env)<br class="calibre33"/>  (+ x y))<br class="calibre33"/>; {x 1, y 2}<br class="calibre33"/>;= 3</tt></span></blockquote><p class="calibre23"><tt class="calibre22">&amp;env</tt> can also prove itself useful to safely optimize expressions at compile time. Here is a very crude version of such a macro that evaluates the provided expression at compile time if it does not use any locals defined within the context of the macro’s usage:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defmacro simplify<br class="calibre33"/>  [expr]<br class="calibre33"/>  (let [locals (set (keys &amp;env))]<br class="calibre33"/>    (if (some locals (flatten expr))     </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>      expr                               </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>      (do<br class="calibre33"/>        (println "Precomputing: " expr)<br class="calibre33"/>        (list `quote (eval expr))))))    </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Here we do a <span class="italic">very</span> crude search for references to the locals within the body of code provided to our macro.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">If we suspect any such usage, then we return the code unaltered.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">Otherwise, we evaluate the expression provided to our macro <span class="italic">at compile time</span>, and return that value in place of our macro’s expression (after helpfully printing an informational message so we can know what’s going on).</blockquote><p class="calibre18">This macro allows us to optimize expressions that we suspect can be eliminated from runtime code while retaining the unoptimized derivation of such expressions in our source code (often a far better practice than manually precomputing value and using the resulting “magic” constants):</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn f<br class="calibre33"/>  [a b c]<br class="calibre33"/>  (+ a b c (simplify (apply + (range 5e7)))))<br class="calibre33"/>; Precomputing:  (apply + (range 5e7))<br class="calibre33"/>;= #'user/f<br class="calibre33"/>(f 1 2 3)            ;; returns instantly<br class="calibre33"/>;= 1249999975000006<br class="calibre33"/>(defn f'<br class="calibre33"/>  [a b c]<br class="calibre33"/>  (simplify (apply + a b c (range 5e7))))<br class="calibre33"/>;= #'user/f'<br class="calibre33"/>(f' 1 2 3)           ;; takes ~2.5s to calculate<br class="calibre33"/>;= 1249999975000006</tt></span></blockquote><p class="calibre23">Because the <tt class="calibre22">apply</tt> expression in our function ƒ contains no references to function locals, the <tt class="calibre22">simplify</tt> macro optimizes it away into a constant value. This optimization takes the form of <tt class="calibre22">simplify</tt> precomputing that value at compile time, so that runtime usages of ƒ do not need to pay the (~2.5s) cost of summing the numbers in that <tt class="calibre22">range</tt>. On the other hand, the expression within the <tt class="calibre22">simplify</tt> usage in the <tt class="calibre22">f'</tt> function <span class="italic">does</span> depend upon local bindings as indicated by <tt class="calibre22">&amp;env</tt>; therefore, <tt class="calibre22">simplify</tt> performs no optimizations, leaving our expression to be fully evaluated at runtime.</p><p id="filepos910571" class="calibre18"><span class="bold">Testing and debugging &amp;env usage</span>. <a id="filepos910645"></a>It can be difficult to test macros that use <tt class="calibre22">&amp;env</tt>. We have two options at our disposal: either write your macro and use logging or other methods of observation to determine its operation (as we did above with the <tt class="calibre22">println</tt> in <tt class="calibre22">simplify</tt>), or we can take advantage of some of the implementation details of macros to test them in isolation.</p><p class="calibre18">Macros are currently implemented as functions that take two extra arguments <a id="filepos911124"></a>in front of their regular signatures, the values of <tt class="calibre22">&amp;form</tt><a id="filepos911201"></a> and <tt class="calibre22">&amp;env</tt> when they are invoked by the Clojure compiler. However, as we saw in <a href="#filepos876175"><span class="calibre5">When to Use Macros</span></a>, Clojure prevents us from using macros as functions in order to avoid a large class of errors that would result.</p><p class="calibre18">We can get around this by reaching into our macro’s var, grabbing its implementing function, and using it directly—much like the compiler does:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(@#'simplify nil {} '(inc 1))       </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>; Precomputing:  (inc 1)<br class="calibre33"/>;= (quote 2)<br class="calibre33"/>(@#'simplify nil {'x nil} '(inc x))<br class="calibre33"/>;= (inc x)</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">The line noise preceding <tt class="calibre22">simplify</tt> looks like cursing—it is the sugared syntax for dereferencing a named var, equivalent to <tt class="calibre22">(deref (var simplify))</tt>, and generally useful for obtaining the value of a private var—and should constitute a warning by itself. This particular abuse of macros is useful for testing in a pinch, but relies on particular current implementation details in Clojure.</blockquote><p class="calibre18">Here we’re invoking the macro’s implementing function with two arguments prior to the expression we’re testing with <tt class="calibre22">simplify</tt>: a <tt class="calibre22">nil</tt> argument for its <tt class="calibre22">&amp;form</tt> (which we know we’re not using) and an <tt class="calibre22">&amp;env</tt> map either containing or not containing a key for a hypothetical local binding. This allows us to see what code <tt class="calibre22">simplify</tt> will produce for a couple of expressions. Note that we can’t test <tt class="calibre22">simplify</tt> by using <tt class="calibre22">macroexpand</tt> in this case, because it provides no way for us to mock out the <tt class="calibre22">&amp;env</tt> map, as we can when touching the macro’s implementing function directly.<a id="filepos913272"></a><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos913314"></a><a href="#filepos933286"><span class="calibre32">178</span></a><span class="calibre32">]</span></small></sup></p><p id="filepos913413" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">&amp;form</span></span></span></p><p class="calibre18"><tt class="calibre22">&amp;form</tt><a id="filepos913558"></a> holds the whole form currently being macro-expanded, that is, a list containing the name of the macro as a symbol (as found in the user code: including alias or renames) and the arguments to the macro. It’s really the form as read by the reader.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos913848"></a><a href="#filepos933719"><span class="calibre32">179</span></a><span class="calibre32">]</span></small></sup> This means <tt class="calibre22">&amp;form</tt> has all the metadata <a id="filepos913995"></a>specified by the user, such as type hints and added by the reader, like the line number of the macro’s usage.</p><p class="calibre18">Let’s take a look at two powerful usages of <tt class="calibre22">&amp;form</tt>: emitting useful compile-time error messages from macros and ensuring that user-provided type hints are preserved by your macros.</p><p id="filepos914343" class="calibre23"><span class="calibre53"><span class="bold">Producing useful macro error messages</span></span></p><p id="filepos914441" class="calibre18">One key usage of this information is to ensure that any errors thrown by your macros provide accurate and informative messages. For example, consider a macro that accepts a bunch of vector triples<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos914700"></a><a href="#filepos933941"><span class="calibre32">180</span></a><span class="calibre32">]</span></small></sup>—it might build the corresponding ontology, precalculating various relationships and properties of that ontology so that that work does not have to be done at runtime:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defmacro ontology<br class="calibre33"/>  [&amp; triples]<br class="calibre33"/>  (every? #(or (== 3 (count %))<br class="calibre33"/>               (throw (IllegalArgumentException.<br class="calibre33"/>                        "All triples provided as arguments must have 3 elements")))<br class="calibre33"/>          triples)<br class="calibre33"/>  ;; build and emit pre-processed ontology here...<br class="calibre33"/>  )</tt></span></blockquote><p class="calibre23">The exception will only be thrown when one of the vectors provided as an argument to <tt class="calibre22">ontology</tt> does not have three elements. However, the accompanying message will be less than ideal:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(ontology ["Boston" :capital-of])                           </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #&lt;IllegalArgumentException java.lang.IllegalArgumentException:<br class="calibre33"/>;=   All triples provided as arguments must have 3 elements&gt;<br class="calibre33"/>(pst)<br class="calibre33"/>;= IllegalArgumentException All triples provided as arguments must have 3 elements<br class="calibre33"/>;=   user/ontology (NO_SOURCE_FILE:3)                       </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">The incomplete triple does throw an exception, but…</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">The line number shown in the exception’s stack trace is incorrect from the user’s perspective—<tt class="calibre22">3</tt> here is relative to the <span class="italic">macro’s</span> source, <span class="italic">not</span> the usage of it.</blockquote><p class="calibre18">The line number isn’t a big deal in this simple, short REPL interaction, but an inaccurate line number may lead to wasted minutes or hours debugging a faulty macro usage in a real project with potentially large source files. We can fix this by using <tt class="calibre22">&amp;form</tt> and its metadata:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defmacro ontology<br class="calibre33"/>  [&amp; triples]<br class="calibre33"/>  (every? #(or (== 3 (count %))<br class="calibre33"/>               (throw (IllegalArgumentException.<br class="calibre33"/>                        (format "`%s` provided to `%s` on line %s has &lt; 3 elements"<br class="calibre33"/>                                %                           </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>                                (first &amp;form)               </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>                                (-&gt; &amp;form meta :line)))))   </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>          triples)<br class="calibre33"/>  ;; ...<br class="calibre33"/>  )</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">We include the offending vector argument in the error message; this doesn’t require <tt class="calibre22">&amp;form</tt>, but is a nice touch in any case.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">The first element in <tt class="calibre22">&amp;form</tt> is always going to be the name of the macro as identified by the user. We’ll see the utility of this in a bit.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">Here we pull out the line number from the reader-supplied metadata on <tt class="calibre22">&amp;form</tt>. This line number accurately identifies where the <span class="italic">user’s code</span> uses the macro.</blockquote><p class="calibre18">With these changes, the experience of using our macro is improved significantly in the case of a compile-time error:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(ontology ["Boston" :capital-of])<br class="calibre33"/>;= #&lt;IllegalArgumentException java.lang.IllegalArgumentException:<br class="calibre33"/>;=   `["Boston" :capital-of]` provided to `ontology` on line 1 has &lt; 3 elements&gt;</tt></span></blockquote><p class="calibre23">Nice, now our error message is much clearer with regard to the line number. But, why bother reprinting the name used to identify our macro? It is possible to rename the symbols used to identify vars “imported” from another namespace <a id="filepos920034"></a>by using the <tt class="calibre22">refer</tt> function and its derivatives—a very useful feature in order to use functions and macros from other namespaces that have the same or similar names.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos920252"></a><a href="#filepos934503"><span class="calibre32">181</span></a><span class="calibre32">]</span></small></sup> So, if we switch to another namespace, we have the option of using our <tt class="calibre22">ontology</tt> macro via another name:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(ns com.clojurebook.macros)<br class="calibre33"/>;= nil<br class="calibre33"/>(refer 'user :rename '{ontology triples})<br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre23">Now our <tt class="calibre22">ontology</tt> macro is available as <tt class="calibre22">triples</tt> in the <tt class="calibre22">com.clojurebook.macros</tt> namespace. Thankfully, our revised <tt class="calibre22">ontology</tt> macro will throw errors that accurately (and helpfully) indicate the name of the macro <span class="italic">as present in the actual usage</span>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(triples ["Boston" :capital-of])<br class="calibre33"/>;= #&lt;IllegalArgumentException java.lang.IllegalArgumentException:<br class="calibre33"/>;=   `["Boston" :capital-of]` provided to `triples` on line 1 has &lt; 3 elements&gt;</tt></span></blockquote><p class="calibre23">Without the use of <tt class="calibre22">(first &amp;form)</tt> in building that error message, some degree of confusion might ensue before our hapless macro user remembered that he had renamed <tt class="calibre22">ontology</tt> to <tt class="calibre22">triples</tt> in the current namespace.</p><p id="filepos921546" class="calibre23"><span class="calibre53"><span class="bold">Preserving user-provided type hints</span></span></p><p id="filepos921642" class="calibre18">Most macros discard the metadata <a id="filepos921703"></a>attached to the forms within their context, including type hints.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos921810"></a><a href="#filepos934965"><span class="calibre32">182</span></a><span class="calibre32">]</span></small></sup> For example, here the <tt class="calibre22">or</tt><a id="filepos921939"></a> macro form does not propagate the <tt class="calibre22">^String</tt> type hint to the code it produces, resulting in a reflection warning:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(set! *warn-on-reflection* true)<br class="calibre33"/>;= true<br class="calibre33"/>(defn first-char-of-either<br class="calibre33"/>  [a b]<br class="calibre33"/>  (.substring ^String (or a b) 0 1))<br class="calibre33"/>; Reflection warning, NO_SOURCE_PATH:2 - call to substring can't be resolved.<br class="calibre33"/>;= #'user/first-char-of-either</tt></span></blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Such cases are rarely found in the wild, because type hints are usually put upstream of interop calls, resulting in the type of the macro form being determined through type inference:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(defn first-char-of-either<br class="calibre33"/>  [^String a ^String b]<br class="calibre33"/>  (.substring (or a b) 0 1))<br class="calibre33"/>;= #'user/first-char-of-either</tt></span></blockquote><p class="calibre25">We can verify that the hint metadata on the <tt class="calibre22">or</tt> expression is lost; here, the expression, with metadata:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(binding [*print-meta* true]<br class="calibre33"/>  (prn '^String (or a b)))<br class="calibre33"/>; ^{:tag String, :line 1} (or a b)</tt></span></blockquote><p class="calibre23">But if we <tt class="calibre22">macroexpand</tt> the same expression, that metadata is gone:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(binding [*print-meta* true]<br class="calibre33"/>  (prn (macroexpand '^String (or a b))))<br class="calibre33"/>; (let* [or__3548__auto__ a]<br class="calibre33"/>;   (if or__3548__auto__ or__3548__auto__ (clojure.core/or b)))</tt></span></blockquote><p class="calibre23">However, there’s no reason why the type hint on the <tt class="calibre22">or</tt> expression can’t be preserved; doing so simply requires using <tt class="calibre22">&amp;form</tt> effectively in its macro definition. First, let’s see what <tt class="calibre22">or</tt> looks like, as implemented in <tt class="calibre22">clojure.core</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defmacro or<br class="calibre33"/>  ([] nil)<br class="calibre33"/>  ([x] x)<br class="calibre33"/>  ([x &amp; next]<br class="calibre33"/>    `(let [or# ~x]<br class="calibre33"/>       (if or# or# (or ~@next)))))</tt></span></blockquote><p class="calibre23">What we need to do is ensure that the metadata on <tt class="calibre22">&amp;form</tt>—which contains the user-provided type hint, if any—is propagated onto the expression returned from <tt class="calibre22">or</tt>. In many cases, we could simply wrap the outer level of our macro’s body with a <tt class="calibre22">with-meta</tt> call to add <tt class="calibre22">&amp;form</tt>’s metadata to the returned expression, but we can’t do that here;<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos924802"></a><a href="#filepos935304"><span class="calibre32">183</span></a><span class="calibre32">]</span></small></sup> instead, we’ll need to put type hints where they belong: on a symbol:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defmacro OR<br class="calibre33"/>  ([] nil)<br class="calibre33"/>  ([x]<br class="calibre33"/>    (let [result (with-meta (gensym "res") (meta &amp;form))]<br class="calibre33"/>      `(let [~result ~x]<br class="calibre33"/>         ~result)))<br class="calibre33"/>  ([x &amp; next]<br class="calibre33"/>    (let [result (with-meta (gensym "res") (meta &amp;form))]<br class="calibre33"/>      `(let [or# ~x<br class="calibre33"/>             ~result (if or# or# (OR ~@next))]<br class="calibre33"/>         ~result))))</tt></span></blockquote><p class="calibre23">We can verify that the hint we’re providing is being preserved by looking at the output of <tt class="calibre22">macroexpand</tt> again (notice that we’re using our <tt class="calibre22">or</tt> variant, <tt class="calibre22">OR</tt>):</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(binding [*print-meta* true]<br class="calibre33"/>  (prn (macroexpand '^String (OR a b))))<br class="calibre33"/>; (let* [or__1176__auto__ a<br class="calibre33"/>;        ^{:tag String, :line 2}<br class="calibre33"/>;        res1186 (if or__1176__auto__ or__1176__auto__ (user/or b))]<br class="calibre33"/>;   ^{:tag String, :line 2} res1186)</tt></span></blockquote><p class="calibre23">User-supplied metadata is now no longer lost, in this case resulting in the elimination of the reflective call:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn first-char-of-any<br class="calibre33"/>  [a b]<br class="calibre33"/>  (.substring ^String (OR a b) 0 1))<br class="calibre33"/>;= #'user/first-char-of-any</tt></span></blockquote><p class="calibre23">The pattern exemplified in the definition of <tt class="calibre22">OR</tt> above can be broken out into a reusable function that can be easily used with any macro:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn preserve-metadata<br class="calibre33"/>  "Ensures that the body containing `expr` will carry the metadata<br class="calibre33"/>   from `&amp;form`."<br class="calibre33"/>  [&amp;form expr]<br class="calibre33"/>  (let [res (with-meta (gensym "res") (meta &amp;form))]<br class="calibre33"/>     `(let [~res ~expr]<br class="calibre33"/>        ~res)))<br class="calibre33"/><br class="calibre33"/>(defmacro OR<br class="calibre33"/>  "Same as `clojure.core/or`, but preserves user-supplied metadata<br class="calibre33"/>   (e.g. type hints)."<br class="calibre33"/>  ([] nil)<br class="calibre33"/>  ([x] (preserve-metadata &amp;form x))<br class="calibre33"/>  ([x &amp; next]<br class="calibre33"/>    (preserve-metadata &amp;form `(let [or# ~x]<br class="calibre33"/>                                (if or# or# (or ~@next))))))</tt></span></blockquote><p class="calibre23">Writing a <tt class="calibre22">defmacro</tt> variant that always uses <tt class="calibre22">preserve-metadata</tt> to maintain user-supplied metadata for macro expressions is left as an exercise for the reader.<a id="filepos927698"></a></p><p id="filepos927709" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Testing Contextual Macros</span></span></span></p><p id="filepos927824" class="calibre18">As we’ve seen, macros using <tt class="calibre22">&amp;form</tt> and <tt class="calibre22">&amp;env</tt> can’t be easily tested. However, based on our knowledge of these arguments and of how macros are implemented, we can whip up an implementation of <tt class="calibre22">macroexpand-1</tt> that allows us to effectively mock <tt class="calibre22">&amp;env</tt> to aid in testing and debugging:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn macroexpand1-env [env form]<br class="calibre33"/>  (if-let [[x &amp; xs] (and (seq? form) (seq form))]<br class="calibre33"/>    (if-let [v (and (symbol? x) (resolve x))]<br class="calibre33"/>      (if (-&gt; v meta :macro)<br class="calibre33"/>        (apply @v form env xs)<br class="calibre33"/>        form)<br class="calibre33"/>      form)<br class="calibre33"/>    form))</tt></span></blockquote><p class="calibre23">We can use <tt class="calibre22">macroexpand1-env</tt> to test how our contextual <tt class="calibre22">simplify</tt> macro behaves when used within different “environments” of locals:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(macroexpand1-env '{} '(simplify (range 10)))<br class="calibre33"/>; Precomputing:  (range 10)<br class="calibre33"/>;= (quote (0 1 2 3 4 5 6 7 8 9))<br class="calibre33"/>(macroexpand1-env '{range nil} '(simplify (range 10)))<br class="calibre33"/>;= (range 10)</tt></span></blockquote><p class="calibre23">And we can test and verify macros’ handling of <tt class="calibre22">&amp;form</tt> metadata by specifying the metadata attached to the code provided to <tt class="calibre22">macroexpand1-env</tt>. For example, say we modified the <tt class="calibre22">spy</tt> macro we tinkered with before to echo the line number of the macro’s usage, obtained from the metadata on <tt class="calibre22">&amp;form</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defmacro spy [expr]<br class="calibre33"/>  `(let [value# ~expr]<br class="calibre33"/>     (println (str "line #" ~(-&gt; &amp;form meta :line) ",")<br class="calibre33"/>              '~expr value#)<br class="calibre33"/>     value#))<br class="calibre33"/>;= #'user/spy<br class="calibre33"/>(let [a 1<br class="calibre33"/>      a (spy (inc a))<br class="calibre33"/>      a (spy (inc a))]<br class="calibre33"/>  a)<br class="calibre33"/>; line #2, (inc a) 2<br class="calibre33"/>; line #3, (inc a) 3<br class="calibre33"/>;= 3</tt></span></blockquote><p class="calibre23">If we wanted to verify that that echoing of the line number worked without running the code the macro emitted, we could use <tt class="calibre22">macroexpand1-env</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(macroexpand1-env {} (with-meta '(spy (+ 1 1)) {:line 42}))  </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= (clojure.core/let [value__602__auto__ (+ 1 1)]<br class="calibre33"/>;=   (clojure.core/println<br class="calibre33"/>;=     (clojure.core/str "line #" 42 ",")                    </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;=     (quote (+ 1 1)) value__602__auto__)<br class="calibre33"/>;=   value__602__auto__)</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">We override the <tt class="calibre22">:line</tt> metadata on the form we provide to <tt class="calibre22">macroexpand1-env</tt> to some unusual value we’ll recognize…</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">…and we can verify that, yes, our macro is picking up and using the line number metadata on <tt class="calibre22">&amp;form</tt> properly.</blockquote><p class="calibre18">The body of <tt class="calibre22">macroexpand1-env</tt> is actually a perfect candidate for a macro: those nested <tt class="calibre22">if-let</tt> expressions and the repeated <tt class="calibre22">form</tt> aren’t especially elegant. It would be better if we could collapse all of those <tt class="calibre22">if-let</tt>s into a single form, perhaps like this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn macroexpand1-env [env form]<br class="calibre33"/>  (if-all-let [[x &amp; xs] (and (seq? form) (seq form))<br class="calibre33"/>               v (and (symbol? x) (resolve x))<br class="calibre33"/>               _ (-&gt; v meta :macro)]<br class="calibre33"/>    (apply @v form env xs)<br class="calibre33"/>    form))</tt></span></blockquote><p class="calibre23">We would like <tt class="calibre22">if-all-let</tt> to evaluate the <tt class="calibre22">then</tt> form only if none of the bound expressions evaluated to <tt class="calibre22">false</tt> or <tt class="calibre22">nil</tt>. A macro can do this for us:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defmacro if-all-let [bindings then else]<br class="calibre33"/>  (reduce (fn [subform binding]<br class="calibre33"/>            `(if-let [~@binding] ~subform ~else))<br class="calibre33"/>    then (reverse (partition 2 bindings))))</tt></span></blockquote><p class="calibre23">This satisfies our second implementation of <tt class="calibre22">macroexpand1-env</tt>, and is generally quite useful where we might otherwise have had nested <tt class="calibre22">if-let</tt> forms.<a id="filepos932834"></a></p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos932938"></a><a href="#filepos906548"><span class="calibre32">177</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Note that metadata on keys of </span><span class="calibre10"><tt class="calibre22">&amp;env</tt></span><span class="calibre10"> can’t be relied upon, in particular in the presence of local aliases.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos933286"></a><a href="#filepos913314"><span class="calibre32">178</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="#filepos927709"><span class="calibre10"><span class="calibre5">Testing Contextual Macros</span></span></a><span class="calibre10"> for our stab at an alternative macroexpansion function that does support this without the var-dereferencing line noise.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos933719"></a><a href="#filepos913848"><span class="calibre32">179</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Or, returned by a previous expansion.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos933941"></a><a href="#filepos914700"><span class="calibre32">180</span></a><span class="calibre32">] </span></small></sup><span class="calibre10"><span class="italic">Triples</span></span><span class="calibre10"> are a term for subject-predicate-object expressions, as found in semantic web technologies like RDF. Specific representations and semantics of triples vary from implementation to implementation, but a simplified example of a vector triple might be </span><span class="calibre10"><tt class="calibre22">["Boston" :capital-of "Massachusetts"]</tt></span><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos934503"></a><a href="#filepos920252"><span class="calibre32">181</span></a><span class="calibre32">] </span></small></sup><span class="calibre10"><tt class="calibre22">refer</tt></span><span class="calibre10"> is described in </span><a href="#filepos1138316"><span class="calibre10"><span class="calibre5">“refer”</span></span></a><span class="calibre10">, and is also reused by </span><span class="calibre10"><tt class="calibre22">use</tt></span><span class="calibre10">, described later in that chapter.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos934965"></a><a href="#filepos921810"><span class="calibre32">182</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">We describe type hints in </span><a href="#filepos1324665"><span class="calibre10"><span class="calibre5">Type Hinting for Performance</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos935304"></a><a href="#filepos924802"><span class="calibre32">183</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">This is due to an unfortunate implementation detail: special forms (like </span><span class="calibre10"><tt class="calibre22">let</tt></span><span class="calibre10">, the outermost form in the expression returned by </span><span class="calibre10"><tt class="calibre22">or</tt></span><span class="calibre10">) cannot be hinted. Thus, we must introduce a local to put the hint on it.</span></p><div class="mbppagebreak"></div><p id="filepos935751" class="calibre6"><span class="calibre4"><span class="bold">In Detail: -&gt; and -&gt;&gt;</span></span></p><p id="filepos935842" class="calibre18">To explore how macros work to solve real problems, let’s work up an alternative implementation of a commonly used macro in Clojure: <tt class="calibre22">-&gt;</tt>, which is very similar to its cousin, <tt class="calibre22">-&gt;&gt;</tt>. Often called <span class="italic">threading macros</span><a id="filepos936113"></a>, these are included in <tt class="calibre22">clojure.core</tt> (with a number of derivatives with similar semantics in various third-party libraries), and are remarkably useful in cleaning up chained function calls and chained Java-interop method calls.</p><p class="calibre18">What we’d like to do is be able rewrite somewhat awkward code like this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(prn (conj (reverse [1 2 3]) 4))</tt></span></blockquote><p class="calibre23">…and instead write code like this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(thread [1 2 3] reverse (conj 4) prn)</tt></span></blockquote><p class="calibre23">This way, rather than reading code inside-out (which can be difficult with deeply nested calls), we can read our code sequentially, left-to-right as a series of successive actions: “Start with [1 2 3], reverse it, <tt class="calibre22">conj</tt> 4 onto it, then <tt class="calibre22">prn</tt> it.”</p><p class="calibre18">It’s not hard to envision a macro to do this. Given a series of forms, we’ll take the first form and insert it as the second item in the second form, then take the resulting form and insert it as the second item in the third form, and so on.</p><p class="calibre18">Additionally, if any form after the first is not already a list, let’s consider it a list of one item. This lets us avoid parens on single-argument functions like this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(-&gt; foo (bar) (baz))</tt></span></blockquote><p class="calibre23">and instead write:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(-&gt; foo bar baz)</tt></span></blockquote><p class="calibre23">First, let’s write a simple utility function to ensure that a form is a seq.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn ensure-seq [x]<br class="calibre33"/>  (if (seq? x) x (list x)))<br class="calibre33"/><br class="calibre33"/>(ensure-seq 'x)<br class="calibre33"/>;= (x)<br class="calibre33"/>(ensure-seq '(x))<br class="calibre33"/>;= (x)</tt></span></blockquote><p class="calibre23">Now, given two forms <tt class="calibre22">x</tt> and <tt class="calibre22">ys</tt>, we want a function to insert <tt class="calibre22">x</tt> as the second item in <tt class="calibre22">ys</tt>, ensuring that <tt class="calibre22">ys</tt> is a seq.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn insert-second<br class="calibre33"/>  "Insert x as the second item in seq y."<br class="calibre33"/>  [x ys]<br class="calibre33"/>  (let [ys (ensure-seq ys)]<br class="calibre33"/>    (concat (list (first ys) x)<br class="calibre33"/>            (rest ys))))</tt></span></blockquote><p class="calibre23">Although this is a normal function, remember that it will be called from our macro. Thus the values of <tt class="calibre22">x</tt> and <tt class="calibre22">ys</tt> will be data structures representing unevaluated source code.</p><p class="calibre18">We can write this code more concisely with a bit of syntax-quoting and unquoting; remember, you can use these mechanisms outside of the body of a macro:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn insert-second<br class="calibre33"/>  "Insert x as the second item in seq y."<br class="calibre33"/>  [x ys]<br class="calibre33"/>  (let [ys (ensure-seq ys)]<br class="calibre33"/>    `(~(first ys) ~x ~@(rest ys))))</tt></span></blockquote><p class="calibre23">We can do it even more concisely using <tt class="calibre22">list*</tt>, a function that we looked at in <a href="#filepos366032"><span class="calibre5">Creating seqs</span></a> that is used frequently in the implementation of macros and their helpers:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn insert-second<br class="calibre33"/>  "Insert x as the second item in seq y."<br class="calibre33"/>  [x ys]<br class="calibre33"/>  (let [ys (ensure-seq ys)]<br class="calibre33"/>    (list* (first ys) x (rest ys))))</tt></span></blockquote><p class="calibre23">Now let’s write our macro, which we’ll call <tt class="calibre22">thread</tt>. <tt class="calibre22">(thread x)</tt> should just return <tt class="calibre22">x</tt>. <tt class="calibre22">(thread x (a b))</tt> should return <tt class="calibre22">(a x b)</tt>, using our utility functions. <tt class="calibre22">(thread x (a b) (c d))</tt> can thread the first two items and then recursively call <tt class="calibre22">thread</tt> on the result.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defmacro thread<br class="calibre33"/>  "Thread x through successive forms."<br class="calibre33"/>  ([x] x)<br class="calibre33"/>  ([x form] (insert-second x form))<br class="calibre33"/>  ([x form &amp; more] `(thread (thread ~x ~form) ~@more)))</tt></span></blockquote><p class="calibre23">It looks like it works, just as the standard <tt class="calibre22">-&gt;</tt> macro does:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos940677"></a><a href="#filepos944177"><span class="calibre32">184</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(thread [1 2 3] (conj 4) reverse println)<br class="calibre33"/>;= (4 3 2 1)<br class="calibre33"/>(-&gt; [1 2 3] (conj 4) reverse println)<br class="calibre33"/>;= (4 3 2 1)</tt></span></blockquote><p class="calibre23">One question we haven’t asked ourselves is whether we could write this macro as a normal function, to avoid the use of macros at all. It turns out we can, with a slight modification:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn thread-fns<br class="calibre33"/>  ([x] x)<br class="calibre33"/>  ([x form] (form x))<br class="calibre33"/>  ([x form &amp; more] (apply thread-fns (form x) more)))<br class="calibre33"/><br class="calibre33"/>(thread-fns [1 2 3] reverse #(conj % 4) prn)<br class="calibre33"/>;= (4 3 2 1)</tt></span></blockquote><p class="calibre23">In this case, having to wrap some of our function calls in <tt class="calibre22">#()</tt> makes our code more verbose and slightly harder to read, as well as adding overhead to our code via extraneous function calls. Additionally, the functional version will not work with bare Java method calls, whereas the macro version, being a simple manipulation of lists and symbols, does.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(thread [1 2 3] .toString (.split " ") seq)<br class="calibre33"/>;= ("[1" "2" "3]")<br class="calibre33"/><br class="calibre33"/>(thread-fns [1 2 3] .toString #(.split % " ") seq)<br class="calibre33"/>;= #&lt;CompilerException java.lang.RuntimeException:<br class="calibre33"/>;=   Unable to resolve symbol: .toString in this context, <br class="calibre33"/>  compiling:(NO_SOURCE_PATH:1)&gt;<br class="calibre33"/><br class="calibre33"/>;; This is starting to look a bit hairy...<br class="calibre33"/>(thread-fns [1 2 3] #(.toString %) #(.split % " ") seq)<br class="calibre33"/>;= ("[1" "2" "3]")</tt></span></blockquote><p class="calibre23">It seems that the macro variant of our threading operator does offer some compelling syntactic advantages over the purely function-based approach. Indeed, the threading macros in Clojure are often used to great effect in clarifying the application of functional pipelines to yield transformations over a single value or a collection of values.</p><p class="calibre18">The real implementation of <tt class="calibre22">-&gt;</tt> is actually not much more complex than our <tt class="calibre22">thread</tt>. <tt class="calibre22">clojure.core</tt> provides a few other threading macros, including:</p><p class="calibre23"><tt class="calibre22">..</tt></p><blockquote class="calibre17">Works just like <tt class="calibre22">-&gt;</tt>, but only works with Java interop calls (and calls of static Java methods, which <tt class="calibre22">-&gt;</tt> does not support). <tt class="calibre22">..</tt> was introduced before <tt class="calibre22">-&gt;</tt>, and it’s rarely used now, but you may still see it in the wild.</blockquote><p class="calibre23"><tt class="calibre22">-&gt;&gt;</tt></p><blockquote class="calibre17">Threads forms together by inserting each form as the <span class="italic">last</span> item in successive forms, rather than as the second item. This is used most commonly when transforming sequences or other collections through a series of functions. For example:</blockquote><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(-&gt;&gt; (range 10) (map inc) (reduce +))<br class="calibre33"/>;= 55</tt></span></blockquote><p class="calibre23">Hopefully this serves as a compelling example of the power and utility of macros.<a id="filepos944073"></a></p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos944177"></a><a href="#filepos940677"><span class="calibre32">184</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">A reimplementation of </span><span class="calibre10"><tt class="calibre22">-&gt;&gt;</tt></span><span class="calibre10"> would be just as straightforward, and is left as an exercise. Hint: you’ll need an </span><span class="calibre10"><tt class="calibre22">insert-last</tt></span><span class="calibre10"> function instead of </span><span class="calibre10"><tt class="calibre22">insert-second</tt></span><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos944637" class="calibre6"><span class="calibre4"><span class="bold">Final Thoughts</span></span></p><p class="calibre18">As with any other Lisp, macros are essential to Clojure’s expressive power. A little macrology goes a long way in eliminating eyesores and abstracting away common patterns in your code. However, they are by no means the most basic construct or the one you should reach for first: you can go a very long way with Clojure without creating a single macro.</p><p class="calibre18">Functional programming and data modeling already yield tremendous expressive power and allow us to abstract away most repeating patterns in our code. Macros are the <span class="italic">final</span> step, simplifying patterns of control flow and adding syntactic sugar to minimize or eliminate code awkwardness.<a id="filepos945416"></a></p><div class="mbppagebreak"></div><p id="filepos945443" class="calibre6"><span class="calibre2"><span class="bold">Chapter 6. Datatypes and Protocols</span></span></p><p id="filepos945540" class="calibre13">While programming in other languages, many of us have experienced this situation: you have crafted beautiful interfaces obeying all laws of good design, just to realize that you must deal with an object provided by another module over which you have absolutely no control. There’s little hope that the maintainers of this module will ever add support for your interface—be it for technical, political, or legal reasons. In no time you are now juggling (drowning in?) adapters and proxies.</p><p class="calibre18">The luckiest among us work in languages dynamic enough to allow <span class="italic">monkey-patching</span><a id="filepos946178"></a>, where classes are open and methods can be jammed into those classes when necessary in order to bridge the distance between one interface and another. Thankfully, the term is depreciative enough to make you twitch and think twice before using it, since such surgery carries an armload of complexity, caveats, and pitfalls.</p><p class="calibre18">The fundamental problem behind these symptoms has previously been named the <span class="italic">expression problem</span><a id="filepos946641"></a>:</p><blockquote class="calibre35"><span class="calibre10"><span class="italic">The Expression Problem is a new name for an old problem. The goal is to define a datatype by cases, where one can add new cases to the datatype and new functions over the datatype, without recompiling existing code, and while retaining static type safety (e.g., no casts).</span></span></blockquote><blockquote class="calibre63"><span class="calibre10">—Philip Wadler, </span><span class="calibre10"><span class="italic">http://www.daimi.au.dk/~madst/tool/papers/expression.txt</span></span></blockquote><p class="calibre23">Some argue whether the expression problem in dynamic languages is still the expression problem as originally coined by Philip Wadler. We are not going to determine how many angels can dance on the head of a pin in this book, so we’ll be satisfied to keep to our own <span class="italic">dynamic expression problem</span><a id="filepos947522"></a>. Phrased using more object-oriented parlance:</p><blockquote class="calibre35"><span class="calibre10"><span class="italic">The dynamic Expression Problem is a new name for an old problem. The goal is to have interfaces and type where one can create new types implementing existing interfaces and provide implementation of a new interface for an existing type, without recompiling existing code.</span></span></blockquote><p class="calibre23">The first half of this goal—having new types to implement old interfaces—is commonly met: every object-oriented language offers this capacity. The second half—providing implementations of new interfaces to old types—is the interesting part of the problem, and the one that few languages ever attempt to address. We are going to see how Clojure solves it.</p><p id="filepos948323" class="calibre6"><span class="calibre4"><span class="bold">Protocols</span></span></p><p id="filepos948393" class="calibre18">The Clojure corollary to interfaces are called <tt class="calibre22">protocols</tt>.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos948522"></a><a href="#filepos955012"><span class="calibre32">185</span></a><span class="calibre32">]</span></small></sup><span class="italic">Interface</span> is a term best kept reserved for Java interfaces.<a id="filepos948684"></a></p><p class="calibre18">A protocol consists of one or more methods, where each method can have multiple arities. All methods have at least one argument, corresponding to the privileged <tt class="calibre22">this</tt> in Java and <tt class="calibre22">self</tt> in Ruby and Python.</p><p class="calibre18">The first argument to each method in a protocol is said to be privileged because a particular protocol implementation will be chosen for each call based on it and, more specifically, on its type. Hence, protocols provide single type-based dispatch. This is a very limited form of polymorphic dispatch and it had been chosen for protocols for pragmatic reasons, namely:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">That’s what most hosts (e.g., the JVM, the CLR, and JavaScript virtual machines) offer and, more important, optimize;</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Despite being limited, it covers a wide range of needs</blockquote></li></ul><p class="calibre18">If you truly need unrestricted or multiple dispatch, Clojure has an answer in multimethods, explored in <a href="#filepos1073489"><span class="calibre5">Chapter 7</span></a>.</p><p class="calibre18">A protocol definition looks like this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defprotocol ProtocolName<br class="calibre33"/>  "documentation"<br class="calibre33"/>  (a-method [this arg1 arg2] "method docstring")<br class="calibre33"/>  (another-method [x] [x arg] "docstring"))       </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Because the privileged argument is explicit, you can give it any name you wish: <tt class="calibre22">this</tt>, <tt class="calibre22">self</tt>, <tt class="calibre22">_</tt>, etc.</blockquote><p class="calibre18">Unlike most other names in Clojure, the names of protocols and types are usually written in <tt class="calibre22">CamelCase</tt> because they compile down to native JVM interfaces and classes. This allows you to easily distinguish protocols and types from other entities in Clojure, and it allows for idiomatic usage from other JVM languages.</p><p class="calibre18">From a user standpoint, <span class="italic">protocol methods are functions</span>: <a id="filepos951095"></a>there is no special syntax involved in using them, you can look their documentation up with <tt class="calibre22">doc</tt>, you can pass them to higher-order functions, and so on. However, a protocol should not be designed with the user but with the protocol implementer in mind. A good protocol should consist of a small set of methods with no overlapping concerns; a good protocol is one that is <span class="italic">easy to implement</span>. There’s nothing wrong with a protocol having a single method.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Although protocol methods are functions, you cannot use destructuring or rest arguments in the specification of those methods within the </span><span class="calibre10"><tt class="calibre22">defprotocol</tt></span><span class="calibre10"> form. For example, based on what we learned in </span><a href="#filepos168988"><span class="calibre10"><span class="calibre5">Destructuring function arguments</span></span></a><span class="calibre10">, you might think that this defines a protocol with a single method that accepts two positional arguments and some number of additional arguments gathered into the </span><span class="calibre10"><tt class="calibre22">more</tt></span><span class="calibre10"> seq:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(defprotocol AProtocol<br class="calibre33"/>  (methodName [this x y &amp; more]))</tt></span></blockquote><blockquote class="calibre35"><span class="calibre10">However, because protocols generate a JVM interface—which cannot support all the argument structure variations that Clojure functions provide—</span><span class="calibre10"><tt class="calibre22">methodName</tt></span><a id="filepos952784"></a><span class="calibre10"> is taken to be a method that accepts </span><span class="calibre10"><span class="italic">four</span></span><span class="calibre10"> arguments, and only four arguments.</span></blockquote><p class="calibre25">Ancillary or convenience functions have no reason to be part of a protocol. They should instead be built on top of protocol methods.</p><p class="calibre18">When necessary, user-facing functions and protocol methods may even belong to different namespaces <a id="filepos953246"></a>to make explicit which are part of the public API and which are part of the implementor’s API.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos953384"></a><a href="#filepos955258"><span class="calibre32">186</span></a><span class="calibre32">]</span></small></sup> An example of this separation can be found in Clojure itself: the namespace <tt class="calibre22">clojure.core.protocols</tt> introduces a protocol called <tt class="calibre22">InternalReduce</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defprotocol InternalReduce<br class="calibre33"/>  "Protocol for concrete seq types that can reduce themselves<br class="calibre33"/>   faster than first/next recursion. Called by clojure.core/reduce."<br class="calibre33"/>  (internal-reduce [seq f start]))</tt></span></blockquote><p class="calibre23">As users of Clojure and its sequence operations, we would never need to use or even know about this protocol. However, if we were to implement our own data structure, and wanted to provide optimized <tt class="calibre22">reduce</tt> functionality based on implementation-specific factors, implementing that protocol would be of interest to us.</p><p class="calibre18">As we explore protocols and datatypes, we’ll use this <tt class="calibre22">Matrix</tt> protocol, which defines operations to access and update bidimensional sequential data structures (such as arrays or vectors or nested versions of the same):</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defprotocol Matrix<br class="calibre33"/>  "Protocol for working with 2d datastructures."<br class="calibre33"/>  (lookup [matrix i j])<br class="calibre33"/>  (update [matrix i j value])<br class="calibre33"/>  (rows [matrix])<br class="calibre33"/>  (cols [matrix])<br class="calibre33"/>  (dims [matrix]))</tt></span></blockquote><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos955012"></a><a href="#filepos948522"><span class="calibre32">185</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">This will sound familiar to Smalltalk or Objective C hackers.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos955258"></a><a href="#filepos953384"><span class="calibre32">186</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">This is exactly analogous to the API/SPI (</span><span class="calibre10"><span class="italic">service provider interface</span></span><span class="calibre10">) distinction in many Java libraries.</span></p><div class="mbppagebreak"></div><p id="filepos955552" class="calibre6"><span class="calibre4"><span class="bold">Extending to Existing Types</span></span></p><p id="filepos955640" class="calibre18">Our first implementation of this protocol will be a very naive one for vectors of vectors. “Vector of vectors” is not a type in Clojure or even in the JVM,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos955862"></a><a href="#filepos966369"><span class="calibre32">187</span></a><span class="calibre32">]</span></small></sup> so we are simply going to extend the protocol to Clojure vectors:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(extend-protocol Matrix<br class="calibre33"/>  clojure.lang.IPersistentVector<br class="calibre33"/>  (lookup [vov i j]<br class="calibre33"/>    (get-in vov [i j]))<br class="calibre33"/>  (update [vov i j value]<br class="calibre33"/>    (assoc-in vov [i j] value))<br class="calibre33"/>  (rows [vov]<br class="calibre33"/>    (seq vov))<br class="calibre33"/>  (cols [vov]<br class="calibre33"/>    (apply map vector vov))<br class="calibre33"/>  (dims [vov]<br class="calibre33"/>    [(count vov) (count (first vov))]))</tt></span></blockquote><p class="calibre23">Let’s stop and detail <tt class="calibre22">extend-protocol</tt><a id="filepos956613"></a>. The first argument is the name of the protocol (<tt class="calibre22">Matrix</tt> here). Then we have an alternation of symbols (denoting type names like <tt class="calibre22">IPersistentVector</tt>, the foundational vector interface in Clojure) and lists (method implementations for the previously specified type and extended protocol).</p><p class="calibre18">Method implementations are no different from regular functions. Unlike in Ruby or Java, there is no implicit <tt class="calibre22">self</tt> or <tt class="calibre22">this</tt>: the privileged first argument that determines which implementation of a protocol to dispatch to is explicitly passed as the first argument to the method. In this regard, protocol implementation functions are similar to methods in Python.</p><p class="calibre18">A noteworthy aspect of protocols is that <span class="italic">you are not required to implement all methods</span><a id="filepos957458"></a>: Clojure will simply throw an exception if you try to call an unimplemented method.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos957584"></a><a href="#filepos966801"><span class="calibre32">188</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18"><tt class="calibre22">extend-protocol</tt> is not the only way to extend a protocol to a type; also available are:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Inline implementation</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">extend</tt></blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">extend-type</tt></blockquote></li></ul><p class="calibre18">We will talk about <tt class="calibre22">extend</tt> and inline implementation later in <a href="#filepos1023003"><span class="calibre5">Reusing Implementations</span></a> and <a href="#filepos1011033"><span class="calibre5">Inline Implementation</span></a>, respectively.</p><p class="calibre18"><tt class="calibre22">extend-type</tt><a id="filepos958518"></a> is the dual to <tt class="calibre22">extend-protocol</tt>: where <tt class="calibre22">extend-protocol</tt> allows you to extend one protocol to several types, <tt class="calibre22">extend-type</tt> allows you to extend several protocols to one type. They share the same layout, only the places where protocol names and types names occur are inverted.</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 6-1. Comparison of use cases for extend-type versus extend-protocol</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(extend-type AType<br class="calibre33"/>  AProtocol<br class="calibre33"/>  (method-from-AProtocol [this x]<br class="calibre33"/>    (;...implementation for AType<br class="calibre33"/>     ))<br class="calibre33"/>  AnotherProtocol<br class="calibre33"/>  (method1-from-AnotherProtocol [this x]<br class="calibre33"/>    (;...implementation for AType<br class="calibre33"/>     ))<br class="calibre33"/>  (method2-from-AnotherProtocol [this x y]<br class="calibre33"/>    (;...implementation for AType<br class="calibre33"/>     )))<br class="calibre33"/><br class="calibre33"/>(extend-protocol AProtocol<br class="calibre33"/>  AType<br class="calibre33"/>  (method1-from-AProtocol [this x]<br class="calibre33"/>    (;...implementation for AType<br class="calibre33"/>     ))<br class="calibre33"/>  AnotherType<br class="calibre33"/>  (method1-from-AProtocol [this x]<br class="calibre33"/>    (;...implementation for AnotherType<br class="calibre33"/>     ))<br class="calibre33"/>  (method2-from-AProtocol [this x y]<br class="calibre33"/>    (;...implementation for AnotherType<br class="calibre33"/>     )))</tt></span></p><p class="calibre13">A protocol can also be extended to <tt class="calibre22">nil</tt>, so you can potentially say goodbye to many null pointer exceptions by providing a sane default behavior for it:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(extend-protocol Matrix<br class="calibre33"/>  nil<br class="calibre33"/>  (lookup [x i j])<br class="calibre33"/>  (update [x i j value])<br class="calibre33"/>  (rows [x] [])<br class="calibre33"/>  (cols [x] [])<br class="calibre33"/>  (dims [x] [0 0]))<br class="calibre33"/><br class="calibre33"/>(lookup nil 5 5)<br class="calibre33"/>;= nil<br class="calibre33"/>(dims nil)<br class="calibre33"/>;= [0 0]</tt></span></blockquote><p class="calibre23">To use our protocol and the implementation of it for vectors of vectors, it would help to have a<a id="filepos960610"></a>
<span class="italic">factory function<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos960672"></a><a href="#filepos967092"><span class="calibre32">189</span></a><span class="calibre32">]</span></small></sup></span> that creates an empty vector of vectors with particular dimensions.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn vov<br class="calibre33"/>  "Create a vector of h w-item vectors."<br class="calibre33"/>  [h w]<br class="calibre33"/>  (vec (repeat h (vec (repeat w nil)))))</tt></span></blockquote><p class="calibre23">Now, let’s play:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def matrix (vov 3 4))<br class="calibre33"/>;= #'user/matrix<br class="calibre33"/>matrix<br class="calibre33"/>;= [[nil nil nil nil]<br class="calibre33"/>;=  [nil nil nil nil]<br class="calibre33"/>;=  [nil nil nil nil]]<br class="calibre33"/>(update matrix 1 2 :x)<br class="calibre33"/>;= [[nil nil nil nil]<br class="calibre33"/>;=  [nil nil :x nil]<br class="calibre33"/>;=  [nil nil nil nil]]<br class="calibre33"/>(lookup *1 1 2)<br class="calibre33"/>;= :x<br class="calibre33"/>(rows (update matrix 1 2 :x))<br class="calibre33"/>;= ([nil nil nil nil]<br class="calibre33"/>;=  [nil nil :x nil]<br class="calibre33"/>;=  [nil nil nil nil])<br class="calibre33"/>(cols (update matrix 1 2 :x))<br class="calibre33"/>;= ([nil nil nil]<br class="calibre33"/>;=  [nil nil nil]<br class="calibre33"/>;=  [nil :x nil]<br class="calibre33"/>;=  [nil nil nil])</tt></span></blockquote><p class="calibre23">Good, this works well. We have effectively <span class="italic">extended</span> (implemented) a protocol to an existing type, vectors. This has been done in a sane, namespaced way:<a id="filepos962047"></a> because each protocol’s methods correspond with a set of namespaced functions, one protocol extension isn’t going to clash with any other, even if they share some identical method names.</p><p class="calibre18">To make the point clear that we can extend a protocol to any Java type, let’s provide another implementation of our Matrix protocol, this time for bidimensional arrays of floating-point doubles—which, unlike <tt class="calibre22">IPersistentVector</tt>, cannot be suspected of providing special support for protocols.</p><p id="filepos962584" class="calibre23"></p><p class="calibre23"><span class="italic">Example 6-2. Extending a protocol to a Java array</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(extend-protocol Matrix<br class="calibre33"/>  (Class/forName "[[D")                 </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  (lookup [matrix i j]<br class="calibre33"/>    (aget matrix i j))<br class="calibre33"/>  (update [matrix i j value]            </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>    (let [clone (aclone matrix)]<br class="calibre33"/>      (aset clone i<br class="calibre33"/>        (doto (aclone (aget clone i))<br class="calibre33"/>          (aset j value)))<br class="calibre33"/>      clone))<br class="calibre33"/>  (rows [matrix]<br class="calibre33"/>    (map vec matrix))<br class="calibre33"/>  (cols [matrix]<br class="calibre33"/>    (apply map vector matrix))<br class="calibre33"/>  (dims [matrix]<br class="calibre33"/>    (let [rs (count matrix)]<br class="calibre33"/>      (if (zero? rs)<br class="calibre33"/>        [0 0]<br class="calibre33"/>        [rs (count (aget matrix 0))]))))</tt></span></p><p class="calibre23"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">This <tt class="calibre22">Class/forName</tt> call allows you to obtain a reference to the <tt class="calibre22">Class</tt> corresponding to two-dimensional arrays of doubles, referred to as <tt class="calibre22">double[][].class</tt> in Java; see <a href="#filepos1613851"><span class="calibre5">“Array classes”</span></a> for more on this notation.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">Arrays are <span class="italic">not</span> immutable, but we provide some degree of immutable semantics through our <tt class="calibre22">Matrix</tt> implementation that uses arrays, so it is as consistent as possible with our previous vector-of-vectors implementation: every update clones the outer array of arrays, clones the affected row, and swaps the clone with the updated value into the top-level array, which is returned. Of course, unrestricted mutability might be desirable for performance-intensive matrices; having separate protocols for such opposing semantics would make sense.</blockquote><p class="calibre13">This implementation will be chosen for us by the protocol machinery based on the type of the first argument provided to each of its functions; here we can see array matrices performing as expected:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def matrix (make-array Double/TYPE 2 3))<br class="calibre33"/>;= #'user/matrix<br class="calibre33"/>(rows matrix)<br class="calibre33"/>;= ([0.0 0.0 0.0]<br class="calibre33"/>;=  [0.0 0.0 0.0])<br class="calibre33"/>(rows (update matrix 1 1 3.4))<br class="calibre33"/>;= ([0.0 0.0 0.0]<br class="calibre33"/>;=  [0.0 3.4 0.0])<br class="calibre33"/>(lookup (update matrix 1 1 3.4) 1 1)<br class="calibre33"/>;= 3.4<br class="calibre33"/>(cols (update matrix 1 1 3.4))<br class="calibre33"/>;= ([0.0 0.0]<br class="calibre33"/>;=  [0.0 3.4]<br class="calibre33"/>;=  [0.0 0.0])<br class="calibre33"/>(dims matrix)<br class="calibre33"/>;= [2 3]</tt></span></blockquote><p class="calibre23">Now it should be clear that, despite fulfilling much the same role as Java interfaces, Clojure protocols are more potent and do not suffer from the dynamic version of the <span class="italic">expression problem</span>: we can bring any preexisting type in to satisfy the contract of our protocols without modifying those types or having any other special access to them.</p><p class="calibre18">However, we have so far only extended protocols to types defined in Java. Thankfully, Clojure provides its own ways of defining new types.<a id="filepos966265"></a></p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos966369"></a><a href="#filepos955862"><span class="calibre32">187</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Java generics don’t exist at the bytecode level, they disappear during compilation—this is known as </span><span class="calibre10"><span class="italic">type erasure</span></span><span class="calibre10"> and as a side effect, makes life simpler for implementors of dynamic languages.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos966801"></a><a href="#filepos957584"><span class="calibre32">188</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">The actual exception type varies depending on the way the protocol was implemented, so don’t rely on it.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos967092"></a><a href="#filepos960672"><span class="calibre32">189</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Factory functions in Clojure fill the role of constructors and static factory methods found elsewhere. Clojure provides a number of factory functions you’ve seen already, e.g., </span><span class="calibre10"><tt class="calibre22">hash-map</tt></span><span class="calibre10">, </span><span class="calibre10"><tt class="calibre22">sorted-set</tt></span><span class="calibre10">, etc., and as we describe in </span><a href="#filepos988434"><span class="calibre10"><span class="calibre5">Constructors and factory functions</span></span></a><span class="calibre10">, you’ll find yourself wanting to define your own as well.</span></p><div class="mbppagebreak"></div><p id="filepos967758" class="calibre6"><span class="calibre4"><span class="bold">Defining Your Own Types</span></span></p><p id="filepos967842" class="calibre18">A Clojure type <span class="italic">is</span> a Java class, although a Clojure type definition is as easy as</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defrecord Point [x y])</tt></span></blockquote><p class="calibre23">or</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(deftype Point [x y])</tt></span></blockquote><p class="calibre23">We’ll discuss the many commonalities that <tt class="calibre22">deftype</tt><a id="filepos968295"></a> and <tt class="calibre22">defrecord</tt><a id="filepos968325"></a> share before diving into what makes each unique.</p><p class="calibre18">Both of these forms define a new Java class <tt class="calibre22">Point</tt>, with two <tt class="calibre22">public</tt> and <tt class="calibre22">final</tt> fields named <tt class="calibre22">x</tt> and <tt class="calibre22">y</tt>. Just like protocols (and unlike other names in Clojure), type names are usually written in <tt class="calibre22">CamelCase</tt> and not in <tt class="calibre22">lower-dashed-case</tt> because they do compile down to Java classes. Creating a new <tt class="calibre22">Point</tt> instance is as simple as calling its constructor—<tt class="calibre22">(Point. 3 4)</tt>—one argument per field in the same order as given upon definition, whether it was defined as a <span class="italic">type</span> or a <span class="italic">record type</span>. Because they are regular fields on Java objects:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Accessing and updating their values is <span class="italic">much</span> faster than the same operations involving, for example, regular Clojure maps.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">You can access fields of <tt class="calibre22">deftype</tt> or <tt class="calibre22">defrecord</tt> instances by using Clojure’s standard field access interop syntax:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos969545"></a><a href="#filepos1003077"><span class="calibre32">190</span></a><span class="calibre32">]</span></small></sup></blockquote></li></ul><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(.x (Point. 3 4))<br class="calibre33"/>;= 3</tt></span></blockquote><p class="calibre23">As-is, each field is typed as a default <tt class="calibre22">java.lang.Object</tt>; this is often perfectly sufficient for many models, and a necessity if the types of some values in your model may vary. However, if you need to, you can declare fields to be primitive types by using the same sort of metadata that is used to declare the types accepted and returned by functions. You can also optionally hint nonprimitive fields as you would hint method calls, although hints do not change the concrete type of the field as seen by, for example, a Java user of the defined type.</p><p class="calibre18">So, this defines a record type that has primitive <tt class="calibre22">long</tt> fields <tt class="calibre22">x</tt> and <tt class="calibre22">y</tt>, and an <tt class="calibre22">Object</tt>
<tt class="calibre22">name</tt> that is hinted as a <tt class="calibre22">String</tt> within any inline method implementations that you might add to the type:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defrecord NamedPoint [^String name ^long x ^long y])</tt></span></blockquote><p class="calibre23">We discuss hinting and type declarations at length in <a href="#filepos1324665"><span class="calibre5">Type Hinting for Performance</span></a> and <a href="#filepos1591810"><span class="calibre5">Declare Functions to Take and Return Primitives</span></a>, respectively, though neither are critical to building a fundamental understanding of how <tt class="calibre22">deftype</tt> and <tt class="calibre22">defrecord</tt> work.</p><p class="calibre18">It is sometimes useful to know what fields a particular type requires and provides, especially in the case of records, which can support holding auxiliary fields beyond what are defined for its constructor. This enumeration of defined fields is called a <span class="italic">basis</span>, available via a static method on the class defined by <tt class="calibre22">deftype</tt> or <tt class="calibre22">defrecord</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(NamedPoint/getBasis)<br class="calibre33"/>;= [name x y]</tt></span></blockquote><p class="calibre23">Each symbol within the basis retains the metadata provided in the original vector of fields, including type information:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(map meta (NamedPoint/getBasis))<br class="calibre33"/>;= ({:tag String} {:tag long} {:tag long})</tt></span></blockquote><p class="calibre23">We’ll focus on records first: they are designed to be used to model and represent application-level data,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos972212"></a><a href="#filepos1003486"><span class="calibre32">191</span></a><span class="calibre32">]</span></small></sup> whereas <tt class="calibre22">deftype</tt> types are intended to define low-level infrastructure types, such as when you are implementing a new data structure.</p><p class="calibre18">The differences between the two facilities lie entirely with the defaults that records provide in terms of interoperating with the rest of Clojure and certain Java facilities, and certain capabilities that <tt class="calibre22">deftype</tt> provides that make it possible to optimize the low-level operations that they’re designed to address. In the end, you should find yourself using records far more than <tt class="calibre22">deftype</tt> types for most classes of programs and problems.</p><blockquote class="calibre38"></blockquote><blockquote class="calibre39"><span class="calibre10"><span class="bold">TYPES ARE NOT DEFINED IN NAMESPACES</span></span></blockquote><blockquote id="filepos973122" class="calibre17"><span class="calibre10">When you define a new type with </span><span class="calibre10"><tt class="calibre22">defrecord</tt></span><span class="calibre10"> or </span><span class="calibre10"><tt class="calibre22">deftype</tt></span><span class="calibre10">, the resulting class is defined as being in the Java package corresponding to the current namespace, and it is implicitly imported into the defining namespace, so you can refer to it by its unqualified name. However, when you use this defining namespace from another, types are not imported because they are host classes, </span><span class="calibre10"><span class="italic">not</span></span><span class="calibre10"> vars. </span><span class="calibre10"><span class="italic">You have to explicitly import defined types even if you </span></span><span class="calibre10"><tt class="calibre22"><span class="italic">use</span></tt></span><span class="calibre10"><span class="italic"> or </span></span><span class="calibre10"><tt class="calibre22"><span class="italic">require</span></tt></span><span class="calibre10"><span class="italic"> the defining namespace</span></span><span class="calibre10">.</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(def x "hello")<br class="calibre33"/>;= #'user/hello<br class="calibre33"/>(defrecord Point [x y])<br class="calibre33"/>;= user.Point                       </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre21"><tt class="calibre22"><br class="calibre33"/>(Point. 5 5)<br class="calibre33"/>;= #user.Point{:x 5, :y 5}<br class="calibre33"/>(ns user2)<br class="calibre33"/>(refer 'user)                       </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre21"><tt class="calibre22"><br class="calibre33"/>x                                   </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre21"><tt class="calibre22"><br class="calibre33"/>;= "hello"<br class="calibre33"/>Point                               </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre21"><tt class="calibre22"><br class="calibre33"/>;= CompilerException java.lang.Exception:<br class="calibre33"/>;=   Unable to resolve symbol: Point<br class="calibre33"/>(import 'user.Point)                </tt></span><a></a><img src="images/00001.jpg" class="calibre36"/><span class="calibre21"><tt class="calibre22"><br class="calibre33"/>Point<br class="calibre33"/>;= user.Point</tt></span></blockquote><blockquote class="calibre38"><img src="images/00011.jpg" class="calibre36"/><span class="calibre10">
</span></blockquote><blockquote class="calibre37"><span class="calibre10">Defining a type </span><span class="calibre10"><tt class="calibre22">Point</tt></span><span class="calibre10"> while in the </span><span class="calibre10"><tt class="calibre22">user</tt></span><span class="calibre10"> namespace defines a new Java class </span><span class="calibre10"><tt class="calibre22">user.Point</tt></span><span class="calibre10">. That type’s unqualified name can be used directly because it is implicitly imported into the current namespace.</span></blockquote><blockquote class="calibre35"><img src="images/00007.jpg" class="calibre36"/><span class="calibre10">
</span></blockquote><blockquote class="calibre37"><span class="calibre10"><tt class="calibre22">refer</tt></span><span class="calibre10"> is similar to </span><span class="calibre10"><tt class="calibre22">use</tt></span><span class="calibre10">, but without the loading semantics—it presupposes the namespace already exists.</span></blockquote><blockquote class="calibre35"><img src="images/00003.jpg" class="calibre36"/><span class="calibre10">
</span></blockquote><blockquote class="calibre37"><span class="calibre10"><tt class="calibre22">x</tt></span><span class="calibre10"> is now </span><span class="calibre10"><span class="italic">referred</span></span><span class="calibre10"> in the current namespace (</span><span class="calibre10"><tt class="calibre22">user2</tt></span><span class="calibre10">).</span></blockquote><blockquote class="calibre35"><img src="images/00013.jpg" class="calibre36"/><span class="calibre10">
</span></blockquote><blockquote class="calibre37"><span class="calibre10"><tt class="calibre22">Point</tt></span><span class="calibre10"> is not available though.</span></blockquote><blockquote class="calibre35"><img src="images/00001.jpg" class="calibre36"/><span class="calibre10">
</span></blockquote><blockquote class="calibre37"><span class="calibre10"><tt class="calibre22">Point</tt></span><span class="calibre10">, being a class, needs to be </span><span class="calibre10"><span class="italic">imported</span></span><span class="calibre10"> in the current namespace in order to refer to it via its short name.</span></blockquote><blockquote class="calibre17"><span class="calibre10">You can learn about the finer points of Clojure namespaces in </span><a href="#filepos1134534"><span class="calibre10"><span class="calibre5">Defining and Using Namespaces</span></span></a><span class="calibre10">.</span></blockquote><p id="filepos977618" class="calibre99"><span class="calibre19"><span class="bold"><span class="calibre5">Records</span></span></span></p><p id="filepos977716" class="calibre18">Often called <span class="italic">record types</span>, types defined by <tt class="calibre22">defrecord</tt><a id="filepos977813"></a> are a specialization of those defined by <tt class="calibre22">deftype</tt>. Additional facilities provided by records include:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Value semantics</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Full participation in the associative collection abstraction</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Metadata support</blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17">Reader support, so instances of record types can be created by simply reading data</blockquote></li><li value="5" class="calibre16"><blockquote class="calibre17">An additional convenience constructor for creating records with metadata and auxiliary fields as desired</blockquote></li></ul><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Clojure retains a vestigial “struct” map implementation—via the </span><a id="filepos978983"></a><span class="calibre10"><tt class="calibre22">defstruct</tt></span><span class="calibre10">, </span><span class="calibre10"><tt class="calibre22">create-struct</tt></span><span class="calibre10">, </span><span class="calibre10"><tt class="calibre22">struct-map</tt></span><span class="calibre10">, and </span><span class="calibre10"><tt class="calibre22">struct</tt></span><span class="calibre10"> functions—that should be considered deprecated at this point, and avoided. If you want a flexible struct, maps will often do just fine, as we described in </span><a href="#filepos459863"><span class="calibre10"><span class="calibre5">Maps as ad-hoc structs</span></span></a><span class="calibre10">; alternatively, if you need them, records are superior to the older </span><span class="calibre10"><tt class="calibre22">struct-map</tt></span><span class="calibre10"> implementation in every way. We’ll talk about how to choose among these options in </span><a href="#filepos993043"><span class="calibre10"><span class="calibre5">When to use maps or records</span></span></a><span class="calibre10">.</span></blockquote><p class="calibre25"><span class="bold">Value semantics</span>. <span class="italic">Value semantics</span><a id="filepos979962"></a> implies two things: records are immutable, and, given two records whose fields are equal, those two records are themselves equal:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defrecord Point [x y])<br class="calibre33"/>;= user.Point<br class="calibre33"/>(= (Point. 3 4) (Point. 3 4))<br class="calibre33"/>;= true<br class="calibre33"/>(= 3 3N)<br class="calibre33"/>;= true<br class="calibre33"/>(= (Point. 3N 4N) (Point. 3 4))<br class="calibre33"/>;= true</tt></span></blockquote><p class="calibre23">You should be used to such semantics from working with Clojure’s data structures, which make the same guarantees. Records achieve this by automatically providing correct and consistent implementations of <tt class="calibre22">Object.equals</tt> and <tt class="calibre22">Object.hashCode</tt> that are dependent upon the values of records’ fields.</p><p id="filepos980739" class="calibre18"><span class="bold">Records are associative collections</span>. Records participate in the associative abstraction,<a id="filepos980863"></a><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos980905"></a><a href="#filepos1003748"><span class="calibre32">192</span></a><span class="calibre32">]</span></small></sup> so you can use with records all of the facilities you’re used to using with maps.</p><p class="calibre18">For example, while the fields of both types and records may be accessed using interop forms like <tt class="calibre22">(.x instance)</tt>, record fields can be accessed by functions—specifically, keywords, which as we saw in <a href="#filepos438207"><span class="calibre5">Concise Collection Access</span></a>, are functions that look themselves up in the associative collection that they are called with. Such calls work just the same with records as you would expect when working with maps:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(:x (Point. 3 4))                  </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= 3<br class="calibre33"/>(:z (Point. 3 4) 0)                </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= 0<br class="calibre33"/>(map :x [(Point. 3 4)<br class="calibre33"/>         (Point. 5 6)<br class="calibre33"/>         (Point. 7 8)])<br class="calibre33"/>;= (3 5 7)</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Note that when the keyword <a id="filepos982338"></a>is explicit and its literal placed in function position, the compiler is able to optimize the access down to levels close to the <tt class="calibre22">(.x instance)</tt> raw field dereference.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">Default values for keywords that have no corresponding value in a record work as well.</blockquote><p class="calibre18">Further, updating a field value is as simple as calling <tt class="calibre22">assoc</tt> on it, and all the rest of the associative and collection functions are at your disposal including <tt class="calibre22">keys</tt>, <tt class="calibre22">get</tt>, <tt class="calibre22">seq</tt>, <tt class="calibre22">conj</tt>, <tt class="calibre22">into</tt>, and so on. And, just like maps, records implement Java’s <tt class="calibre22">java.util.Map</tt> interface, so you can pass records to Java APIs that expect to read data out of a <tt class="calibre22">Map</tt> instance.</p><p class="calibre18">While records are defined with a fixed set of fields, you can still associate new slots into a record that are not part of that initial set:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos983433"></a><a href="#filepos1004164"><span class="calibre32">193</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(assoc (Point. 3 4) :z 5)                         </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #user.Point{:x 3, :y 4, :z 5}<br class="calibre33"/>(let [p (assoc (Point. 3 4) :z 5)]                </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  (dissoc p :x))<br class="calibre33"/>;= {:y 4, :z 5}<br class="calibre33"/>(let [p (assoc (Point. 3 4) :z 5)]                </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  (dissoc p :z))<br class="calibre33"/>;= #user.Point{:x 3, :y 4}</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">A record can be extended with additional slots.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">dissoc</tt><a id="filepos984698"></a>iating a declared field produces a return value that is a simple map, not a record.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">However, <tt class="calibre22">dissoc</tt>iating an auxiliary slot does not degenerate the return value into a simple map.</blockquote><p class="calibre18">Note that these additional slots are kept “off to the side” from a record’s predefined fields in a regular Clojure hash map of their own, and have corresponding lookup and update performance characteristics; that is, they do not somehow become new fields on the record’s underlying Java class:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(:z (assoc (Point. 3 4) :z 5))<br class="calibre33"/>;= 5<br class="calibre33"/>(.z (assoc (Point. 3 4) :z 5))<br class="calibre33"/>;= #&lt;java.lang.IllegalArgumentException:<br class="calibre33"/>;=   No matching field found: z for class user.Point&gt;</tt></span></blockquote><p class="calibre23"><span class="bold">Metadata support</span>. <a id="filepos985747"></a>Just as with other Clojure collections, you can retrieve and set metadata on records using <tt class="calibre22">meta</tt> and <tt class="calibre22">with-meta</tt> (and <tt class="calibre22">vary-meta</tt> as a consequence) without impacting records’ value semantics:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(-&gt; (Point. 3 4)<br class="calibre33"/>  (with-meta {:foo :bar})<br class="calibre33"/>  meta)<br class="calibre33"/>;= {:foo :bar}</tt></span></blockquote><p class="calibre23">See <a href="#filepos512813"><span class="calibre5">Metadata</span></a> for an overview of metadata and its use cases.</p><p id="filepos986303" class="calibre18"><span class="bold">Readable representation</span>. You may have noticed that the REPL prints record instances with a particular syntax, distinct from regular Clojure maps and different again from arbitrary Java objects:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">#user.Point{:x 3, :y 4, :z 5}</tt></span></blockquote><p class="calibre23">This is a record literal, the equivalent of square brackets used to denote vectors, colon-prefixed symbols to denote keywords, and so on. This means that you can print and read record instances to and from their textual representation just like any other Clojure literal:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(pr-str (assoc (Point. 3 4) :z [:a :b]))<br class="calibre33"/>;= "#user.Point{:x 3, :y 4, :z [:a :b]}"<br class="calibre33"/>(= (read-string *1)<br class="calibre33"/>   (assoc (Point. 3 4) :z [:a :b]))<br class="calibre33"/>;= true</tt></span></blockquote><p class="calibre23">This makes it just as easy to use records to store and retrieve data (in a file or database or other) as it is with any other value supported by the Clojure reader.</p><p class="calibre18"><span class="bold">Auxiliary constructor</span>. <a id="filepos987493"></a>In addition to a constructor that accepts the defined fields of the type, records also offer a constructor that reflects some of their additional capabilities; namely, field extensibility and metadata support. This second constructor expects two extra arguments: a map containing slots beyond the fields specified when the record type was defined, and a map of metadata to attach to the created record:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(Point. 3 4 {:foo :bar} {:z 5})<br class="calibre33"/>;= #user.Point{:x 3, :y 4, :z 5}<br class="calibre33"/>(meta *1)<br class="calibre33"/>;= {:foo :bar}</tt></span></blockquote><p class="calibre23">This is semantically equivalent (and more efficient) than modifying a base record instance one step at a time like so:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(-&gt; (Point. 3 4)<br class="calibre33"/>  (with-meta {:foo :bar})<br class="calibre33"/>  (assoc :z 5))</tt></span></blockquote><p id="filepos988434" class="calibre23"><span class="calibre53"><span class="bold">Constructors and factory functions</span></span></p><p id="filepos988529" class="calibre18">Constructors should generally not be part of your public API. Instead, you should provide one or more factory functions so that:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">You can match the expected usage of callers, which is not necessarily provided for by the oftentimes too low-level constructors generated by an underlying model’s <tt class="calibre22">deftype</tt> and <tt class="calibre22">defrecord</tt> forms.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">You can apply such factory functions in a higher-order fashion to easily produce type and record instances from gobs of “regular” Clojure data.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">You can maximize API stability for callers even if the underlying model implementations change.</blockquote></li></ol><p class="calibre18">A factory will not be as brittle as constructors to code change: as soon as you change a record type’s list of fields, you change its constructor’s signature, whereas factories allow you to add logic such as validation of arguments or producing derived or default field values. Clojure types don’t allow you to define custom constructors, so anything that you would put into the body of a constructor in other languages needs to be placed into factory functions in Clojure.</p><p class="calibre18">Both <tt class="calibre22">deftype</tt> and <tt class="calibre22">defrecord</tt> implicitly create one factory function of the form <tt class="calibre22">-&gt;MyType</tt> that accepts field values positionally:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(-&gt;Point 3 4)<br class="calibre33"/>;= #user.Point{:x 3, :y 4}</tt></span></blockquote><p class="calibre23">Records also emit a second factory function of the form <tt class="calibre22">map-&gt;MyType</tt>, which accepts a single map that is used for populating the new record instance:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(map-&gt;Point {:x 3, :y 4, :z 5})<br class="calibre33"/>;= #user.Point{:x 3, :y 4, :z 5}</tt></span></blockquote><p class="calibre23">These are both useful for creating type and record instances from Clojure data, especially in conjunction with higher-order functions:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(apply -&gt;Point [5 6])<br class="calibre33"/>;= #user.Point{:x 5, :y 6}<br class="calibre33"/><br class="calibre33"/>(map (partial apply -&gt;Point) [[5 6] [7 8] [9 10]])<br class="calibre33"/>;= (#user.Point{:x 5, :y 6}<br class="calibre33"/>;=  #user.Point{:x 7, :y 8}<br class="calibre33"/>;=  #user.Point{:x 9, :y 10})<br class="calibre33"/><br class="calibre33"/>(map map-&gt;Point [{:x 1 :y 2} {:x 5 :y 6 :z 44}])<br class="calibre33"/>;= (#user.Point{:x 1, :y 2}<br class="calibre33"/>;=  #user.Point{:x 5, :y 6, :z 44})</tt></span></blockquote><p class="calibre23">For records, the map-based factory is also accessible as the static method <tt class="calibre22">create</tt> on the type, which can be a great help for Java consumers of libraries and types you define in Clojure:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(Point/create {:x 3, :y 4, :z 5})<br class="calibre33"/>;= #user.Point{:x 3, :y 4, :z 5}</tt></span></blockquote><p class="calibre23">While these provided factories are helpful, you’ll still need to roll your own as soon as you need to add logic, derived fields, or validations to a factory function:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn log-point<br class="calibre33"/>  [x]<br class="calibre33"/>  {:pre [(pos? x)]}<br class="calibre33"/>  (Point. x (Math/log x)))<br class="calibre33"/><br class="calibre33"/>(log-point -42)<br class="calibre33"/>;= #&lt;AssertionError java.lang.AssertionError: Assert failed: (pos? x)&gt;<br class="calibre33"/>(log-point Math/E)<br class="calibre33"/>;= #user.Point{:x 2.718281828459045, :y 1.0}</tt></span></blockquote><p class="calibre23">Oftentimes, factories occur spontaneously in the writing process as an intermediate step between maps and records where you first start refactoring <a id="filepos992518"></a>your code by introducing factories, which produce simple maps to make your code clearer. Such as:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn point [x y]<br class="calibre33"/>  {:x x, :y y})</tt></span></blockquote><p class="calibre23">When you later want to switch to records for a given type, you only have to rewrite the factory function to use your new record type. This thankfully often allows client code referencing the factory function to continue unchanged and unaware of the shift.</p><p id="filepos993043" class="calibre23"><span class="calibre53"><span class="bold">When to use maps or records</span></span></p><p id="filepos993131" class="calibre18">While there are excellent use cases for records,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos993242"></a><a href="#filepos1004611"><span class="calibre32">194</span></a><span class="calibre32">]</span></small></sup> it is often preferable to approach problems using regular maps first, moving on to records later as circumstances warrant.</p><p class="calibre18">Maps are the simplest way to get started writing code and modeling data because maps do not force you to predefine any types or schema at all, thus giving you more conceptual latitude when prototyping a feature. However, as soon as you perceive the need for type-based polymorphism <a id="filepos993774"></a>(available via protocols for records and types) or performance-sensitive field access, you can switch to records and be done: most of your code (if not all) will work as is because of the abstractions shared between maps and records.</p><p class="calibre18">One pitfall when switching from maps to records is that <span class="italic">records are not functions</span>.<a id="filepos994135"></a> So, <tt class="calibre22">((Point. 3 4) :x)</tt> will not work, while <tt class="calibre22">({:x 5 :y 6} :x)</tt> will. However, if you follow the recommendations in <a href="#filepos438207"><span class="calibre5">Concise Collection Access</span></a> on when it is appropriate to use maps as functions, there should be no overlap between the kind of maps used as functions and the kind of maps replaced by records.</p><p class="calibre18">Another trap is that maps and records can never be equal, so you have to pay extra attention when mixing maps and records to represent the same data.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defrecord Point [x y])<br class="calibre33"/>;= user.Point<br class="calibre33"/>(= (Point. 3 4) (Point. 3 4))<br class="calibre33"/>;= true<br class="calibre33"/>(= {:x 3 :y 4} (Point. 3 4))<br class="calibre33"/>;= false<br class="calibre33"/>(= (Point. 3 4) {:x 3 :y 4}) </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= false</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Clojure is thankfully well-behaved, and doesn’t break the symmetric property of equality.<a id="filepos995354"></a></blockquote><p id="filepos995374" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Types</span></span></span></p><p class="calibre18"><tt class="calibre22">deftype</tt><a id="filepos995513"></a> is the lowest-level type definition form in Clojure—in fact, <tt class="calibre22">defrecord</tt> is really just a macro that builds on top of <tt class="calibre22">deftype</tt><a id="filepos995664"></a>. As you might expect, many of the “creature comforts” of records are unavailable in types defined with <tt class="calibre22">deftype</tt>. It is fundamentally intended to be used to define low-level infrastructure types, as might be needed for implementing a new data structure or reference type; in contrast, maps and records should be used to house your application-level data.</p><p class="calibre18">What this low-level type form does offer is one key facility that is <span class="italic">sometimes</span> unavoidable at the lowest levels of an application or library: mutable fields!</p><p class="calibre18">Before jumping to mutable fields, let’s first clarify that normal (immutable) field access with <tt class="calibre22">deftype</tt> instances is <span class="italic">only</span> possible via interop forms:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(deftype Point [x y])<br class="calibre33"/>;= user.Point<br class="calibre33"/>(.x (Point. 3 4))<br class="calibre33"/>;= 3<br class="calibre33"/>(:x (Point. 3 4))<br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre23"><tt class="calibre22">deftype</tt> types are not associative,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos996758"></a><a href="#filepos1004966"><span class="calibre32">195</span></a><span class="calibre32">]</span></small></sup> and so the most common pattern of using keywords as accessor functions is unavailable. Thus, we must rely upon the fact that types compile down to Java classes, with each immutable field in that class being defined as publicly available and <tt class="calibre22">final</tt>.</p><p class="calibre18">Mutable fields <a id="filepos997157"></a>come in two flavors: volatile or unsynchronized. To declare a field as mutable, you have to qualify it with the metadata <a id="filepos997285"></a><tt class="calibre22">^:volatile-mutable</tt> or <tt class="calibre22">^:unsynchronized-mutable</tt>, e.g.:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(deftype MyType [^:volatile-mutable fld])</tt></span></blockquote><p class="calibre23">This <tt class="calibre22">*-mutable</tt> metadata will compose without a problem with any field type declarations you may need to use.</p><p class="calibre18">“Volatile” here has the same meaning as the <tt class="calibre22">volatile</tt> field modifier in Java: reads and writes are atomic<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos997821"></a><a href="#filepos1005500"><span class="calibre32">196</span></a><span class="calibre32">]</span></small></sup> and must be executed in program order; i.e., they cannot be reordered by the JIT compiler or by the CPU. Volatiles are thus unsurprising and thread-safe—but uncoordinated and still entirely open to race conditions.</p><p class="calibre18">On the other hand, an unsynchronized field is a “regular” Java mutable field whose use will be thread-safe only under the guard of a lock<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos998341"></a><a href="#filepos1005924"><span class="calibre32">197</span></a><span class="calibre32">]</span></small></sup>…or in the most expert of hands.</p><p class="calibre18">While immutable fields <a id="filepos998525"></a>are public, <span class="italic">mutable fields are always private</span> and only accessible from within method bodies provided inline with the type definition. Inline implementations will be covered in detail in <a href="#filepos1007944"><span class="calibre5">Implementing Protocols</span></a>; for now it will suffice to provide a simple example of a type that contains a single mutable field and implements the sole method of the Clojure interface that defines the <tt class="calibre22">deref</tt> abstraction, <tt class="calibre22">IDeref</tt>:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos999055"></a><a href="#filepos1006386"><span class="calibre32">198</span></a><span class="calibre32">]</span></small></sup></p><p id="filepos999154" class="calibre18"><span class="bold">Schrödinger’s cat</span>. </p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(deftype SchrödingerCat [^:unsynchronized-mutable state]<br class="calibre33"/>  clojure.lang.IDeref<br class="calibre33"/>  (deref [sc]<br class="calibre33"/>    (locking sc<br class="calibre33"/>      (or state<br class="calibre33"/>        (set! state (if (zero? (rand-int 2))<br class="calibre33"/>                      :dead<br class="calibre33"/>                      :alive))))))<br class="calibre33"/><br class="calibre33"/>(defn schrödinger-cat<br class="calibre33"/> "Creates a new Schrödinger's cat. Beware, the REPL may kill it!"<br class="calibre33"/> []<br class="calibre33"/> (SchrödingerCat. nil))<br class="calibre33"/><br class="calibre33"/>(def felix (schrödinger-cat))<br class="calibre33"/>;= #'user/felix                       </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>@felix                                </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= :dead<br class="calibre33"/>(schrödinger-cat)<br class="calibre33"/>;= #&lt;SchrödingerCat@3248bc64: :dead&gt;<br class="calibre33"/>(schrödinger-cat)<br class="calibre33"/>;= #&lt;SchrödingerCat@3248bc64: :alive&gt;</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Felix is still both alive and dead…</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">…until we—or the REPL—kill him (or ensure his survival) as a side effect of dereferencing.</blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">MUTABLE FIELDS OR REFERENCE/DATAFLOW TYPES?</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Because the state of our </span><span class="calibre10"><tt class="calibre22">SchrödingerCat</tt></span><span class="calibre10"> is not determined until we “look in the box,” it is equivalent to</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(delay (if (zero? (rand-int 2))<br class="calibre33"/>         :dead<br class="calibre33"/>         :alive))</tt></span></blockquote><blockquote class="calibre35"><span class="calibre10">Most of the time, an application’s mutability needs can be satisfied by Clojure’s reference types (agents, atoms, and refs), dataflow types (futures, promises, and delays), or judicious use of </span><span class="calibre10"><tt class="calibre22">java.util.concurrent</tt></span><span class="calibre10"> classes. Using such facilities—all described in </span><a href="#filepos593810"><span class="calibre10"><span class="calibre5">Chapter 4</span></span></a><span class="calibre10">—is a far more satisfying option than touching mutable fields: they eliminate large swaths of complexity, focus mutability among a limited set of loci, and generally cut away opportunities for you to cause problems for yourself. In short, don’t rush for mutable fields when you have better tools at hand!</span></blockquote><p class="calibre25">As we can see above, setting a mutable field can be done by simply <tt class="calibre22">set!</tt>-ing the field as named in the <tt class="calibre22">deftype</tt> field vector with a new value, that is, a <tt class="calibre22">(set! field value)</tt>.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1002520"></a><a href="#filepos1006954"><span class="calibre32">199</span></a><span class="calibre32">]</span></small></sup> A mutable field can be accessed within the body of an implementation simply by referring to it.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1002746"></a><a href="#filepos1007409"><span class="calibre32">200</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">Now that we understand the different sorts of types in Clojure, we can resume our tour of protocols.<a id="filepos1002973"></a></p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1003077"></a><a href="#filepos969545"><span class="calibre32">190</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Records provide a more flexible abstraction for field access, which we describe in </span><a href="#filepos980739"><span class="calibre10"><span class="calibre5">“Records are associative collections”</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1003486"></a><a href="#filepos972212"><span class="calibre32">191</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">You might say that records and maps are the “POJO”s of the Clojure world.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1003748"></a><a href="#filepos980905"><span class="calibre32">192</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Defined by the </span><span class="calibre10"><tt class="calibre22">clojure.lang.Associative</tt></span><span class="calibre10"> interface and described in </span><a href="#filepos387941"><span class="calibre10"><span class="calibre5">Associative</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1004164"></a><a href="#filepos983433"><span class="calibre32">193</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">This characteristic, where a type or object with a fixed set of predefined fields can be “expanded” to include other values, is sometimes referred to in other languages and frameworks as an </span><span class="calibre10"><span class="italic">expando</span></span><span class="calibre10"> property.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1004611"></a><a href="#filepos993242"><span class="calibre32">194</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="#filepos2042853"><span class="calibre10"><span class="calibre5">Chapter 18</span></span></a><span class="calibre10"> for a diagram to help guide your thinking in this area.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1004966"></a><a href="#filepos996758"><span class="calibre32">195</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Unless you were to define a type that implements Clojure’s </span><span class="calibre10"><tt class="calibre22">clojure.lang.Associative</tt></span><span class="calibre10"> interface; we'll tackle something very similar to this in </span><a href="#filepos1046777"><span class="calibre10"><span class="calibre5">Participating in Clojure’s Collection Abstractions</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1005500"></a><a href="#filepos997821"><span class="calibre32">196</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">According to the </span><span class="calibre10"><span class="italic">Java Memory Model</span></span><span class="calibre10">, writes to </span><span class="calibre10"><span class="italic">nonvolatile</span></span><span class="calibre10"> long or double fields are not guaranteed to be atomic. See JSR-133, section 11.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1005924"></a><a href="#filepos998341"><span class="calibre32">197</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">If you’re brave enough—and need wildly mutable fields badly enough—you can use the </span><span class="calibre10"><tt class="calibre22">locking</tt></span><span class="calibre10"> macro, described in </span><a href="#filepos829168"><span class="calibre10"><span class="calibre5">Locking</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1006386"></a><a href="#filepos999055"><span class="calibre32">198</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Any type that implements </span><span class="calibre10"><tt class="calibre22">IDeref</tt></span><span class="calibre10"> may be dereferenced with </span><span class="calibre10"><tt class="calibre22">deref</tt></span><span class="calibre10"> and therefore with the </span><span class="calibre10"><tt class="calibre22">@</tt></span><span class="calibre10"> reader syntax, described in the </span><a href="#filepos597825"><span class="calibre10"><span class="calibre5">Note</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1006954"></a><a href="#filepos1002520"><span class="calibre32">199</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">This is the equivalent of </span><span class="calibre10"><tt class="calibre22">this.field = value</tt></span><span class="calibre10"> in Java, </span><span class="calibre10"><tt class="calibre22">self.field = value</tt></span><span class="calibre10"> in Python, and </span><span class="calibre10"><tt class="calibre22">@field = value</tt></span><span class="calibre10"> in Ruby.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1007409"></a><a href="#filepos1002746"><span class="calibre32">200</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Mutable fields in method body implementations behave like local bindings; that is, you can refer to them directly instead of doing something like </span><span class="calibre10"><tt class="calibre22">(.x this)</tt></span><span class="calibre10">, and you can shadow their names just as easily as “real” local bindings established by </span><span class="calibre10"><tt class="calibre22">let</tt></span><span class="calibre10"> or in the argument vector of a function.</span></p><div class="mbppagebreak"></div><p id="filepos1007944" class="calibre6"><span class="calibre4"><span class="bold">Implementing Protocols</span></span></p><p id="filepos1008027" class="calibre18">There are two ways to implement a protocol for any given type:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">Provide implementations for protocol methods when a type is initially defined via <tt class="calibre22">deftype</tt> or <tt class="calibre22">defrecord</tt>; this is called <span class="italic">inline implementation</span>.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Use the <tt class="calibre22">extend*</tt> functions to register implementations for a type with the protocol.</blockquote></li></ol><p class="calibre18">Let’s contrast the two approaches in Examples <a href="#filepos1008958"><span class="calibre5">6-3</span></a> and <a href="#filepos1009665"><span class="calibre5">6-4</span></a> through implementing the <tt class="calibre22">Matrix</tt> protocol for the <tt class="calibre22">Point</tt> record type, where we’ll consider a point to be a 2×1 matrix:<a id="filepos1008947"></a></p><p id="filepos1008958" class="calibre23"></p><p class="calibre23"><span class="italic">Example 6-3. Implementing a protocol inline</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(defrecord Point [x y]<br class="calibre33"/>  Matrix<br class="calibre33"/>  (lookup [pt i j]<br class="calibre33"/>    (when (zero? j)<br class="calibre33"/>      (case i<br class="calibre33"/>        0 x<br class="calibre33"/>        1 y)))<br class="calibre33"/>  (update [pt i j value]<br class="calibre33"/>    (if (zero? j)<br class="calibre33"/>      (condp = i<br class="calibre33"/>        0 (Point. value y)<br class="calibre33"/>        1 (Point. x value))<br class="calibre33"/>      pt))<br class="calibre33"/>  (rows [pt] [[x] [y]])<br class="calibre33"/>  (cols [pt] [[x y]])<br class="calibre33"/>  (dims [pt] [2 1]))</tt></span></p><p id="filepos1009665" class="calibre13"></p><p class="calibre23"><span class="italic">Example 6-4. Extending a protocol to an already-defined type</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(defrecord Point [x y])<br class="calibre33"/><br class="calibre33"/>(extend-protocol Matrix<br class="calibre33"/>  Point<br class="calibre33"/>  (lookup [pt i j]<br class="calibre33"/>    (when (zero? j)<br class="calibre33"/>      (case i<br class="calibre33"/>        0 (:x pt)<br class="calibre33"/>        1 (:y pt))))<br class="calibre33"/>  (update [pt i j value]<br class="calibre33"/>    (if (zero? j)<br class="calibre33"/>      (condp = i<br class="calibre33"/>        0 (Point. value (:y pt))<br class="calibre33"/>        1 (Point. (:x pt) value))<br class="calibre33"/>      pt))<br class="calibre33"/>  (rows [pt]<br class="calibre33"/>    [[(:x pt)] [(:y pt)]])<br class="calibre33"/>  (cols [pt]<br class="calibre33"/>    [[(:x pt) (:y pt)]])<br class="calibre33"/>  (dims [pt] [2 1]))</tt></span></p><p class="calibre13">A minor difference between the two approaches is how you access field values: when you extend a type externally you have to access the types’ fields using keywords (or interop forms like <tt class="calibre22">(.x pt)</tt>), while when you provide inline implementations, you can directly refer to field values by their name since they are in the lexical scope.</p><p class="calibre18">Beyond that, the differences between inline implementation and using <tt class="calibre22">extend-*</tt> functions are legion.</p><p id="filepos1011033" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Inline Implementation</span></span></span></p><p id="filepos1011144" class="calibre18">Generally, inline implementations provide better performance for two reasons: they have direct access to the type’s fields, and calling protocol methods will be as fast as calling an interface method in Java.</p><p class="calibre18">Because each protocol is backed by a Java interface, implementing a protocol’s methods inline results in a class that implements the protocol’s corresponding interface, where you define that class’s method bodies in those inline implementations. Furthermore, each call site of a protocol function first performs a test against the backing interface, which triggers the fastest path when it’s available: a regular method call, something the JVM can recognize and is built to optimize aggressively.</p><p class="calibre18">However, some of that underlying machinery can poke through when using inline implementations; namely, clashes can occur between protocol methods with the same name and signature. You can’t provide inline implementations for two protocols whose method signatures conflict, nor even one protocol whose method signatures conflict with any <tt class="calibre22">java.lang.Object</tt> methods, or perhaps most confusingly, if you attempt to provide an inline implementation for any of the interfaces for which <tt class="calibre22">defrecord</tt> automatically provides implementations, including <tt class="calibre22">java.util.Map</tt>, <tt class="calibre22">java.io.Serializable</tt>, <tt class="calibre22">clojure.lang.IPersistentMap</tt>, and others. In such cases, an error will be thrown:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defprotocol ClashWhenInlined<br class="calibre33"/>  (size [x]))<br class="calibre33"/>;= ClashWhenInlined<br class="calibre33"/>(defrecord R []<br class="calibre33"/>  ClashWhenInlined<br class="calibre33"/>  (size [x]))                      </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #&lt;CompilerException java.lang.ClassFormatError:<br class="calibre33"/>;=   Duplicate method name&amp;signature in class file user/R, <br class="calibre33"/>  compiling:(NO_SOURCE_PATH:1)&gt;<br class="calibre33"/><br class="calibre33"/>(defrecord R [])<br class="calibre33"/>;= user.R<br class="calibre33"/>(extend-type R                     </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  ClashWhenInlined<br class="calibre33"/>  (size [x]))<br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">This is going to clash with the <tt class="calibre22">size</tt> method that is defined in <tt class="calibre22">java.util.Map</tt>, which is automatically implemented by records.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">All is well when we use <tt class="calibre22">extend-type</tt><a id="filepos1014015"></a> to register an implementation for our record type with the protocol, because that extension does not impact the construction of the <tt class="calibre22">R</tt> type—it isn’t retroactively modified to implement the interface backing the protocol.</blockquote><p class="calibre18">Because inline extensions are baked into the type produced by <tt class="calibre22">deftype</tt><a id="filepos1014374"></a> or <tt class="calibre22">defrecord</tt><a id="filepos1014403"></a>, you cannot change those implementations at runtime without redefining the whole type. Doing so further means that you must reevaluate all code that directly depends on the type in question.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1014636"></a><a href="#filepos1034190"><span class="calibre32">201</span></a><span class="calibre32">]</span></small></sup> However, the most pernicious problem with inline implementations is that, because <tt class="calibre22">deftype</tt> and <tt class="calibre22">defrecord</tt> each create and define a new type, existing objects that predate the updated type will <span class="italic">never</span> utilize any updated inline implementations.</p><p class="calibre18">Thus, inline implementations, while tempting because they appear so familiar (methods in classes!), are more static than other protocol extension mechanisms, and are best kept as an optimizing step.</p><p class="calibre18">The exception to this general rule is that inline implementation is the only way for a Clojure type to implement Java interfaces.</p><p id="filepos1015392" class="calibre23"><span class="calibre53"><span class="bold">Inline implementations of Java interfaces</span></span></p><p id="filepos1015494" class="calibre18">Since inline implementation of a protocol is simply implementing a protocol’s corresponding Java interface<a id="filepos1015630"></a>, the exact same approach can be used to implement methods of <span class="italic">any</span> Java interface, and as a special case, methods of <tt class="calibre22">java.lang.Object</tt>.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1015821"></a><a href="#filepos1034632"><span class="calibre32">202</span></a><span class="calibre32">]</span></small></sup> Just as with protocols, you are not required to implement all methods of an interface; exception-throwing stubs are generated for any unsupported methods.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(deftype MyType [a b c]<br class="calibre33"/>  java.lang.Runnable<br class="calibre33"/>  (run [this] ...)<br class="calibre33"/>  Object<br class="calibre33"/>  (equals [this that] ...)<br class="calibre33"/>  (hashCode [this] ...)<br class="calibre33"/>  Protocol1<br class="calibre33"/>  (method1 [this ...] ...)<br class="calibre33"/>  Protocol2<br class="calibre33"/>  (method2 [this ...] ...)<br class="calibre33"/>  (method3 [this ...] ...))</tt></span></blockquote><p class="calibre23">Being able to extend <tt class="calibre22">Object</tt> base methods allows you to give value semantics to <tt class="calibre22">Point</tt> even when it’s defined through <tt class="calibre22">deftype</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(deftype Point [x y]<br class="calibre33"/>  Matrix<br class="calibre33"/>  (lookup [pt i j]<br class="calibre33"/>    (when (zero? j)<br class="calibre33"/>      (case i<br class="calibre33"/>        0 x<br class="calibre33"/>        1 y)))<br class="calibre33"/>  (update [pt i j value]<br class="calibre33"/>    (if (zero? j)<br class="calibre33"/>      (case i<br class="calibre33"/>        0 (Point. value y)<br class="calibre33"/>        1 (Point. x value))<br class="calibre33"/>      pt))<br class="calibre33"/>  (rows [pt]<br class="calibre33"/>    [[x] [y]])<br class="calibre33"/>  (cols [pt]<br class="calibre33"/>    [[x y]])<br class="calibre33"/>  (dims [pt]<br class="calibre33"/>    [2 1])<br class="calibre33"/>  Object<br class="calibre33"/>  (equals [this other]<br class="calibre33"/>    (and (instance? (class this) other)    </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>      (= x (.x other)) (= y (.y other))))<br class="calibre33"/>  (hashCode [this]<br class="calibre33"/>    (-&gt; x hash (hash-combine y))))</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Inline implementations cannot refer to the type being defined.</blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Implementing </span><span class="calibre10"><tt class="calibre22">equals</tt></span><a id="filepos1018158"></a><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">hashCode</tt></span><span class="calibre10"> is as tedious and risky in Clojure as it is in Java—having them implemented for us by </span><span class="calibre10"><tt class="calibre22">defrecord</tt></span><span class="calibre10"> is one of that form’s biggest draws, after all. However, implementing these methods correctly is even a bit trickier for </span><span class="calibre10"><tt class="calibre22">deftype</tt></span><a id="filepos1018566"></a><span class="calibre10"> types because you cannot refer to the type being defined in an inline declaration: if you try to replace </span><span class="calibre10"><tt class="calibre22">(class this)</tt></span><span class="calibre10"> by </span><span class="calibre10"><tt class="calibre22">Point</tt></span><span class="calibre10"> in the previous code, it will compile but </span><span class="calibre10"><tt class="calibre22">(instance? Point other)</tt></span><span class="calibre10"> will always return </span><span class="calibre10"><tt class="calibre22">false</tt></span><span class="calibre10">. This is a known limitation of the current compiler. Other possible workarounds include calling a function from within the inline implementation that </span><span class="calibre10"><span class="italic">can</span></span><span class="calibre10"> refer to the defined class, or to test against an interface (or a protocol) in lieu of a concrete class.</span></blockquote><p id="filepos1019348" class="calibre25"><span class="calibre53"><span class="bold">Defining anonymous types with reify</span></span></p><p id="filepos1019444" class="calibre18">Besides <tt class="calibre22">defrecord</tt> and <tt class="calibre22">deftype</tt> there is one other construct that accepts inline implementations: <tt class="calibre22">reify</tt>.</p><p class="calibre18">Unlike <tt class="calibre22">deftype</tt> and <tt class="calibre22">defrecord</tt>, <tt class="calibre22">reify</tt> is not a top-level form; rather than defining a named type, it evaluates to an <span class="italic">instance</span> of an unnamed type. Essentially, it is a way to create objects that satisfy any protocol (or implement methods of any interface or <tt class="calibre22">Object</tt>). This makes it analogous to anonymous inner classes in Java.</p><p class="calibre18">The overall layout of <tt class="calibre22">reify</tt> is identical to <tt class="calibre22">defrecord</tt> or <tt class="calibre22">deftype</tt>, but without any declaration of fields:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(reify<br class="calibre33"/>  Protocol-or-Interface-or-Object<br class="calibre33"/>  (method1 [this x]<br class="calibre33"/>    (implementation))<br class="calibre33"/>  Another-Protocol-or-Interface<br class="calibre33"/>  (method2 [this x y]<br class="calibre33"/>    (implementation))<br class="calibre33"/>  (method3 [this x]<br class="calibre33"/>    (implementation)))</tt></span></blockquote><p class="calibre23">Just as with types and records, you don’t have to provide implementations for all methods of a given protocol or interface.</p><p class="calibre18">Instances created by <tt class="calibre22">reify</tt> form closures, leaving method implementation bodies with direct access to any local in the lexical scope. This is very useful to create adapters (as in <a href="#filepos1021085"><span class="calibre5">Example 6-5</span></a>) or one-shot instances (as in <a href="#filepos1021543"><span class="calibre5">Example 6-6</span></a>).</p><p id="filepos1021085" class="calibre23"></p><p class="calibre23"><span class="italic">Example 6-5. Adapting a function as an ActionListener</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(defn listener<br class="calibre33"/>  "Creates an AWT/Swing `ActionListener` that delegates to the given function."<br class="calibre33"/>  [f]<br class="calibre33"/>  (reify<br class="calibre33"/>    java.awt.event.ActionListener<br class="calibre33"/>    (actionPerformed [this e]<br class="calibre33"/>      (f e))))</tt></span></p><p id="filepos1021543" class="calibre13"></p><p class="calibre23"><span class="italic">Example 6-6. Using a reified FileFilter implementation to obtain only directory files</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(.listFiles (java.io.File. ".")<br class="calibre33"/>  (reify<br class="calibre33"/>    java.io.FileFilter<br class="calibre33"/>    (accept [this f]<br class="calibre33"/>      (.isDirectory f))))</tt></span></p><p class="calibre13">Such use cases overlap with those of <tt class="calibre22">proxy</tt>,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1022042"></a><a href="#filepos1035343"><span class="calibre32">203</span></a><span class="calibre32">]</span></small></sup> but:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">reify</tt> is simpler: its method implementations are “baked in” just like those provided to <tt class="calibre22">deftype</tt> and <tt class="calibre22">defrecord</tt> forms, so dynamic updates are not directly supported.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">reify</tt> is more limited: it can only satisfy protocols and implement methods of Java interfaces and <tt class="calibre22">Object</tt>. Concrete classes may not be subclassed, whether they are abstract or not.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Because all of <tt class="calibre22">reify</tt>’s method implementations are inlined into the host class, calls to those methods have zero overhead.</blockquote></li><a id="filepos1022991"></a></ul><p id="filepos1023003" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Reusing Implementations</span></span></span></p><p id="filepos1023116" class="calibre18">In the Clojure model of protocols and types, there is no concept of hierarchy. As we’ll see, that is not a limitation, insofar as type-based inheritance is <span class="italic">itself</span> a complicating limitation and Clojure provides a more powerful and flexible alternative.</p><p class="calibre18">Types can only ever satisfy protocols or implement interfaces—there is no way to rely upon type inheritance as in most other languages where you can define a new type that subclasses another concrete type, thereby inheriting the latter’s method implementations. Clojure’s answer to the need to reuse concrete method implementations lays with the function that provides the foundation of the <tt class="calibre22">extend-type</tt> and <tt class="calibre22">extend-protocol</tt> macros: <tt class="calibre22">extend</tt>.</p><p class="calibre18"><tt class="calibre22">extend</tt><a id="filepos1023954"></a> takes as its first argument the type to extend and then an alternation of protocols and <span class="italic">implementation maps</span>, which map method names (as keywords) to functions that implement those methods for the specified type.</p><p class="calibre18">Let’s use <tt class="calibre22">extend</tt> to add <tt class="calibre22">Matrix</tt> implementations for the <tt class="calibre22">Point</tt> record type:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defrecord Point [x y])<br class="calibre33"/><br class="calibre33"/>(extend Point<br class="calibre33"/>  Matrix<br class="calibre33"/>  {:lookup (fn [pt i j]<br class="calibre33"/>             (when (zero? j)<br class="calibre33"/>               (case i<br class="calibre33"/>                 0 (:x pt)<br class="calibre33"/>                 1 (:y pt))))<br class="calibre33"/>   :update (fn [pt i j value]<br class="calibre33"/>             (if (zero? j)<br class="calibre33"/>               (condp = i<br class="calibre33"/>                 0 (Point. value (:y pt))<br class="calibre33"/>                 1 (Point. (:x pt) value))<br class="calibre33"/>               pt))<br class="calibre33"/>   :rows (fn [pt]<br class="calibre33"/>          [[(:x pt)] [(:y pt)]])<br class="calibre33"/>   :cols (fn [pt]<br class="calibre33"/>           [[(:x pt) (:y pt)]])<br class="calibre33"/>   :dims (fn [pt] [2 1]))</tt></span></blockquote><p class="calibre23">Since <tt class="calibre22">extend</tt> is a function and not a macro like <tt class="calibre22">extend-type</tt> and <tt class="calibre22">extend-protocol</tt>, the implementation map is taken as a <span class="italic">value</span> that we can pass around, manipulate, and combine with other implementation maps. With this flexibility available, we can model any permutation of implementation reuse we desire, from simple stuff like “inheritance” to more subtle notions like traits and mixins.</p><p class="calibre18">A simple example is defining default implementations for <tt class="calibre22">rows</tt> and <tt class="calibre22">cols</tt> that depend only upon type-specific implementations of <tt class="calibre22">dims</tt> and <tt class="calibre22">lookup</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def abstract-matrix-impl<br class="calibre33"/>  {:cols (fn [pt]<br class="calibre33"/>           (let [[h w] (dims pt)]<br class="calibre33"/>             (map<br class="calibre33"/>               (fn [x] (map #(lookup pt x y) (range 0 w)))<br class="calibre33"/>               (range 0 h))))<br class="calibre33"/>   :rows (fn [pt]<br class="calibre33"/>           (apply map vector (cols pt)))})</tt></span></blockquote><p class="calibre23">Now we can provide an extension of <tt class="calibre22">Matrix</tt> to <tt class="calibre22">Point</tt>, which builds upon the default implementation by simply <tt class="calibre22">assoc</tt>ing in our type-specific method implementations:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(extend Point<br class="calibre33"/>  Matrix<br class="calibre33"/>  (assoc abstract-matrix-impl<br class="calibre33"/>    :lookup (fn [pt i j]<br class="calibre33"/>             (when (zero? j)<br class="calibre33"/>               (case i<br class="calibre33"/>                 0 (:x pt)<br class="calibre33"/>                 1 (:y pt))))<br class="calibre33"/>    :update (fn [pt i j value]<br class="calibre33"/>              (if (zero? j)<br class="calibre33"/>                (condp = i<br class="calibre33"/>                  0 (Point. value (:y pt))<br class="calibre33"/>                  1 (Point. (:x pt) value))<br class="calibre33"/>               pt))<br class="calibre33"/>    :dims (fn [pt] [2 1])))</tt></span></blockquote><p class="calibre23">While this example is quite simple and isn’t especially innovative with regard to the state of mainstream object-oriented class design, it does illustrate how, thanks to the protocol methods allowing you to treat method implementations simply as named functions, you can model whatever inheritance relationships you like, entirely dissociated from concrete types that might otherwise get in your way.</p><p class="calibre18">More interesting would be to leverage implementations as values to provide <span class="italic">mixins</span><a id="filepos1027971"></a>—that is, a way to combine several discrete implementations of a single protocol in a meaningful way.</p><p class="calibre18">For this example, let’s define a new protocol, <tt class="calibre22">Measurable</tt>:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1028217"></a><a href="#filepos1035669"><span class="calibre32">204</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defprotocol Measurable<br class="calibre33"/>  "A protocol for retrieving the dimensions of widgets."<br class="calibre33"/>  (width [measurable] "Returns the width in px.")<br class="calibre33"/>  (height [measurable] "Returns the height in px."))</tt></span></blockquote><p class="calibre23">Then we define a new <tt class="calibre22">Button</tt> record type to which we extend the <tt class="calibre22">Measurable</tt> protocol, along with a <tt class="calibre22">bordered</tt> implementation map:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defrecord Button [text])<br class="calibre33"/><br class="calibre33"/>(extend-type Button<br class="calibre33"/>  Measurable<br class="calibre33"/>  (width [btn]<br class="calibre33"/>    (* 8 (-&gt; btn :text count)))<br class="calibre33"/>  (height [btn] 8))<br class="calibre33"/><br class="calibre33"/>(def bordered<br class="calibre33"/>  {:width #(* 2 (:border-width %))<br class="calibre33"/>   :height #(* 2 (:border-height %))})</tt></span></blockquote><p class="calibre23">Now we’d like to define a <tt class="calibre22">BorderedButton</tt> that combines the implementations of both <tt class="calibre22">Button</tt> and <tt class="calibre22">bordered</tt>. But, there’s a problem: we don’t have an implementation map for <tt class="calibre22">Button</tt>. Protocols are helpfully not just static names that we can use with <tt class="calibre22">extend</tt>, et al.; they name vars that contain a variety of useful bits:</p><p id="filepos1029623" class="calibre23"></p><p class="calibre23"><span class="italic">Example 6-7. Contents of a protocol var’s map</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">Measurable<br class="calibre33"/>;= {:impls<br class="calibre33"/>;=   {user.Button<br class="calibre33"/>;=     {:height #&lt;user$eval2056$fn__2057 user$eval2056$fn__2057@112f8578&gt;,<br class="calibre33"/>;=      :width #&lt;user$eval2056$fn__2059 user$eval2056$fn__2059@74b90ff7&gt;}},<br class="calibre33"/>;=  :on-interface user.Measurable,<br class="calibre33"/>;=  :on user.Measurable,<br class="calibre33"/>;=  :doc "A protocol for retrieving the 2D dimensions of widgets.",<br class="calibre33"/>;=  :sigs<br class="calibre33"/>;=    {:height<br class="calibre33"/>;=      {:doc "Returns the height in px.",<br class="calibre33"/>;=       :arglists ([measurable]),<br class="calibre33"/>;=       :name height},<br class="calibre33"/>;=     :width<br class="calibre33"/>;=       {:doc "Returns the width in px.",<br class="calibre33"/>;=        :arglists ([measurable]),<br class="calibre33"/>;=        :name width}},<br class="calibre33"/>;=  :var #'user/Measurable,<br class="calibre33"/>;=  :method-map {:width :width, :height :height},<br class="calibre33"/>;=  :method-builders<br class="calibre33"/>;=    {#'user/height #&lt;user$eval2012$fn__2013 user$eval2012$fn__2013@27aa7aac&gt;,<br class="calibre33"/>;=     #'user/width #&lt;user$eval2012$fn__2024 user$eval2012$fn__2024@4848268a&gt;}}</tt></span></p><p class="calibre13">There is plenty of interesting stuff in there even if most—if not all—are implementation details.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1031112"></a><a href="#filepos1036102"><span class="calibre32">205</span></a><span class="calibre32">]</span></small></sup> Relevant to our mixin example, we can spot that <tt class="calibre22">(get-in Measurable [:impls Button])</tt> yields the implementation map for <tt class="calibre22">Button</tt> for the <tt class="calibre22">Measurable</tt> protocol:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(get-in Measurable [:impls Button])<br class="calibre33"/>;= {:height #&lt;user$eval1251$fn__1252 user$eval1251$fn__1252@744589eb&gt;,<br class="calibre33"/>;=  :width #&lt;user$eval1251$fn__1254 user$eval1251$fn__1254@40735f45&gt;}</tt></span></blockquote><p class="calibre23">The missing piece is a means to combine multiple implementations of a given method into a new implementation. Such a function should take the functions to combine and another function to compute the new result given the result of the two other implementations:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn combine<br class="calibre33"/> "Takes two functions f and g and returns a fn that takes a variable number<br class="calibre33"/>  of args, applies them to f and g and then returns the result of<br class="calibre33"/>  (op rf rg) where rf and rg are the results of the calls to f and g."<br class="calibre33"/> [op f g]<br class="calibre33"/> (fn [&amp; args]<br class="calibre33"/>   (op (apply f args) (apply g args))))</tt></span></blockquote><p class="calibre23">At last we can define our <tt class="calibre22">BorderedButton</tt> type and extend <tt class="calibre22">Measurable</tt> to it, using <tt class="calibre22">+</tt> to combine results from our <tt class="calibre22">bordered</tt> map of implementations and the implementations already registered with <tt class="calibre22">Measurable</tt> for <tt class="calibre22">Button</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defrecord BorderedButton [text border-width border-height])<br class="calibre33"/><br class="calibre33"/>(extend BorderedButton<br class="calibre33"/>  Measurable<br class="calibre33"/>  (merge-with (partial combine +)<br class="calibre33"/>    (get-in Measurable [:impls Button])<br class="calibre33"/>    bordered))</tt></span></blockquote><p class="calibre23">It’s time to verify that a <tt class="calibre22">BorderedButton</tt> instance correctly computes its dimensions compared to a <tt class="calibre22">Button</tt> instance with the same text:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [btn (Button. "Hello World")]<br class="calibre33"/>  [(width btn) (height btn)])<br class="calibre33"/>;= [88 8]<br class="calibre33"/><br class="calibre33"/>(let [bbtn (BorderedButton. "Hello World" 6 4)]<br class="calibre33"/>  [(width bbtn) (height bbtn)])<br class="calibre33"/>;= [100 16]</tt></span></blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Another argument in favor of </span><span class="calibre10"><span class="italic">not</span></span><span class="calibre10"> inlining implementations prematurely is that such powerful reuse patterns are not available for types that include inline extensions. In such cases you’ll have to resort to delegation and/or macros.</span><a id="filepos1034077"></a></blockquote><br class="calibre33"/><hr class="calibre34"/><p class="calibre25"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1034190"></a><a href="#filepos1014636"><span class="calibre32">201</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">This amount of code is tremendously reduced when you follow our advice from </span><a href="#filepos988434"><span class="calibre10"><span class="calibre5">Constructors and factory functions</span></span></a><span class="calibre10"> to implement a factory function for your types.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1034632"></a><a href="#filepos1015821"><span class="calibre32">202</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Any other class, abstract or not, cannot be extended inline. You must resort to </span><span class="calibre10"><tt class="calibre22">gen-class</tt></span><span class="calibre10"> or </span><span class="calibre10"><tt class="calibre22">proxy</tt></span><span class="calibre10">, described in </span><a href="#filepos1362472"><span class="calibre10"><span class="calibre5">Defining Named Classes</span></span></a><span class="calibre10"> and </span><a href="#filepos1352402"><span class="calibre10"><span class="calibre5">Instances of Anonymous Classes: proxy</span></span></a><span class="calibre10"> respectively, to subclass any concrete type.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1035343"></a><a href="#filepos1022042"><span class="calibre32">203</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="#filepos1352402"><span class="calibre10"><span class="calibre5">Instances of Anonymous Classes: proxy</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1035669"></a><a href="#filepos1028217"><span class="calibre32">204</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">This example is largely inspired by the one provided in the Wikipedia article on mixins: </span><a href="https://en.wikipedia.org/wiki/Mixin"><span class="calibre10"><span class="calibre5">https://en.wikipedia.org/wiki/Mixin</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1036102"></a><a href="#filepos1031112"><span class="calibre32">205</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="#filepos1036465"><span class="calibre10"><span class="calibre5">Protocol Introspection</span></span></a><span class="calibre10"> for a brief tour of the functions that form the supported API available for protocol introspection.</span></p><div class="mbppagebreak"></div><p id="filepos1036465" class="calibre6"><span class="calibre4"><span class="bold">Protocol Introspection</span></span></p><p id="filepos1036548" class="calibre18">Now that we’ve seen the soft underbelly of protocols in <a href="#filepos1029623"><span class="calibre5">Example 6-7</span></a>, we should mention the convenience functions for introspecting protocols: <tt class="calibre22">extenders</tt>, <tt class="calibre22">extends?</tt>, and <tt class="calibre22">satisfies?</tt>, which collectively provide a supported API for answering common questions about protocols and their relationships with types.</p><p class="calibre23"><tt class="calibre22">extenders</tt></p><blockquote id="filepos1037019" class="calibre17">Returns the classes that have been extended to a given protocol. For example, after going through the examples involving the <tt class="calibre22">Measurable</tt> protocol in the last section, we can see which types participate in that protocol:</blockquote><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(extenders Measurable)<br class="calibre33"/>;= (user.BorderedButton user.Button)</tt></span></blockquote><blockquote class="calibre35">This is the equivalent of asking, “Which classes implement some Java interface <tt class="calibre22">x</tt>?” Note that, because types can be extended to satisfy protocols <span class="italic">at any point at runtime</span>, these results are only true for the point in time when a protocol is queried via <tt class="calibre22">extenders</tt>.</blockquote><p class="calibre23"><tt class="calibre22">extends?</tt></p><blockquote id="filepos1037836" class="calibre17">Returns true only if a type has been extended to a protocol:</blockquote><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(extends? Measurable Button)<br class="calibre33"/>;= true</tt></span></blockquote><p class="calibre6"><tt class="calibre22">satisfies?</tt></p><blockquote id="filepos1038125" class="calibre17">Is the analog of <tt class="calibre22">instance?</tt>: it asks whether a particular instance participates in a given protocol, either by dint of having been extended to it via <tt class="calibre22">extend</tt> and its derivatives:</blockquote><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(satisfies? Measurable (Button. "hello"))<br class="calibre33"/>;= true<br class="calibre33"/>(satisfies? Measurable :other-value)<br class="calibre33"/>;= false</tt></span></blockquote><blockquote class="calibre35">…or by its type having provided inline implementations of the protocol’s methods:</blockquote><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(deftype Foo [x y]<br class="calibre33"/>  Measurable<br class="calibre33"/>  (width [_] x)<br class="calibre33"/>  (height [_] y))<br class="calibre33"/>;= user.Foo<br class="calibre33"/>(satisfies? Measurable (Foo. 5 5))<br class="calibre33"/>;= true</tt></span></blockquote><blockquote class="calibre35">In this latter case, because types that provide inline implementations are really just implementing methods on the host interface that the protocol generates, there can be overlap between <tt class="calibre22">satisfies?</tt> and <tt class="calibre22">instance?</tt> for the same object:</blockquote><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(instance? user.Measurable (Foo. 5 5))    </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= true</tt></span></blockquote><blockquote class="calibre38"><img src="images/00011.jpg" class="calibre36"/></blockquote><blockquote class="calibre100"><blockquote class="calibre37"><tt class="calibre22">user.Measurable</tt> is the interface generated by the <tt class="calibre22">Measurable</tt> protocol that we defined at <tt class="calibre22">#'user/Measurable</tt>.</blockquote></blockquote><div class="mbppagebreak"></div><p id="filepos1039878" class="calibre6"><span class="calibre4"><span class="bold">Protocol Dispatch Edge Cases</span></span></p><p id="filepos1039967" class="calibre18">Since protocol methods produce namespaced functions, there can never be a conflict between two protocols’ functions. However, there are some edge cases that have no corollary in typical object-oriented languages where protocol dispatch can produce some surprising results.</p><p class="calibre18"><span class="bold">Competing implementations</span>. The fact that protocols can be extended at any time and at runtime is a huge boon to interactive development and for allowing protocol implementations to evolve to accommodate tricky modeling or optimization problems.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1040588"></a><a href="#filepos1045595"><span class="calibre32">206</span></a><span class="calibre32">]</span></small></sup> However, if two implementations of the same protocol for the same type exist, then the last implementation that was loaded will replace the first—potentially to surprising effect if the implementation you expect happens to be loaded first.</p><p class="calibre18">Alas, this is a problem of policy rather than technology! The rule of thumb to avoid such conflicts is: if you are neither the protocol or type owner, <span class="italic">be prepared to retract your implementation</span>. The potential conflict between the two owners is usually settled by chronology: when the protocol predates the type, it’s the type owner’s responsibility to extend the protocol and vice versa.</p><p class="calibre18"><span class="bold">Class hierarchies break “ties” when possible</span>. <a id="filepos1041445"></a>A related situation is where two implementations of a single protocol exist for two related types, and both are applicable for a particular protocol method call. For example, say we extend a protocol to two related interfaces—<tt class="calibre22">java.util.List</tt><a id="filepos1041703"></a> and <tt class="calibre22">java.util.Collection</tt><a id="filepos1041744"></a>, maybe—and then call one of the protocol methods with a type that matches both:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defprotocol P<br class="calibre33"/>  (a [x]))<br class="calibre33"/>;= P<br class="calibre33"/>(extend-protocol P<br class="calibre33"/>  java.util.Collection<br class="calibre33"/>  (a [x] :collection!)<br class="calibre33"/>  java.util.List<br class="calibre33"/>  (a [x] :list!))<br class="calibre33"/>;= nil<br class="calibre33"/>(a [])<br class="calibre33"/>;= :list!</tt></span></blockquote><p class="calibre23">In such cases, the protocol dispatch machinery uses class hierarchy relationships to make a decision, and will always choose the protocol implementation for the most specific type—in this case, the one for <tt class="calibre22">java.util.List</tt> “wins” since it extends the base <tt class="calibre22">Collection</tt> interface.</p><p class="calibre18"><span class="bold">Unresolvable “ties” choose an arbitrary implementation</span>. But, what happens if the two types extended to a protocol have no class hierarchy relationship? In that case, the protocol dispatch mechanism will select and cache an <span class="italic">arbitrary</span> implementation.<a id="filepos1042799"></a> The most likely scenario where this can occur is when protocols are extended to multiple high-level Java interfaces.</p><p class="calibre18">Consider a protocol to which we extend two implementations, each for an interface type, neither of which have any relationship to the other with regard to class hierarchy; here, <tt class="calibre22">java.util.Map</tt><a id="filepos1043155"></a> and <tt class="calibre22">java.io.Serializable</tt><a id="filepos1043196"></a>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defprotocol P<br class="calibre33"/>  (a [x]))<br class="calibre33"/><br class="calibre33"/>(extend-protocol P<br class="calibre33"/>  java.util.Map<br class="calibre33"/>  (a [x] :map!)<br class="calibre33"/>  java.io.Serializable<br class="calibre33"/>  (a [x] :serializable!))</tt></span></blockquote><p class="calibre23">What will happen if we call <tt class="calibre22">a</tt> with a Clojure map, which implements both of these interfaces?</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(a {})<br class="calibre33"/>;= :serializable!</tt></span></blockquote><p class="calibre23">Okay…that’s <span class="italic">one</span> reasonable result—but why that one and not the <tt class="calibre22">Map</tt> implementation? The trap lies in the fact that this dispatch choice (which protocols cache for each concrete type that is dispatched upon) <span class="italic">can be different</span> the next time you restart your application or REPL and call the same protocol function. For the above example, this means that you cannot know ahead of time if <tt class="calibre22">(a {})</tt> will return <tt class="calibre22">:serializable!</tt> or <tt class="calibre22">:map</tt>!</p><p class="calibre18">There are a couple of options for resolving this:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">Extend the protocol to concrete types that you know you want to support. There is never any ambiguity of dispatch between concrete types.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1044618"></a><a href="#filepos1045982"><span class="calibre32">207</span></a><span class="calibre32">]</span></small></sup></blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Wanting to extend multiple unrelated high-level interfaces to a protocol may be a sign of a design problem, where the contract of the protocol is too broad. Revisit that contract.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Use multimethods. In contrast to protocols, multimethods do fail with an error if a call results in an unresolvable tie between dispatch values. Further, multimethods provide a “preference” mechanism that can be used to specify how to resolve such ambiguity.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1045377"></a><a href="#filepos1046323"><span class="calibre32">208</span></a><span class="calibre32">]</span></small></sup></blockquote></li><a id="filepos1045490"></a></ol><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1045595"></a><a href="#filepos1040588"><span class="calibre32">206</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">An example of the latter is described at </span><a href="http://dosync.posterous.com/51626638"><span class="calibre10"><span class="calibre5">http://dosync.posterous.com/51626638</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1045982"></a><a href="#filepos1044618"><span class="calibre32">207</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">…and thus never any ambiguity of dispatch among protocol implementations for </span><span class="calibre10"><tt class="calibre22">deftype</tt></span><span class="calibre10"> or record types.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1046323"></a><a href="#filepos1045377"><span class="calibre32">208</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Multimethods are described in detail in </span><a href="#filepos1073489"><span class="calibre10"><span class="calibre5">Chapter 7</span></span></a><span class="calibre10">, with their preference mechanism discussed in </span><a href="#filepos1118504"><span class="calibre10"><span class="calibre5">Multiple Inheritance</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos1046777" class="calibre6"><span class="calibre4"><span class="bold">Participating in Clojure’s Collection Abstractions</span></span></p><p id="filepos1046890" class="calibre18">In <a href="#filepos999154"><span class="calibre5">“Schrödinger’s cat”</span></a>, we had a glimpse of how to make a custom type participate in one of Clojure’s abstractions by making a type <tt class="calibre22">deref</tt>erenceable. Let’s raise the bar a bit and work through a complete data structure implementation that is fully integrated into Clojure’s abstractions: namely, an array-backed set, specialized to be more efficient in both performance and memory than standard tree-based hashing sets for very small numbers of items.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1047480"></a><a href="#filepos1070547"><span class="calibre32">209</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">Participating in a Clojure abstraction currently means extending certain Java interfaces that Clojure defines for each abstraction. Thus, all of our implementation work must be performed inline.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1047836"></a><a href="#filepos1071149"><span class="calibre32">210</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">In general, the most difficult part of participating in Clojure’s abstractions is identifying which interfaces and methods are to be implemented, as such things are largely undocumented officially.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1048197"></a><a href="#filepos1071595"><span class="calibre32">211</span></a><span class="calibre32">]</span></small></sup> A helper function will get us most of the way there, though:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn scaffold<br class="calibre33"/>  "Given an interface, returns a 'hollow' body suitable for use with `deftype`."<br class="calibre33"/>  [interface]<br class="calibre33"/>  (doseq [[iface methods] (-&gt;&gt; interface<br class="calibre33"/>                            .getMethods<br class="calibre33"/>                            (map #(vector (.getName (.getDeclaringClass %))<br class="calibre33"/>                                    (symbol (.getName %))<br class="calibre33"/>                                    (count (.getParameterTypes %))))<br class="calibre33"/>                            (group-by first))]<br class="calibre33"/>    (println (str "  " iface))<br class="calibre33"/>    (doseq [[_ name argcount] methods]<br class="calibre33"/>      (println<br class="calibre33"/>        (str "    "<br class="calibre33"/>          (list name (into '[this] (take argcount (repeatedly gensym)))))))))</tt></span></blockquote><p class="calibre23">By looking at the output of <tt class="calibre22">(ancestors (class #{}))</tt>, we can see that <tt class="calibre22">clojure.lang.IPersistentSet</tt> is the primary interface implemented by a Clojure set; providing it to <tt class="calibre22">scaffold</tt> yields a good starting point for our own set implementation:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(scaffold clojure.lang.IPersistentSet)<br class="calibre33"/>;  clojure.lang.IPersistentSet<br class="calibre33"/>;    (get [this G__5617])<br class="calibre33"/>;    (contains [this G__5618])<br class="calibre33"/>;    (disjoin [this G__5619])<br class="calibre33"/>;  clojure.lang.IPersistentCollection<br class="calibre33"/>;    (count [this])<br class="calibre33"/>;    (cons [this G__5620])<br class="calibre33"/>;    (empty [this])<br class="calibre33"/>;    (equiv [this G__5621])<br class="calibre33"/>;  clojure.lang.Seqable           </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;    (seq [this])<br class="calibre33"/>;  clojure.lang.Counted<br class="calibre33"/>;    (count [this])               </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">If all you wanted was to ensure your data structure was seqable, you’d only need to implement the <tt class="calibre22">seq</tt> method of <tt class="calibre22">clojure.lang.Seqable</tt>.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">Note that there are two <tt class="calibre22">count</tt> methods with the same signature; one of them must be elided.</blockquote><p class="calibre18">To implement a Clojure set, we need to implement those methods, in addition to <tt class="calibre22">Object</tt>’s <tt class="calibre22">hashCode</tt> and <tt class="calibre22">equals</tt> so as to ensure proper value semantics. All of those methods’ contracts should be obvious except perhaps <tt class="calibre22">cons</tt> and <tt class="calibre22">equiv</tt>. <tt class="calibre22">cons</tt>, despite its name, is the method that backs <tt class="calibre22">conj</tt>; <tt class="calibre22">equiv</tt> is similar to <tt class="calibre22">equals</tt>, but ensures sane equivalence semantics when applied to numerics (see <a href="#filepos1583249"><span class="calibre5">Equivalence can preserve your sanity</span></a>). We’ll not need to worry much about the special requirements of the latter, as our set is not a numeric type.</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 6-8. An array-backed set implementation using deftype</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(declare empty-array-set)<br class="calibre33"/>(def ^:private ^:const max-size 4)                                             </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/><br class="calibre33"/>(deftype ArraySet [^objects items<br class="calibre33"/>                   ^int size<br class="calibre33"/>                   ^:unsynchronized-mutable ^int hashcode]<br class="calibre33"/>  clojure.lang.IPersistentSet<br class="calibre33"/>  (get [this x]<br class="calibre33"/>    (loop [i 0]<br class="calibre33"/>      (when (&lt; i size)<br class="calibre33"/>        (if (= x (aget items i))<br class="calibre33"/>          (aget items i)<br class="calibre33"/>          (recur (inc i))))))<br class="calibre33"/>  (contains [this x]<br class="calibre33"/>    (boolean<br class="calibre33"/>      (loop [i 0]<br class="calibre33"/>        (when (&lt; i size)<br class="calibre33"/>          (or (= x (aget items i)) (recur (inc i)))))))<br class="calibre33"/>  (disjoin [this x]<br class="calibre33"/>    (loop [i 0]<br class="calibre33"/>      (if (== i size)<br class="calibre33"/>        this<br class="calibre33"/>        (if (not= x (aget items i))<br class="calibre33"/>          (recur (inc i))<br class="calibre33"/>          (ArraySet. (doto (aclone items)<br class="calibre33"/>                       (aset i (aget items (dec size)))<br class="calibre33"/>                       (aset (dec size) nil))<br class="calibre33"/>                     (dec size)<br class="calibre33"/>                     -1)))))<br class="calibre33"/> clojure.lang.IPersistentCollection<br class="calibre33"/>  (count [this] size)<br class="calibre33"/>  (cons [this x]<br class="calibre33"/>    (cond<br class="calibre33"/>      (.contains this x) this<br class="calibre33"/>      (== size max-size) (into #{x} this)                                      </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>      :else (ArraySet. (doto (aclone items)<br class="calibre33"/>                         (aset size x))<br class="calibre33"/>                       (inc size)<br class="calibre33"/>                       -1)))<br class="calibre33"/>  (empty [this] empty-array-set)<br class="calibre33"/>  (equiv [this that] (.equals this that))                                      </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  clojure.lang.Seqable<br class="calibre33"/>  (seq [this] (take size items))<br class="calibre33"/>  Object<br class="calibre33"/>  (hashCode [this]<br class="calibre33"/>    (when (== -1 hashcode)<br class="calibre33"/>      (set! hashcode (int (areduce items idx ret 0                             </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>                            (unchecked-add-int ret (hash (aget items idx)))))))<br class="calibre33"/>    hashcode)<br class="calibre33"/>  (equals [this that]<br class="calibre33"/>    (or<br class="calibre33"/>      (identical? this that)<br class="calibre33"/>      (and (or (instance? java.util.Set that)<br class="calibre33"/>               (instance? clojure.lang.IPersistentSet that))<br class="calibre33"/>           (= (count this) (count that))<br class="calibre33"/>           (every? #(contains? this %) that)))))<br class="calibre33"/><br class="calibre33"/>(def ^:private empty-array-set (ArraySet. (object-array max-size) 0 -1))<br class="calibre33"/><br class="calibre33"/>(defn array-set                                                                </tt></span><a></a><img src="images/00001.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  "Creates an array-backed set containing the given values."<br class="calibre33"/>  [&amp; vals]<br class="calibre33"/>  (into empty-array-set vals))</tt></span></p><p class="calibre101"><img src="images/00011.jpg" class="calibre36"/><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">A key characteristic of collection implementations specialized for a particular character of dataset is that once the dataset shifts outside of an implementation’s “sweet spot,” that implementation should “promote” the data into a different sort of collection that is more suitable without moving outside of the abstraction in question. Here, for a set optimized to contain small numbers of values, we promote the set’s data to a regular Clojure hash set once more than four items are to be held. A different threshold might be found to be more appropriate for very specific usage patterns,</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">equiv</tt> delegates to <tt class="calibre22">equals</tt> to align the behavior of <tt class="calibre22">ArraySet</tt> with the implementation of <tt class="calibre22">clojure.lang.APersistentSet</tt>.</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">Since our set implementation is backed by an array, we’ve had to use various operations—<tt class="calibre22">areduce</tt>, <tt class="calibre22">aget</tt>, <tt class="calibre22">aset</tt>, and so on—that we’ve not talked about yet, although they have little to do with our current focus. See <a href="#filepos1605156"><span class="calibre5">Use Primitive Arrays Judiciously</span></a> to understand Clojure’s operations over arrays.</blockquote><p class="calibre23"><img src="images/00001.jpg" class="calibre36"/></p><blockquote class="calibre37">The constructor for <tt class="calibre22">ArraySet</tt> is in no way suitable for end users—its fields are entirely related to its implementation. Because of this, and all of the other good reasons we talked about in <a href="#filepos988434"><span class="calibre5">Constructors and factory functions</span></a>, we provide a user-friendly <tt class="calibre22">array-set</tt> factory function.</blockquote><p class="calibre18">Does this implementation work?</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(array-set)<br class="calibre33"/>;= #{}<br class="calibre33"/>(conj (array-set) 1)<br class="calibre33"/>;= #{1}<br class="calibre33"/>(apply array-set "hello")<br class="calibre33"/>;= #{\h \e \l \o}<br class="calibre33"/>(get (apply array-set "hello") \w)<br class="calibre33"/>;= nil<br class="calibre33"/>(get (apply array-set "hello") \h)<br class="calibre33"/>;= \h<br class="calibre33"/>(contains? (apply array-set "hello") \h)<br class="calibre33"/>;= true<br class="calibre33"/>(= (array-set) #{})<br class="calibre33"/>;= true</tt></span></blockquote><p class="calibre23">So far so good, but…</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">((apply array-set "hello") \h)<br class="calibre33"/>; #&lt;ClassCastException java.lang.ClassCastException:<br class="calibre33"/>;   user.ArraySet cannot be cast to clojure.lang.IFn&gt;</tt></span></blockquote><p class="calibre23">This exception isn’t surprising: we haven’t implemented anything to allow <tt class="calibre22">ArraySet</tt><a id="filepos1059120"></a> to be callable as a function. To do this, we must implement the suitable arities of the <tt class="calibre22">clojure.land.IFn</tt> interface, which is implemented by all Clojure functions. This is entirely optional—there’s nothing to say that a perfectly useful collection <span class="italic">must</span> be callable—but that feature is very convenient, so we’ll take a stab at adding it.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1059522"></a><a href="#filepos1072021"><span class="calibre32">212</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">More serious is this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(= #{} (array-set))<br class="calibre33"/>;= false</tt></span></blockquote><p class="calibre23">We are breaking the symmetric property of <tt class="calibre22">=</tt>, a key part of its general contract. This stems from the fact that Clojure sets are by definition also Java sets, as defined by <tt class="calibre22">java.util.Set</tt>.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1060061"></a><a href="#filepos1072512"><span class="calibre32">213</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">Let’s use <tt class="calibre22">scaffold</tt> again to see what we need to implement <tt class="calibre22">java.util.Set</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(scaffold java.util.Set)<br class="calibre33"/>;  java.util.Set<br class="calibre33"/>;    (add [this G__6140])<br class="calibre33"/>;    (equals [this G__6141])<br class="calibre33"/>;    (hashCode [this])<br class="calibre33"/>;    (clear [this])<br class="calibre33"/>;    (isEmpty [this])<br class="calibre33"/>;    (contains [this G__6142])<br class="calibre33"/>;    (addAll [this G__6143])<br class="calibre33"/>;    (size [this])<br class="calibre33"/>;    (toArray [this G__6144])<br class="calibre33"/>;    (toArray [this])<br class="calibre33"/>;    (iterator [this])<br class="calibre33"/>;    (remove [this G__6145])<br class="calibre33"/>;    (removeAll [this G__6146])<br class="calibre33"/>;    (containsAll [this G__6147])<br class="calibre33"/>;    (retainAll [this G__6148])</tt></span></blockquote><p class="calibre23">Don’t panic: only the read portion of that interface needs to be implemented, since <tt class="calibre22">ArraySet</tt> is immutable and persistent. <tt class="calibre22">equals</tt>, <tt class="calibre22">hashCode</tt>, and <tt class="calibre22">contains</tt> are already done, so we are left with:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">  java.util.Set<br class="calibre33"/>    (isEmpty [this])<br class="calibre33"/>    (size [this])<br class="calibre33"/>    (toArray [this G__6144])<br class="calibre33"/>    (toArray [this])<br class="calibre33"/>    (iterator [this])<br class="calibre33"/>    (containsAll [this G__6147])</tt></span></blockquote><p class="calibre23">None of these methods are difficult to write. The only pitfall would be to leak the <tt class="calibre22">items</tt> array when returning from <tt class="calibre22">toArray</tt>; this would leave our internal array open to being modified underneath us, ruining our immutability guarantee. The implementation of <tt class="calibre22">iterator</tt> could be tedious if done naively, but is actually very simple as long as you remember that sequences are Java collections as well, and so we can just reuse the <tt class="calibre22">Iterator</tt> they provide:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 6-9. An improved array-backed set implementation using deftype</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(deftype ArraySet [^objects items<br class="calibre33"/>                   ^int size<br class="calibre33"/>                   ^:unsynchronized-mutable ^int hashcode]<br class="calibre33"/>  clojure.lang.IPersistentSet<br class="calibre33"/>  (get [this x]<br class="calibre33"/>    (loop [i 0]<br class="calibre33"/>      (when (&lt; i size)<br class="calibre33"/>        (if (= x (aget items i))<br class="calibre33"/>          (aget items i)<br class="calibre33"/>          (recur (inc i))))))<br class="calibre33"/>  (contains [this x]<br class="calibre33"/>    (boolean<br class="calibre33"/>      (loop [i 0]<br class="calibre33"/>        (when (&lt; i size)<br class="calibre33"/>          (or (= x (aget items i)) (recur (inc i)))))))<br class="calibre33"/>  (disjoin [this x]<br class="calibre33"/>    (loop [i 0]<br class="calibre33"/>      (if (== i size)<br class="calibre33"/>        this<br class="calibre33"/>        (if (not= x (aget items i))<br class="calibre33"/>          (recur (inc i))<br class="calibre33"/>          (ArraySet. (doto (aclone items)<br class="calibre33"/>                       (aset i (aget items (dec size)))<br class="calibre33"/>                       (aset (dec size) nil))<br class="calibre33"/>                     (dec size)<br class="calibre33"/>                     -1)))))<br class="calibre33"/>  clojure.lang.IPersistentCollection<br class="calibre33"/>  (count [this] size)<br class="calibre33"/>  (cons [this x]<br class="calibre33"/>    (cond<br class="calibre33"/>      (.contains this x) this<br class="calibre33"/>      (== size max-size) (into #{x} this)<br class="calibre33"/>      :else (ArraySet. (doto (aclone items)<br class="calibre33"/>                         (aset size x))<br class="calibre33"/>                       (inc size)<br class="calibre33"/>                       -1)))<br class="calibre33"/>  (empty [this] empty-array-set)<br class="calibre33"/>  (equiv [this that] (.equals this that))<br class="calibre33"/>  clojure.lang.Seqable<br class="calibre33"/>  (seq [this] (take size items))<br class="calibre33"/>  Object<br class="calibre33"/>  (hashCode [this]<br class="calibre33"/>    (when (== -1 hashcode)<br class="calibre33"/>      (set! hashcode (int (areduce items idx ret 0<br class="calibre33"/>                            (unchecked-add-int ret (hash (aget items idx)))))))<br class="calibre33"/>    hashcode)<br class="calibre33"/>  (equals [this that]<br class="calibre33"/>    (or<br class="calibre33"/>      (identical? this that)<br class="calibre33"/>      (and (instance? java.util.Set that)                               </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>           (= (count this) (count that))<br class="calibre33"/>           (every? #(contains? this %) that))))<br class="calibre33"/>  clojure.lang.IFn<br class="calibre33"/>  (invoke [this key] (.get this key))                                   </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  (applyTo [this args]                                                  </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>    (when (not= 1 (count args))<br class="calibre33"/>      (throw (clojure.lang.ArityException. (count args) "ArraySet")))<br class="calibre33"/>    (this (first args)))<br class="calibre33"/>  java.util.Set<br class="calibre33"/>  (isEmpty [this] (zero? size))<br class="calibre33"/>  (size [this] size)<br class="calibre33"/>  (toArray [this array]<br class="calibre33"/>    (.toArray ^java.util.Collection (sequence items) array))            </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  (toArray [this] (into-array (seq this)))<br class="calibre33"/>  (iterator [this] (.iterator ^java.util.Collection (sequence this)))   </tt></span><a></a><img src="images/00001.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  (containsAll [this coll]<br class="calibre33"/>    (every? #(contains? this %) coll)))<br class="calibre33"/><br class="calibre33"/>(def ^:private empty-array-set (ArraySet. (object-array max-size) 0 -1))</tt></span></p><p class="calibre23"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">equals</tt> can be simplified to test only if <tt class="calibre22">that</tt> implements <tt class="calibre22">java.util.Set</tt>, since that interface is now implemented by <tt class="calibre22">ArraySet</tt>.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">For direct invocations, <tt class="calibre22">clojure.lang.IFn</tt> consists of 21 different arities of <tt class="calibre22">invoke</tt>. Sets can only take one argument (the key to look up, as if via <tt class="calibre22">get</tt>), so we only implement that arity; an error will be thrown if an <tt class="calibre22">ArraySet</tt> is called with no or more arguments.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">For invocations via <tt class="calibre22">apply</tt>, <tt class="calibre22">IFn</tt> defines <tt class="calibre22">applyTo</tt>, which takes the seq of arguments provided to <tt class="calibre22">apply</tt>.</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">sequence</tt> is preferred over <tt class="calibre22">seq</tt> because it never returns <tt class="calibre22">nil</tt>: <tt class="calibre22">seq</tt>, by returning <tt class="calibre22">nil</tt>, would cause a <tt class="calibre22">NullPointerException</tt> for empty sets.</blockquote><p class="calibre23"><img src="images/00001.jpg" class="calibre36"/></p><blockquote class="calibre37">Since sequences are Java collections, we can just return the <tt class="calibre22">Iterator</tt> provided by our own seq.</blockquote><p class="calibre13">Now we have a fully functional set implementation that plays nicely with others, and is callable just like Clojure’s regular sets:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(= #{3 1 2 0} (array-set 0 1 2 3))<br class="calibre33"/>;= true<br class="calibre33"/>((apply array-set "hello") \h)<br class="calibre33"/>;= \h</tt></span></blockquote><p class="calibre23">But, is <tt class="calibre22">ArraySet</tt> of any benefit to us? Let’s see how it compares to Clojure’s general-purpose <tt class="calibre22">hash-set</tt>, using a mix of lookups, <tt class="calibre22">disj</tt>, and <tt class="calibre22">conj</tt> operations:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn microbenchmark<br class="calibre33"/>  [f &amp; {:keys [size trials] :or {size 4 trials 1e6}}]<br class="calibre33"/>  (let [items (repeatedly size gensym)]<br class="calibre33"/>    (time (loop [s (apply f items)<br class="calibre33"/>                 n trials]<br class="calibre33"/>            (when (pos? n)<br class="calibre33"/>              (doseq [x items] (contains? s x))<br class="calibre33"/>              (let [x (rand-nth items)]<br class="calibre33"/>                (recur (-&gt; s (disj x) (conj x)) (dec n))))))))<br class="calibre33"/><br class="calibre33"/>(doseq [n (range 1 5)<br class="calibre33"/>          f [#'array-set #'hash-set]]<br class="calibre33"/>    (print n (-&gt; f meta :name) ": ")<br class="calibre33"/>    (microbenchmark @f :size n))<br class="calibre33"/>; size 1 array-set : "Elapsed time: 839.336 msecs"<br class="calibre33"/>; size 1 hash-set : "Elapsed time: 1105.059 msecs"<br class="calibre33"/>; size 2 array-set : "Elapsed time: 1201.81 msecs"<br class="calibre33"/>; size 2 hash-set : "Elapsed time: 1369.192 msecs"<br class="calibre33"/>; size 3 array-set : "Elapsed time: 1658.36 msecs"<br class="calibre33"/>; size 3 hash-set : "Elapsed time: 1740.955 msecs"<br class="calibre33"/>; size 4 array-set : "Elapsed time: 2197.424 msecs"<br class="calibre33"/>; size 4 hash-set : "Elapsed time: 2154.637 msecs"</tt></span></blockquote><p class="calibre23">It looks like <tt class="calibre22">array-set</tt> will yield the same or better performance for very small sets compared to <tt class="calibre22">hash-set</tt>, and since it’s using a simple Java array for storage, it will certainly consume less memory than the corresponding tree-based implementation used by <tt class="calibre22">hash-set</tt>.</p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1070547"></a><a href="#filepos1047480"><span class="calibre32">209</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">The tree-based implementation strategy used by most of Clojure’s collections, which we took a close look at in </span><a href="#filepos483122"><span class="calibre10"><span class="calibre5">Visualizing persistence: maps (and vectors and sets)</span></span></a><span class="calibre10">, is excellent for general-purpose usage, but specialized access and usage patterns can be fertile ground for specialized data structure implementations.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1071149"></a><a href="#filepos1047836"><span class="calibre32">210</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">In the long term, interfaces for core abstractions are planned to be replaced by protocols; this is already the case in ClojureScript, mentioned in </span><a href="#filepos2072318"><span class="calibre10"><span class="calibre5">ClojureScript</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1071595"></a><a href="#filepos1048197"><span class="calibre32">211</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Clojure Atlas is one tool that can help identify the interfaces backing Clojure’s abstractions: </span><a href="http://www.clojureatlas.com"><span class="calibre10"><span class="calibre5">http://www.clojureatlas.com</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1072021"></a><a href="#filepos1059522"><span class="calibre32">212</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Similarly, </span><span class="calibre10"><tt class="calibre22">ArraySet</tt></span><span class="calibre10"> does not yet support metadata, functionality defined by </span><span class="calibre10"><tt class="calibre22">clojure.lang.IObj</tt></span><span class="calibre10">. It only defines two methods that are very easy to implement; we leave this as an exercise for the reader.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1072512"></a><a href="#filepos1060061"><span class="calibre32">213</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">The same holds true for Clojure map implementations, which should also implement Java’s </span><span class="calibre10"><tt class="calibre22">java.util.Map</tt></span><span class="calibre10"> interface.</span></p><div class="mbppagebreak"></div><p id="filepos1072817" class="calibre6"><span class="calibre4"><span class="bold">Final Thoughts</span></span></p><p class="calibre18">Types, records, and protocols together shape a potent framework that puts the focus on data and avoids extraneous ceremony and complexity. This data-centric approach to types and abstractions allows us to model domains and interactions more faithfully, apply the whole language to those models—such as how we can work with records and maps in a uniform way using the core collection and associative abstractions and functions—and helps us to avoid having to make false choices due to often unnecessary complexities like class hierarchies.<a id="filepos1073462"></a></p><div class="mbppagebreak"></div><p id="filepos1073489" class="calibre6"><span class="calibre2"><span class="bold">Chapter 7. Multimethods</span></span></p><p id="filepos1073575" class="calibre13">We have previously talked about protocols: they introduce a common but limited form of polymorphic dispatch—namely type-based single dispatch. In this chapter, we’ll explore <span class="italic">multimethods</span>, which expand dispatch flexibility to not only offer multiple dispatch, but even dispatch based on things other than argument type. That is, for a given multimethod, the implementation used for any given invocation can be chosen as a function of any property of the arguments, without one of them being privileged. Additionally, multimethods support arbitrary hierarchies and means of disambiguating multiple inheritance.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">In Java, one method name can have several signatures of the same length differing only by the types of the arguments, a situation called </span><span class="calibre10"><span class="italic">overloading</span></span><a id="filepos1074587"></a><span class="calibre10">. However this does not constitute a kind of multiple dispatch: the right signature is selected during compilation based on the types of the method’s arguments. The only </span><span class="calibre10"><span class="italic">dynamic</span></span><span class="calibre10"> dispatch occurs on the type of the privileged argument: </span><span class="calibre10"><tt class="calibre22">this</tt></span><span class="calibre10">.</span></blockquote><p id="filepos1074974" class="calibre25"><span class="calibre4"><span class="bold">Multimethods Basics</span></span></p><p id="filepos1075054" class="calibre18">A multimethod is created using a <tt class="calibre22">defmulti</tt> form, and implementations of a multimethod are provided by <tt class="calibre22">defmethod</tt><a id="filepos1075210"></a> forms. The mnemonic is that they come in the same order as in the word <span class="italic">multimethod</span> itself: first you define the <span class="italic">multi</span>ple dispatch then the <span class="italic">methods</span> to which calls are dispatched.</p><p class="calibre18">Let’s look at an example: a function that fills XML/HTML nodes and whose behavior depends on the tag name, using the representation of XML defined by the <tt class="calibre22">clojure.xml</tt> namespace. An element is a map of three keys: <tt class="calibre22">:tag</tt> for the name (as a keyword) of the element, <tt class="calibre22">:attrs</tt> for a map of attribute names (as keywords) to values (as strings), and <tt class="calibre22">:content</tt> for a collection of child nodes and content.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defmulti fill<br class="calibre33"/>  "Fill a xml/html node (as per clojure.xml)<br class="calibre33"/>   with the provided value."<br class="calibre33"/>  (fn [node value] (:tag node)))                 </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/><br class="calibre33"/>(defmethod fill :div                             </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  [node value]<br class="calibre33"/>  (assoc node :content [(str value)]))<br class="calibre33"/><br class="calibre33"/>(defmethod fill :input<br class="calibre33"/>  [node value]<br class="calibre33"/>  (assoc-in node [:attrs :value] (str value)))</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">This is the <span class="italic">dispatch function</span><a id="filepos1076856"></a>; the arguments to the multimethod are passed to this function to yield a <span class="italic">dispatch value</span>, which is used to select which method to invoke for those arguments.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">The <tt class="calibre22">:div</tt> here is a dispatch value. When the return of the dispatch function matches this dispatch value, the provided method implementation (which is just another function) is selected and invoked.</blockquote><p class="calibre18">A multimethod’s operation is nothing complex:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">Take arguments.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Compute the dispatch value by invoking the dispatch function with the given arguments.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Select the implementation method that was defined to support the dispatch value.</blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17">Call the implementation method with the original arguments.</blockquote></li></ol><p class="calibre18">That’s all. You could easily reimplement such a system in a few lines of Clojure using atoms and macros,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1078306"></a><a href="#filepos1083315"><span class="calibre32">214</span></a><span class="calibre32">]</span></small></sup> or in some amount of code in Ruby or Python.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1078481"></a><a href="#filepos1083542"><span class="calibre32">215</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">Multimethods certainly <span class="italic">look</span> a little different than other function definitions, in a couple different ways:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">A multimethod—despite defining a function—does not explicitly specify its arities. Instead, it supports all arities supported by its dispatch function.</blockquote></li><a id="filepos1079015"></a><li value="2" class="calibre16"><blockquote class="calibre17">The <tt class="calibre22">defmulti</tt> form is what actually defines a new var, <tt class="calibre22">fill</tt> in our example above. Each <tt class="calibre22">defmethod</tt> form simply registers a new implementation method on the “root” multimethod; counterintuitively, <tt class="calibre22">defmethod</tt> does not define or redefine any vars.</blockquote></li><a id="filepos1079396"></a></ul><p class="calibre18">So far we haven’t exercised our code yet, let’s make sure everything is working as expected:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(fill {:tag :div} "hello")<br class="calibre33"/>;= {:content ["hello"], :tag :div}<br class="calibre33"/>(fill {:tag :input} "hello")<br class="calibre33"/>;= {:attrs {:value "hello"}, :tag :input}<br class="calibre33"/>(fill {:span :input} "hello")<br class="calibre33"/>;= #&lt;IllegalArgumentException java.lang.IllegalArgumentException:<br class="calibre33"/>;=   No method in multimethod 'fill' for dispatch value: null&gt;</tt></span></blockquote><p class="calibre23">Here is a shortcoming of our approach so far: since we don’t have a base case, <tt class="calibre22">fill</tt> works only on elements it knows; that is, those for which we have provided an implementation via <tt class="calibre22">defmethod</tt>.</p><p class="calibre18">Helpfully, there’s a special dispatch value: <tt class="calibre22">:default</tt>.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defmethod fill :default<br class="calibre33"/>  [node value]<br class="calibre33"/>  (assoc node :content [(str value)]))<br class="calibre33"/><br class="calibre33"/>(fill {:span :input} "hello")<br class="calibre33"/>;= {:content ["hello"], :span :input}<br class="calibre33"/>(fill {:span :input} "hello")<br class="calibre33"/>;= {:content ["hello"], :span :input}</tt></span></blockquote><p class="calibre23">It works, and we can even get rid of the implementation for <tt class="calibre22">:div</tt> since it’s covered by the base case!</p><p class="calibre18">However, our regular dispatch values are already keywords: this means we can run into trouble if we want to extend <tt class="calibre22">fill</tt> to cover the <tt class="calibre22">&lt;default&gt;</tt> tag<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1081087"></a><a href="#filepos1084397"><span class="calibre32">216</span></a><span class="calibre32">]</span></small></sup> in a specialized way.</p><p class="calibre18">Gladfully <tt class="calibre22">defmulti</tt> takes options, and there’s a way to specify what the default dispatch value should be:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defmulti fill<br class="calibre33"/>  "Fill a xml/html node (as per clojure.xml)<br class="calibre33"/>   with the provided value."<br class="calibre33"/>  (fn [node value] (:tag node))<br class="calibre33"/>  :default nil)                                 </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/><br class="calibre33"/>(defmethod fill nil                             </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  [node value]<br class="calibre33"/>  (assoc node :content [(str value)]))<br class="calibre33"/><br class="calibre33"/>(defmethod fill :input<br class="calibre33"/>  [node value]<br class="calibre33"/>  (assoc-in node [:attrs :value] (str value)))<br class="calibre33"/><br class="calibre33"/>(defmethod fill :default                        </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  [node value]<br class="calibre33"/>  (assoc-in node [:attrs :name] (str value)))</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">defmulti</tt>’s options are simply keyword/value pairs, here used to set the default dispatch value to <tt class="calibre22">nil</tt>.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">Here is the corresponding default implementation.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">This is now not the default implementation but the one for <tt class="calibre22">&lt;default&gt;</tt> elements.<a id="filepos1083202"></a></blockquote><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1083315"></a><a href="#filepos1078306"><span class="calibre32">214</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">This is left as an exercise to the reader.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1083542"></a><a href="#filepos1078481"><span class="calibre32">215</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Multiple dispatch systems similar to Clojure’s multimethods exist for other languages; Philip J. Eby’s PEAK-Rules (</span><a href="http://pypi.python.org/pypi/PEAK-Rules"><span class="calibre10"><span class="calibre5">http://pypi.python.org/pypi/PEAK-Rules</span></span></a><span class="calibre10">) for Python is one particularly mature one. A narrative exploration of implementing Clojure-style multimethods in Python can be found at </span><a href="http://codeblog.dhananjaynene.com/2010/08/clojure-style-multi-methods-in-python/"><span class="calibre10"><span class="calibre5">http://codeblog.dhananjaynene.com/2010/08/clojure-style-multi-methods-in-python/</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1084397"></a><a href="#filepos1081087"><span class="calibre32">216</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Let’s assume we are dealing with some specific XML format or that someone sneaked it into HTML5.</span></p><div class="mbppagebreak"></div><p id="filepos1084633" class="calibre6"><span class="calibre4"><span class="bold">Toward Hierarchies</span></span></p><p id="filepos1084712" class="calibre18">Let’s refine <tt class="calibre22">fill</tt> so that we apply different behaviors for different <tt class="calibre22">&lt;input&gt;</tt> tags. For example, we want to check radio buttons or checkboxes when their <tt class="calibre22">value</tt> attribute matches the value arguments passed to <tt class="calibre22">fill</tt>.</p><p class="calibre18">The current dispatch function does not provide information on attributes so, to dispatch on the <tt class="calibre22">type</tt> attribute, we need to modify the dispatch function:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(ns-unmap *ns* 'fill)<br class="calibre33"/><br class="calibre33"/>(defn- fill-dispatch [node value]<br class="calibre33"/>  (if (= :input (:tag node))<br class="calibre33"/>    [(:tag node) (-&gt; node :attrs :type)]<br class="calibre33"/>    (:tag node)))<br class="calibre33"/><br class="calibre33"/>(defmulti fill<br class="calibre33"/>  "Fill a xml/html node (as per clojure.xml)<br class="calibre33"/>   with the provided value."<br class="calibre33"/>  #'fill-dispatch                             </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  :default nil)<br class="calibre33"/><br class="calibre33"/>(defmethod fill nil<br class="calibre33"/>  [node value]<br class="calibre33"/>  (assoc node :content [(str value)]))<br class="calibre33"/><br class="calibre33"/>(defmethod fill [:input nil]<br class="calibre33"/>  [node value]<br class="calibre33"/>  (assoc-in node [:attrs :value] (str value)))<br class="calibre33"/><br class="calibre33"/>(defmethod fill [:input "hidden"]<br class="calibre33"/>  [node value]<br class="calibre33"/>  (assoc-in node [:attrs :value] (str value)))<br class="calibre33"/><br class="calibre33"/>(defmethod fill [:input "text"]<br class="calibre33"/>  [node value]<br class="calibre33"/>  (assoc-in node [:attrs :value] (str value)))<br class="calibre33"/><br class="calibre33"/>(defmethod fill [:input "radio"]<br class="calibre33"/>  [node value]<br class="calibre33"/>  (if (= value (-&gt; node :attrs :value))<br class="calibre33"/>    (assoc-in node [:attrs :checked] "checked")<br class="calibre33"/>    (update-in node [:attrs] dissoc :checked)))<br class="calibre33"/><br class="calibre33"/>(defmethod fill [:input "checkbox"]<br class="calibre33"/>  [node value]<br class="calibre33"/>  (if (= value (-&gt; node :attrs :value))<br class="calibre33"/>    (assoc-in node [:attrs :checked] "checked")<br class="calibre33"/>    (update-in node [:attrs] dissoc :checked)))<br class="calibre33"/><br class="calibre33"/>(defmethod fill :default<br class="calibre33"/>  [node value]<br class="calibre33"/>  (assoc-in node [:attrs :name] (str value)))</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Using <tt class="calibre22">#'fill-dispatch</tt> instead of simply <tt class="calibre22">fill-dispatch</tt> adds a layer of indirection that allows us to modify the dispatch function without touching <tt class="calibre22">ns-unmap</tt> or losing any already-defined methods. Using <tt class="calibre22">fill-dispatch</tt> captures the value of the dispatch function at the time <tt class="calibre22">defmulti</tt> was evaluated, and the dispatch function would not be updated subsequently. This is very useful when evolving code at the REPL.</blockquote><blockquote id="filepos1087646" class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">REDEFINING A MULTIMETHOD DOES NOT UPDATE THE MULTIMETHOD’S DISPATCH FUNCTION</span></span></span></blockquote><blockquote id="filepos1087845" class="calibre17"><span class="calibre10">Notice that in our example above, we </span><span class="calibre10"><tt class="calibre22">ns-unmap</tt></span><span class="calibre10">
</span><span class="calibre10"><tt class="calibre22">fill</tt></span><span class="calibre10"> from our namespace so we can redefine it. This isn’t typically necessary when redefining functions, but </span><span class="calibre10"><tt class="calibre22">defmulti</tt></span><span class="calibre10"> has </span><span class="calibre10"><tt class="calibre22">defonce</tt></span><span class="calibre10"> semantics, so dispatch functions cannot be changed without unmapping the root var of the multimethod first. This means you have to unmap it from the current namespace before redefining it, or your changes will be silently ignored!</span></blockquote><p class="calibre25">An interesting point of this iteration is that dispatch values are now a mix of <tt class="calibre22">nil</tt>, keywords and pairs of keywords and strings. <span class="italic">Dispatch values are not constrained to keywords</span>. That said, we’ll soon see that keywords still play a special role in regard to multimethods.</p><p class="calibre18">For now, we should test our new code:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(fill {:tag :input<br class="calibre33"/>       :attrs {:value "first choice"<br class="calibre33"/>               :type "checkbox"}}<br class="calibre33"/>      "first choice")                 </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= {:tag :input,<br class="calibre33"/>;=  :attrs {:checked "checked",<br class="calibre33"/>;=          :type "checkbox",<br class="calibre33"/>;=          :value "first choice"}}<br class="calibre33"/>(fill *1 "off")                       </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= {:tag :input<br class="calibre33"/>;=  :attrs {:type "checkbox",<br class="calibre33"/>;=          :value "first choice"}}</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Calling <tt class="calibre22">fill</tt> with a checkbox element’s map and the <tt class="calibre22">:value</tt> of that checkbox is properly yielding a checked checkbox…</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">…and calling <tt class="calibre22">fill</tt> with that checked checkbox and any other value results in an unchecked checkbox.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1090365"></a><a href="#filepos1091292"><span class="calibre32">217</span></a><span class="calibre32">]</span></small></sup></blockquote><p class="calibre18">These results seem good but there’s a fair amount of repetition in the latest iteration: checkboxes and radio buttons should share the same implementation, as should explicit text fields and implicit ones (<tt class="calibre22">nil</tt>) too. Furthermore the <tt class="calibre22">text</tt> behavior should be the default case for unknown types.</p><p class="calibre18">In short, we would like to specify that checkboxes and radio buttons are <span class="italic">checkable inputs</span> and that unknown input types should be treated as text inputs. This can be done by defining a hierarchy, which allows us to express the relationships among dispatch values, which our multimethod will use to refine its selection of method implementations.</p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1091292"></a><a href="#filepos1090365"><span class="calibre32">217</span></a><span class="calibre32">] </span></small></sup><span class="calibre10"><tt class="calibre22">*1</tt></span><span class="calibre10"> holds the value of the last expression evaluated in the REPL. See </span><a href="#filepos1460851"><span class="calibre10"><span class="calibre5">REPL-bound vars</span></span></a><span class="calibre10"> for details.</span></p><div class="mbppagebreak"></div><p id="filepos1091657" class="calibre6"><span class="calibre4"><span class="bold">Hierarchies</span></span></p><p class="calibre18">Clojure’s multimethods allow us to define hierarchies to support whatever relationships your domain requires, including multiple inheritance. These hierarchies are defined in terms of relations between <span class="italic">named objects<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1092012"></a><a href="#filepos1110054"><span class="calibre32">218</span></a><span class="calibre32">]</span></small></sup></span> (keywords or symbols<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1092167"></a><a href="#filepos1110514"><span class="calibre32">219</span></a><span class="calibre32">]</span></small></sup>) and classes.</p><p class="calibre18">“Hierarchies” being plural is no accident: you can have more than one hierarchy. There’s the global (and default) hierarchy and ones you can create as needed via <tt class="calibre22">make-hierarchy</tt>. In addition, hierarchies and multimethods are in no way restricted to a single namespace:<a id="filepos1092590"></a> you can extend a hierarchy (through <tt class="calibre22">derive</tt>) or a multimethod (via <tt class="calibre22">defmethod</tt>) from any namespace—not necessarily the one in which they were defined.</p><p class="calibre18">The global hierarchy being shared, access to it is more guarded. Namely, <span class="italic">non-namespaced keywords (or symbols) cannot be used in the global hierarchy</span><a id="filepos1092952"></a>. This helps prevent two innocent libraries from stepping on each other’s toes by independently choosing to use the same keyword to represent different semantics.</p><p class="calibre18">You define a hierarchical relation with <tt class="calibre22">derive</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(derive ::checkbox ::checkable)     </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= nil<br class="calibre33"/>(derive ::radio ::checkable)<br class="calibre33"/>;= nil<br class="calibre33"/>(derive ::checkable ::input)<br class="calibre33"/>;= nil<br class="calibre33"/>(derive ::text ::input)<br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Recall that <tt class="calibre22">::keyword</tt> is a shorthand for <tt class="calibre22">:current.namespace/keyword</tt>; thus, <tt class="calibre22">::checkbox</tt> here is equivalent to <tt class="calibre22">:user/checkbox</tt>. Also remember that <tt class="calibre22">::keyword</tt> is to <tt class="calibre22">:keyword</tt> as <tt class="calibre22">`symbol</tt> is to <tt class="calibre22">'symbol</tt>. See <a href="#filepos82628"><span class="calibre5">Keywords</span></a> for more details.</blockquote><p class="calibre18">We have just described in the relationships that hold between different “classes”: checkboxes and radio buttons are “checkable,” and all “checkable” and “text” elements are input elements. You can test these relationships within the hierarchy using <tt class="calibre22">isa?</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(isa? ::radio ::input)              </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= true<br class="calibre33"/>(isa? ::radio ::text)<br class="calibre33"/>;= false</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Derivation is transitive: <tt class="calibre22">::radio</tt> is a <tt class="calibre22">::checkable</tt>, which is an <tt class="calibre22">::input</tt>.</blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10"><tt class="calibre22">isa?</tt></span><a id="filepos1095190"></a><span class="calibre10"> is rarely used outside of the REPL. If you find yourself using it a lot in code, it means there’s a multimethod waiting to be extracted. In this regard, it’s very similar to </span><a id="filepos1095398"></a><span class="calibre10"><tt class="calibre22">instance?</tt></span><span class="calibre10">: generally its presence hints at a dispatch facility (Java interface, protocol, or multimethod) to be factored out.</span></blockquote><p class="calibre25">There are a handful of other introspective functions: <tt class="calibre22">underive</tt>, <tt class="calibre22">ancestors</tt>, <tt class="calibre22">parents</tt>, and <tt class="calibre22">descendants</tt>, which are useful either when working at the REPL or can be leveraged to perform some metaprogramming stunts.</p><p class="calibre18">Classes and interfaces can also participate in hierarchies but <span class="italic">only as children of a derivation</span>, never as parents,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1096057"></a><a href="#filepos1110739"><span class="calibre32">220</span></a><span class="calibre32">]</span></small></sup> Said another way, outside of the class hierarchy implicitly defined by your Clojure environment’s classpath,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1096298"></a><a href="#filepos1111197"><span class="calibre32">221</span></a><span class="calibre32">]</span></small></sup> classes and interfaces can only ever be leaves in a hierarchy.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(isa? java.util.ArrayList Object)<br class="calibre33"/>;= true<br class="calibre33"/>(isa? java.util.ArrayList java.util.List)<br class="calibre33"/>;= true<br class="calibre33"/>(isa? java.util.ArrayList java.util.Map)     </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= false<br class="calibre33"/>(derive java.util.Map ::collection)          </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= nil<br class="calibre33"/>(derive java.util.Collection ::collection)<br class="calibre33"/>;= nil<br class="calibre33"/>(isa? java.util.ArrayList ::collection)      </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= true<br class="calibre33"/>(isa? java.util.HashMap ::collection)<br class="calibre33"/>;= true</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">In the Java Collections framework, <tt class="calibre22">Map</tt>s and <tt class="calibre22">Collection</tt>s are entirely separate. No dispatch mechanism that relies solely on these static types can provide a way to handle a <tt class="calibre22">Map</tt> and a <tt class="calibre22">Collection</tt> with a single method (short of falling back to, for example, <tt class="calibre22">Object</tt>).</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">We can declare that <tt class="calibre22">Map</tt> and <tt class="calibre22">Collection</tt> are derived from a new identifier in the global hierarchy, called <tt class="calibre22">::collection</tt>.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">We can now use <tt class="calibre22">::collection</tt><a id="filepos1098282"></a> as a target dispatch value in <tt class="calibre22">defmethod</tt>, as it now matches any classes that implement <tt class="calibre22">Map</tt> or <tt class="calibre22">Collection</tt>.</blockquote><p class="calibre18">This aspect of hierarchies isn’t relevant to our running example, though. We’ll return to the topic of using classes and interfaces in hierarchies in <a href="#filepos1118504"><span class="calibre5">Multiple Inheritance</span></a>.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">The whole Java class hierarchy is always part of any hierarchy, even when freshly created by </span><span class="calibre10"><tt class="calibre22">make-hierarchy</tt></span><a id="filepos1099018"></a><span class="calibre10">.</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(def h (make-hierarchy))<br class="calibre33"/>;= #'user/h<br class="calibre33"/>(isa? h java.util.ArrayList java.util.Collection)<br class="calibre33"/>;= true</tt></span></blockquote><blockquote class="calibre35"><span class="calibre10">Thus </span><span class="calibre10"><tt class="calibre22">isa?</tt></span><span class="calibre10"> supersets </span><span class="calibre10"><tt class="calibre22">instance?</tt></span><span class="calibre10">, in that it can be used to test whether a class is derived from another class, or whether a class implements an interface.</span></blockquote><p id="filepos1099597" class="calibre25"><span class="calibre19"><span class="bold"><span class="calibre5">Independent Hierarchies</span></span></span></p><p class="calibre18">Currently <tt class="calibre22">fill-dispatch</tt><a id="filepos1099770"></a> returns <tt class="calibre22">nil</tt>, keywords, and vectors. Two of them can’t participate in hierarchies (<tt class="calibre22">nil</tt> and vectors) and the third can’t participate in the global hierarchy because those keywords are not namespaced.</p><p class="calibre18">So we are left with the choice between having <tt class="calibre22">fill-dispatch</tt> return namespaced keywords, or using a private hierarchy.</p><p class="calibre18"><tt class="calibre22">derive</tt><a id="filepos1100202"></a> implicitly mutates the global hierarchy, but when you use a custom hierarchy, you have to manage the mutation yourself. It’s as simple as putting the hierarchy into a reference type such as refs, atoms, or vars. Var is a safe choice:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1100480"></a><a href="#filepos1111540"><span class="calibre32">222</span></a><span class="calibre32">]</span></small></sup> that’s what is used for the global hierarchy.</p><p id="filepos1100627" class="calibre23"></p><p class="calibre23"><span class="italic">Example 7-1. Implementing fill with a custom hierarchy</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(ns-unmap *ns* 'fill)<br class="calibre33"/><br class="calibre33"/>(def fill-hierarchy (-&gt; (make-hierarchy)                      </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>                      (derive :input.radio ::checkable)<br class="calibre33"/>                      (derive :input.checkbox ::checkable)<br class="calibre33"/>                      (derive ::checkable :input)<br class="calibre33"/>                      (derive :input.text :input)<br class="calibre33"/>                      (derive :input.hidden :input)))<br class="calibre33"/><br class="calibre33"/>(defn- fill-dispatch [node value]<br class="calibre33"/>  (if-let [type (and (= :input (:tag node))<br class="calibre33"/>                  (-&gt; node :attrs :type))]<br class="calibre33"/>    (keyword (str "input." type))<br class="calibre33"/>    (:tag node)))<br class="calibre33"/><br class="calibre33"/>(defmulti fill<br class="calibre33"/>  "Fill a xml/html node (as per clojure.xml)<br class="calibre33"/>   with the provided value."<br class="calibre33"/>  #'fill-dispatch<br class="calibre33"/>  :default nil<br class="calibre33"/>  :hierarchy #'fill-hierarchy)                                 </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/><br class="calibre33"/>(defmethod fill nil [node value]<br class="calibre33"/>  (assoc node :content [(str value)]))<br class="calibre33"/><br class="calibre33"/>(defmethod fill :input [node value]<br class="calibre33"/>  (assoc-in node [:attrs :value] (str value)))<br class="calibre33"/><br class="calibre33"/>(defmethod fill ::checkable [node value]<br class="calibre33"/>  (if (= value (-&gt; node :attrs :value))<br class="calibre33"/>    (assoc-in node [:attrs :checked] "checked")<br class="calibre33"/>    (update-in node [:attrs] dissoc :checked)))</tt></span></p><p class="calibre23"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Both <tt class="calibre22">input.type</tt> and <tt class="calibre22">::checkable</tt> are means of avoiding potential collisions with legitimate tag names. <tt class="calibre22">.</tt> in a keyword has no special meaning—it’s simply part of its name.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">Multimethods expect a reference type of some kind as the value of the <tt class="calibre22">:hierarchy</tt> option, not a hierarchy value; this allows you to update the hierarchy if necessary at runtime. In this case, we provide the <tt class="calibre22">fill-hierarchy</tt>
<span class="italic">var</span> (rather than its value at the time of evaluating the <tt class="calibre22">defmulti</tt> form); we could use <tt class="calibre22">alter-var-root</tt> to modify the hierarchy dynamically, without redefining the multimethod’s root.</blockquote><blockquote class="calibre89"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">All hierarchy-related functions (such as </span><span class="calibre10"><tt class="calibre22">derive</tt></span><span class="calibre10">, </span><span class="calibre10"><tt class="calibre22">isa?</tt></span><span class="calibre10">, </span><span class="calibre10"><tt class="calibre22">parents</tt></span><span class="calibre10">, and so on) require the hierarchy value as an additional first argument. Out of this list, </span><span class="calibre10"><tt class="calibre22">derive</tt></span><span class="calibre10"> is the most peculiar because without an explicit hierarchy, it’s a side-effecting function—modifying the global hierarchy—and with an explicit hierarchy, it’s a pure function!</span></blockquote><p class="calibre25">Our latest iteration on the <tt class="calibre22">fill</tt> code doesn’t repeat itself, so this goal has been attained. The second goal is not a success though: indeed unknown input types, like text inputs, are not handled.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(fill {:tag :input<br class="calibre33"/>       :attrs {:type "date"}}<br class="calibre33"/>      "20110820")<br class="calibre33"/>;= {:content ["20110820"], :attrs {:type "date"}, :tag :input}</tt></span></blockquote><p class="calibre23">Not exactly what we had in mind! We haven’t expressed that unknown input types should be treated as text. The problem is that the set of inputs of unknown types is open, so we can’t create all the necessary derivations by anticipation. And, since the set of dispatch values is bigger than only those for input tags, we can’t use the default value for covering unexpected input types.</p><p class="calibre18">Or can we? If we think <span class="italic">dynamically</span> instead of assuming that we must statically define our hierarchy ahead of time, we realize that hierarchies are <span class="italic">not</span> static. This means our default case can act as a safety net and dynamically define the needed derivation so that for a given new input type, the default case will be hit only once.</p><p id="filepos1105631" class="calibre23"></p><p class="calibre23"><span class="italic">Example 7-2. Dynamically updating the hierarchy used by fill</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(defmethod fill nil [node value]<br class="calibre33"/>  (if (= :input (:tag node))<br class="calibre33"/>    (do<br class="calibre33"/>      (alter-var-root #'fill-hierarchy<br class="calibre33"/>        derive (fill-dispatch node value) :input)   </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>      (fill node value))                            </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>    (assoc node :content [(str value)])))</tt></span></p><p class="calibre23"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">We alter the value of the var dynamically, specifying that the dispatch value for the unknown <tt class="calibre22">:input</tt> node should derive from <tt class="calibre22">:input</tt> in our hierarchy.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">After making that change, we recursively call <tt class="calibre22">fill</tt>, which will dispatch to the <tt class="calibre22">:input</tt> method implementation now that we’ve updated the hierarchy with a new derivation suited for this case.</blockquote><p class="calibre13">This trick works well:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(fill {:tag :input<br class="calibre33"/>       :attrs {:type "date"}}<br class="calibre33"/>      "20110820")<br class="calibre33"/>;= {:attrs {:value "20110820", :type "date"}, :tag :input}</tt></span></blockquote><p class="calibre23">A less clever way of achieving this result would be to introduce a <tt class="calibre22">fill-input</tt> multimethod and calling it from the <tt class="calibre22">:input</tt> case of <tt class="calibre22">fill</tt>.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(ns-unmap *ns* 'fill)<br class="calibre33"/><br class="calibre33"/>(def input-hierarchy (-&gt; (make-hierarchy)<br class="calibre33"/>                         (derive :input.radio ::checkable)<br class="calibre33"/>                         (derive :input.checkbox ::checkable)))   </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/><br class="calibre33"/>(defn- fill-dispatch [node value]<br class="calibre33"/>  (:tag node))<br class="calibre33"/><br class="calibre33"/>(defmulti fill<br class="calibre33"/>  "Fill a xml/html node (as per clojure.xml)<br class="calibre33"/>   with the provided value."<br class="calibre33"/>  #'fill-dispatch<br class="calibre33"/>  :default nil)                                                   </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/><br class="calibre33"/>(defmulti fill-input<br class="calibre33"/>  "Fill an input field."<br class="calibre33"/>  (fn [node value] (-&gt; node :attrs :type))<br class="calibre33"/>  :default nil<br class="calibre33"/>  :hierarchy #'input-hierarchy)<br class="calibre33"/><br class="calibre33"/>(defmethod fill nil [node value]<br class="calibre33"/>  (assoc node :content [(str value)]))<br class="calibre33"/><br class="calibre33"/>(defmethod fill :input [node value]<br class="calibre33"/>  (fill-input node value))<br class="calibre33"/><br class="calibre33"/>(defmethod fill-input nil [node value]<br class="calibre33"/>  (assoc-in node [:attrs :value] (str value)))<br class="calibre33"/><br class="calibre33"/>(defmethod fill-input ::checkable [node value]<br class="calibre33"/>  (if (= value (-&gt; node :attrs :value))<br class="calibre33"/>    (assoc-in node [:attrs :checked] "checked")<br class="calibre33"/>    (update-in node [:attrs] dissoc :checked)))</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Explicitly deriving <tt class="calibre22">:text</tt> and <tt class="calibre22">:hidden</tt> from the default case is no longer necessary. Plus, it’s downright impossible because our default dispatch value is <tt class="calibre22">nil</tt>, which cannot participate in hierarchies.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">fill</tt> no longer depends on a custom hierarchy—only <tt class="calibre22">fill-input</tt>.<a id="filepos1109941"></a></blockquote><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1110054"></a><a href="#filepos1092012"><span class="calibre32">218</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Named objects are objects on which you can call </span><span class="calibre10"><tt class="calibre22">name</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">namespace</tt></span><span class="calibre10">, they implement the </span><span class="calibre10"><tt class="calibre22">clojure.lang.Named</tt></span><span class="calibre10"> interface.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1110514"></a><a href="#filepos1092167"><span class="calibre32">219</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Keywords are generally preferred though.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1110739"></a><a href="#filepos1096057"><span class="calibre32">220</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">The only way to derive from a class or interface is to create a type with interop or </span><span class="calibre10"><tt class="calibre22">deftype</tt></span><span class="calibre10">, </span><span class="calibre10"><tt class="calibre22">defrecord</tt></span><span class="calibre10">, or </span><span class="calibre10"><tt class="calibre22">reify</tt></span><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1111197"></a><a href="#filepos1096298"><span class="calibre32">221</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="#filepos1168529"><span class="calibre10"><span class="calibre5">A classpath primer</span></span></a><span class="calibre10"> for information about the classpath.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1111540"></a><a href="#filepos1100480"><span class="calibre32">222</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">It’s the safe choice because hierarchies generally don’t change often and you want changes to them to be visible from all threads. If you have other requirements (e.g., transactional changes or dynamic scope), pick the relevant reference type. See </span><a href="#filepos593810"><span class="calibre10"><span class="calibre5">Chapter 4</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos1112040" class="calibre6"><span class="calibre4"><span class="bold">Making It Really Multiple!</span></span></p><p id="filepos1112127" class="calibre18">So far, our example has exerted non-type-based dispatch but not multiple dispatch: the second argument (<tt class="calibre22">value</tt>) was carefully ignored in all previous dispatch functions.</p><p class="calibre18">That’s not much of a big deal because most multiple dispatch works in the same way: the dispatch function computes one value, which gets matched to an implementation according to the applicable hierarchy. The multimethod system is unaware that our dispatch functions <a id="filepos1112633"></a>were only vetting the first argument.</p><p class="calibre18">However, dispatch values that are vectors are special-cased by <tt class="calibre22">isa?</tt>, element by element:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1112841"></a><a href="#filepos1117712"><span class="calibre32">223</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(isa? fill-hierarchy [:input.checkbox :text] [::checkable :input])<br class="calibre33"/>;= true</tt></span></blockquote><p class="calibre23">As we already pointed out, the Java class hierarchy is included in all hierarchies, this means we can throw some classes into the mix if we need to:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(isa? fill-hierarchy [:input.checkbox String] [::checkable CharSequence])<br class="calibre33"/>;= true</tt></span></blockquote><p class="calibre23">We are going to leverage this feature to make <tt class="calibre22">fill</tt> smarter and react accordingly to the type of its <tt class="calibre22">value</tt> argument.</p><p class="calibre18">The first step is to modify <tt class="calibre22">fill-dispatch</tt> to return a vector of one keyword and one class.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1113792"></a><a href="#filepos1117969"><span class="calibre32">224</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn- fill-dispatch [node value]<br class="calibre33"/>  (if-let [type (and (= :input (:tag node))<br class="calibre33"/>                  (-&gt; node :attrs :type))]<br class="calibre33"/>    [(keyword (str "input." type)) (class value)]<br class="calibre33"/>    [(:tag node) (class value)]))</tt></span></blockquote><p class="calibre23">Now we’d like to say that the base case is to convert the value to a <tt class="calibre22">String</tt>, whatever its type is. However, checkboxes accept sets as values: a checkbox will be checked if and only if its value is in the set.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(ns-unmap *ns* 'fill)<br class="calibre33"/><br class="calibre33"/>(def fill-hierarchy (-&gt; (make-hierarchy)<br class="calibre33"/>                      (derive :input.radio ::checkable)<br class="calibre33"/>                      (derive :input.checkbox ::checkable)))<br class="calibre33"/><br class="calibre33"/>(defn- fill-dispatch [node value]<br class="calibre33"/>  (if-let [type (and (= :input (:tag node))<br class="calibre33"/>                  (-&gt; node :attrs :type))]<br class="calibre33"/>    [(keyword (str "input." type)) (class value)]<br class="calibre33"/>    [(:tag node) (class value)]))<br class="calibre33"/><br class="calibre33"/>(defmulti fill<br class="calibre33"/>  "Fill a xml/html node (as per clojure.xml)<br class="calibre33"/>   with the provided value."<br class="calibre33"/>  #'fill-dispatch<br class="calibre33"/>  :default nil<br class="calibre33"/>  :hierarchy #'fill-hierarchy)<br class="calibre33"/><br class="calibre33"/>(defmethod fill nil<br class="calibre33"/>  [node value]<br class="calibre33"/>  (if (= :input (:tag node))<br class="calibre33"/>    (do<br class="calibre33"/>      (alter-var-root #'fill-hierarchy<br class="calibre33"/>        derive (first (fill-dispatch node value)) :input)    </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>      (fill node value))<br class="calibre33"/>    (assoc node :content [(str value)])))<br class="calibre33"/><br class="calibre33"/>(defmethod fill<br class="calibre33"/>  [:input Object] [node value]<br class="calibre33"/>  (assoc-in node [:attrs :value] (str value)))<br class="calibre33"/><br class="calibre33"/>(defmethod fill [::checkable clojure.lang.IPersistentSet]<br class="calibre33"/>  [node value]<br class="calibre33"/>  (if (contains? value (-&gt; node :attrs :value))<br class="calibre33"/>    (assoc-in node [:attrs :checked] "checked")<br class="calibre33"/>    (update-in node [:attrs] dissoc :checked)))</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">This new <tt class="calibre22">first</tt> is here to take only the keyword part of the dispatch value. Remember: you can only use keywords, symbols, or classes in hierarchies.</blockquote><p class="calibre18">Now we can check and uncheck checkboxes by using the more flexible set notation for checkable values:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(fill {:tag :input<br class="calibre33"/>       :attrs {:value "yes"<br class="calibre33"/>               :type "checkbox"}}<br class="calibre33"/>         #{"yes" "y"})<br class="calibre33"/>;= {:attrs {:checked "checked", :type "checkbox", :value "yes"}, :tag :input}<br class="calibre33"/>(fill *1 #{"no" "n"})<br class="calibre33"/>;= {:attrs {:type "checkbox", :value "yes"}, :tag :input}</tt></span></blockquote><p class="calibre23">While other input elements and noninput elements are filled as we’d expect:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(fill {:tag :input :attrs {:type "text"}} "some text")<br class="calibre33"/>;= {:attrs {:value "some text", :type "text"}, :tag :input}<br class="calibre33"/>(fill {:tag :h1} "Big Title!")<br class="calibre33"/>;= {:content ["Big Title!"], :tag :h1}</tt></span></blockquote><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1117712"></a><a href="#filepos1112841"><span class="calibre32">223</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">It works recursively: you can use vectors of vectors as dispatch values!</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1117969"></a><a href="#filepos1113792"><span class="calibre32">224</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">This example is based on </span><a href="#filepos1100627"><span class="calibre10"><span class="calibre5">Example 7-1</span></span></a><span class="calibre10"> along with the dynamic modification of hierarchies as demonstrated in </span><a href="#filepos1105631"><span class="calibre10"><span class="calibre5">Example 7-2</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos1118426" class="calibre6"><span class="calibre4"><span class="bold">A Few More Things</span></span></p><p id="filepos1118504" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Multiple Inheritance</span></span></span></p><p id="filepos1118614" class="calibre18">Our running <tt class="calibre22">fill</tt> example doesn’t have a hierarchy complex enough to introduce multiple “inheritance.” Such relationships arise frequently when you have multimethods dealing with interfaces.</p><p class="calibre18">Let’s say we want a <tt class="calibre22">run</tt> function that can execute anything vaguely runnable (like <tt class="calibre22">java.lang.Runnable</tt> and <tt class="calibre22">java.util.concurrent.Callable</tt>):</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defmulti run "Executes the computation." class)<br class="calibre33"/><br class="calibre33"/>(defmethod run Runnable<br class="calibre33"/>  [x]<br class="calibre33"/>  (.run x))<br class="calibre33"/><br class="calibre33"/>(defmethod run java.util.concurrent.Callable<br class="calibre33"/>  [x]<br class="calibre33"/>  (.call x))</tt></span></blockquote><p class="calibre23">Let’s test it on a function:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(run #(println "hello!"))<br class="calibre33"/>;= #&lt;IllegalArgumentException java.lang.IllegalArgumentException:<br class="calibre33"/>;=   Multiple methods in multimethod 'run' match dispatch value:<br class="calibre33"/>;=     class user$fn__1422 -&gt; interface java.util.concurrent.Callable and<br class="calibre33"/>;=                            interface java.lang.Runnable, and neither is preferred&gt;</tt></span></blockquote><p class="calibre23">The exception is pretty self-explanatory: since Clojure functions implement both <tt class="calibre22">Runnable</tt> and <tt class="calibre22">Callable</tt>, the multimethod doesn’t know which implementation to pick and hints that one should be <span class="italic">preferred</span>.</p><p class="calibre18">Preferences <a id="filepos1120224"></a>are expressed through the <tt class="calibre22">prefer-method</tt><a id="filepos1120279"></a> function. This function expects three arguments: the multimethod considered and <span class="italic">two</span> dispatch values, the first being the one that should be preferred over the second:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(prefer-method run java.util.concurrent.Callable Runnable)<br class="calibre33"/>;= #&lt;MultiFn clojure.lang.MultiFn@6dc98c1b&gt;<br class="calibre33"/>(run #(println "hello!"))<br class="calibre33"/>;= hello!<br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre23">Now the multimethod knows which implementation to pick, to <span class="italic">prefer</span>, and runs without problem.</p><p class="calibre18">This preferences mechanism allows us to declaratively resolve <span class="italic">diamond problems</span>,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1121017"></a><a href="#filepos1130318"><span class="calibre32">225</span></a><span class="calibre32">]</span></small></sup> that is, situations where one class derives from the same superclass via two or more other intermediary superclasses. Hence you don’t have to defensively design your hierarchies in fear of multiple inheritance. <span class="italic">Preferences make multiple inheritance explicit, and therefore easy to reason about.</span></p><p id="filepos1121420" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Introspecting Multimethods</span></span></span></p><p id="filepos1121536" class="calibre18">There are a handful of rarely used functions that allow you to go meta with multimethods: <tt class="calibre22">remove-method</tt>, <tt class="calibre22">remove-all-methods</tt>, <tt class="calibre22">prefers</tt>, <tt class="calibre22">methods</tt>, and <tt class="calibre22">get-method</tt>. These functions allow you to query and update multimethods.</p><p class="calibre18">You’ll notice that there’s no <tt class="calibre22">add-method</tt> though. It’s good to know that the <tt class="calibre22">defmethod</tt> macro, despite being a <tt class="calibre22">def</tt>-something form, isn’t required to be a top-level expression. However, you may prefer to register an existing function as a method implementation; we can find out how to do this by taking a peek under the covers:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(macroexpand-1 '(defmethod mmethod-name dispatch-value [args] body))<br class="calibre33"/>;= (. mmethod-name clojure.core/addMethod dispatch-value (clojure.core/fn [args] <br class="calibre33"/>    body)) </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">The <tt class="calibre22">clojure.core/addMethod</tt> instead of just <tt class="calibre22">addMethod</tt> is an artifact of <tt class="calibre22">syntax-quote</tt>. Preventing it is awkward but Clojure is smart enough to know to ignore namespaces on Java methods names.</blockquote><p class="calibre18">This suggests a simple implementation of <tt class="calibre22">add-method</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn add-method [multifn dispatch-val f]<br class="calibre33"/>  (.addMethod multifn dispatch-val f))</tt></span></blockquote><p class="calibre23">As a side note, it happens that this function can be found as a private function of the <tt class="calibre22">clojure.pprint</tt> namespace, under the name <tt class="calibre22">use-method</tt>. However, whether you are using <tt class="calibre22">use-method</tt> or the above exposed <tt class="calibre22">add-method</tt> you are relying on an implementation detail, so be prepared to actively maintain it with next releases of Clojure.</p><p id="filepos1123608" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">type Versus class; or, the Revenge of the Map</span></span></span></p><p class="calibre18"><tt class="calibre22">class</tt><a id="filepos1123785"></a> has a close cousin, <tt class="calibre22">type</tt>. <tt class="calibre22">(type x)</tt> generally returns the same result as <tt class="calibre22">(class x)</tt>, except when <tt class="calibre22">x</tt> has <tt class="calibre22">:type</tt> metadata:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(class {})<br class="calibre33"/>;= clojure.lang.PersistentArrayMap<br class="calibre33"/>(type {})<br class="calibre33"/>;= clojure.lang.PersistentArrayMap<br class="calibre33"/>(class ^{:type :a-tag} {})<br class="calibre33"/>;= clojure.lang.PersistentArrayMap<br class="calibre33"/>(type ^{:type :a-tag} {})<br class="calibre33"/>;= :a-tag</tt></span></blockquote><p class="calibre23"><tt class="calibre22">:type</tt> metadata <a id="filepos1124347"></a>is a low ceremony way of categorizing data into types and having these types participate in multimethods. Note that it also works if you put the metadata on other kinds of objects: vectors, sets, functions, and so on.</p><p class="calibre18">For example, let’s extend our example from <a href="#filepos1118504"><span class="calibre5">Multiple Inheritance</span></a> to make it so that our <tt class="calibre22">run</tt> multimethod will interchangeably accept <tt class="calibre22">Runnable</tt>s, <tt class="calibre22">Callable</tt>, regular Clojure functions, as well as maps “typed” as runnable that contain any of these things in a <tt class="calibre22">:run</tt> slot:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(ns-unmap *ns* 'run)<br class="calibre33"/><br class="calibre33"/>(defmulti run "Executes the computation." type)                           </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/><br class="calibre33"/>(defmethod run Runnable<br class="calibre33"/>  [x]<br class="calibre33"/>  (.run x))<br class="calibre33"/><br class="calibre33"/>(defmethod run java.util.concurrent.Callable<br class="calibre33"/>  [x]<br class="calibre33"/>  (.call x))<br class="calibre33"/><br class="calibre33"/>(prefer-method run java.util.concurrent.Callable Runnable)<br class="calibre33"/><br class="calibre33"/>(defmethod run :runnable-map<br class="calibre33"/>  [m]<br class="calibre33"/>  (run (:run m)))<br class="calibre33"/><br class="calibre33"/>(run #(println "hello!"))<br class="calibre33"/>;= hello!<br class="calibre33"/>;= nil<br class="calibre33"/>(run (reify Runnable<br class="calibre33"/>       (run [this] (println "hello!"))))<br class="calibre33"/>;= hello!<br class="calibre33"/>;= nil<br class="calibre33"/>(run ^{:type :runnable-map}<br class="calibre33"/>      {:run #(println "hello!") :other :data})<br class="calibre33"/>;= hello!<br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">We now have <tt class="calibre22">type</tt> acting as the dispatch function for <tt class="calibre22">run</tt>, so that it will return the <tt class="calibre22">:type</tt> metadata on any passed maps, falling back to returning the class of the argument if no such metadata is available.</blockquote><p class="calibre18">Of course, you could modify the dispatch function to explicitly check for a <tt class="calibre22">:run</tt> slot in any provided map to achieve the same end. However, what would happen if you wanted to be able to <tt class="calibre22">run</tt> some function you knew was available as the last element of vectors produced elsewhere in your application? You would need to modify your dispatch function to allow for that, thereby subverting a big part of the motivation of multimethods (and really, many of Clojure’s other facilities): to allow you to disentangle operations from the data that is being operated over.</p><p id="filepos1126997" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">The Range of Dispatch Functions Is Unlimited</span></span></span></p><p id="filepos1127131" class="calibre18">Our final example will help to illustrate the flexibility that is available to you with multimethods. So far, we’ve been working with multimethods whose dispatch functions return values based solely on their arguments. However, there is no requirement at all that that be the case.</p><p class="calibre18">Consider a messaging system where the handling of each message is significantly different depending upon its priority:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def priorities (atom {:911-call :high<br class="calibre33"/>                       :evacuation :high<br class="calibre33"/>                       :pothole-report :low<br class="calibre33"/>                       :tree-down :low}))<br class="calibre33"/><br class="calibre33"/>(defmulti route-message<br class="calibre33"/>  (fn [message] (@priorities (:type message))))<br class="calibre33"/><br class="calibre33"/>(defmethod route-message :low<br class="calibre33"/>  [{:keys [type]}]<br class="calibre33"/>  (println (format "Oh, there's another %s. Put it in the log." (name type))))<br class="calibre33"/><br class="calibre33"/>(defmethod route-message :high<br class="calibre33"/>  [{:keys [type]}]<br class="calibre33"/>  (println (format "Alert the authorities, there's a %s!" (name type))))</tt></span></blockquote><p class="calibre23">This seems pretty straightforward:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1128495"></a><a href="#filepos1130692"><span class="calibre32">226</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(route-message {:type :911-call})<br class="calibre33"/>;= Alert the authorities, there's a 911-call!<br class="calibre33"/>;= nil<br class="calibre33"/>(route-message {:type :tree-down})<br class="calibre33"/>;= Oh, there's another tree-down. Put it in the log.<br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre23">However, what if the message priorities themselves can change dynamically? No problem: just adjust the data that is driving the dispatch function, and the behavior of <tt class="calibre22">route-message</tt> can change significantly <span class="italic">without any changes to code or data</span>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(swap! priorities assoc :tree-down :high)<br class="calibre33"/>;= {:911-call :high, :pothole-report :low, :tree-down :high, :evacuation :high}<br class="calibre33"/>(route-message {:type :tree-down})<br class="calibre33"/>;= Alert the authorities, there's a tree-down!<br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre23">This gives you a lot of latitude and power, perhaps just enough to solve the problem you have. At the same time—apologies for the mixed metaphor—it might be just enough rope with which to hang yourself. A multimethod whose behavior is not strictly dependent upon the values provided as arguments is, by definition, not idempotent.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1129948"></a><a href="#filepos1131026"><span class="calibre32">227</span></a><span class="calibre32">]</span></small></sup> That doesn’t make such functions unreliable or evil or useless, just more difficult to understand, test, and compose with other functions compared to their idempotent cousins.</p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1130318"></a><a href="#filepos1121017"><span class="calibre32">225</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Not always a diamond as Clojure’s hierarchies don’t have a universal root. In Clojure, this problem would best be named the </span><span class="calibre10"><span class="italic">V problem</span></span><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1130692"></a><a href="#filepos1128495"><span class="calibre32">226</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Presumably our </span><span class="calibre10"><tt class="calibre22">route-message</tt></span><span class="calibre10"> implementations would do more than print something to standard out.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1131026"></a><a href="#filepos1129948"><span class="calibre32">227</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="#filepos316677"><span class="calibre10"><span class="calibre5">Pure Functions</span></span></a><span class="calibre10"> for more about idempotence, pure functions, and their benefits.</span></p><div class="mbppagebreak"></div><p id="filepos1131345" class="calibre6"><span class="calibre4"><span class="bold">Final Thoughts</span></span></p><p class="calibre18">Following along the <tt class="calibre22">fill</tt> example, we have covered all of the essential features of Clojure multimethods.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1131596"></a><a href="#filepos1132173"><span class="calibre32">228</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">It takes some time to get accustomed to their power, to think outside of single type-based dispatch. Each time you envision writing a bunch of nested conditionals or a big <tt class="calibre22">cond</tt> or defining a plethora of types just to link your data with particular functionality, you should ask yourself whether a multimethod wouldn’t serve you better.<a id="filepos1132069"></a></p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1132173"></a><a href="#filepos1131596"><span class="calibre32">228</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">You can find some additional examples that use multimethods in </span><a href="#filepos1819820"><span class="calibre10"><span class="calibre5">Chapter 15</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos1132485" class="calibre6"><span class="calibre4"><span class="bold">Part III. Tools, Platform, and Projects</span></span></p><div class="mbppagebreak"></div><p id="filepos1132603" class="calibre6"><span class="calibre2"><span class="bold">Chapter 8. Organizing and Building Clojure Projects</span></span></p><p id="filepos1132717" class="calibre13">Ironically, one of the most challenging aspects of adopting a new, promising programming language often has little to do with the language itself: you need to organize and build the codebase you’ve written in that new language into artifacts that can be distributed and used, either by other programmers as libraries, by end users, or installed into, for example, server environments as is done for web applications. The specifics of this challenge can vary greatly depending upon whether you’re using the new language as part of an existing project or in an entirely new effort, and what your specific deployment requirements are.</p><p class="calibre18">It’s impossible for us to cover all the ways in which you can organize your projects and redistribute the fruits of your Clojure labors, and differences of opinion in some of these areas can often outstrip their importance,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1133672"></a><a href="#filepos1183917"><span class="calibre32">229</span></a><span class="calibre32">]</span></small></sup> but it is incumbent upon us to set you on a good path that is in accordance with the typical approaches in the Clojure community. In this chapter, we’ll give you some general hints on how to think about structuring Clojure codebases, and present the best ways to solve the build problem for Clojure projects using the two most popular build tools in the Clojure community, Leiningen and Maven.</p><p id="filepos1134167" class="calibre6"><span class="calibre4"><span class="bold">Project Geography</span></span></p><p class="calibre18">Before getting into the mechanics of builds, we first need to establish how to organize your Clojure projects with regard to the physical placement of files as well as the functional organization of your codebase. This means talking about <span class="italic">namespaces</span>.</p><p id="filepos1134534" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Defining and Using Namespaces</span></span></span></p><p id="filepos1134653" class="calibre18">As we said in <a href="#filepos109342"><span class="calibre5">Namespaces</span></a>,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1134796"></a><a href="#filepos1184521"><span class="calibre32">230</span></a><span class="calibre32">]</span></small></sup> Clojure’s namespaces:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Are dynamic mappings of symbols to Java class names and vars, the latter containing any value you specify (most often functions, constant data, and reference types)</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Are roughly analogous to packages in Java and modules in Python and Ruby</blockquote></li></ul><p class="calibre18">All Clojure code is defined within namespaces. If you neglect to define your own, any vars you define will be mapped into the default <tt class="calibre22">user</tt> namespace. While fine for a lot of REPL <a id="filepos1135604"></a>interactions, that’s almost never a good idea once you want to build something to last and be used by others. We need to know how to define namespaces idiomatically, how they map onto individual source files, and how they are best used to provide high-level structure and organization for your Clojure codebase. Clojure provides discrete functions for manipulating the minutiae of namespaces (very useful at the REPL), as well as a unification of those functions into a single macro that we can use to declare in one place a namespace’s name, top-level documentation, and dependencies on other namespaces and Java classes.</p><p class="calibre18"><span class="bold">in-ns</span>. <a id="filepos1136284"></a><tt class="calibre22">def</tt> and all of its variants (like <tt class="calibre22">defn</tt>) define vars within the <span class="italic">current namespace</span>, which is always bound in <tt class="calibre22">*ns*</tt>:</p><p class="calibre8"></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">*ns*<br class="calibre33"/>;= #&lt;Namespace user&gt;<br class="calibre33"/>(defn a [] 42)<br class="calibre33"/>;= #'user/a</tt></span></blockquote><p class="calibre23">Using <tt class="calibre22">in-ns</tt>, we can switch to other namespaces (creating them if they don’t already exist), thereby allowing us to define vars in those other namespaces:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(in-ns 'physics.constants)<br class="calibre33"/>;= #&lt;Namespace physics.constants&gt;<br class="calibre33"/>(def ^:const planck 6.62606957e-34)<br class="calibre33"/>;= #'physics.constants/planck</tt></span></blockquote><p class="calibre23">However, we’ll quickly discover that something is awry in our new namespace:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(+ 1 1)<br class="calibre33"/>;= #&lt;CompilerException java.lang.RuntimeException:<br class="calibre33"/>;=   Unable to resolve symbol: + in this context, compiling:(NO_SOURCE_PATH:1)&gt;</tt></span></blockquote><p class="calibre23">The <tt class="calibre22">+</tt> function <a id="filepos1137500"></a>(and all other functions in the <tt class="calibre22">clojure.core</tt> namespace) aren’t available as they are in the default <tt class="calibre22">user</tt> namespace we’ve worked within all along—though they are accessible using a namespace-qualified symbol:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(clojure.core/range -20 20 4)<br class="calibre33"/>;= (-20 -16 -12 -8 -4 0 4 8 12 16)</tt></span></blockquote><p class="calibre23">Remember that namespaces are mappings of symbols to vars; while <tt class="calibre22">in-ns</tt> switches us to the namespace we name, that’s all it does. Special forms remain available (including <tt class="calibre22">def</tt>, <tt class="calibre22">var</tt>, <tt class="calibre22">.</tt>, and so on), but we need to load code from other namespaces and map vars named there into our new namespace in order to use that code reasonably succinctly.</p><p id="filepos1138316" class="calibre18"><span class="bold">refer</span>. <a id="filepos1138359"></a>Assuming a namespace is already loaded, we can use <tt class="calibre22">refer</tt> to add mappings to its vars for our namespace. We defined a dummy function <tt class="calibre22">a</tt> in the <tt class="calibre22">user</tt> namespace earlier. We can establish mappings in our empty namespace for all of the public vars in <tt class="calibre22">user</tt>, allowing us to access <tt class="calibre22">a</tt> more easily:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">user/a<br class="calibre33"/>;= #&lt;user$a user$a@6080669d&gt;<br class="calibre33"/>(clojure.core/refer 'user)<br class="calibre33"/>;= nil<br class="calibre33"/>(a)<br class="calibre33"/>;= 42</tt></span></blockquote><p class="calibre23"><tt class="calibre22">a</tt> is now mapped within our current namespace to the var at <tt class="calibre22">user/a</tt>, and we can use it as if it were defined locally. That’s certainly easier than having to use namespace-qualified symbols everywhere to access vars in other namespaces.</p><p class="calibre18"><tt class="calibre22">refer</tt> can be used to do more than a simple “import” though: you can specify that certain vars be excluded, included, or renamed when they are mapped into the current namespace by using optional keyword args of <tt class="calibre22">:exclude</tt>, <tt class="calibre22">:only</tt>, and <tt class="calibre22">:rename</tt>, respectively. For example, let’s <tt class="calibre22">refer</tt> to <tt class="calibre22">clojure.core</tt>, but exclude some functions and map some of the arithmetic operators to different names locally:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(clojure.core/refer 'clojure.core<br class="calibre33"/>  :exclude '(range)<br class="calibre33"/>  :rename '{+ add<br class="calibre33"/>            - sub<br class="calibre33"/>            / div<br class="calibre33"/>            * mul})<br class="calibre33"/>;= nil<br class="calibre33"/>(-&gt; 5 (add 18) (mul 2) (sub 6))<br class="calibre33"/>;= 40<br class="calibre33"/>(range -20 20 4)<br class="calibre33"/>;= #&lt;CompilerException java.lang.RuntimeException:<br class="calibre33"/>;=   Unable to resolve symbol: range in this context, compiling:(NO_SOURCE_PATH:1)&gt;</tt></span></blockquote><p class="calibre23">Now we can use all the public functions<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1140356"></a><a href="#filepos1184890"><span class="calibre32">231</span></a><span class="calibre32">]</span></small></sup> from <tt class="calibre22">clojure.core</tt><a id="filepos1140478"></a> (except for <tt class="calibre22">range</tt>, which we excluded), and we’re using different names for some of the arithmetic functions.</p><p class="calibre18">While <tt class="calibre22">clojure.core</tt> is always preloaded (and <tt class="calibre22">refer</tt>ed to in the <tt class="calibre22">user</tt> namespace), we’ll often need more than that, and we’ll want to define multiple namespaces ourselves in order to organize our codebases sensibly. We need a facility for loading namespaces.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10"><tt class="calibre22">refer</tt></span><span class="calibre10"> is rarely used directly, but its effects and options are available through </span><span class="calibre10"><tt class="calibre22">use</tt></span><span class="calibre10">, which </span><span class="calibre10"><span class="italic">is</span></span><span class="calibre10"> widely used.</span></blockquote><p class="calibre25"><span class="bold">require and use</span>. When some code needs to make use of functions or data defined in public vars in another namespace, <tt class="calibre22">require</tt><a id="filepos1141533"></a> and <tt class="calibre22">use</tt><a id="filepos1141557"></a> are used to:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">Ensure that the namespaces in question are loaded.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Optionally establish aliases for those namespaces’ names.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Trigger the implicit use of <tt class="calibre22">refer</tt> to allow code to refer to other namespaces’ vars without qualification.</blockquote></li></ol><p class="calibre18"><tt class="calibre22">require</tt> provides (1) and (2); <tt class="calibre22">use</tt> is built on top of it and <tt class="calibre22">refer</tt> to provide (3) in a succinct way.</p><p class="calibre18">Let’s start with a new REPL, where we’d like to use the <tt class="calibre22">union</tt> function in the <tt class="calibre22">clojure.set</tt> namespace:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(clojure.set/union #{1 2 3} #{4 5 6})<br class="calibre33"/>;= #&lt;ClassNotFoundException java.lang.ClassNotFoundException: clojure.set&gt;</tt></span></blockquote><p class="calibre23">Wait, that namespace isn’t loaded yet—only <tt class="calibre22">clojure.core</tt> is preloaded. We can use <tt class="calibre22">require</tt> to load the <tt class="calibre22">clojure.set</tt> namespace from the classpath;<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1142897"></a><a href="#filepos1185310"><span class="calibre32">232</span></a><span class="calibre32">]</span></small></sup> afterward, we can use any function within that namespace:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(require 'clojure.set)<br class="calibre33"/>;= nil<br class="calibre33"/>(clojure.set/union #{1 2 3} #{4 5 6})<br class="calibre33"/>;= #{1 2 3 4 5 6}</tt></span></blockquote><p class="calibre23">Having to use fully qualified symbols to name vars can be a pain though, especially if the libraries you are using provide namespaces that are long or have a number of segments. Thankfully, <tt class="calibre22">require</tt> provides a way to specify an alias for a namespace:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(require '[clojure.set :as set])  </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= nil<br class="calibre33"/>(set/union #{1 2 3} #{4 5 6})<br class="calibre33"/>;= #{1 2 3 4 5 6}</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">The vector arguments provided to <tt class="calibre22">require</tt> and <tt class="calibre22">use</tt> are sometimes called <span class="italic">libspecs</span><a id="filepos1144107"></a>: they specify how a library is to be loaded and referred to within the current namespace.</blockquote><p class="calibre18">When you need to require multiple namespaces that share a common prefix, you can provide to <tt class="calibre22">require</tt> a sequential collection where the first element is the namespace prefix and the remaining elements are the remaining segments specifying the namespaces you’d like to load. So, if we wanted to <tt class="calibre22">require</tt> both <tt class="calibre22">clojure.set</tt><a id="filepos1144590"></a> and <tt class="calibre22">clojure.string</tt><a id="filepos1144625"></a>, we would not have to repeat the <tt class="calibre22">clojure</tt> prefix:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(require '(clojure string [set :as set]))</tt></span></blockquote><p class="calibre23"><tt class="calibre22">use</tt> provides all of the capabilities of <tt class="calibre22">require</tt>, except that by default, it <tt class="calibre22">refer</tt>s the given namespace after it is loaded. So, <tt class="calibre22">(use 'clojure.xml)</tt> is the equivalent of:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(require 'clojure.xml)<br class="calibre33"/>(refer 'clojure.xml)</tt></span></blockquote><p class="calibre23">In addition, <tt class="calibre22">use</tt> passes along all of its arguments to <tt class="calibre22">refer</tt>, so you can leverage the latter’s <tt class="calibre22">:exclude</tt>, <tt class="calibre22">:only</tt>, and <tt class="calibre22">:rename</tt> options to their fullest. To illustrate, let’s consider a scenario where we need to use <tt class="calibre22">clojure.string</tt> and <tt class="calibre22">clojure.set</tt>:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">We’re happy to <tt class="calibre22">refer</tt> all of the vars in the latter into our current namespace, but…</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">We have a number of local functions whose names conflict with those in <tt class="calibre22">clojure.string</tt>; a simple namespace alias (using <tt class="calibre22">:as</tt> with <tt class="calibre22">require</tt>) will work there, but…</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">We need to use <tt class="calibre22">clojure.string/join</tt> a lot, and it doesn’t conflict with any functions in our current namespace, so we’d like to avoid the namespace alias in that case.</blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">clojure.string</tt> and <tt class="calibre22">clojure.set</tt> both define a <tt class="calibre22">join</tt> function; attempting to refer both of them in will result in an error, so we want to prefer <tt class="calibre22">clojure.string/join</tt>.</blockquote></li></ol><p class="calibre18"><tt class="calibre22">use</tt> can accommodate these criteria readily:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(use '(clojure [string :only (join) :as str]<br class="calibre33"/>               [set :exclude (join)]))<br class="calibre33"/>;= nil<br class="calibre33"/>join<br class="calibre33"/>;= #&lt;string$join clojure.string$join@2259a735&gt;<br class="calibre33"/>intersection<br class="calibre33"/>;= #&lt;set$intersection clojure.set$intersection@2f7fc44f&gt;<br class="calibre33"/>str/trim<br class="calibre33"/>;= #&lt;string$trim clojure.string$trim@283aa791&gt;</tt></span></blockquote><p class="calibre23">We can now access <tt class="calibre22">clojure.string</tt>’s <tt class="calibre22">join</tt> function without any namespace qualification, but the rest of <tt class="calibre22">clojure.set</tt> has been <tt class="calibre22">refer</tt>ed into our namespace (including <tt class="calibre22">intersection</tt>), and the entire <tt class="calibre22">clojure.string</tt> namespace is available via the <tt class="calibre22">str</tt> alias.</p><blockquote class="calibre38"></blockquote><blockquote class="calibre39"><span class="calibre10"><span class="bold">USING REQUIRE, REFER, AND USE EFFECTIVELY</span></span></blockquote><blockquote class="calibre17"><span class="calibre10">These functions in concert provide many subtle options, especially compared to the blunt instruments that are </span><span class="calibre10"><tt class="calibre22">import</tt></span><span class="calibre10"> in Java and </span><span class="calibre10"><tt class="calibre22">require</tt></span><span class="calibre10"> in Ruby. Using them effectively and idiomatically can be a tripping point for some new to Clojure.</span></blockquote><blockquote class="calibre17"><span class="calibre10">A good default is to always use </span><span class="calibre10"><tt class="calibre22">require</tt></span><span class="calibre10">, generally with an alias for each namespace:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(require '(clojure [string :as str]<br class="calibre33"/>                   [set :as set]))</tt></span></blockquote><blockquote class="calibre35"><span class="calibre10">This is roughly equivalent to </span><span class="calibre10"><tt class="calibre22">import sys, os</tt></span><span class="calibre10"> in Python. Because namespaces generally have multiple segments (compared to the single-token module names common in Python), Clojure does not provide a default alias for </span><span class="calibre10"><tt class="calibre22">require</tt></span><span class="calibre10">d namespaces, but it does allow you to control the alias that is used. Of course, if the namespace in question is short, or you only use vars from it a few times, then a bare </span><span class="calibre10"><tt class="calibre22">require</tt></span><span class="calibre10"> without any alias is entirely appropriate.</span></blockquote><blockquote class="calibre17"><span class="calibre10">Another commonly recommended pattern is to prefer </span><span class="calibre10"><tt class="calibre22">use</tt></span><span class="calibre10"> in conjunction with a namespace alias and an explicit included list of vars to </span><span class="calibre10"><tt class="calibre22">refer</tt></span><span class="calibre10"> into the current namespace:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(use '[clojure.set :as set :only (intersection)])</tt></span></blockquote><blockquote class="calibre35"><span class="calibre10">Insofar as this form of </span><span class="calibre10"><tt class="calibre22">use</tt></span><span class="calibre10"> provides you with a superset of all of the functionality provided by </span><span class="calibre10"><tt class="calibre22">require</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">refer</tt></span><span class="calibre10">, using it means you can consolidate all your namespace references into a single </span><span class="calibre10"><tt class="calibre22">use</tt></span><span class="calibre10"> form. Even where you might otherwise use aliasing </span><span class="calibre10"><tt class="calibre22">require</tt></span><span class="calibre10"> forms, the equivalent </span><span class="calibre10"><tt class="calibre22">use</tt></span><span class="calibre10"> form is hardly longer and allows you to add </span><span class="calibre10"><tt class="calibre22">refer</tt></span><span class="calibre10">ed functions to the </span><span class="calibre10"><tt class="calibre22">:only</tt></span><span class="calibre10"> argument very easily.</span></blockquote><blockquote class="calibre17"><span class="calibre10">In any case, it is generally good practice to avoid unconstrained usages of </span><span class="calibre10"><tt class="calibre22">use</tt></span><span class="calibre10">, that is, those that do not include an </span><span class="calibre10"><tt class="calibre22">:only</tt></span><span class="calibre10"> option to explicitly name the functions that should be </span><span class="calibre10"><tt class="calibre22">refer</tt></span><span class="calibre10">ed into the current namespace. Doing so makes it clear what parts of other namespaces your code makes use of, and avoids any name collision warnings that may crop up as upstream libraries change and add functions that you may have already declared locally.</span></blockquote><p class="calibre50"><span class="bold">import</span>. <a id="filepos1151241"></a>While Clojure namespaces primarily map symbols to vars, often canonically defined in multiple other namespaces, they also map symbols to Java classes and interfaces. You can use <tt class="calibre22">import</tt> to add such mappings to the current namespace.</p><p class="calibre18"><tt class="calibre22">import</tt> expects as arguments the full names of the classes to import, or a sequential collection describing the package and classes to import. Importing a class makes its “short name” available for use within the current namespace:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(Date.)                                                           </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #&lt;CompilerException java.lang.IllegalArgumentException:<br class="calibre33"/>;=   Unable to resolve classname: Date, compiling:(NO_SOURCE_PATH:1)&gt;<br class="calibre33"/>(java.util.Date.)                                                 </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #&lt;Date Mon Jul 18 12:31:38 EDT 2011&gt;<br class="calibre33"/>(import 'java.util.Date 'java.text.SimpleDateFormat)              </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= java.text.SimpleDateFormat<br class="calibre33"/>(.format (SimpleDateFormat. "MM/dd/yyyy") (Date.))                </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= "07/18/2011"</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">Date</tt> is in the <tt class="calibre22">java.util</tt> package, and so usages of its short name will cause an error before it is imported into the current namespace.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">We can use Java classes and interfaces without any explicit importing at all, but such usage requires fully qualified classnames, which can be unpleasantly verbose.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">You can import classes into the current namespace by providing <tt class="calibre22">import</tt> with symbols naming the classes.</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">After being imported, the classes’ short names can be used to refer to them.</blockquote><p class="calibre18">All classes in the <tt class="calibre22">java.lang</tt><a id="filepos1154167"></a> package are always imported into every namespace by default; for example, <tt class="calibre22">java.lang.String</tt> is available via the <tt class="calibre22">String</tt> symbol, and does not need to be <tt class="calibre22">import</tt>ed separately.</p><p class="calibre18">When you want to import multiple classes from a single package, you can provide to <tt class="calibre22">import</tt> the same kind of package-prefixed collection that <tt class="calibre22">require</tt> accepts for namespaces with the same prefix:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(import '(java.util Arrays Collections))<br class="calibre33"/>;= java.util.Collections<br class="calibre33"/>(-&gt;&gt; (iterate inc 0)<br class="calibre33"/>  (take 5)<br class="calibre33"/>  into-array<br class="calibre33"/>  Arrays/asList<br class="calibre33"/>  Collections/max)<br class="calibre33"/>;= 4</tt></span></blockquote><p class="calibre23">It’s a rare case, but be aware that you cannot import two classes with the same short name into the same namespace:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(import 'java.awt.List 'java.util.List)<br class="calibre33"/>;= #&lt;IllegalStateException java.lang.IllegalStateException:<br class="calibre33"/>;=   List already refers to: class java.awt.List in namespace: user&gt;</tt></span></blockquote><p class="calibre23">The workaround here (as in Java) would be to import the one that you use most frequently within your namespace, and use the other’s fully qualified classname.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">While Clojure’s </span><span class="calibre10"><tt class="calibre22">import</tt></span><span class="calibre10"> is conceptually similar to Java’s </span><span class="calibre10"><tt class="calibre22">import</tt></span><span class="calibre10"> statements, there are a couple of important differences.</span></blockquote><blockquote class="calibre17"><span class="calibre10">First, it provides no analogue to the wildcard import used frequently in Java, such as </span><a id="filepos1156132"></a><span class="calibre10"><tt class="calibre22">import java.util.*;</tt></span><span class="calibre10">. If you need to import multiple classes from a single package, you will need to enumerate each of them, surely as part of a package-prefixed list as shown above.</span></blockquote><blockquote class="calibre17"><span class="calibre10">Second, if you need to refer to an </span><span class="calibre10"><span class="italic">inner class</span></span><a id="filepos1156520"></a><span class="calibre10"> (e.g., </span><span class="calibre10"><tt class="calibre22">java.lang.Thread.State</tt></span><span class="calibre10">, </span><span class="calibre10"><tt class="calibre22">java.util.Map.Entry</tt></span><span class="calibre10">), you need to use the Java-internal notation for them (e.g., </span><span class="calibre10"><tt class="calibre22">java.lang.Thread$State</tt></span><span class="calibre10">, </span><span class="calibre10"><tt class="calibre22">java.util.Map$Entry</tt></span><span class="calibre10">). This applies to any reference to inner classes, not just those provided to </span><span class="calibre10"><tt class="calibre22">import</tt></span><span class="calibre10">.</span></blockquote><p class="calibre25"><span class="bold">ns</span>. <a id="filepos1157109"></a>All of the namespace utility functions we’ve looked at so far in this section should generally be reserved for use in the REPL. Whenever you are working on code you would like to reuse outside of a REPL, you should use the <tt class="calibre22">ns</tt> macro to define your namespaces.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1157420"></a><a href="#filepos1185847"><span class="calibre32">233</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18"><tt class="calibre22">ns</tt> allows you to declaratively specify a namespace’s name along with its top-level documentation and what it needs to have <tt class="calibre22">require</tt>d, <tt class="calibre22">refer</tt>ed, <tt class="calibre22">use</tt>d, and <tt class="calibre22">import</tt>ed to load successfully and work properly. It is a very thin wrapper around these functions; thus, this pile of utility function calls:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(in-ns 'examples.ns)<br class="calibre33"/>(clojure.core/refer 'clojure.core :exclude '[next replace remove])<br class="calibre33"/>(require '(clojure [string :as string]<br class="calibre33"/>                   [set :as set])<br class="calibre33"/>         '[clojure.java.shell :as sh])<br class="calibre33"/>(use '(clojure zip xml))<br class="calibre33"/>(import 'java.util.Date<br class="calibre33"/>        'java.text.SimpleDateFormat<br class="calibre33"/>        '(java.util.concurrent Executors<br class="calibre33"/>                               LinkedBlockingQueue))</tt></span></blockquote><p class="calibre23">is equivalent to this <tt class="calibre22">ns</tt> declaration:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(ns examples.ns<br class="calibre33"/>  (:refer-clojure :exclude [next replace remove])<br class="calibre33"/>  (:require (clojure [string :as string]<br class="calibre33"/>                     [set :as set])<br class="calibre33"/>            [clojure.java.shell :as sh])<br class="calibre33"/>  (:use (clojure zip xml))<br class="calibre33"/>  (:import java.util.Date<br class="calibre33"/>           java.text.SimpleDateFormat<br class="calibre33"/>           (java.util.concurrent Executors<br class="calibre33"/>                                 LinkedBlockingQueue)))</tt></span></blockquote><p class="calibre23">All the semantics for <tt class="calibre22">require</tt>, <tt class="calibre22">refer</tt>, and so on remain the same, but since <tt class="calibre22">ns</tt> is a macro, (notice that keywords are being used here, e.g., <tt class="calibre22">:use</tt> instead of <tt class="calibre22">use</tt>), the extensive quoting of names is unnecessary.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">In the previous examples, we are excluding vars from </span><span class="calibre10"><tt class="calibre22">clojure.core</tt></span><span class="calibre10"> because their names (</span><span class="calibre10"><tt class="calibre22">next</tt></span><span class="calibre10">, </span><span class="calibre10"><tt class="calibre22">replace</tt></span><span class="calibre10">, and </span><span class="calibre10"><tt class="calibre22">remove</tt></span><span class="calibre10">) conflict with same-named vars defined in </span><span class="calibre10"><tt class="calibre22">clojure.zip</tt></span><span class="calibre10">, which we </span><span class="calibre10"><tt class="calibre22">use</tt></span><span class="calibre10"> without exclusions a few lines down. Our </span><span class="calibre10"><tt class="calibre22">use</tt></span><span class="calibre10"> of </span><span class="calibre10"><tt class="calibre22">clojure.zip</tt></span><span class="calibre10">
</span><span class="calibre10"><span class="italic">would</span></span><span class="calibre10"> override the mappings to the vars referred from </span><span class="calibre10"><tt class="calibre22">clojure.core</tt></span><span class="calibre10"> (with a warning), but explicitly excluding them here makes it clear to later maintainers that we’re aware of the conflict.</span></blockquote><p class="calibre25">Once defined, namespaces may be inspected and modified at runtime, usually via a REPL. We talk about the different tools available for working with namespaces at runtime in <a href="#filepos1460286"><span class="calibre5">The Bare REPL</span></a>.<a id="filepos1160945"></a></p><p id="filepos1160956" class="calibre23"><span class="calibre53"><span class="bold">Namespaces and files</span></span></p><p id="filepos1161037" class="calibre18">There are some hard-and-fast rules about how Clojure source files must be organized:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1161184"></a><a href="#filepos1186700"><span class="calibre32">234</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18"><span class="bold">Use one file per namespace</span>. Each namespace should be defined in a separate file, and this file’s location within your project’s Clojure source root must correspond with the namespace’s segments. For example, the code for the <tt class="calibre22">com.mycompany.foo</tt> namespace should be in a file located at <span class="italic">com/mycompany/foo.clj</span>.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1161682"></a><a href="#filepos1186991"><span class="calibre32">235</span></a><span class="calibre32">]</span></small></sup> When that namespace is <tt class="calibre22">require</tt>d or <tt class="calibre22">use</tt>d, e.g., by <tt class="calibre22">(require 'com.mycompany.foo)</tt>, the file at <span class="italic">com/mycompany/foo.clj</span> will be loaded, after which the namespace must be defined or an error will result.</p><p class="calibre18"><span class="bold">Use underscores in filenames when namespaces contain dashes</span>. <a id="filepos1162109"></a>Very simply, if your namespace is to be <tt class="calibre22">com.my-project.foo</tt>, the source code for that namespace should be in a file located at <span class="italic">com/my_project/foo.clj</span>. Only the filename and directories corresponding to the namespace’s segments are affected—you would continue to refer to the namespace in Clojure code using its declared name (e.g., <tt class="calibre22">(require 'com.my-project.foo)</tt>, not <tt class="calibre22">(require 'com.my_project.foo)</tt>). This is necessary because the JVM does not allow for dashes in class or package names, but it is generally idiomatic to use dashes instead of underscores when naming Clojure entities, including namespaces, vars, locals, and so on.</p><p class="calibre18"><span class="bold">Start every namespace with a comprehensive ns form</span>. The first Clojure form in every namespace’s “root” (and usually only) file should be a well-tended <tt class="calibre22">ns</tt> form; bare usages of namespace-manipulating functions like <tt class="calibre22">require</tt> and <tt class="calibre22">refer</tt> are entirely unnecessary outside of a REPL environment. Aside from just being good form, using <tt class="calibre22">ns</tt>:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">Encourages the consolidation of what might otherwise be disparate usages of <tt class="calibre22">require</tt>, et al.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Makes it easy for readers and later maintainers of your code to get an immediate impression of how a given namespace relates to its dependencies since it is always positioned at the top of each file.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Leaves the door open for refactoring and other code-manipulation tools that need to modify sets of required namespaces, functions, and imported classes, since <tt class="calibre22">ns</tt> is a macro that can accept only unevaluated names for these things.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1164073"></a><a href="#filepos1187432"><span class="calibre32">236</span></a><span class="calibre32">]</span></small></sup> The unrestricted evaluation possible in conjunction with lower-level namespace-modification forms makes such tools infeasible.</blockquote></li><a id="filepos1164313"></a></ol><p class="calibre18"><span class="bold">Avoid cyclic namespace dependencies</span>. The dependencies <a id="filepos1164415"></a>among Clojure namespaces within any application must form a directed acyclic graph; meaning, namespace <span class="italic">X</span> cannot require a namespace <span class="italic">Y</span> which itself requires namespace <span class="italic">X</span> (either directly or via one of its dependencies). Attempting to do this will result in an error like this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">#&lt;Exception java.lang.Exception:<br class="calibre33"/>  Cyclic load dependency:<br class="calibre33"/>  [ /some/namespace/X ]-&gt;/some/namespace/Y-&gt;[ /some/namespace/X ]&gt;</tt></span></blockquote><p class="calibre23"><span class="bold">Use declare to enable forward references</span>. Clojure loads each form in each namespace’s files sequentially, resolving references to previously defined vars as it goes. This means that referring to an undefined var will cause an error:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn a [x] (+ constant (b x)))<br class="calibre33"/>;= #&lt;CompilerException java.lang.RuntimeException:<br class="calibre33"/>;=   Unable to resolve symbol: constant in this context, compiling:(NO_SOURCE_PATH:1)&gt;</tt></span></blockquote><p class="calibre23">Many languages define compilation units that allow them to find all of the “dangling” identifiers within a program before resolving references to them; Clojure does not do this. However, all is not lost if, for the sake of clarity or style, you want to define higher-level functions before the lower-level ones they reference: use <tt class="calibre22">declare</tt> to intern a var in the current namespace, define your higher-level function (referring freely to the <tt class="calibre22">declare</tt>d vars), and then define the vars that you had previously only <tt class="calibre22">declare</tt>d:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(declare constant b)<br class="calibre33"/>;= #'user/b<br class="calibre33"/>(defn a [x] (+ constant (b x)))<br class="calibre33"/>;= #'user/a<br class="calibre33"/>(def constant 42)<br class="calibre33"/>;= #'user/constant<br class="calibre33"/>(defn b [y] (max y constant))<br class="calibre33"/>;= #'user/b<br class="calibre33"/>(a 100)<br class="calibre33"/>;= 142</tt></span></blockquote><p class="calibre23">The one wrinkle to be aware of is that, if you neglect to actually define a previously <tt class="calibre22">declare</tt>d var, that var will yield an unusable placeholder value when dereferenced at runtime that will almost surely result in an exception when your higher-level code attempts to do something with it.</p><p class="calibre18"><span class="bold">Avoid single-segment namespaces</span>. <a id="filepos1166855"></a>Namespaces should have multiple segments; for example, the <tt class="calibre22">com.my-project.foo</tt> namespace has three segments. The reason for this is twofold:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">If you AOT-compile a single-segment namespace, that process will yield at least one class file that is in the default package (i.e., is a “bare” class not in a Java package). This can prevent the namespace from being loaded in some environments, and will always prevent the namespace’s corresponding class from being usable from Java, due to that language’s restrictions on use of classes in the default package.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Even if you’re absolutely, positively sure you’re never going to want to redistribute AOT-compiled class files for your single-segment namespace, you still run a higher risk of namespace clashes than is prudent, no matter how clever you are at naming things.</blockquote></li></ol><p class="calibre18">Don’t think that we’re recommending that you reach for the heights of absurdity when it comes to namespace segment depth; no one likes names like <tt class="calibre22">com.foo.bar.baz.factory.factory.factories.Factory</tt>. However, there is some happy middle ground between that and a single segment, readily clashing namespace like <tt class="calibre22">app</tt> or <tt class="calibre22">util</tt>.</p><p class="calibre18">Regardless of how you organize your namespaces, they (and all other code and resources your library or application depends upon) will end up being loaded via the <span class="italic">classpath</span>.<a id="filepos1168518"></a></p><p id="filepos1168529" class="calibre23"><span class="calibre53"><span class="bold">A classpath primer</span></span></p><p id="filepos1168608" class="calibre18">For programmers unfamiliar with Java, the <span class="italic">classpath</span> can often be a source of confusion. The classpath is the search path that the JVM will use when looking for user-defined libraries and resources. This path can include both directories and <span class="italic">.zip</span> archives, including <span class="italic">.jar</span> files. Clojure being hosted on the JVM, it inherits Java’s classpath system.</p><p class="calibre18">The classpath has its own idiosyncrasies, but it is not unique, and has many similarities to other search path mechanisms you are surely familiar with. For example, shells in both Unix and Windows environments define a <tt class="calibre22">PATH</tt> environment variable, which stores a concatenated set of paths where executables may be found. Ruby and Python also have search paths: Ruby stores its in the runtime variable <tt class="calibre22">$LOAD_PATH</tt>,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1169501"></a><a href="#filepos1188206"><span class="calibre32">237</span></a><span class="calibre32">]</span></small></sup> while Python relies upon the <tt class="calibre22">PYTHONPATH</tt><a id="filepos1169645"></a> environment variable. In all of these cases, the search path tends to be automatically handled by a combination of system-wide settings and dependency management tools (such as Ruby Gems or Python’s <tt class="calibre22">easy_install</tt> and <tt class="calibre22">pip</tt>).</p><p class="calibre18">The same autoconfiguration of the classpath is available through Leiningen and Maven, the tools most often used for managing dependencies in Clojure projects, as well as most popular Java IDEs and Emacs. For example, once you have defined your dependencies in your <span class="italic">project.clj</span> or <span class="italic">pom.xml</span> file, starting a REPL through either of these tools will result in those dependencies being added to the REPL’s classpath automatically. The same applies if you are using Leiningen or Maven plug-ins that bootstrap full applications, such as when running web applications locally via <tt class="calibre22">lein-ring</tt> or <tt class="calibre22">jetty:run</tt>.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1170589"></a><a href="#filepos1188461"><span class="calibre32">238</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">However, if you need to start a Java process directly within a shell, you need to construct the classpath manually. Even if you never use Clojure from the command line, knowing how the classpath is defined in the most fundamental way will help you understand what more advanced tools are doing for you.</p><p class="calibre18"><span class="bold">Defining the classpath</span>. By default, the classpath is empty. This is an inconvenient difference compared to the other search path mechanisms we mentioned, which all include the current working directory (<tt class="calibre22">.</tt>) by default, so that libraries rooted there will be found at runtime.</p><p class="calibre18">To set the classpath for a Java process, specify it on the command line with the <tt class="calibre22">-cp</tt> flag. For example, to include the current working directory, the <span class="italic">src</span> directory, the <span class="italic">clojure.jar</span> archive file, and all <span class="italic">.jar</span> files in the <span class="italic">lib</span> directory, on Unix-like systems we’d do this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">java -cp '.:src:clojure.jar:lib/*' clojure.main</tt></span></blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">As with all other search path mechanisms, the classpath is defined in a platform-dependent manner due to differences in filename conventions on different systems. On Unix-like systems, the classpath is a </span><a id="filepos1172208"></a><span class="calibre10"><tt class="calibre22">:</tt></span><span class="calibre10">-delimited list of </span><span class="calibre10"><tt class="calibre22">/</tt></span><span class="calibre10">-defined paths; on Windows, it’s a </span><span class="calibre10"><tt class="calibre22">;</tt></span><span class="calibre10">-delimited list of </span><span class="calibre10"><tt class="calibre22">\</tt></span><span class="calibre10">-defined paths. So, our example classpath above for Unix-like systems would translate to this one on Windows:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">'.;src;clojure.jar;lib\*'</tt></span></blockquote><p class="calibre25"><span class="bold">Classpath and the REPL</span>. <a id="filepos1172794"></a>The classpath can be inspected from Clojure at runtime:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">$ java -cp clojure.jar clojure.main<br class="calibre33"/>Clojure 1.3.0<br class="calibre33"/>(System/getProperty "java.class.path")<br class="calibre33"/>;= "clojure.jar"</tt></span></blockquote><p class="calibre23">The primary classpath (held by the <tt class="calibre22">java.class.path</tt> system property) is defined when the JVM process starts via command-line parameter or environment variable, but it unfortunately cannot be changed at runtime. This is at odds with Clojure’s normal development cycle, which tends to involve opening a persistent REPL session and leaving it open. Changes to the classpath require a JVM restart, and therefore a REPL<a id="filepos1173529"></a> restart.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1173580"></a><a href="#filepos1188786"><span class="calibre32">239</span></a><span class="calibre32">]</span></small></sup></p><p id="filepos1173679" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Location, Location, Location</span></span></span></p><p id="filepos1173797" class="calibre18">There are two predominant project layout conventions used in Clojure projects, the defaults for which are defined by the predominant build tools used by Clojure projects.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1174030"></a><a href="#filepos1190093"><span class="calibre32">240</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">First, there’s the “Maven <a id="filepos1174187"></a>style,” which puts all source files under a top-level <span class="italic">src</span> directory but separates source files into separate subdirectories based on language and role within a project. Primary source code that defines public APIs or shipped features goes in <span class="italic">src/main</span>; code that defines unit and functional tests that isn’t generally distributed goes in <span class="italic">src/test</span>, and so on:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 8-1. The “Maven-style” project layout</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">&lt;project dir&gt;<br class="calibre33"/> |<br class="calibre33"/> |- src<br class="calibre33"/>    |- main<br class="calibre33"/>       |- clojure<br class="calibre33"/>       |- java<br class="calibre33"/>       |- resources<br class="calibre33"/>       |- ...<br class="calibre33"/>    |- test<br class="calibre33"/>       |- clojure<br class="calibre33"/>       |- java<br class="calibre33"/>       |- resources<br class="calibre33"/>       |- ...</tt></span></p><p class="calibre13">When using this sort of project layout, Clojure source files are rooted at <span class="italic">src/main/clojure</span>, Java source files<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1175307"></a><a href="#filepos1190520"><span class="calibre32">241</span></a><span class="calibre32">]</span></small></sup> are rooted at <span class="italic">src/main/java</span>, and so on. The fact that the roles and types of files are reflected in the directory structure can make some activities simpler. For example, rather than having to use filename filters to select a set of files of a particular type from a source root, you can “blindly” refer to sets of files by referring to the directory where each type of file is rooted. This can greatly simplify the packaging of resources: if you have a set of resources that need to be included in a web application (images, JavaScript files, and so on), they can be grouped under <span class="italic">src/main/webapp</span>, and you can safely put resources that shouldn’t be redistributed in a different source root that you can be sure is never referenced by your build and packaging process.</p><p class="calibre18">The Maven-style layout is the most standardized option available—its encouragement of source file location conventions means that projects that use it rarely deviate. The primary disadvantage of the Maven-style project layout is that file paths are longer due to the prefixing of <span class="italic">src/main</span>, <span class="italic">src/test</span>, and so on.</p><p class="calibre18">The other predominant project layout style is one that is difficult to characterize, because it can vary substantially from project to project:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 8-2. The “freeform” project layout examples</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">&lt;project dir&gt;<br class="calibre33"/> |<br class="calibre33"/> |- src<br class="calibre33"/> |- test<br class="calibre33"/><br class="calibre33"/>&lt;project dir&gt;<br class="calibre33"/> |<br class="calibre33"/> |- src<br class="calibre33"/>    |- java<br class="calibre33"/>    |- clojure<br class="calibre33"/> |- test<br class="calibre33"/> |- resources<br class="calibre33"/> |- web</tt></span></p><p class="calibre13">Compared to the Maven-style layout, freeform project layouts optimize for shorter file path length (in part to make it easier to refer to files on the command line), and generally have fewer conventions that are reused from project to project outside of the existence of <span class="italic">src</span> and <span class="italic">test</span>. Source files of different types are often mixed within the same source root (e.g., both Java and Clojure source files might be rooted at <span class="italic">src</span>), though sometimes not depending upon a specific project’s build configuration. You’ll find that projects use this layout in conjunction with build tools other than Maven, including Leiningen.</p><p id="filepos1177845" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">The Functional Organization of Clojure Codebases</span></span></span></p><p id="filepos1177983" class="calibre18">So far, we’ve only talked about mechanical ground rules—where files go, naming rules, the correspondence between namespaces <a id="filepos1178139"></a>and files, and so on. More subtle are the questions about how to organize Clojure code from a functional perspective:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">How many functions should be used to implement a particular algorithm?</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">How many functions should a namespace contain?</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">How many namespaces should a project contain?</blockquote></li></ul><p class="calibre18">Corollary questions related to other programming languages are usually easier to answer, in part because there are often particular requirements that end up explicitly defining “good style.” Many frequently used frameworks in various languages have specific expectations about how plug-ins/components/models/extensions are defined (e.g., “one class per database table” or “one module per user interface component”), so that the shape of a codebase is determined in large part by incidental or mechanical characteristics of the libraries it uses and the broader environment it will be deployed into.</p><p class="calibre18">In contrast, you are rarely forced to hew to a particular organization of a Clojure application as a side effect of using a particular library or framework.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1179616"></a><a href="#filepos1190929"><span class="calibre32">242</span></a><span class="calibre32">]</span></small></sup> In particular, broad application of functional programming techniques and occasional, judicious use of macros allows you to structure Clojure libraries and applications to mirror the contours of your domain far more than is possible in other languages. It’s fair to say that Clojure encourages you to think more clearly about your domain than you likely have for years, with the end result that your data or model will often naturally dictate your program’s structure more than you thought possible.</p><p class="calibre18">That is all to say, outside of some very general principles, there’s probably no such thing as a “typical structure” of Clojure programs. This notion may either be disconcerting or very appealing, depending on your background and expectations. For our part, we’ve found it consistently refreshing to be able to focus on the essentials of a feature or algorithm or domain, without the distractions that can come with particular sorts of order imposed by decisions made long ago and far away from the problems we aim to solve in our code.</p><p id="filepos1180795" class="calibre23"><span class="calibre53"><span class="bold">Basic project organization principles</span></span></p><p class="calibre18">It would be poor form for us to vaguely talk about general principles and not mention at least a few that we have in mind:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Keep different things separate, maybe in different namespaces: code that works with customer records should probably all be in one namespace, away from the namespace that loads templates for your web content.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Keep related things together, maybe grouped into natural categories that are manifested as namespaces. For example, use the hierarchy implied by namespaces’ names to indicate relationships, such as that between a high level API (say, <tt class="calibre22">foo.ui</tt>) and a lower-level or provider APIs (e.g., <tt class="calibre22">foo.ui.linux</tt> and <tt class="calibre22">foo.ui.windows</tt>).</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Define vars that contain implementation-specific data or functions <tt class="calibre22">^:private</tt> (or, private using the <tt class="calibre22">defn-</tt> convenience form for defining private functions) as much as possible. This keeps clients from unwittingly depending upon things likely to change, while still providing them a back door to access “behind the curtain” functions and data if absolutely necessary via the <tt class="calibre22">var</tt> special form (or its reader sugar <tt class="calibre22">#'</tt>).</blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17">Don’t repeat yourself: define constants only once in a designated namespace, and break common functionality out into utility functions and utility namespaces as warranted.</blockquote></li><li value="5" class="calibre16"><blockquote class="calibre17">Use the common <span class="italic">abstractions</span> of reference types, collections, and sequences when you can, rather than marrying any particular concrete implementation of any of them.</blockquote></li><li value="6" class="calibre16"><blockquote class="calibre17">Unpure functions should be considered harmful, and implemented only when absolutely necessary.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1183115"></a><a href="#filepos1191435"><span class="calibre32">243</span></a><span class="calibre32">]</span></small></sup></blockquote></li></ul><p class="calibre18">In the large, your Clojure projects will benefit from the same attention to modularity and separation of concerns that yields benefits in projects written in any other language. Beyond that, remember that namespaces are an organizational tool provided solely for your benefit: a large application written using 500 namespaces will function and perform just as well as the same application piled into one huge namespace. Therefore, you should feel free to structure your applications to match the structure of your domain and suit your team’s way of working.</p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1183917"></a><a href="#filepos1133672"><span class="calibre32">229</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">The entire question of “build” is perhaps the grandest bikeshed ever built, lagging in controversy and bile perhaps only behind the </span><span class="calibre10"><span class="italic">tabs versus spaces</span></span><span class="calibre10"> and </span><span class="calibre10"><span class="italic">emacs versus vi</span></span><span class="calibre10"> “debates”: </span><a href="http://bikeshed.org"><span class="calibre10"><span class="calibre5">http://bikeshed.org</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1184521"></a><a href="#filepos1134796"><span class="calibre32">230</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">If you’ve not digested that section yet, do so now; that is where we introduce namespaces at the most basic level, talk about symbols, vars, and how the former resolve to the latter.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1184890"></a><a href="#filepos1140356"><span class="calibre32">231</span></a><span class="calibre32">] </span></small></sup><span class="calibre10"><tt class="calibre22">refer</tt></span><span class="calibre10"> will not bring in any private vars from the source namespace. See </span><a href="#filepos735003"><span class="calibre10"><span class="calibre5">Vars</span></span></a><span class="calibre10"> for details on private vars.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1185310"></a><a href="#filepos1142897"><span class="calibre32">232</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="#filepos1160956"><span class="calibre10"><span class="calibre5">Namespaces and files</span></span></a><span class="calibre10"> for how Clojure namespaces correspond to files on disk, and </span><a href="#filepos1168529"><span class="calibre10"><span class="calibre5">A classpath primer</span></span></a><span class="calibre10"> for what the classpath is and why you should care.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1185847"></a><a href="#filepos1157420"><span class="calibre32">233</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">It may be tempting to take a transcript of what you get working within a REPL, paste it all into a </span><span class="calibre10"><span class="italic">.clj</span></span><span class="calibre10"> file (complete with bare </span><span class="calibre10"><tt class="calibre22">in-ns</tt></span><span class="calibre10">, </span><span class="calibre10"><tt class="calibre22">refer</tt></span><span class="calibre10">, et al. forms), and call it a day. We urge you to fight any such temptation. As we’ll discuss in the next section, there are some rules of good hygiene when it comes to organizing Clojure code, and neglecting to fully specify your namespaces by using </span><span class="calibre10"><tt class="calibre22">ns</tt></span><span class="calibre10"> would be running counter to those guidelines for no benefit.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1186700"></a><a href="#filepos1161184"><span class="calibre32">234</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Like all rules, most of these can be broken if you have a good reason to do so, but such reasons are rare.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1186991"></a><a href="#filepos1161682"><span class="calibre32">235</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">These paths are relative to whatever source root you’re using. We get into the physical layout of Clojure projects on disk in </span><a href="#filepos1173679"><span class="calibre10"><span class="calibre5">Location, Location, Location</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1187432"></a><a href="#filepos1164073"><span class="calibre32">236</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">For example, </span><span class="calibre10"><span class="italic">slamhound</span></span><span class="calibre10">, which adjusts which namespaces are </span><span class="calibre10"><tt class="calibre22">require</tt></span><span class="calibre10">d and </span><span class="calibre10"><tt class="calibre22">use</tt></span><span class="calibre10">d and which classes are </span><span class="calibre10"><tt class="calibre22">import</tt></span><span class="calibre10">ed in an </span><span class="calibre10"><tt class="calibre22">ns</tt></span><span class="calibre10"> form based on the code in a given file: </span><a href="https://github.com/technomancy/slamhound"><span class="calibre10"><span class="calibre5">https://github.com/technomancy/slamhound</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1188206"></a><a href="#filepos1169501"><span class="calibre32">237</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Also known as </span><span class="calibre10"><tt class="calibre22">$:</tt></span><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1188461"></a><a href="#filepos1170589"><span class="calibre32">238</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="#filepos2022780"><span class="calibre10"><span class="calibre5">Running Web Apps Locally</span></span></a><span class="calibre10"> for details.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1188786"></a><a href="#filepos1173580"><span class="calibre32">239</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">There </span><span class="calibre10"><span class="italic">are</span></span><span class="calibre10"> ways to get around this. Clojure itself provides an </span><span class="calibre10"><tt class="calibre22">add-classpath</tt></span><span class="calibre10"> function, though it is deprecated and generally not recommended. Another is pomegranate (</span><a href="https://github.com/cemerick/pomegranate"><span class="calibre10"><span class="calibre5">https://github.com/cemerick/pomegranate</span></span></a><span class="calibre10">), which provides a maintained replacement for </span><span class="calibre10"><tt class="calibre22">add-classpath</tt></span><span class="calibre10"> that provides a way to add </span><span class="calibre10"><span class="italic">.jar</span></span><span class="calibre10"> files and transitive Leiningen/Maven dependencies to a Clojure runtime. Finally, all sorts of JVM module systems, including OSGi, the NetBeans module system, and JVM application servers of all stripes provide easy ways to augment or redefine the classpath within applications or individual modules. All of these mechanisms use facilities built in to the JVM (such as managed </span><span class="calibre10"><tt class="calibre22">ClassLoader</tt></span><span class="calibre10"> hierarchies) in order to enable such capabilities.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1190093"></a><a href="#filepos1174030"><span class="calibre32">240</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">All (decent) build tools (including Leiningen and Maven) allow you to put source files wherever you want. These layouts are just the defaults, although it’s hard to imagine a case where it’d be worth the trouble to not use those defaults.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1190520"></a><a href="#filepos1175307"><span class="calibre32">241</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Assuming you have them; take a look at </span><a href="#filepos1252908"><span class="calibre10"><span class="calibre5">Building mixed-source projects</span></span></a><span class="calibre10"> for some tips if your project is a Java/Clojure hybrid.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1190929"></a><a href="#filepos1179616"><span class="calibre32">242</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Even if you are extending or integrating an existing Java library or framework using Clojure, it is rare to not be able to sequester the relevant interop that hooks the Clojure functions and data into the framework, leaving you free to structure your Clojure codebase as best suits the domain or your chosen architecture.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1191435"></a><a href="#filepos1183115"><span class="calibre32">243</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Pure functions are critical to the successful and effective application of functional programming, a cornerstone of designing idiomatic Clojure libraries and applications. Read about functional programming in </span><a href="#filepos215673"><span class="calibre10"><span class="calibre5">Chapter 2</span></span></a><span class="calibre10">, and pure functions specifically in </span><a href="#filepos316677"><span class="calibre10"><span class="calibre5">Pure Functions</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos1192042" class="calibre6"><span class="calibre4"><span class="bold">Build</span></span></p><p id="filepos1192108" class="calibre18">“Build” is an umbrella term that has come to encompass more and more of the things we do <span class="italic">after</span> we’ve written the code but before the code has been delivered (another loaded term, given the complications of software as a service, cloud computing, and so on).</p><p class="calibre18">For our purposes here, we’ll consider <span class="italic">build</span> to mean:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Compilation</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17"><span class="italic">Dependency management</span>, which allows you to systematically use external libraries</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Packaging the results of compilation and other project assets into <span class="italic">artifacts</span></blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17">Distribution of those artifacts within a dependency management context</blockquote></li></ul><p class="calibre18">That overly formal description sounds more complicated than the activities it describes. You’re likely doing these things already:</p><p class="calibre3"></p><p class="calibre1"><span class="italic">Table 8-1. Contrasting “build” solutions for different programming languages</span></p><table border="1" valign="top" class="calibre40"><tr border="1" valign="top" class="calibre27"><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7">   </span></span></span></th><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Compilation </span></span></span></th><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Dependency management </span></span></span></th><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Packaging </span></span></span></th><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Distribution </span></span></span></th></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Ruby </span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">rake</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">gem</tt></span><span class="calibre21">, </span><span class="calibre21"><tt class="calibre22">rvm</tt></span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> Gems </span></td><td border="1" valign="top" class="calibre28"><span class="calibre21">  </span><span class="calibre21"><span class="italic">rubygems.org</span></span></td></tr><tr border="1" valign="top" class="calibre43"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Python </span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">distutils</tt></span><span class="calibre21">, SCons</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">pip</tt></span><span class="calibre21">, </span><span class="calibre21"><tt class="calibre22">virtualenv</tt></span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> Eggs </span></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">PyPI <sup class="calibre44"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1195886"></a><a href="#filepos1197174"><span class="calibre32">a</span></a><span class="calibre32">]</span></small></sup></span></p></td></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> Java </span></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">javac</tt></span><span class="calibre21">, Ant, Maven, Gradle, etc.</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">The Maven model, Ivy </span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Jar files and variants thereof </span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Maven artifact repositories </span></p></td></tr><tr border="1" valign="top" class="calibre27"><td colspan="5" border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre45"><span class="calibre21"> </span></p><p class="calibre42"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1197174"></a><a href="#filepos1195886"><span class="calibre32">a</span></a><span class="calibre32">] </span></small></sup><a href="http://pypi.python.org/pypi"><span class="calibre21"><span class="calibre5">http://pypi.python.org/pypi</span></span></a></p></td></tr></table><p class="calibre23">Because Clojure is a JVM language, it naturally reuses large swaths of that ecosystem’s build, packaging, and distribution infrastructure and mechanics:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Leiningen reuses much of the Maven infrastructure while providing a far more pleasant “UI” and Clojure-native development experience.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">There are plug-ins for Maven, Gradle, and Ant that aid in driving Clojure builds from those tools.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Clojure libraries are packaged as <span class="italic">.jar</span> files, Clojure web applications are (usually) packaged as <span class="italic">.war</span> files,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1198292"></a><a href="#filepos1261117"><span class="calibre32">244</span></a><span class="calibre32">]</span></small></sup> and so on.</blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17">Clojure libraries are distributed via Maven repositories, which are accessible to every Java (and therefore Clojure) build tool.</blockquote></li></ul><p class="calibre18">This alignment between Clojure and Java’s build tooling and practices allows Clojure applications and libraries to depend upon and use Java libraries, and allows you to distribute libraries written in Clojure that programmers using other JVM languages (such as Java, Groovy, Scala, JRuby, Jython, and so on) can depend upon and use.</p><p class="calibre18">If you are already using Java or some other JVM language, you’ll find that adding some Clojure to your codebase will have a minimal impact your existing build process. On the other hand, if you’re coming from Ruby, Python, or some other non-JVM language, you can take comfort in the fact that Clojure build processes and configurations are nearly always far simpler than their Java-tailored corollaries.</p><p id="filepos1199448" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Ahead-of-Time Compilation</span></span></span></p><p id="filepos1199563" class="calibre18">As we mentioned in <a href="#filepos37449"><span class="calibre5">The Clojure REPL</span></a>, Clojure code is <span class="italic">always</span> compiled—there is no Clojure interpreter. Compilation, which involves generating bytecode for a given chunk of Clojure code and loading that bytecode into the host JVM, can happen in two different ways:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">At runtime; this is what happens when you use the REPL, or when you load a Clojure source file from disk. The contents of source files are compiled into bytecode, and loaded into the JVM. This bytecode and the classes it defines are not retained after the host JVM has been terminated.</blockquote></li><a id="filepos1200340"></a><li value="2" class="calibre16"><blockquote class="calibre17">“Ahead-of-time” (AOT) compilation is the same as this runtime compilation, but the resulting bytecode is saved to disk as JVM class files.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1200600"></a><a href="#filepos1261461"><span class="calibre32">245</span></a><span class="calibre32">]</span></small></sup> Those class files can then be reused in later JVM instances in lieu of the originating Clojure source files.</blockquote></li></ul><blockquote class="calibre47"></blockquote><blockquote class="calibre39"><img src="images/00032.jpg" class="calibre102"/></blockquote><blockquote class="calibre57"><span class="calibre10"><span class="italic"><span class="calibre7">Figure 8-1. Clojure’s compilation process</span></span></span></blockquote><p class="calibre50">Clojure code can be loaded from source files or from AOT-compiled class files interchangeably, without any functional differences. Requiring a namespace—for example, <tt class="calibre22">(require 'clojure.set)</tt>—will search the classpath for the <span class="italic">clojure/set.clj</span> source file that defines that namespace, or from the corresponding AOT-compiled class files.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1201607"></a><a href="#filepos1261820"><span class="calibre32">246</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">Thus, outside of a few select circumstances, AOT compilation is entirely optional. Since Clojure libraries and applications generally have no technical reason to demand AOT compilation, it’s reasonable to prefer to distribute Clojure sources when you can. In fact, AOT compilation can have some significant downsides:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">JVM class files are by definition much larger on disk compared to the Clojure source files from which they are generated.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">AOT compilation adds a discrete compile step back into the otherwise lightweight Clojure development cycle.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">AOT compiling a project locks the Clojure library or application in question into the version of Clojure that was used to AOT-compile its sources. You cannot assume that code AOT-compiled with one version of Clojure can be deployed at runtime with another version of Clojure.</blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17">AOT compilation is <span class="italic">transitive</span>. If you AOT compile namespace <tt class="calibre22">foo</tt> that requires namespace <tt class="calibre22">bar</tt>, then <tt class="calibre22">bar</tt> will be AOT compiled as well, and so on. Depending upon the specific namespace dependencies within your library or application, this can result in a much larger scope of AOT compilation than you may expect given your build configuration.</blockquote></li></ol><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">TIP</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">When all you need is to generate a single named class (or a handful) as an entry point for a Java framework, there is an easy way to break the transitivity: use </span><span class="calibre10"><tt class="calibre22">gen-class</tt></span><span class="calibre10"> (or the </span><span class="calibre10"><tt class="calibre22">:gen-class</tt></span><span class="calibre10"> option of </span><span class="calibre10"><tt class="calibre22">ns</tt></span><span class="calibre10">) with a distinct implementation namespace specified by </span><span class="calibre10"><tt class="calibre22">:impl-ns</tt></span><span class="calibre10">. Compilation doesn’t follow such dependencies, so requiring the compilation of the </span><span class="calibre10"><tt class="calibre22">gen-class</tt></span><span class="calibre10"> namespace won’t trigger a compilation of your entire codebase.</span></blockquote><p class="calibre25">AOT compilation should be reserved for a few select use cases:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">When you cannot or do not want to distribute source code.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">When you want to use various class file engineering tools as part of your packaging process, such as obfuscators.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">When startup time of your application is <span class="italic">absolutely critical</span>, such that you’re willing to bear the costs of AOT-compilation. Loading AOT-compiled class files is far faster than getting to the same point from Clojure source files.</blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17">When you expect your Clojure code to be used from Java or another JVM language via named Java classes or interfaces generated by <tt class="calibre22">gen-class</tt>, <tt class="calibre22">defrecord</tt>, <tt class="calibre22">deftype</tt>, or <tt class="calibre22">defprotocol</tt>.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1205387"></a><a href="#filepos1262426"><span class="calibre32">247</span></a><span class="calibre32">]</span></small></sup></blockquote></li></ol><p class="calibre18">We talk about some of the options for performing AOT compilation in Leiningen and Maven in <a href="#filepos1247107"><span class="calibre5">AOT compilation configuration</span></a>.</p><p id="filepos1205713" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Dependency Management</span></span></span></p><p id="filepos1205824" class="calibre18">Every software development team should use dependency management for their projects. Teams using Clojure are no different.</p><p class="calibre18">Not so long ago, there was a dark time when it was the norm to ship dependencies around the Internet in <span class="italic">.zip</span> and <span class="italic">.tar.gz</span> files, manually and carefully putting them in specific places in projects (often a <span class="italic">lib</span> directory), and adding the results to version control systems. Build processes would then refer to these dependencies using simple file paths, and they would either bundle the dependencies into distributed binaries or other artifacts or blithely assume that downstream users of the project would have the same versions of those dependencies already, or would know where to obtain them.</p><p class="calibre18">Modern demands have thankfully pushed out such practices in large part, given their reliance on manual tweaking and complete lack of repeatable process.</p><p class="calibre18">While Perl has CPAN (perhaps the granddaddy of all dependency management approaches), Python has <tt class="calibre22">pip</tt> and <tt class="calibre22">virtualenv</tt>, and Ruby has <tt class="calibre22">gem</tt> and <tt class="calibre22">rvm</tt>, dependency management on the JVM is dominated by Maven and the model it defined in the mid-2000s. Clojure fully embraces that model, regardless of which build tool you might use.</p><p id="filepos1207197" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">The Maven Dependency Management Model</span></span></span></p><p id="filepos1207324" class="calibre18">Maven’s dependency management model provides for:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">The identification and versioning of <span class="italic">artifacts</span> using <span class="italic">coordinates</span></blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">The declaration of <span class="italic">dependencies</span> of artifacts and the projects that produce them</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">The storage and retrieval of artifacts in <span class="italic">repositories</span> along with specifications of their dependencies</blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17">The calculation of artifacts’ <span class="italic">transitive dependencies</span></blockquote></li></ul><p class="calibre18">Let’s unpack these concepts and the broad strokes of the mechanics involved.</p><p id="filepos1208273" class="calibre23"><span class="calibre53"><span class="bold">Artifacts and coordinates</span></span></p><p id="filepos1208359" class="calibre18">An <span class="italic">artifact</span> is any file that is a product of a project’s build process. Clojure libraries and applications are packaged just like those written using Java and other JVM languages. Concretely, this means you’ll primarily be using and producing two types of artifacts:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17"><span class="italic">.jar</span> files, which are <span class="italic">.zip</span> files that contain:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1208879"></a><a href="#filepos1262783"><span class="calibre32">248</span></a><span class="calibre32">]</span></small></sup></blockquote><ul class="calibre55"><li value="1" class="calibre16"><blockquote class="calibre17">Clojure source files, JVM class files, and other assets (such as static configuration files, images, etc.) in a hierarchy mirroring their position in their source directory roots or compilation target directory</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Optional metadata in a <tt class="calibre22">META-INF</tt> directory entry</blockquote></li></ul></li><li value="2" class="calibre16"><blockquote class="calibre17"><span class="italic">.war</span> files, which are also <span class="italic">.zip</span> files, are the JVM standard for packaging web applications. See <a href="#filepos2000202"><span class="calibre5">Web Application Packaging</span></a> for more info about <span class="italic">.war</span> files and how they are used.</blockquote></li></ul><blockquote class="calibre38"></blockquote><blockquote class="calibre39"><span class="calibre10"><span class="bold">RARE PACKAGING TYPES</span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Regular, unadorned </span><span class="calibre10"><span class="italic">.zip</span></span><a id="filepos1210105"></a><span class="calibre10"> or </span><span class="calibre10"><span class="italic">.tar.gz</span></span><a id="filepos1210174"></a><span class="calibre10"> files are also found occasionally in Maven repositories, but these are more often used to transport noncode assets. For example, you might want to include a JVM installer with a client-side application installer that is constructed in an automated fashion at build time; zipping up the JVM installer and deploying it into your organization’s Maven repository would ensure that your project could declare a dependency on it and script the inclusion of that installer.</span></blockquote><blockquote class="calibre17"><span class="calibre10">In addition, application frameworks like the Eclipse and NetBeans rich client platforms have their own packaging types and requirements, although they are largely just variations on the </span><span class="calibre10"><span class="italic">.jar</span></span><a id="filepos1210963"></a><span class="calibre10"> file theme and are rarely (if ever) used outside of the specific framework for which they are intended.</span></blockquote><p class="calibre50">Artifacts of all types are identified using <span class="italic">coordinates</span>, a basket of attributes that together uniquely identify a particular version of an artifact:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">groupId</tt>, often an organizational or project identifier like <tt class="calibre22">org.apache.lucene</tt> or <tt class="calibre22">com.google.collections</tt>.</blockquote></li><a id="filepos1211562"></a><li value="2" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">artifactId</tt>, an identifier of the artifact within the organization or project, such as <tt class="calibre22">lucene-core</tt> or <tt class="calibre22">lucene-queryparser</tt>. Projects often produce multiple related artifacts under the same <tt class="calibre22">groupId</tt>, though it’s common for smaller Clojure open source libraries to have the same <tt class="calibre22">groupId</tt> and <tt class="calibre22">artifactId</tt> when there is no distinction between the organization and project.</blockquote></li><a id="filepos1212081"></a><li value="3" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">packaging</tt>, an identifier of the type of artifact that is being referred to that corresponds to the file extension of the artifact itself. This defaults to <tt class="calibre22">jar</tt>, and is generally not specified in the default case.</blockquote></li><a id="filepos1212411"></a><li value="4" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">version</tt>, a version string that ideally follows the conventions of semantic versioning.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1212624"></a><a href="#filepos1263270"><span class="calibre32">249</span></a><span class="calibre32">]</span></small></sup></blockquote></li><a id="filepos1212737"></a></ul><p class="calibre18">In textual settings, Maven coordinates are often specified in a format like <tt class="calibre22">groupId:artifactId:packaging:version</tt>, so v1.3.0 of Clojure’s jar is referred to as <tt class="calibre22">org.clojure:clojure:1.3.0</tt> (remembering that the <tt class="calibre22">jar</tt> packaging is the default). Each project defines its own coordinates—sometimes in a Maven <span class="italic">pom.xml</span> file, sometimes in a <span class="italic">project.clj</span> file if you are using Leiningen. In any case, each time a project has been built and the author wishes to distribute the resulting artifacts, a corresponding <span class="italic">pom.xml</span> file is uploaded along with the artifacts to a Maven <span class="italic">repository</span>.</p><p id="filepos1213411" class="calibre23"><span class="calibre53"><span class="bold">Repositories</span></span></p><p id="filepos1213484" class="calibre18">When a set of artifacts is uploaded to a Maven <span class="italic">repository</span>, that repository generally indexes the versioning and dependency information in the <span class="italic">pom.xml</span> provided to it along with the artifacts; this is called <span class="italic">deployment</span><a id="filepos1213749"></a>. From that point, the repository will be able to distribute the artifacts to any clients that wish to obtain them (almost always other developers whose projects depend upon the artifacts).</p><p class="calibre18">There are hundreds (maybe thousands) of public repositories in operation worldwide, but there are just few large ones that hold the majority of Maven <a id="filepos1214127"></a>artifacts:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17"><span class="italic">Maven central</span>, the largest repository and default location where Maven-based build tools search for dependencies. All the official Clojure distributions and core libraries are released to Maven central.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17"><span class="italic">Clojars.org</span>, an open Clojure community repository for which Leiningen provides simplified integration. Many very popular open source Clojure libraries are deployed to Clojars, including Ring, Clutch, and Enlive.</blockquote></li><a id="filepos1214803"></a><li value="3" class="calibre16"><blockquote class="calibre17">Large open source organizations like Apache, JBoss, and RedHat maintain their own Maven repositories as well.</blockquote></li></ul><p class="calibre18">You will likely also work with two other types of Maven repositories at some point:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Private/internal repositories are often maintained by companies and other organizations to house artifacts produced by their own projects, and sometimes to proxy public repositories such as Maven central or Clojars.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">The <span class="italic">local repository</span>, which is created by Maven and other Maven-based build tools at <span class="italic">~/.m2/repository</span>. This is where dependencies of your projects will be downloaded and cached for future use. You can also choose to <span class="italic">install</span> artifacts from projects you build into this local repository (which is conceptually the same process as deployment, but so named in order to distinguish the install action being targeted at the local repository).</blockquote></li></ul><p id="filepos1216038" class="calibre23"><span class="calibre53"><span class="bold">Dependencies</span></span></p><p id="filepos1216111" class="calibre18">Just as every project defines its coordinates, every project defines its <span class="italic">dependencies</span>. Dependencies are expressed as references to other projects’ artifacts, using those artifacts’ coordinates. Using these specifications of dependencies, Maven and other Maven-based build tools can:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Determine a project’s set of <span class="italic">transitive dependencies</span>—that is, a project’s dependencies’ dependencies’ dependencies, and so on. Put more formally, a project’s dependencies form a directed acyclic graph, rooted at the project being built, run, examined, etc. It is a fatal error for a project’s dependencies to form a referential cycle.</blockquote></li><a id="filepos1216925"></a><li value="2" class="calibre16"><blockquote class="calibre17">Given a full set of a project’s transitive dependencies, new REPLs and compilation and application processes can be started with the dependencies’ artifacts added to the JVM’s classpath; this allows code running in those processes to refer to classes, resources, and Clojure source files contained in those dependencies.</blockquote></li></ul><p class="calibre18">Resolving a project’s dependencies is a straightforward graph traversal that you generally don’t have to be aware of.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1217541"></a><a href="#filepos1263718"><span class="calibre32">250</span></a><span class="calibre32">]</span></small></sup> The only real caveat is the flexibility that exists in specifying dependency versions, which primarily comes in the form of <span class="italic">snapshots</span> and <span class="italic">version ranges</span>.</p><blockquote id="filepos1217808" class="calibre38"></blockquote><blockquote class="calibre39"><span class="calibre10"><span class="bold">CLOJURE IS “JUST” ANOTHER DEPENDENCY</span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Those with a background in Python, Ruby, and other languages that have their own dedicated runtime often have an expectation that you “install” Clojure, just as you might install some particular version of Ruby. This is not so.</span></blockquote><blockquote class="calibre17"><span class="calibre10">Technically, Clojure is just another Java/JVM library, and therefore is just another dependency within your project; it is the JVM that you must install. Clojure then must be added to your application’s classpath, usually with the help of Leiningen or Maven during development and testing.</span></blockquote><blockquote class="calibre17"><span class="calibre10">The fact that Clojure is a JVM library can have some very tangible benefits in terms of deployment<sup class="calibre58"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1218843"></a><a href="#filepos1264322"><span class="calibre32">251</span></a><span class="calibre32">]</span></small></sup> and team and customer acceptance.<sup class="calibre58"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1219007"></a><a href="#filepos1265237"><span class="calibre32">252</span></a><span class="calibre32">]</span></small></sup></span></blockquote><p class="calibre50"><span class="bold">Snapshot and release versions</span>. <a id="filepos1219190"></a>Within the Maven dependency model, versions are classified as either <span class="italic">snapshots</span><a id="filepos1219282"></a> or <span class="italic">releases</span><a id="filepos1219308"></a>. Most version strings—including examples like <tt class="calibre22">1.0.0</tt>, <tt class="calibre22">3.6</tt>, <tt class="calibre22">0.2.1-beta5</tt>, and so on—are considered release versions, implying that such versions are fixed in time and will never change. This is enforced by all sane repositories, which will prevent a previously deployed artifact with a release version string from being updated. This supports the objective of repeatable builds: because released artifacts cannot change after they are deployed to a repository, once you’ve built and tested against a particular version of a dependency, you can forever rely upon those results.</p><p class="calibre18">Snapshot versions are entirely different. Denoted by version strings that end with a <tt class="calibre22">-SNAPSHOT</tt> suffix—such as <tt class="calibre22">1.0.0-SNAPSHOT</tt>, <tt class="calibre22">3.6-SNAPSHOT</tt>, or <tt class="calibre22">0.2.1-beta5-SNAPSHOT</tt>—snapshots are intended to identify artifacts produced from the bleeding edge of development. Thus, the same version number can refer to different concrete artifacts over time, as development releases are created and distributed to repositories.</p><p class="calibre18">For example, say you want to track ongoing development leading up to version <tt class="calibre22">2.0.0</tt> of a particular library because <tt class="calibre22">2.0.0</tt> will provide some key features your project needs. That library will likely distribute many builds with a version of <tt class="calibre22">2.0.0-SNAPSHOT</tt>, and as long as you specify that version string in your project’s dependencies, you will always be working with and testing against the latest prerelease version.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1220913"></a><a href="#filepos1265565"><span class="calibre32">253</span></a><span class="calibre32">]</span></small></sup> You can then switch to using the <tt class="calibre22">2.0.0</tt> release version of the library once its authors finish their work and deploy the final release artifact to the project’s repository.</p><p class="calibre18"><span class="bold">Version ranges</span>. <a id="filepos1221247"></a>Say you have a dependency on version <tt class="calibre22">1.6.0</tt> of a library, but you might know that you could safely depend upon a library not breaking API compatibility until its next major release. Insofar as nearly all artifacts use semantic versioning, as in this case, it is often useful to define dependency versions in terms of <span class="italic">ranges of versions</span>. Maven supports a number of version range formats:</p><p class="calibre3"></p><p class="calibre1"><span class="italic">Table 8-2. Maven version range formats<sup class="calibre30"><small class="calibre31"><span class="calibre32"><span class="italic">[</span></span><a id="filepos1221834"></a><a href="#filepos1225430"><span class="calibre32"><span class="italic">254</span></span></a><span class="calibre32"><span class="italic">]</span></span></small></sup></span><a id="filepos1221947"></a></p><table border="1" valign="top" class="calibre40"><tr border="1" valign="top" class="calibre27"><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Range format </span></span></span></th><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Semantics </span></span></span></th></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">(,1.0]</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">x &lt;= 1.0</tt></span><span class="calibre21">
</span></p></td></tr><tr border="1" valign="top" class="calibre43"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">1.0</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> “Soft” requirement on  </span><span class="calibre21"><tt class="calibre22">1.0 </tt></span></p></td></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">[1.0]</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> Hard requirement on  </span><span class="calibre21"><tt class="calibre22">1.0</tt></span><span class="calibre21">
</span></p></td></tr><tr border="1" valign="top" class="calibre43"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">[1.2,1.3]</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">1.2 &lt;= x &lt;= 1.3</tt></span><span class="calibre21">
</span></p></td></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">[1.0,2.0)</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">1.0 &lt;= x &lt; 2.0</tt></span><span class="calibre21">
</span></p></td></tr><tr border="1" valign="top" class="calibre43"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">[1.5,)</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">x &gt;= 1.5</tt></span><span class="calibre21">
</span></p></td></tr><tr border="1" valign="top" class="calibre27"><td colspan="2" border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre45"><span class="calibre21"> </span></p><p class="calibre42"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1225430"></a><a href="#filepos1221834"><span class="calibre32">254</span></a><span class="calibre32">] </span></small></sup><span class="calibre21">Taken from </span><a href="http://docs.codehaus.org/display/MAVEN/Dependency+Mediation+and+Conflict+Resolution"><span class="calibre21"><span class="calibre5">http://docs.codehaus.org/display/MAVEN/Dependency+Mediation+and+Conflict+Resolution</span></span></a><span class="calibre21">.</span></p></td></tr></table><p class="calibre23">So, we can specify our dependency on the library as <tt class="calibre22">[1.6.0,2.0.0)</tt>, which will allow our project’s artifacts to be resolved in conjunction with any version of the library between <tt class="calibre22">1.6.0</tt> (inclusive) and <tt class="calibre22">2.0.0</tt> (exclusive). Once <tt class="calibre22">2.0.0</tt> is released (perhaps breaking compatibility with the prior <tt class="calibre22">1.x.x</tt> releases given a bump in the major version number), we’ll need to test (and maybe tweak) our project to work with <tt class="calibre22">2.0.0</tt> and distribute a new release—perhaps specifying a version range dependency on the library of <tt class="calibre22">[2.0.0, 3.0.0)</tt>.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Note that in the table above, a “bare” version number (e.g., </span><a id="filepos1226712"></a><span class="calibre10"><tt class="calibre22">1.0</tt></span><span class="calibre10">) is noted as a “soft” version requirement. This means that if two different bare versions of a particular artifact are depended upon—for example, you depend on version </span><span class="calibre10"><tt class="calibre22">1.2</tt></span><span class="calibre10"> of a library, and one of your dependencies depends on version </span><span class="calibre10"><tt class="calibre22">1.6</tt></span><span class="calibre10"> of the same library—the later version will be selected and used in all builds, REPLs, and so on. This almost never causes any problems, but when it does, specifying a version range will eliminate the ambiguity. In this example, if you change your direct dependency on the library to </span><span class="calibre10"><tt class="calibre22">[1.2,1.5]</tt></span><span class="calibre10">, then version </span><span class="calibre10"><tt class="calibre22">1.5</tt></span><span class="calibre10"> will be selected.</span></blockquote><p class="calibre25">This scenario and your usage of version ranges in general depends upon your assessment of the projects that produce the libraries you depend upon. If they use semantic versioning (of some sort) reliably, then version ranges can be a great way to ensure that the artifacts you produce will be used only with versions of their dependencies with which they are likely to be compatible. On the other hand, if your dependencies are versioned using some other scheme,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1228099"></a><a href="#filepos1265979"><span class="calibre32">255</span></a><span class="calibre32">]</span></small></sup> then version ranges may be less useful to you.<a id="filepos1228241"></a></p><p id="filepos1228252" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Build Tools and Configuration Patterns</span></span></span></p><p id="filepos1228380" class="calibre18">Now that we’ve covered some key background on project organization and build concepts, let’s look at some examples of working with the two most popular build tools in the Clojure community, Leiningen and Maven. This should only be considered a brisk overview though, so consider:</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Each of these tools is deep in its own way, and this is not the place for a comprehensive treatise on the tools’ capabilities and failings. Whichever build tool you choose, be sure to refer to its documentation and community resources to make the most of what it has to offer. Finally, we do provide some additional build examples specifically for web applications in </span><a href="#filepos1991497"><span class="calibre10"><span class="calibre5">Chapter 17</span></span></a><span class="calibre10">.</span></blockquote><p class="calibre25"><span class="bold">Stick with what works</span>. As we said at the beginning of this chapter, it’s impossible for us to provide any absolute truths―perhaps particularly when it comes to build tools. That said, there are some heuristics to help you in deciding which tool to use for your Clojure projects, which we discuss at length below in sections on Leiningen and Maven. There’s one heuristic that should probably override others, however:</p><p class="calibre18">If your organization has standardized on a major JVM-based build toolchain, keep using it. There are Clojure plug-ins for Ant,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1230027"></a><a href="#filepos1266694"><span class="calibre32">256</span></a><span class="calibre32">]</span></small></sup> Maven, Gradle,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1230172"></a><a href="#filepos1267040"><span class="calibre32">257</span></a><span class="calibre32">]</span></small></sup> Buildr, and probably other systems we’re not familiar with, so introducing Clojure into projects already using these tools is a straightforward matter and does not require disturbing a build and project management process that is already in place and working well.</p><p id="filepos1230538" class="calibre23"><span class="calibre53"><span class="bold">Maven</span></span></p><p id="filepos1230604" class="calibre18">Maven is probably the most commonly used build tool in the Java world. An open source Apache project,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1230768"></a><a href="#filepos1267394"><span class="calibre32">258</span></a><span class="calibre32">]</span></small></sup> its scope is far broader than most build tools: through an extensive third-party plug-in community, it aims to provide ways to manage the “full life cycle” of software projects, including things like integration and functional testing, code coverage, test reporting, and release management, in addition to the typical build processes of code compilation and packaging.</p><p class="calibre18">One of Maven’s distinguishing characteristics is that you will find that other JVM-based tooling offers excellent integration with Maven, such as IDEs like Eclipse, NetBeans, and IntelliJ; team facilities like Hudson/Jenkins, Clover, and Cobertura; and auxiliary build tooling like NSIS, IzPack, <tt class="calibre22">javacc</tt>, ANTLR, and Selenium. If you’d like to have maximal integration between tools like this and your build tool, or those “full life cycle” activities are important to you or your organization, you should give Maven serious consideration for your Clojure projects.</p><p class="calibre18">Here is a basic <span class="italic">pom.xml</span> that will get you started with a simple Clojure project in Maven:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1232011"></a><a href="#filepos1267787"><span class="calibre32">259</span></a><span class="calibre32">]</span></small></sup></p><p id="filepos1232110" class="calibre23"></p><p class="calibre23"><span class="italic">Example 8-3. Basic pom.xml suitable for simple Clojure projects</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">&lt;project xmlns="http://maven.apache.org/POM/4.0.0"<br class="calibre33"/>    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br class="calibre33"/>    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 <br class="calibre33"/>                        http://maven.apache.org/maven-v4_0_0.xsd"&gt;<br class="calibre33"/>    <br class="calibre33"/>    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br class="calibre33"/>    &lt;groupId&gt;com.clojurebook&lt;/groupId&gt;<br class="calibre33"/>    &lt;artifactId&gt;sample-maven-project&lt;/artifactId&gt;<br class="calibre33"/>    &lt;version&gt;1.0.0&lt;/version&gt;<br class="calibre33"/>    &lt;packaging&gt;clojure&lt;/packaging&gt;<br class="calibre33"/><br class="calibre33"/>    &lt;dependencies&gt;<br class="calibre33"/>        &lt;dependency&gt;<br class="calibre33"/>            &lt;groupId&gt;org.clojure&lt;/groupId&gt;<br class="calibre33"/>            &lt;artifactId&gt;clojure&lt;/artifactId&gt;<br class="calibre33"/>            &lt;version&gt;1.3.0&lt;/version&gt;<br class="calibre33"/>        &lt;/dependency&gt;<br class="calibre33"/>    &lt;/dependencies&gt;<br class="calibre33"/><br class="calibre33"/>    &lt;build&gt;<br class="calibre33"/>        &lt;resources&gt;<br class="calibre33"/>            &lt;resource&gt;<br class="calibre33"/>                &lt;directory&gt;src/main/clojure&lt;/directory&gt;<br class="calibre33"/>            &lt;/resource&gt;<br class="calibre33"/>        &lt;/resources&gt;<br class="calibre33"/>        &lt;plugins&gt;<br class="calibre33"/>            &lt;plugin&gt;<br class="calibre33"/>                &lt;groupId&gt;com.theoryinpractise&lt;/groupId&gt;<br class="calibre33"/>                &lt;artifactId&gt;clojure-maven-plugin&lt;/artifactId&gt;<br class="calibre33"/>                &lt;version&gt;1.3.8&lt;/version&gt;<br class="calibre33"/>                &lt;extensions&gt;true&lt;/extensions&gt;<br class="calibre33"/>                &lt;configuration&gt;<br class="calibre33"/>                    &lt;warnOnReflection&gt;true&lt;/warnOnReflection&gt;<br class="calibre33"/>                    &lt;temporaryOutputDirectory&gt;true&lt;/temporaryOutputDirectory&gt;<br class="calibre33"/>                &lt;/configuration&gt;<br class="calibre33"/>            &lt;/plugin&gt;<br class="calibre33"/>        &lt;/plugins&gt;<br class="calibre33"/>    &lt;/build&gt;<br class="calibre33"/>&lt;/project&gt;</tt></span></p><p class="calibre13">This <span class="italic">pom.xml</span>:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Defines Maven coordinates of <tt class="calibre22">com.clojurebook:sample-maven-project:1.0.0</tt>.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Defines packaging of <tt class="calibre22">clojure</tt>, which prompts <tt class="calibre22">clojure-maven-plugin</tt> to add its AOT compilation and unit test goals to the corresponding Maven life cycle phases.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Sets a single dependency of Clojure v1.3.0 (<tt class="calibre22">org.clojure:clojure:1.3.0</tt>).</blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17">Adds the standard Clojure source directory as a Maven resource directory; this causes Clojure source files in that directory to be added to the <span class="italic">.jar</span> file produced by this project’s build.</blockquote></li><li value="5" class="calibre16"><blockquote class="calibre17">Configures <tt class="calibre22">clojure-maven-plugin</tt> to run the AOT compiler in the <a href="#filepos1250762">“sanity check”</a> mode described in <a href="#filepos1247107"><span class="calibre5">AOT compilation configuration</span></a>, warning when reflective interop calls are encountered and depositing the generated class files into a temporary directory (so they are not included in packaged artifacts).</blockquote></li></ul><p class="calibre18">Some typical workflows with a project using this <span class="italic">pom.xml</span> would be:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">mvn clojure:repl</tt> will start a new Clojure REPL with the classpath set to include all of the transitive dependencies of the project.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">mvn package</tt> will AOT-compile the Clojure source files as a sanity check and build the <span class="italic">.jar</span> file containing those files.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">mvn test</tt> will run all of the Java and Clojure tests present in your project (rooted at <span class="italic">test/src/java</span> and <span class="italic">test/src/clojure</span>, respectively)</blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">mvn install</tt>—in addition to what <tt class="calibre22">mvn package</tt> does—will <span class="italic">install</span> the <span class="italic">.jar</span> file in your local Maven repository.</blockquote></li><li value="5" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">mvn deploy</tt>—in addition to what <tt class="calibre22">mvn install</tt> does—will <span class="italic">deploy</span> the <span class="italic">.jar</span> file to a remote repository that you would need to add into <span class="italic">pom.xml</span>.</blockquote></li></ul><p class="calibre18">All of the Clojure-specific functionality in Maven <a id="filepos1237516"></a>is provided by the <tt class="calibre22">clojure-maven-plugin</tt><a id="filepos1237571"></a>,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1237614"></a><a href="#filepos1268556"><span class="calibre32">260</span></a><span class="calibre32">]</span></small></sup> which provides a plethora of options for controlling how and when it invokes Clojure’s AOT compilation, runs specific Clojure scripts in your project, runs Clojure unit and functional tests, and so on. In addition, it provides a number of goals beyond <tt class="calibre22">clojure:repl</tt> that are useful in the course of development.</p><p class="calibre18">Aside from <tt class="calibre22">clojure-maven-plugin</tt>, there are hundreds of Maven plug-ins <a id="filepos1238142"></a>available to assist in automating various build, testing, and project management activities, as well as for enabling enhanced integration of Maven projects with external tools and environments. In general, simply search the Web for <tt class="calibre22">foo maven plugin</tt>, and you are likely to find a useful plug-in for the <tt class="calibre22">foo</tt> you are interested in.</p><p id="filepos1238499" class="calibre23"><span class="calibre53"><span class="bold">Leiningen</span></span></p><p id="filepos1238569" class="calibre18">Leiningen<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1238641"></a><a href="#filepos1268898"><span class="calibre32">261</span></a><span class="calibre32">]</span></small></sup> is billed as “A build tool for Clojure designed to not set your hair on fire.”<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1238854"></a><a href="#filepos1269352"><span class="calibre32">262</span></a><span class="calibre32">]</span></small></sup> This mission was borne largely out of frustration with some of the complexity that Maven and Ant imply for the most common build requirements of Clojure projects. It aims to offer a simpler overall workflow for common tasks than Ant or Maven.</p><p class="calibre18">If you are coming from outside the JVM world—from Ruby, Python, or similar languages—you will likely find Leiningen more appealing than Maven. While it reuses parts of Maven under the covers, Leiningen provides a more Clojure-idiomatic treatment of the Maven dependency model, and a more lightweight development process. In particular, changing or extending Leiningen’s build process can be done entirely within Clojure,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1239685"></a><a href="#filepos1269875"><span class="calibre32">263</span></a><span class="calibre32">]</span></small></sup> a refreshingly pleasant experience compared to what’s required to build Maven plug-ins. The tradeoff is that Leiningen does not offer access to the array of third-party plug-ins and integration options in the Maven ecosystem, although the set of Leiningen plug-ins <a id="filepos1240048"></a>that are available continues to grow.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1240127"></a><a href="#filepos1270272"><span class="calibre32">264</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">Here is a basic <span class="italic">project.clj</span> that will get you started with a simple Clojure project in Leiningen:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 8-4. Basic project.clj suitable for simple Clojure projects</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(defproject com.clojurebook/sample-lein-project "1.0.0"<br class="calibre33"/>  :dependencies [[org.clojure/clojure "1.3.0"]])</tt></span></p><p class="calibre13"><tt class="calibre22">defproject</tt><a id="filepos1240730"></a> is a macro that defines a model of your project suitable for Leiningen. Aside from the key-value pairs that constitute the bulk of the project configuration, <tt class="calibre22">defproject</tt> requires the first two arguments to it to be the project’s coordinates (specified using a Clojure symbol and a string, here <tt class="calibre22">com.clojurebook/sample-lein-project "1.0.0"</tt>, which corresponds to <tt class="calibre22">com.clojurebook:sample-lein-project:1.0.0</tt> in Maven notation).</p><p class="calibre18"><tt class="calibre22">defproject</tt> provides a shortcut where you can set the group and artifact ID to the same value with an unnamespaced symbol. This is most often done for open source projects where the project <span class="italic">is</span> the organization; for example, Ring (the Clojure web framework) has <tt class="calibre22">ring "1.0.1"</tt> as its first two arguments to <tt class="calibre22">defproject</tt>, resulting in Maven coordinates of <tt class="calibre22">ring:ring:1.0.1</tt>.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Leiningen provides a command to create the scaffolding of a new project; invoking </span><span class="calibre10"><tt class="calibre22">lein new my-project</tt></span><span class="calibre10"> will create a new </span><span class="calibre10"><span class="italic">my-project</span></span><span class="calibre10"> directory containing a </span><span class="calibre10"><span class="italic">project.clj</span></span><span class="calibre10"> file (with coordinates of </span><span class="calibre10"><tt class="calibre22">my-project "1.0.0-SNAPSHOT"</tt></span><span class="calibre10">), and placeholder source files and test source files.</span></blockquote><p class="calibre25">This basic <span class="italic">project.clj</span><a id="filepos1242366"></a> provides roughly the same configuration options as the sample Maven <span class="italic">pom.xml</span> discussed in <a href="#filepos1230538"><span class="calibre5">Maven</span></a>, with the difference that the root Clojure source directory is <span class="italic">src</span> rather than <span class="italic">src/main/clojure</span>, and the root Clojure test source directory is <span class="italic">test</span> rather than <span class="italic">src/test/clojure</span>. The real difference between the two approaches for such a simple project is that the behavior of the Leiningen build is dependent upon which <tt class="calibre22">lein</tt> commands are issued and in which order, whereas the Maven build enforces consistent ordering and semantics for each build phase.</p><p class="calibre18">Those differences aside, the basic Leiningen workflows are very similar to Maven’s:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">lein repl</tt> will start a new Clojure REPL with the classpath set to include all of the transitive dependencies of the project.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">lein test</tt> will run all of the Clojure tests present in the project (usually housed in the <span class="italic">test</span> directory).</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">lein jar</tt> performs the same packaging as <tt class="calibre22">mvn package</tt>, but does not automatically perform AOT compilation of the Clojure sources.</blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">lein uberjar</tt> will produce an <span class="italic">uberjar</span>, a <span class="italic">.jar</span> file just like that generated by <tt class="calibre22">lein jar</tt>, but with all of your project’s transitive dependencies “unpacked” into it. Uberjars are a commonly used for simple deployments, where an entire application can be delivered as a single file, executable with a single <tt class="calibre22">java</tt> invocation.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1244341"></a><a href="#filepos1270705"><span class="calibre32">265</span></a><span class="calibre32">]</span></small></sup></blockquote></li><li value="5" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">lein compile</tt> will AOT compile all of the project’s Clojure sources based on the <tt class="calibre22">:aot</tt> configuration in <span class="italic">project.clj</span>. We talk about configuring Leiningen for AOT compilation next, in <a href="#filepos1247107"><span class="calibre5">AOT compilation configuration</span></a>.</blockquote></li><li value="6" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">lein pom</tt> will generate a Maven-compatible <span class="italic">pom.xml</span> file that contains the project and dependency information in your project’s <span class="italic">project.clj</span> file. It is this <span class="italic">pom.xml</span> file that would be used in deploying to a remote Maven repository or installed into your local Maven repository.</blockquote></li><li value="7" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">lein deps</tt> ensures that all dependencies your project specifies are available, downloading them if necessary. This is generally done for you automatically (i.e., whenever the <tt class="calibre22">:dependencies</tt> vector is changed).</blockquote></li></ul><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">As you can see, the notation used for describing dependencies in Leiningen and Maven is syntactically very different. However, the same information is being conveyed; this Leiningen dependency:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">[org.clojure/clojure "1.3.0"]</tt></span></blockquote><blockquote class="calibre35"><span class="calibre10">is exactly equivalent to this one in Maven:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">&lt;dependency&gt;<br class="calibre33"/>  &lt;groupId&gt;org.clojure&lt;/groupId&gt;<br class="calibre33"/>  &lt;artifactId&gt;clojure&lt;/artifactId&gt;<br class="calibre33"/>  &lt;version&gt;1.3.0&lt;/version&gt;<br class="calibre33"/>&lt;/dependency&gt;</tt></span></blockquote><blockquote class="calibre35"><span class="calibre10">Because it is more concise, and because it is much more widespread in the Clojure community (e.g., project </span><span class="calibre10"><span class="italic">README</span></span><span class="calibre10"> files are more likely to provide Leiningen-style dependency vectors than snippets of </span><span class="calibre10"><tt class="calibre22">&lt;dependency&gt;</tt></span><span class="calibre10"> XML for use in Maven), from this point forward in the book, whenever we refer to a Clojure library used in an example, </span><span class="calibre10"><span class="italic">we will provide the corresponding dependency using Leiningen’s notation</span></span><span class="calibre10">.</span></blockquote><p id="filepos1247107" class="calibre25"><span class="calibre53"><span class="bold">AOT compilation configuration</span></span></p><p id="filepos1247197" class="calibre18">Outside of defining dependencies and packaging artifacts, one of the most common things you need to do in a Clojure build process is AOT compile your Clojure sources. The motivations and tradeoffs associated with AOT compilation should be considered before proceeding, though. Please digest <a href="#filepos1199448"><span class="calibre5">Ahead-of-Time Compilation</span></a> before deciding an AOT compilation is necessary or desirable for your project; oftentimes, it is not.</p><p class="calibre18">In any case, both Leiningen and Maven provide straightforward ways of enabling, disabling, and configuring AOT compilation.</p><p class="calibre18"><span class="bold">Leiningen</span>. By default, Leiningen <a id="filepos1247926"></a>will not perform AOT compilation on your project’s Clojure sources. Configuring it to do so requires adding an <tt class="calibre22">:aot</tt> slot to the project configuration, where that slot’s value may be:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">:all</tt>, which prompts Leiningen to AOT compile all namespaces found in your project</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">A vector of namespaces specifying which namespaces within the project should be compiled.</blockquote></li></ul><p class="calibre18">Once you’ve added an <tt class="calibre22">:aot</tt> configuration, running <tt class="calibre22">lein compile</tt> will cause your project’s Clojure namespaces to be AOT compiled.</p><p class="calibre18"><span class="bold">Maven</span>. <a id="filepos1248767"></a>AOT compilation is enabled in <tt class="calibre22">clojure-maven-plugin</tt> by default, at least when using the <tt class="calibre22">clojure</tt> packaging as shown in <a href="#filepos1232110"><span class="calibre5">Example 8-3</span></a>. That packaging binds <tt class="calibre22">clojure-maven-plugin</tt>’s compilation goal to Maven’s <tt class="calibre22">compile</tt> phase, so that AOT compilation is run after Maven’s default Java compilation finishes.</p><p class="calibre18">If you’re not using <tt class="calibre22">clojure</tt> packaging, you’ll need to configure this phase binding explicitly:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">&lt;plugin&gt;<br class="calibre33"/>    &lt;groupId&gt;com.theoryinpractise&lt;/groupId&gt;<br class="calibre33"/>    &lt;artifactId&gt;clojure-maven-plugin&lt;/artifactId&gt;<br class="calibre33"/>    &lt;version&gt;1.3.8&lt;/version&gt;<br class="calibre33"/>    &lt;configuration&gt;<br class="calibre33"/>        &lt;warnOnReflection&gt;true&lt;/warnOnReflection&gt;<br class="calibre33"/>        &lt;temporaryOutputDirectory&gt;false&lt;/temporaryOutputDirectory&gt;<br class="calibre33"/>    &lt;/configuration&gt;<br class="calibre33"/><br class="calibre33"/>    &lt;executions&gt;<br class="calibre33"/>        &lt;execution&gt;<br class="calibre33"/>            &lt;id&gt;compile-clojure&lt;/id&gt;<br class="calibre33"/>            &lt;phase&gt;compile&lt;/phase&gt;<br class="calibre33"/>            &lt;goals&gt;<br class="calibre33"/>                &lt;goal&gt;compile&lt;/goal&gt;<br class="calibre33"/>            &lt;/goals&gt;<br class="calibre33"/>        &lt;/execution&gt;<br class="calibre33"/>    &lt;/executions&gt;<br class="calibre33"/>&lt;/plugin&gt;</tt></span></blockquote><p class="calibre23">Here we also see the two configuration parameters that are most relevant to AOT compilation: <tt class="calibre22">warnOnReflection</tt><a id="filepos1250488"></a> and <tt class="calibre22">temporaryOutputDirectory</tt><a id="filepos1250533"></a>. Respectively, these control whether <tt class="calibre22">*warn-on-reflection</tt> is enabled, and whether class files generated by AOT compilation are saved to the default <span class="italic">classes</span> output directory, or to a temporary directory.</p><p id="filepos1250762" class="calibre18"><span class="bold">AOT compilation as a sanity check</span>. Even if you don’t want to distribute AOT-compiled class files, including AOT compilation in your build process (and ignoring the class file results) can be a useful sanity check on your Clojure project’s code. Because AOT compilation requires that the code in question be loaded, all referred libraries, namespaces, vars, and Java classes must be resolved and loaded; if there is a problem with any of those references, an AOT compilation step will uncover it.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1251332"></a><a href="#filepos1271339"><span class="calibre32">266</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18"><tt class="calibre22">clojure-maven-plugin</tt> provides for this scenario; simply add <tt class="calibre22">&lt;temporaryOutputDirectory&gt;true&lt;/temporaryOutputDirectory&gt;</tt> to the plug-in’s <tt class="calibre22">&lt;configuration&gt;</tt> element, and AOT compilation results will be directed toward a temporary directory (that is later deleted). This ensures that the AOT sanity check is performed, but its results won’t leak into your packaged distribution.</p><p class="calibre18">Leiningen does not currently offer an easy way to perform AOT compilation but ignore the resulting class files when packaging a project’s artifact(s). Currently, the best option is to invoke <tt class="calibre22">lein compile</tt> (to perform the AOT compilation), and be sure to invoke <tt class="calibre22">lein clean</tt> before using Leiningen to package your project for distribution.</p><p class="calibre18">Similarly, you can enable <tt class="calibre22">*warn-on-reflection*</tt> during the course of AOT compilation, which will cause Clojure to emit a warning for each instance of interop reflection or argument type mismatches it encounters in your code.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1252565"></a><a href="#filepos1271758"><span class="calibre32">267</span></a><span class="calibre32">]</span></small></sup> To enable these warnings, add a <tt class="calibre22">&lt;warnOnReflection&gt;true&lt;/warnOnReflection&gt;</tt> element to your <tt class="calibre22">clojure-maven-plugin</tt>’s configuration, or <tt class="calibre22">:warn-on-reflection true</tt> to your <span class="italic">project.clj</span> file for Leiningen.</p><p id="filepos1252908" class="calibre23"><span class="calibre53"><span class="bold">Building mixed-source projects</span></span></p><p id="filepos1252999" class="calibre18">If you want to add Clojure to an existing project, you may need to pay some attention to the order in which various parts of such hybrid projects are compiled.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1253221"></a><a href="#filepos1272322"><span class="calibre32">268</span></a><span class="calibre32">]</span></small></sup> Very simply, if your Java code needs to refer to named classes generated by Clojure’s type definition forms in the same project, you’ll need to AOT compile your Clojure sources before compiling your Java sources. Likewise, if your Clojure code needs to refer to classes defined in Java code, the Java sources would need to be compiled first.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">These build process concerns related to mixed-source projects may not be relevant at all if your Java code does not use your Clojure code within the same project, or if your Java code is interoperating with your Clojure code without referencing any Clojure-defined types.<sup class="calibre58"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1254149"></a><a href="#filepos1272731"><span class="calibre32">269</span></a><span class="calibre32">]</span></small></sup></span></blockquote><p class="calibre25">In any case, you need to order the compilation steps in your build process to mirror the intra-project language dependencies. Both Leiningen and Maven provide for this straightforwardly.</p><p class="calibre18"><span class="bold">Maven</span>. <tt class="calibre22">clojure-maven-plugin</tt><a id="filepos1254554"></a> defaults to allowing Maven’s Java compilation to proceed before AOT compiling your Clojure codebase. This can be changed by binding <tt class="calibre22">clojure-maven-plugin</tt>’s compilation goal’s execution to a Maven phase that runs prior to <tt class="calibre22">compile</tt>, such as <tt class="calibre22">process-resources</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">&lt;plugin&gt;<br class="calibre33"/>  &lt;groupId&gt;com.theoryinpractise&lt;/groupId&gt;<br class="calibre33"/>  &lt;artifactId&gt;clojure-maven-plugin&lt;/artifactId&gt;<br class="calibre33"/>  &lt;version&gt;1.3.8&lt;/version&gt;<br class="calibre33"/>  &lt;executions&gt;<br class="calibre33"/>    &lt;execution&gt;<br class="calibre33"/>      &lt;id&gt;clojure-compile&lt;/id&gt;<br class="calibre33"/>      &lt;phase&gt;process-resources&lt;/phase&gt;<br class="calibre33"/>      &lt;goals&gt;<br class="calibre33"/>        &lt;goal&gt;compile&lt;/goal&gt;<br class="calibre33"/>      &lt;/goals&gt;<br class="calibre33"/>    &lt;/execution&gt;<br class="calibre33"/>  &lt;/executions&gt;<br class="calibre33"/>&lt;/plugin&gt;</tt></span></blockquote><p class="calibre23"><span class="bold">Leiningen</span>. Leiningen <a id="filepos1255593"></a>also defaults to using <tt class="calibre22">javac</tt> to compile Java code prior to any AOT compilation you have configured, as long as you have defined a location for where that Java code can be found using the <tt class="calibre22">:java-source-path</tt>
<tt class="calibre22">defproject</tt> slot.</p><p class="calibre18">Leiningen allows you to reverse this order, but via programmatic means instead of making a change in configuration as in Maven. First, <tt class="calibre22">:java-source-path</tt> should remain undefined in our <tt class="calibre22">defproject</tt> configuration; otherwise, Leiningen’s default compilation ordering will remain in effect. What we want to do is alter the behavior of its <tt class="calibre22">compile</tt> task so that <tt class="calibre22">javac</tt> runs after that task’s default activity is complete. Leiningen bundles the <tt class="calibre22">robert-hooke</tt> library,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1256420"></a><a href="#filepos1273169"><span class="calibre32">270</span></a><span class="calibre32">]</span></small></sup> which provides a way to do this succinctly within our <span class="italic">project.clj</span> file:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defproject com.clojurebook/lein-mixed-source "1.0.0"<br class="calibre33"/>  :dependencies [[org.clojure/clojure "1.3.0"]]<br class="calibre33"/>  :aot :all)<br class="calibre33"/><br class="calibre33"/>(require '(leiningen compile javac))                                   </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/><br class="calibre33"/>(add-hook #'leiningen.compile/compile                                  </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  (fn [compile project &amp; args]                                         </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>    (apply compile project args)                                       </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>    (leiningen.javac/javac (assoc project :java-source-path "srcj")))) </tt></span><a></a><img src="images/00001.jpg" class="calibre36"/></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">First we require the key Leiningen namespaces.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">We want to add a hook to the driver function for Leiningen’s <tt class="calibre22">compile</tt> task; to do this, <tt class="calibre22">robert-hooke</tt>’s <tt class="calibre22">add-hook</tt> function needs access to the driver function’s var, <tt class="calibre22">#'leiningen.compile/compile</tt>.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">The hook function is provided with the original <tt class="calibre22">compile</tt> function occupying the <tt class="calibre22">#'leiningen.compile/compile</tt> var, the current <tt class="calibre22">project</tt> configuration, and all the other arguments that would have been passed to that original <tt class="calibre22">compile</tt> function. After <tt class="calibre22">add-hook</tt> returns, our hook function will be in complete control over the implementation of the <tt class="calibre22">compile</tt> task.</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">First, we delegate to the original <tt class="calibre22">compile</tt> function, so that the usual Clojure AOT compilation can proceed.</blockquote><p class="calibre23"><img src="images/00001.jpg" class="calibre36"/></p><blockquote class="calibre37">We need to <tt class="calibre22">assoc</tt> in a value for <tt class="calibre22">:java-source-path</tt> so that <tt class="calibre22">javac</tt> knows where to find our Java sources. This is usually included in the authoritative project model (defined by <tt class="calibre22">defproject</tt> at the top of the <span class="italic">project.clj</span> file); keeping it out of there ensures that <tt class="calibre22">compile</tt> won’t attempt to run <tt class="calibre22">javac</tt> prior to compiling the project’s Clojure sources.</blockquote><p class="calibre18">With this in place, running <tt class="calibre22">lein compile</tt><a id="filepos1259955"></a> will invoke our hook function, thus running the usual Clojure AOT compilation followed by using <tt class="calibre22">javac</tt> to compile the Java code we have rooted in the <span class="italic">srcj</span> directory.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">However you want to organize the code within a project, you should absolutely avoid </span><span class="calibre10"><span class="italic">interleaving</span></span><span class="calibre10"> source dependencies. An interleaving dependency would be where, for example, Java code uses a type defined in Clojure that implements an interface defined in Java, all within the same project. Such topologies </span><a id="filepos1260691"></a><span class="calibre10"><span class="italic">can</span></span><span class="calibre10"> be resolved (perhaps more readily in Maven than elsewhere, given its ability to use any number of distinct source roots in conjunction with any number of compilation goal executions), but it’s safe to assume that they are a symptom of a poor design.</span><a id="filepos1261004"></a></blockquote><br class="calibre33"/><hr class="calibre34"/><p class="calibre25"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1261117"></a><a href="#filepos1198292"><span class="calibre32">244</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Heroku is an outlier in this respect, see </span><a href="#filepos2086843"><span class="calibre10"><span class="calibre5">Clojure on Heroku</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1261461"></a><a href="#filepos1200600"><span class="calibre32">245</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">This is exactly analogous to </span><span class="calibre10"><tt class="calibre22">javac</tt></span><span class="calibre10">, which saves generated class files to disk based on the contents of Java source files.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1261820"></a><a href="#filepos1201607"><span class="calibre32">246</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">If both a source file and class files are available for a particular namespace, Clojure will give preference to the class files </span><span class="calibre10"><span class="italic">unless</span></span><span class="calibre10"> the source file has a newer modification date. This allows you to have both source roots and AOT compile target directories on the classpath in a REPL session and still be able to reload namespaces from updated source files as desired.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1262426"></a><a href="#filepos1205387"><span class="calibre32">247</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">It is generally worth ensuring that you are AOT-compiling only those namespaces that include usages of these forms, if only to minimize the size of your packaged artifacts.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1262783"></a><a href="#filepos1208879"><span class="calibre32">248</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">You can read more about </span><span class="calibre10"><span class="italic">.jar</span></span><span class="calibre10"> files at </span><a href="http://java.sun.com/developer/Books/javaprogramming/JAR/basics"><span class="calibre10"><span class="calibre5">http://java.sun.com/developer/Books/javaprogramming/JAR/basics</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1263270"></a><a href="#filepos1212624"><span class="calibre32">249</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Semantic versioning is a well-understood convention for specifying the magnitude of change between software versions. Read more about it at </span><a href="http://semver.org"><span class="calibre10"><span class="calibre5">http://semver.org</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1263718"></a><a href="#filepos1217541"><span class="calibre32">250</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Tools like Leiningen and Maven handle the sticky details for you. If you want to learn more about dependency resolution within the Maven model, </span><a href="http://docs.codehaus.org/display/MAVEN/Dependency+Mediation+and+Conflict+Resolution"><span class="calibre10"><span class="calibre5">http://docs.codehaus.org/display/MAVEN/Dependency+Mediation+and+Conflict+Resolution</span></span></a><span class="calibre10"> is a good reference.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1264322"></a><a href="#filepos1218843"><span class="calibre32">251</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">When it comes time to deploy your application, there are various packaging options, including </span><span class="calibre10"><span class="italic">.war</span></span><span class="calibre10"> files for web apps, discussed in </span><a href="#filepos2000202"><span class="calibre10"><span class="calibre5">Web Application Packaging</span></span></a><span class="calibre10">, </span><span class="calibre10"><span class="italic">uberjars</span></span><span class="calibre10"> for generalized application deployment, which are directly supported by Leiningen as mentioned in </span><a href="#filepos1238499"><span class="calibre10"><span class="calibre5">Leiningen</span></span></a><span class="calibre10">, and other methods, all aiming to produce a single aggregated file containing all of your project’s code and transitive dependencies, including Clojure.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1265237"></a><a href="#filepos1219007"><span class="calibre32">252</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="#filepos2053759"><span class="calibre10"><span class="calibre5">“Clojure is just another .jar file”</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1265565"></a><a href="#filepos1220913"><span class="calibre32">253</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">It is typical for Maven and tooling that depends upon it to check for new snapshots every 24 hours. If you’re using Maven, passing a </span><span class="calibre10"><tt class="calibre22">-U</tt></span><span class="calibre10"> option will force that check to occur.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1265979"></a><a href="#filepos1228099"><span class="calibre32">255</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">An example of an unfortunate approach is to use date-of-release as the version number, such as </span><span class="calibre10"><tt class="calibre22">20110705</tt></span><span class="calibre10">. Even worse is the release of artifacts using things like Git or Mercurial commit SHAs like </span><span class="calibre10"><tt class="calibre22">8c7be13792</tt></span><span class="calibre10">, which are not only not amenable to version range specifications, they are not even monotonically increasing—thus, it’s impossible to tell from such an artifact’s coordinates which version is newer than another.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1266694"></a><a href="#filepos1230027"><span class="calibre32">256</span></a><span class="calibre32">] </span></small></sup><a href="https://github.com/jmcconnell/clojure-ant-tasks"><span class="calibre10"><span class="calibre5">https://github.com/jmcconnell/clojure-ant-tasks</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1267040"></a><a href="#filepos1230172"><span class="calibre32">257</span></a><span class="calibre32">] </span></small></sup><a href="https://bitbucket.org/kotarak/clojuresque/wiki/Home"><span class="calibre10"><span class="calibre5">https://bitbucket.org/kotarak/clojuresque/wiki/Home</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1267394"></a><a href="#filepos1230768"><span class="calibre32">258</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">We recommend starting with the latest version of Maven 3, available from </span><a href="http://maven.apache.org"><span class="calibre10"><span class="calibre5">http://maven.apache.org</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1267787"></a><a href="#filepos1232011"><span class="calibre32">259</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">There is an abundance of documentation available online related to Maven, including two free books that were written by its authors and are available at </span><a href="http://www.sonatype.com/books.html"><span class="calibre10"><span class="calibre5">http://www.sonatype.com/books.html</span></span></a><span class="calibre10">: </span><span class="calibre10"><span class="italic">Maven by Example</span></span><span class="calibre10"> is a tutorial-oriented introductory guide to Maven, while </span><span class="calibre10"><span class="italic">Maven: the Complete Reference</span></span><span class="calibre10"> is worth keeping handy for understanding the minutiae of the tool.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1268556"></a><a href="#filepos1237614"><span class="calibre32">260</span></a><span class="calibre32">] </span></small></sup><a href="http://github.com/talios/clojure-maven-plugin"><span class="calibre10"><span class="calibre5">http://github.com/talios/clojure-maven-plugin</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1268898"></a><a href="#filepos1238641"><span class="calibre32">261</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Leiningen, often referred to colloquially as “lein,” is ostensibly pronounced as </span><span class="calibre10"><span class="italic">LINE-ing-en</span></span><span class="calibre10">, although it’s not rare to hear the alternative </span><span class="calibre10"><span class="italic">LINE-in-gen</span></span><span class="calibre10">, either.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1269352"></a><a href="#filepos1238854"><span class="calibre32">262</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">We recommend starting with the latest version of Leiningen, at least v1.7.0 or later: </span><a href="http://leiningen.org"><span class="calibre10"><span class="calibre5">http://leiningen.org</span></span></a><span class="calibre10">. All of the Leiningen examples in this book have been tested with v1.7.0, as well as the recently released preview of v2.0.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1269875"></a><a href="#filepos1239685"><span class="calibre32">263</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">An example of a small local modification to a Leiningen build process is shown at </span><a href="#filepos1252908"><span class="calibre10"><span class="calibre5">Building mixed-source projects</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1270272"></a><a href="#filepos1240127"><span class="calibre32">264</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">A partial list of Leiningen plug-ins can be found at </span><a href="https://github.com/technomancy/leiningen/wiki/plugins"><span class="calibre10"><span class="calibre5">https://github.com/technomancy/leiningen/wiki/plugins</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1270705"></a><a href="#filepos1244341"><span class="calibre32">265</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">For example, </span><span class="calibre10"><tt class="calibre22">java -cp &lt;path-to-uberjar&gt; com.foo.MainClassName</tt></span><span class="calibre10"> or </span><span class="calibre10"><tt class="calibre22">java -cp &lt;path-to-uberjar&gt; clojure.main -m com.foo.namespace-with-main-fn</tt></span><span class="calibre10">. The latter is most common with Clojure projects, and requires no AOT compilation; see the documentation for </span><span class="calibre10"><tt class="calibre22">clojure.main/main</tt></span><span class="calibre10"> for details.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1271339"></a><a href="#filepos1251332"><span class="calibre32">266</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">The same check can be done by loading code into a REPL, but it is generally good practice to ensure that such quality checks are regularly performed in a repeatable build, rather than in an interactive, rarely reproduced REPL session.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1271758"></a><a href="#filepos1252565"><span class="calibre32">267</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="#filepos1324665"><span class="calibre10"><span class="calibre5">Type Hinting for Performance</span></span></a><span class="calibre10"> for details about interop type hinting, and </span><a href="#filepos1599929"><span class="calibre10"><span class="calibre5">Type errors and warnings</span></span></a><span class="calibre10"> for more about the warnings that Clojure can emit for argument type mismatches.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1272322"></a><a href="#filepos1253221"><span class="calibre32">268</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">For the sake of clarity, we’ll assume here that your hybrid project includes Java as its only other non-Clojure language. Similar advice would hold if you were working on a Clojure/JRuby project or a Scala/Clojure project.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1272731"></a><a href="#filepos1254149"><span class="calibre32">269</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="#filepos1408219"><span class="calibre10"><span class="calibre5">Using Clojure from Java</span></span></a><span class="calibre10"> for details of how to use functionality defined in Clojure from Java without defining new Java-referenceable types in Clojure.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1273169"></a><a href="#filepos1256420"><span class="calibre32">270</span></a><span class="calibre32">] </span></small></sup><span class="calibre10"><tt class="calibre22">robert-hooke</tt></span><span class="calibre10"> is a Clojure library that provides a superset of aspect-oriented programming (AOP) in Clojure; its application to problems usually solved by AOP frameworks in Java is described in </span><a href="#filepos1682627"><span class="calibre10"><span class="calibre5">Aspect-Oriented Programming</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos1273658" class="calibre6"><span class="calibre4"><span class="bold">Final Thoughts</span></span></p><p class="calibre18">Organizing codebases and software projects effectively is a domain unto itself. Hopefully we have provided you with enough of a jump start about how projects may be organized and built in the Clojure style to allow you to focus on learning Clojure itself and getting real work done using it.<a id="filepos1274052"></a></p><div class="mbppagebreak"></div><p id="filepos1274079" class="calibre6"><span class="calibre2"><span class="bold">Chapter 9. Java and JVM Interoperability</span></span></p><p id="filepos1274182" class="calibre13">Many languages provide their own purpose-built runtime; popular examples of this approach include Python (CPython), Ruby (MRI), and Java (the JVM).<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1274392"></a><a href="#filepos1281030"><span class="calibre32">271</span></a><span class="calibre32">]</span></small></sup> In contrast, Clojure is fundamentally a <span class="italic">hosted</span> language, meaning that it targets an existing runtime, also the JVM.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1274645"></a><a href="#filepos1281387"><span class="calibre32">272</span></a><span class="calibre32">]</span></small></sup> This means that rather than reimplementing a variety of foundational facilities (e.g., garbage collection, just-in-time compilation, threading, graphics contexts, etc.) and libraries of all sorts (from basics like String handling to esoterica like cryptographic functions), Clojure simply reuses all of the work that’s been done around the JVM.</p><p class="calibre18">Aside from simply being an implementation time saver, targeting a mature host is advantageous for the Clojure programmer as well:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">The JVM core facilities and ecosystem of libraries are backed by significant engineering organizations. This means that they are generally well-tested, widely used, and aggressively optimized, yielding performance characteristics typically required or desired by most practitioners.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Being on the JVM means that there are standard routes of interoperability. Programs written in one language can call on functionality provided by libraries written in other languages, all in the same runtime, with the Java interfaces and the Java object model being the <span class="italic">lingua franca</span>.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">The Java and broader JVM communities are huge, guaranteeing the wide availability of libraries for every domain, an abundance of support materials, and a large pool of developers with deep platform expertise.</blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17">Tools are available to support all phases of software development, including development environments, build tools, profilers, debuggers, and operations support.</blockquote></li></ul><p class="calibre18">Making the most out of Clojure will likely require that you gain a thorough understanding of its relationship to its host, so you can leverage the best parts of the JVM, the libraries targeting it, and any prior investment you have in them.</p><p id="filepos1276887" class="calibre6"><span class="calibre4"><span class="bold">The JVM Is Clojure’s Foundation</span></span></p><p id="filepos1276981" class="calibre18">You might think that Clojure being a hosted language implies that it is somehow divorced from the JVM in significant ways—similar to how some hosted scripting environments erect a sandbox out of which you cannot easily escape. Nothing could be further from the truth. There are many areas of Clojure that reuse foundational facilities in the JVM; to name a few of the most notable:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Clojure strings are Java <tt class="calibre22">String</tt>s.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Clojure <tt class="calibre22">nil</tt> is Java’s <tt class="calibre22">null</tt>.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Clojure numbers are Java numbers.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1277857"></a><a href="#filepos1281765"><span class="calibre32">273</span></a><span class="calibre32">]</span></small></sup></blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17">Clojure regular expressions are instances of <tt class="calibre22">java.util.regex.Pattern</tt>.</blockquote></li><li value="5" class="calibre16"><blockquote class="calibre17">Clojure data structures implement the read-only portions of the appropriate <tt class="calibre22">java.io.*</tt> collection interfaces; so, Clojure maps implement <tt class="calibre22">java.util.Map</tt>, vectors and sequences and lists implement <tt class="calibre22">java.util.List</tt>, and sets implement <tt class="calibre22">java.util.Set</tt>.</blockquote></li><li value="6" class="calibre16"><blockquote class="calibre17">Clojure functions implement <tt class="calibre22">java.lang.Runnable</tt> and <tt class="calibre22">java.util.concurrent.Callable</tt>, making them trivial to integrate into existing libraries and frameworks that expect these core Java interfaces.</blockquote></li><li value="7" class="calibre16"><blockquote class="calibre17">Behind its syntax and abstractions, Clojure function invocations <span class="italic">are</span> method invocations in Java; thus, Clojure functions and function calls carry no special runtime overhead.</blockquote></li><li value="8" class="calibre16"><blockquote class="calibre17">Clojure is never interpreted; rather, it is always compiled down to efficient JVM bytecode prior to being run, even in interactive settings like the REPL.</blockquote></li><li value="9" class="calibre16"><blockquote class="calibre17">Calling Java APIs from Clojure is semantically and mechanically the same operation as calling such APIs from Java.</blockquote><ul class="calibre55"><li value="1" class="calibre16"><blockquote class="calibre17">Clojure functions compile down to classes.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Clojure’s <tt class="calibre22">defrecord</tt> and <tt class="calibre22">deftype</tt> forms compile down to Java classes containing regular Java fields.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Protocols defined by <tt class="calibre22">defprotocols</tt> generate corresponding Java interfaces.</blockquote></li></ul></li></ul><p class="calibre18">This deep level of integration means that using Java libraries from Clojure<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1280251"></a><a href="#filepos1282121"><span class="calibre32">274</span></a><span class="calibre32">]</span></small></sup> (and vice versa) generally requires no special wrappers, conversions, or other subterfuge, and carries no performance penalty compared to equivalent Java code.</p><p class="calibre18">Further, thanks to the depth of the Java standard library and the size of the community that has gathered around the JVM, it’s rare for there not to be a JVM library (sometimes, many competing libraries) for every potential need you may have. This is usually a welcome change for those coming from environments where it is common to need to reimplement functionality in the preferred language.</p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1281030"></a><a href="#filepos1274392"><span class="calibre32">271</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Though starting with Java 7, changes to the JVM have been made exclusively with languages other than Java in mind—like Clojure—making it an explicitly polyglot runtime.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1281387"></a><a href="#filepos1274645"><span class="calibre32">272</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">There are other implementations of Clojure that target other hosts; see </span><a href="#filepos2071096"><span class="calibre10"><span class="calibre5">(dissoc Clojure 'JVM)</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1281765"></a><a href="#filepos1277857"><span class="calibre32">273</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">There are a couple subtle wrinkles to this; see </span><a href="#filepos1529571"><span class="calibre10"><span class="calibre5">Table 11-1</span></span></a><span class="calibre10"> for details.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1282121"></a><a href="#filepos1280251"><span class="calibre32">274</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Which, remember, is a Java library itself; see </span><a href="#filepos1217808"><span class="calibre10"><span class="calibre5">Clojure Is “Just” Another Dependency</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos1282446" class="calibre6"><span class="calibre4"><span class="bold">Using Java Classes, Methods, and Fields</span></span></p><p id="filepos1282546" class="calibre18">Clojure provides some simple forms for interoperating with its host’s classes, methods, and fields; this makes working with Java libraries within Clojure very natural, and certainly more concise than the equivalent Java code.</p><p id="filepos1282805" class="calibre3"></p><p class="calibre1"><span class="italic">Table 9-1. Clojure interop forms and their Java equivalents<sup class="calibre30"><small class="calibre31"><span class="calibre32"><span class="italic">[</span></span><a id="filepos1283001"></a><a href="#filepos1289508"><span class="calibre32"><span class="italic">275</span></span></a><span class="calibre32"><span class="italic">]</span></span></small></sup></span><a id="filepos1283114"></a></p><table border="1" valign="top" class="calibre40"><tr border="1" valign="top" class="calibre27"><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Operation </span></span></span></th><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Clojure forms </span></span></span></th><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Java equivalents </span></span></span></th></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Create a new instance of a class  </span><span class="calibre21"><tt class="calibre22">ClassName</tt></span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">(ClassName.)</tt></span><span class="calibre21">
</span><span class="calibre21"><tt class="calibre22">(ClassName. arg1 arg2 …)</tt></span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">new ClassName()</tt></span><span class="calibre21">
</span><span class="calibre21"><tt class="calibre22">new ClassName(arg1, arg2, …)</tt></span></p></td></tr><tr border="1" valign="top" class="calibre43"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Invoke an instance method on an  </span><span class="calibre21"><tt class="calibre22">object</tt></span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">(.methodName object)</tt></span><span class="calibre21">
</span><span class="calibre21"><tt class="calibre22">(.methodName object arg1 arg2 …)</tt></span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">object.methodName()</tt></span><span class="calibre21">
</span><span class="calibre21"><tt class="calibre22">object.methodName(arg1, arg2, …)</tt></span></p></td></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Invoke the a static method  </span><span class="calibre21"><tt class="calibre22">staticMethod</tt></span><span class="calibre21"> in a class </span><span class="calibre21"><tt class="calibre22">ClassName</tt></span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">(ClassName/staticMethod)</tt></span><span class="calibre21">
</span><span class="calibre21"><tt class="calibre22">(ClassName/staticMethod arg1 arg2 …)</tt></span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">ClassName.staticMethod()</tt></span><span class="calibre21">
</span><span class="calibre21"><tt class="calibre22">ClassName.staticMethod(arg1, arg2, …)</tt></span></p></td></tr><tr border="1" valign="top" class="calibre43"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Access the value of a static field  </span><span class="calibre21"><tt class="calibre22">FIELD</tt></span><span class="calibre21"> in a class </span><span class="calibre21"><tt class="calibre22">ClassName</tt></span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">ClassName/FIELD</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">ClassName.FIELD</tt></span><span class="calibre21">
</span></p></td></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Refer to a  </span><span class="calibre21"><tt class="calibre22">Class</tt></span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">ClassName</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">ClassName.class</tt></span><span class="calibre21">
</span></p></td></tr><tr border="1" valign="top" class="calibre43"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Access the value of an instance field  </span><span class="calibre21"><tt class="calibre22">field</tt></span><span class="calibre21"> in an object </span><span class="calibre21"><tt class="calibre22">object</tt></span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">(.field object)</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">object.field</tt></span><span class="calibre21">
</span></p></td></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Set the value of an instance field  </span><span class="calibre21"><tt class="calibre22">field</tt></span><span class="calibre21"> in an object </span><span class="calibre21"><tt class="calibre22">object</tt></span><span class="calibre21"> to </span><span class="calibre21"><tt class="calibre22">5</tt></span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">(set! (.fieldName object) 5)</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">object.fieldName = 5</tt></span><span class="calibre21">
</span></p></td></tr><tr border="1" valign="top" class="calibre27"><td colspan="3" border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre45"><span class="calibre21"> </span></p><p class="calibre42"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1289508"></a><a href="#filepos1283001"><span class="calibre32">275</span></a><span class="calibre32">] </span></small></sup><span class="calibre21">We’re fibbing just a little here: There are actually only two fundamental host interop forms, </span><span class="calibre21"><tt class="calibre22">.</tt></span><span class="calibre21"> (a period) and </span><span class="calibre21"><tt class="calibre22">new</tt></span><span class="calibre21">. The former provides method invocation and field access whereas the latter provides constructor invocation. Except for </span><span class="calibre21"><tt class="calibre22">set!</tt></span><span class="calibre21">, all the forms above are expanded into various usages of </span><span class="calibre21"><tt class="calibre22">.</tt></span><span class="calibre21"> and </span><span class="calibre21"><tt class="calibre22">new</tt></span><span class="calibre21">. This syntactic sugar is explained in </span><a href="#filepos190560"><span class="calibre21"><span class="calibre5">Java Interop: . and new</span></span></a><span class="calibre21">.</span></p></td></tr></table><p class="calibre23">Examples <a href="#filepos1290688"><span class="calibre5">9-1</span></a> and <a href="#filepos1293336"><span class="calibre5">9-2</span></a> show a couple of quick REPL interactions where each of these interop forms are used to tap into some core classes in the Java standard library:</p><p id="filepos1290688" class="calibre23"></p><p class="calibre23"><span class="italic">Example 9-1. Retrieving a web page using Java libraries</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(import 'java.net.URL)                     </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= java.net.URL<br class="calibre33"/>(def cnn (URL. "http://cnn.com"))          </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #'user/cnn<br class="calibre33"/>(.getHost cnn)                             </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= "cnn.com"<br class="calibre33"/>(slurp cnn)                                </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= "&lt;html lang=\"en\"&gt;&lt;head&gt;&lt;title&gt;CNN.com………"</tt></span></p><p class="calibre23"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">The <tt class="calibre22">import</tt> macro imports the named class into the current namespace; in this case the platform-standard <tt class="calibre22">URL</tt> class.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">Here we create an instance of <tt class="calibre22">URL</tt> with a single string argument, and store the result in a var. The constructor usage here is equivalent to <tt class="calibre22">new URL("http://cnn.com")</tt> in Java.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">An invocation of the <tt class="calibre22">getHost</tt> method returns what we’d expect; this is equivalent to <tt class="calibre22">url.getHost()</tt> in Java.</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">Clojure has a <tt class="calibre22">slurp</tt> function that will return the string content of a number of different types of objects, including <tt class="calibre22">java.io.File</tt>s, <tt class="calibre22">java.net.Socket</tt>s, byte arrays, and more.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1293027"></a><a href="#filepos1298303"><span class="calibre32">276</span></a><span class="calibre32">]</span></small></sup> Here we provide our <tt class="calibre22">URL</tt> instance to <tt class="calibre22">slurp</tt>, which returns to us the string content of the URL’s page.</blockquote><p class="calibre13">Using static methods and fields is just as easy:</p><p id="filepos1293336" class="calibre23"></p><p class="calibre23"><span class="italic">Example 9-2. Java static method and field usage</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">Double/MAX_VALUE<br class="calibre33"/>;= 1.7976931348623157E308<br class="calibre33"/>(Double/parseDouble "3.141592653589793")<br class="calibre33"/>;= 3.141592653589793</tt></span></p><p class="calibre13">A key consideration in the design of these interop forms was that they are entirely consistent with function position:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1293831"></a><a href="#filepos1299263"><span class="calibre32">277</span></a><span class="calibre32">]</span></small></sup> the “operation” being performed is always the first symbol in each form. Thus, in addition to being functionally analogous to “native” Java method and constructor calls, interop forms are entirely consistent with Clojure’s syntax. This makes them as natural to read and write as non-interop code that uses regular Clojure functions, and enables the use of interop forms in conjunction with Clojure-native facilities like the <tt class="calibre22">-&gt;</tt> family of threading macros. For example, here is an idiomatic Clojure function that, given a decimal string, returns an uppercase hex String:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn decimal-to-hex<br class="calibre33"/>  [x]<br class="calibre33"/>  (-&gt; x<br class="calibre33"/>    Integer/parseInt<br class="calibre33"/>    (Integer/toString 16)<br class="calibre33"/>    .toUpperCase))<br class="calibre33"/>;= #'user/decimal-to-hex<br class="calibre33"/>(decimal-to-hex "255")<br class="calibre33"/>;= "FF"</tt></span></blockquote><p class="calibre23">The <tt class="calibre22">-&gt;</tt> threading macro provides the result of each form as the first argument to the following form (converting bare symbols into single-element lists along the way), returning the result of the final form. So, the body of the <tt class="calibre22">decimal-to-hex</tt> function is equivalent to <tt class="calibre22">(.toUpperCase (Integer/toString (Integer/parseInt x) 16))</tt>; or, to this Java code:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">public String stringToHex (String x) {<br class="calibre33"/>    return Integer.toString(Integer.parseInt(x), 16).toUpperCase();<br class="calibre33"/>}</tt></span></blockquote><p class="calibre23">At least to our eyes, the usage of <tt class="calibre22">-&gt;</tt> (and similar macros such as <tt class="calibre22">-&gt;&gt;<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1295629"></a><a href="#filepos1299682"><span class="calibre32">278</span></a><span class="calibre32">]</span></small></sup></tt>) leads to code that is far easier to read (you can look at it as a linear processing pipeline, which eliminates the need to “scrub” back and forth across an expression whose order of evaluation isn’t simply left-to-right) yet entirely compatible with interop forms thanks to the consistent use of function position.</p><p id="filepos1296055" class="calibre18"><span class="bold">Accessing object fields</span>. <a id="filepos1296116"></a>Public fields are rare in Java APIs, and mutable public fields are particularly so. Nevertheless, Clojure provides easy access to them, and a way to set their value with its <tt class="calibre22">set!</tt> special form:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1296359"></a><a href="#filepos1300157"><span class="calibre32">279</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 9-3. Accessing and setting the fields of a Java object</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(import 'java.awt.Point)<br class="calibre33"/>;= java.awt.Point<br class="calibre33"/>(def pt (Point. 5 10))<br class="calibre33"/>;= #'user/pt<br class="calibre33"/>(.x pt)<br class="calibre33"/>;= 5<br class="calibre33"/>(set! (.x pt) -42)<br class="calibre33"/>;= -42<br class="calibre33"/>(.x pt)<br class="calibre33"/>;= -42</tt></span></p><p class="calibre13">Notice that <tt class="calibre22">set!</tt><a id="filepos1296928"></a> uses the same syntax—<tt class="calibre22">(.x pt)</tt> here—for referring to the field to set as is used to retrieve the field’s value.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">THE JAVA MUTABILITY (TRAP DOOR | ESCAPE HATCH)</span></span></span></blockquote><blockquote id="filepos1297231" class="calibre17"><span class="calibre10">While Clojure encourages the use of immutable values as a good default (as we discussed in </span><a href="#filepos215673"><span class="calibre10"><span class="calibre5">Chapter 2</span></span></a><span class="calibre10">), the same cannot be said of the majority language that shares Clojure’s JVM host. Java’s collections and its defaults in general encourage mutable object state. Since you can use Java libraries, classes, and objects from Clojure quite naturally, you can opt into mutable state without much ceremony at all. This can either serve as a useful escape hatch (especially when you need functionality that is only available as a Java library) or a nasty trap door (when you don’t treat mutable Java objects with the caution they warrant). In any case, keep your wits about you when working with Java objects from Clojure, especially as you come to appreciate and rely upon Clojure’s sane defaults.</span><a id="filepos1298190"></a></blockquote><br class="calibre33"/><hr class="calibre34"/><p class="calibre25"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1298303"></a><a href="#filepos1293027"><span class="calibre32">276</span></a><span class="calibre32">] </span></small></sup><span class="calibre10"><tt class="calibre22">slurp</tt></span><span class="calibre10"> actually relies on the </span><span class="calibre10"><tt class="calibre22">clojure.java.io/reader</tt></span><span class="calibre10"> function to return a </span><span class="calibre10"><tt class="calibre22">java.io.Reader</tt></span><span class="calibre10"> for all these different types of objects—in our example, using a variety of Java interop to open a </span><span class="calibre10"><tt class="calibre22">java.net.Socket</tt></span><span class="calibre10"> to the URL, obtain a </span><span class="calibre10"><tt class="calibre22">java.io.InputStream</tt></span><span class="calibre10"> from that socket, which is then wrapped with a </span><span class="calibre10"><tt class="calibre22">Reader</tt></span><span class="calibre10">. </span><span class="calibre10"><tt class="calibre22">slurp</tt></span><span class="calibre10"> then takes over, trivially reading character data from the </span><span class="calibre10"><tt class="calibre22">Reader</tt></span><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1299263"></a><a href="#filepos1293831"><span class="calibre32">277</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Read more about </span><span class="calibre10"><span class="italic">function position</span></span><span class="calibre10"> in </span><a href="#filepos53327"><span class="calibre10"><span class="calibre5">Expressions, Operators, Syntax, and Precedence</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1299682"></a><a href="#filepos1295629"><span class="calibre32">278</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="#filepos935751"><span class="calibre10"><span class="calibre5">In Detail: -&gt; and -&gt;&gt;</span></span></a><span class="calibre10"> for a detailed explanation of </span><span class="calibre10"><tt class="calibre22">-&gt;</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">-&gt;&gt;</tt></span><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1300157"></a><a href="#filepos1296359"><span class="calibre32">279</span></a><span class="calibre32">] </span></small></sup><span class="calibre10"><tt class="calibre22">set!</tt></span><span class="calibre10"> is used in a few other situations where you are directly changing a mutable location; see </span><a href="#filepos197231"><span class="calibre10"><span class="calibre5">Specialized Mutation: set!</span></span></a><span class="calibre10"> for more.</span></p><div class="mbppagebreak"></div><p id="filepos1300556" class="calibre6"><span class="calibre4"><span class="bold">Handy Interop Utilities</span></span></p><p id="filepos1300640" class="calibre18">The vast majority of your usage of Java libraries will involve the core interop forms shown in <a href="#filepos1282805"><span class="calibre5">Table 9-1</span></a>. There are a couple of often-used utilities that you should be aware of, though:</p><p class="calibre23"><tt class="calibre22">class</tt></p><blockquote id="filepos1300959" class="calibre17">Returns the <tt class="calibre22">java.lang.Class</tt> of its argument; e.g., <tt class="calibre22">(class "foo")</tt> ⇒ <tt class="calibre22">java.lang.String</tt></blockquote><p class="calibre23"><tt class="calibre22">instance?</tt></p><blockquote id="filepos1301171" class="calibre17">A predicate function that returns true if its second argument is an instance of the <tt class="calibre22">Class</tt> named by the first argument, as in <tt class="calibre22">(instance? String "foo")</tt> ⇒ <tt class="calibre22">true</tt></blockquote><p class="calibre23"><tt class="calibre22">doto</tt></p><blockquote id="filepos1301451" class="calibre17">A macro that invokes a number of nested forms, providing the first argument to <tt class="calibre22">doto</tt> as the first argument to all later forms.</blockquote><p class="calibre18">The purpose and usage of <tt class="calibre22">class</tt> and <tt class="calibre22">instance?</tt> should be fairly obvious, but <tt class="calibre22">doto</tt> warrants further explanation.</p><p class="calibre18">Many classes in the Java world are mutable, and frequently require initialization beyond what their constructors provide. A good example of this is <tt class="calibre22">java.util.ArrayList</tt>, which you often want to populate with some initial data:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">ArrayList list = new ArrayList();<br class="calibre33"/>list.add(1);<br class="calibre33"/>list.add(2);<br class="calibre33"/>list.add(3);</tt></span></blockquote><p class="calibre23">Of course, Clojure provides literals for its own vectors,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1302370"></a><a href="#filepos1305250"><span class="calibre32">280</span></a><span class="calibre32">]</span></small></sup> but there are some unfortunate circumstances where an existing Java API may <span class="italic">require</span> an <tt class="calibre22">ArrayList</tt><a id="filepos1302578"></a> (rather than accepting any <tt class="calibre22">java.util.List</tt>, in which case a Clojure vector could be passed as an argument directly). In such cases, we could use <tt class="calibre22">let</tt> to create the <tt class="calibre22">ArrayList</tt>, populate it appropriately, and then return the <tt class="calibre22">ArrayList</tt> reference:</p><p id="filepos1302866" class="calibre23"></p><p class="calibre23"><span class="italic">Example 9-4. Populating an ArrayList “manually”</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(let [alist (ArrayList.)]<br class="calibre33"/>  (.add alist 1)<br class="calibre33"/>  (.add alist 2)<br class="calibre33"/>  (.add alist 3)<br class="calibre33"/>  alist)</tt></span></p><p class="calibre13">That works, but is as verbose as Java. <tt class="calibre22">doto</tt><a id="filepos1303266"></a> is a far better option here:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1303337"></a><a href="#filepos1305725"><span class="calibre32">281</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 9-5. Using doto to populate an ArrayList more concisely</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(doto (ArrayList.)<br class="calibre33"/>  (.add 1)<br class="calibre33"/>  (.add 2)<br class="calibre33"/>  (.add 3))</tt></span></p><p class="calibre13">This does exactly the same thing as <a href="#filepos1302866"><span class="calibre5">Example 9-4</span></a>, but is obviously far more concise. The utility of <tt class="calibre22">doto</tt> is even clearer when more extensive operations need to be performed on or with a single object. For example:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 9-6. Using doto to manipulate java.awt.Graphics2D context</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(doto graphics<br class="calibre33"/>  (.setBackground Color/white)<br class="calibre33"/>  (.setColor Color/black)<br class="calibre33"/>  (.scale 2 2)<br class="calibre33"/>  (.clearRect 0 0 500 500)<br class="calibre33"/>  (.drawRect 100 100 300 300))</tt></span></p><p class="calibre13">This applies a series of operations to the <tt class="calibre22">Graphics2D</tt> object, resulting in a black square drawn within a white square in the graphics context, which the <tt class="calibre22">doto</tt> form itself returns.</p><p class="calibre18">Clojure’s primary idiom is of working with values, rather than procedurally mutating fixed references. By providing you with a concise way to syntactically circumscribe any procedural initialization or other side-effecting operations, and implicitly returning the subject of those operations, which can be treated in later Clojure code as just another value, <tt class="calibre22">doto</tt> helps integrate interop with the host’s mutable, stateful objects into this idiom.</p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1305250"></a><a href="#filepos1302370"><span class="calibre32">280</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Note that Clojure’s vector has nothing to do with </span><span class="calibre10"><tt class="calibre22">java.util.Vector</tt></span><span class="calibre10">. See </span><a href="#filepos335797"><span class="calibre10"><span class="calibre5">Chapter 3</span></span></a><span class="calibre10"> for a full discussion of Clojure’s data structures.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1305725"></a><a href="#filepos1303337"><span class="calibre32">281</span></a><span class="calibre32">] </span></small></sup><span class="calibre10"><tt class="calibre22">ArrayList</tt></span><span class="calibre10"> is familiar and a reasonable basis for a simple </span><span class="calibre10"><tt class="calibre22">doto</tt></span><span class="calibre10"> example, but of course, you can populate it with a Clojure collection straight away, as in </span><span class="calibre10"><tt class="calibre22">(ArrayList. [1 2 3])</tt></span><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos1306175" class="calibre6"><span class="calibre4"><span class="bold">Exceptions and Error Handling</span></span></p><p id="filepos1306265" class="calibre18">Clojure reuses the JVM’s exception machinery <span class="italic">in toto</span>,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1306390"></a><a href="#filepos1320192"><span class="calibre32">282</span></a><span class="calibre32">]</span></small></sup> with its familiar <tt class="calibre22">try</tt>/<tt class="calibre22">catch</tt>/<tt class="calibre22">finally</tt>/<tt class="calibre22">throw</tt> idiom. Thus, the pattern of error handling in Clojure will be familiar to anyone who has ever worked with languages that share that idiom, including Java, Ruby, Python, and many others.</p><p class="calibre18">Given that, blocks of code in <a href="#filepos1306934"><span class="calibre5">Example 9-7</span></a> are equivalent with regard to their error handling:</p><p id="filepos1306934" class="calibre23"></p><p class="calibre23"><span class="italic">Example 9-7. Parsing a string as an integer in Java, Ruby, and Clojure, with error handling</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">// Java<br class="calibre33"/>public static Integer asInt (String s) {<br class="calibre33"/>    try {<br class="calibre33"/>        return Integer.parseInt(s);<br class="calibre33"/>    } catch (NumberFormatException e) {<br class="calibre33"/>        e.printStackTrace();<br class="calibre33"/>        return null;<br class="calibre33"/>    } finally {<br class="calibre33"/>        System.out.println("Attempted to parse as integer: " + s);<br class="calibre33"/>    }<br class="calibre33"/>}<br class="calibre33"/><br class="calibre33"/># Ruby<br class="calibre33"/>def as_int (s)<br class="calibre33"/>    begin<br class="calibre33"/>        return Integer(s)<br class="calibre33"/>    rescue Exception =&gt; e<br class="calibre33"/>        puts e.backtrace<br class="calibre33"/>    ensure<br class="calibre33"/>        puts "Attempted to parse as integer: " + s<br class="calibre33"/>    end<br class="calibre33"/>end<br class="calibre33"/><br class="calibre33"/>; Clojure<br class="calibre33"/>(defn as-int<br class="calibre33"/>  [s]<br class="calibre33"/>  (try<br class="calibre33"/>    (Integer/parseInt s)<br class="calibre33"/>    (catch NumberFormatException e<br class="calibre33"/>      (.printStackTrace e))<br class="calibre33"/>    (finally<br class="calibre33"/>      (println "Attempted to parse as integer: " s))))</tt></span></p><p class="calibre13">Parsing integers is a pretty mundane operation, but it makes it clear that the semantics and function of the <tt class="calibre22">try</tt>, <tt class="calibre22">catch</tt>, and <tt class="calibre22">finally</tt> forms in Clojure mirror those in Java and, for example, the corresponding ones in Ruby (<tt class="calibre22">begin</tt>, <tt class="calibre22">rescue</tt>, <tt class="calibre22">ensure</tt>):</p><p class="calibre23"><tt class="calibre22">try</tt></p><blockquote id="filepos1308606" class="calibre17">Delimits the scope of an exception-handling form. It may contain any number of <tt class="calibre22">catch</tt> forms and an optional <tt class="calibre22">finally</tt> form, all prefixed by any number of expressions that represent the code’s “happy path.”<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1308904"></a><a href="#filepos1320810"><span class="calibre32">283</span></a><span class="calibre32">]</span></small></sup> Assuming that happy path, the last expression in a <tt class="calibre22">try</tt> prior to any <tt class="calibre22">catch</tt> or <tt class="calibre22">finally</tt> forms determines the result of the <tt class="calibre22">try</tt> form.</blockquote><p class="calibre23"><tt class="calibre22">catch</tt></p><blockquote id="filepos1309224" class="calibre17">Specifies some code to jump to if an exception of the specified type (i.e., <tt class="calibre22">java.lang.Throwable</tt>, or any subclass thereof) is thrown in the course of the execution of the main body of the <tt class="calibre22">try</tt> form. The thrown exception is bound to the name provided after the exception type. The last expression in an activated <tt class="calibre22">catch</tt> form determines the result of the enclosing <tt class="calibre22">try</tt> form. Any number of <tt class="calibre22">catch</tt> forms may be specified.</blockquote><p class="calibre23"><tt class="calibre22">finally</tt></p><blockquote id="filepos1309780" class="calibre17">Specifies some code to execute just prior to the flow of control exiting the <tt class="calibre22">try</tt> form, regardless of the nature of that exit (that is, even if some code in the body of the <tt class="calibre22">try</tt> form threw an uncaught exception, the expressions in the <tt class="calibre22">finally</tt> form will be executed). The <tt class="calibre22">finally</tt> form does not influence the result of the <tt class="calibre22">try</tt> form at all; thus, it is only ever useful if some side-effecting action(s) need to be taken after the <tt class="calibre22">try</tt> is completed otherwise. The only wrinkle to this is that exceptions thrown from <tt class="calibre22">finally</tt> bodies will replace any exception thrown from the body of the corresponding <tt class="calibre22">try</tt> form (as is true in Java).</blockquote><p class="calibre18">These are the foundations of the JVM’s (and therefore Clojure’s) general-purpose error-handling capabilities.</p><p class="calibre18"><span class="bold">throwing exceptions</span>. <a id="filepos1310727"></a>Clojure code can signal an exception using its <tt class="calibre22">throw</tt> form, which is exactly analogous to Java’s <tt class="calibre22">throw</tt> and <tt class="calibre22">raise</tt> in Ruby and Python:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(throw (IllegalStateException. "I don't know what to do!"))<br class="calibre33"/>;= #&lt;IllegalStateException java.lang.IllegalStateException: I don't know what to do!&gt;</tt></span></blockquote><p class="calibre23">While you can syntactically <tt class="calibre22">raise</tt> any class or an instance of any class in Python, and you can even <tt class="calibre22">raise</tt> strings in Ruby, Clojure’s <tt class="calibre22">throw</tt> must receive an instance of a class that extends <tt class="calibre22">java.lang.Throwable</tt> or some subclass of it:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(throw "foo")<br class="calibre33"/>;= #&lt;ClassCastException java.lang.ClassCastException:<br class="calibre33"/>;=   java.lang.String cannot be cast to java.lang.Throwable&gt;</tt></span></blockquote><p id="filepos1311696" class="calibre23"><span class="bold">Reusing existing exception types</span>. <a id="filepos1311766"></a>One idiom that is often seen in Java codebases, but very, very rarely in Clojure code, is the definition of new exception types. Idiomatic Clojure code, when it does throw an exception, throws an exception of a standard type. There are over 350 exception types in the Java standard library; though it <span class="italic">can</span> happen, it is rare to come across a scenario where one of those exception types is not semantically sufficient to describe the error condition at hand. It’s probably fair to say that 90 percent of all use cases are reasonably satisfied by one of the “core” exception types:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">java.lang.IllegalArgumentException</tt></blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">java.lang.UnsupportedOperationException</tt></blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">java.lang.IllegalStateException</tt></blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">java.io.IOException</tt></blockquote></li></ul><p class="calibre18">This is the general rule, but there are cases where a custom exception type is necessary. If you find yourself in such a situation, you may find the example custom exception type defined in <a href="#filepos1375217"><span class="calibre5">“Defining a custom exception type”</span></a> to be helpful.</p><p id="filepos1313278" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Escaping Checked Exceptions</span></span></span></p><p id="filepos1313395" class="calibre18">While Clojure is hosted on the JVM, it does not inherit Java’s <span class="italic">checked exceptions</span><a id="filepos1313513"></a>. These are types of exceptions that may be declared to be thrown by Java methods; the Java compiler requires callers of such methods to either catch and handle thrown checked exceptions, or to declare that they throw those exceptions themselves. Checked exceptions have long been a controversial topic in the Java ecosystem,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1313880"></a><a href="#filepos1321780"><span class="calibre32">284</span></a><span class="calibre32">]</span></small></sup> with the rough consensus being that checked exceptions generally cause Java codebases to be more verbose and more difficult to maintain.</p><p class="calibre18">Clojure is thankfully not subject to the constraints of checked exceptions declared to be thrown by Java methods called from Clojure code, since checked exceptions are a fabrication of the Java compiler, and simply don’t exist in the JVM at runtime.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1314430"></a><a href="#filepos1322181"><span class="calibre32">285</span></a><span class="calibre32">]</span></small></sup> So, we can (for example) create temporary files using a method that specifies that it can throw <tt class="calibre22">java.io.IOException</tt>, a checked exception:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(File/createTempFile "clojureTempFile" ".txt")</tt></span></blockquote><p class="calibre23">…outside the scope of any <tt class="calibre22">try</tt>/<tt class="calibre22">catch</tt> expression, and without any corollary to Java’s <tt class="calibre22">throws</tt> declaration to indicate that that code may throw an <tt class="calibre22">IOException</tt>. This obviously allows Clojure to be more concise when calling methods with checked exception declarations compared to the equivalent Java code.</p><p id="filepos1315176" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">with-open, finally’s Lament</span></span></span></p><p id="filepos1315295" class="calibre18">The prototypical, most common usage of <tt class="calibre22">finally</tt> is in ensuring proper resource management. For example, here’s a static utility method in Java for appending some text to a file:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 9-8. Appending to a file in Java with manual resource management via finally</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">public static void appendTo (File f, String text) throws IOException {<br class="calibre33"/>    Writer w = null;<br class="calibre33"/>    try {<br class="calibre33"/>        w = new OutputStreamWriter(new FileOutputStream(f, true), "UTF-8");<br class="calibre33"/>        w.write(text);<br class="calibre33"/>        w.flush();<br class="calibre33"/>    } finally {<br class="calibre33"/>        if (w != null) w.close();<br class="calibre33"/>    }<br class="calibre33"/>}</tt></span></p><p class="calibre13">Notice the <tt class="calibre22">finally</tt> block where we conditionally close the <tt class="calibre22">Writer</tt> we open in the preceding <tt class="calibre22">try</tt> block. This pattern (or, the too-easy misapplication of it) is consistently the source of bugs in many programs that work with file, socket, database, and other resources that need explicit management. Because of this, Java 7 introduced a <tt class="calibre22">try-with-resources</tt><a id="filepos1316572"></a> statement<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1316624"></a><a href="#filepos1322426"><span class="calibre32">286</span></a><span class="calibre32">]</span></small></sup> that automatically closes, for example, file handles upon control exiting its scope, very similar to Python’s <tt class="calibre22">with</tt>:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 9-9. Appending to a file in Java 7 using try-with-resources</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">public static void appendTo (File f, String text) throws IOException {<br class="calibre33"/>  try (Writer w = new OutputStreamWriter(new FileOutputStream(f, true), "UTF-8")) {<br class="calibre33"/>      w.write(text);<br class="calibre33"/>      w.flush();<br class="calibre33"/>  }<br class="calibre33"/>}</tt></span></p><p class="calibre13">Clojure provides an equivalent <tt class="calibre22">with-open</tt> form that ensures that resources are closed prior to control exiting its scope.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1317518"></a><a href="#filepos1322924"><span class="calibre32">287</span></a><span class="calibre32">]</span></small></sup> Here is an idiomatic translation of the <tt class="calibre22">appendTo</tt><a id="filepos1317671"></a> method in Clojure, using the <tt class="calibre22">with-open</tt> form to ensure that the <tt class="calibre22">Writer</tt> is closed properly:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 9-10. Appending to a file in Clojure with automatic resource management via with-open</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(require '[clojure.java.io :as io])<br class="calibre33"/><br class="calibre33"/>(defn append-to<br class="calibre33"/>  [f text]<br class="calibre33"/>  (with-open [w (io/writer f :append true)] </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>    (doto w (.write text) .flush)))</tt></span></p><p class="calibre23"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">We could have created an <tt class="calibre22">OutputStreamWriter</tt> and a <tt class="calibre22">FileInputStream</tt> manually ourselves, but the <tt class="calibre22">writer</tt> helper function is too convenient to bother.</blockquote><p class="calibre13">You can optionally bind <a id="filepos1318707"></a>multiple resources within a <tt class="calibre22">with-open</tt> form,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1318801"></a><a href="#filepos1323607"><span class="calibre32">288</span></a><span class="calibre32">]</span></small></sup> each of which will be closed before control exits <tt class="calibre22">with-open</tt>. Here’s a naïve implementation of a copy function that demonstrates this:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 9-11. Appending to a file in Clojure with automatic resource management via with-open</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(defn copy-files<br class="calibre33"/>  [from to]<br class="calibre33"/>  (with-open [in (FileInputStream. from)<br class="calibre33"/>              out (FileOutputStream. to)]<br class="calibre33"/>    (loop [buf (make-array Byte/TYPE 1024)]<br class="calibre33"/>      (let [len (.read in buf)]<br class="calibre33"/>        (when (pos? len)<br class="calibre33"/>          (.write out buf 0 len)<br class="calibre33"/>          (recur buf))))))</tt></span></p><p class="calibre13">This is a fine example of <tt class="calibre22">with-open</tt>, but a far better option would be to use the <tt class="calibre22">copy</tt> function (and the rest of the I/O utilities) in the <tt class="calibre22">clojure.java.io</tt> namespace<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1319942"></a><a href="#filepos1324344"><span class="calibre32">289</span></a><span class="calibre32">]</span></small></sup> in preference to naïve implementations like this.<a id="filepos1320088"></a></p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1320192"></a><a href="#filepos1306390"><span class="calibre32">282</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">There </span><span class="calibre10"><span class="italic">are</span></span><span class="calibre10"> a number of Clojure libraries that provide error-handling extensions that go far beyond what we describe here; in particular, Slingshot provides far more sophisticated modeling and handling of error states: </span><a href="https://github.com/scgilardi/slingshot"><span class="calibre10"><span class="calibre5">https://github.com/scgilardi/slingshot</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1320810"></a><a href="#filepos1308904"><span class="calibre32">283</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Worth pointing out is that Clojure’s </span><span class="calibre10"><tt class="calibre22">catch</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">finally</tt></span><span class="calibre10"> forms must be included </span><span class="calibre10"><span class="italic">within</span></span><span class="calibre10"> a </span><span class="calibre10"><tt class="calibre22">try</tt></span><span class="calibre10">; this makes explicit the semantic relationship between </span><span class="calibre10"><tt class="calibre22">try</tt></span><span class="calibre10"> (or, e.g., </span><span class="calibre10"><tt class="calibre22">begin</tt></span><span class="calibre10"> in Ruby) and </span><span class="calibre10"><tt class="calibre22">catch</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">finally</tt></span><span class="calibre10">, the latter of which are syntactically treated as “top level” peers to </span><span class="calibre10"><tt class="calibre22">try</tt></span><span class="calibre10"> in nearly every other language.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1321780"></a><a href="#filepos1313880"><span class="calibre32">284</span></a><span class="calibre32">] </span></small></sup><a href="http://www.mindview.net/Etc/Discussions/CheckedExceptions"><span class="calibre10"><span class="calibre5">http://www.mindview.net/Etc/Discussions/CheckedExceptions</span></span></a><span class="calibre10"> is a good exploration of the topic.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1322181"></a><a href="#filepos1314430"><span class="calibre32">285</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Incidentally, much like Java’s generics thanks to erasure.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1322426"></a><a href="#filepos1316624"><span class="calibre32">286</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="http://download.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html"><span class="calibre10"><span class="calibre5">http://download.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html</span></span></a><span class="calibre10"> for a primer if you’re not yet familiar with it.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1322924"></a><a href="#filepos1317518"><span class="calibre32">287</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">We can’t pass up the opportunity to mention that </span><span class="calibre10"><tt class="calibre22">with-open</tt></span><span class="calibre10"> is implemented as a nine-line Clojure macro that you could easily write on your own—quite the contrast to the Godot-esque experience that is waiting for improvements delivered by maintainers of languages that lack macros. You can read about macros and what they enable in </span><a href="#filepos831506"><span class="calibre10"><span class="calibre5">Chapter 5</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1323607"></a><a href="#filepos1318801"><span class="calibre32">288</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Any object whose class provides a nullary </span><span class="calibre10"><tt class="calibre22">close</tt></span><span class="calibre10"> method will work here. This matches the </span><span class="calibre10"><tt class="calibre22">close</tt></span><span class="calibre10"> method defined by the </span><span class="calibre10"><tt class="calibre22">java.lang.Closeable</tt></span><span class="calibre10"> interface, but because Clojure is a dynamic language, the resources you use in </span><span class="calibre10"><tt class="calibre22">with-open</tt></span><span class="calibre10"> do not need to actually implement that interface. This is called “duck typing” in many other dynamic languages.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1324344"></a><a href="#filepos1319942"><span class="calibre32">289</span></a><span class="calibre32">] </span></small></sup><a href="http://clojure.github.com/clojure/clojure.java.io-api.html"><span class="calibre10"><span class="calibre5">http://clojure.github.com/clojure/clojure.java.io-api.html</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos1324665" class="calibre6"><span class="calibre4"><span class="bold">Type Hinting for Performance</span></span></p><p id="filepos1324754" class="calibre18">You may have noticed some code examples that use syntax referring to Java class names, such as <tt class="calibre22">^String</tt> here:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn length-of<br class="calibre33"/>  [^String text]<br class="calibre33"/>  (.length text))</tt></span></blockquote><p class="calibre23">The <tt class="calibre22">^ClassName</tt> syntax defines a <span class="italic">type hint</span>, an explicit indication to the Clojure compiler of the object type of an expression, var value, or a named binding.</p><p class="calibre18">The typical type hint syntax is expanded by the Clojure reader into metadata on the value following the hint. So, the <tt class="calibre22">^String text</tt> hinted binding form is expanded by the reader into the equivalent expression <tt class="calibre22">^{:tag String} text</tt>, which evaluates to the symbol <tt class="calibre22">text</tt> with the metadata <tt class="calibre22">{:tag String}</tt>. Clojure internally uses the term “tag” for type.</p><p class="calibre18">These hints are used by the compiler only to avoid emitting reflective interop calls; otherwise, they are unnecessary. So, if our code does not include an interop call, there is no need to include a type hint:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn silly-function<br class="calibre33"/>  [v]<br class="calibre33"/>  (nil? v))</tt></span></blockquote><p class="calibre23">Any hint you provide for <tt class="calibre22">v</tt> here would simply be left unused.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Type hints on function arguments or returns are </span><span class="calibre10"><span class="italic">not</span></span><span class="calibre10"> signature declarations: they do not affect the types that a function can accept or return. Their only effect is to allow Clojure to call Java methods and access Java fields using compile-time generated code—rather than the much-slower option of using reflection at runtime to search for methods or fields matching the interop form in question. Thus, if a hint doesn’t inform an interop operation, they are effectively no-ops. For example, this function hints its argument as being a </span><span class="calibre10"><tt class="calibre22">java.util.List</tt></span><span class="calibre10">, but it can accept an argument of any type:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(defn accepts-anything<br class="calibre33"/>  [^java.util.List x]<br class="calibre33"/>  x)<br class="calibre33"/>;= #'user/accepts-anything<br class="calibre33"/>(accepts-anything (java.util.ArrayList.))<br class="calibre33"/>;= #&lt;ArrayList []&gt;<br class="calibre33"/>(accepts-anything 5)<br class="calibre33"/>;= 5<br class="calibre33"/>(accepts-anything false)<br class="calibre33"/>;= false</tt></span></blockquote><blockquote class="calibre35"><span class="calibre10">This is in contrast to signature </span><span class="calibre10"><span class="italic">declarations</span></span><a id="filepos1327566"></a><span class="calibre10">, which Clojure does provide, but </span><span class="calibre10"><span class="italic">only</span></span><span class="calibre10"> for primitive arguments and return types. We cover primitive type declarations in </span><a href="#filepos1591810"><span class="calibre10"><span class="calibre5">Declare Functions to Take and Return Primitives</span></span></a><span class="calibre10">.</span></blockquote><p class="calibre25">Avoiding reflective interop calls is key to ensuring maximal performance in code that is CPU-bound. In practice, little type-hinting is required in order to avoid reflection entirely, since the Clojure compiler provides for type inference based on the known types of literals, constructor calls, and method return types.</p><p class="calibre18">To illustrate this, let’s add a type hint to some code in order to optimize it. Here’s a function that returns a provided <tt class="calibre22">String</tt>, capitalized:</p><p id="filepos1328466" class="calibre23"></p><p class="calibre23"><span class="italic">Example 9-12. An unhinted capitalization function</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(defn capitalize<br class="calibre33"/>  [s]<br class="calibre33"/>  (-&gt; s<br class="calibre33"/>    (.charAt 0)<br class="calibre33"/>    Character/toUpperCase<br class="calibre33"/>    (str (.substring s 1))))</tt></span></p><p class="calibre13">This implementation works, but we’d probably like to speed it up a little bit:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 9-13. Timing the capitalization of "foo" 100,000 times</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(time (doseq [s (repeat 100000 "foo")]<br class="calibre33"/>        (capitalize s)))<br class="calibre33"/>; "Elapsed time: 5040.218 msecs"</tt></span></p><p class="calibre13">In this sort of case, where you suspect that type hinting may yield some benefits, turning on reflection warnings in the Clojure compiler is helpful; doing so indicates where reflective calls are being emitted:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1329530"></a><a href="#filepos1335860"><span class="calibre32">290</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 9-14. Getting reflection warnings for the capitalize function from </span><a href="#filepos1328466"><span class="italic"><span class="calibre5">Example 9-12</span></span></a></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(set! *warn-on-reflection* true)<br class="calibre33"/>;= true<br class="calibre33"/>(defn capitalize<br class="calibre33"/>  [s]<br class="calibre33"/>  (-&gt; s<br class="calibre33"/>    (.charAt 0)<br class="calibre33"/>    Character/toUpperCase<br class="calibre33"/>    (str (.substring s 1))))<br class="calibre33"/>; Reflection warning, NO_SOURCE_PATH:27 - call to charAt can't be resolved.<br class="calibre33"/>; Reflection warning, NO_SOURCE_PATH:29 - call to toUpperCase can't be resolved.<br class="calibre33"/>; Reflection warning, NO_SOURCE_PATH:29 - call to substring can't be resolved.<br class="calibre33"/>;= #'user/capitalize</tt></span></p><p class="calibre13">We see here that three interop calls are being emitted reflectively. We can address this by adding a single type hint (notice the <tt class="calibre22">^String</tt> addition):</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn fast-capitalize<br class="calibre33"/>  [^String s]<br class="calibre33"/>  (-&gt; s<br class="calibre33"/>    (.charAt 0)<br class="calibre33"/>    Character/toUpperCase<br class="calibre33"/>    (str (.substring s 1))))</tt></span></blockquote><p class="calibre23">This will eliminate all three reflective calls. How can just one type hint impact all three reflective calls? This is where the Clojure compiler’s type inference comes into play:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">The let-bound name <tt class="calibre22">s</tt> is explicitly type-hinted to be a String. Therefore…</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">…the <tt class="calibre22">.charAt</tt> call can be compiled down to a direct call to <tt class="calibre22">String.charAt</tt>. The compiler knows that this method returns a <tt class="calibre22">char</tt>, so…</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">…it can properly select the <tt class="calibre22">char</tt> variant of <tt class="calibre22">Character.toUpperCase</tt> (rather than its <tt class="calibre22">int</tt> override).</blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17">Finally, the compiler again refers back to the explicit <tt class="calibre22">String</tt> type hint on <tt class="calibre22">s</tt> to inform its selection of <tt class="calibre22">String.substring</tt> when compiling the <tt class="calibre22">.substring</tt> interop method call.</blockquote></li></ol><p class="calibre18">How does this impact the performance of our revised <tt class="calibre22">fast-capitalize</tt> function? Let’s see:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(time (doseq [s (repeat 100000 "foo")]<br class="calibre33"/>        (fast-capitalize s)))<br class="calibre33"/>; "Elapsed time: 154.889 msecs"</tt></span></blockquote><p class="calibre23">From 5 seconds down to .155 seconds. Not bad.</p><p class="calibre18">Type hints can be added to any expression. Consider this function, which has a reflective call to <tt class="calibre22">String.split</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn split-name<br class="calibre33"/>  [user]<br class="calibre33"/>  (zipmap [:first :last]<br class="calibre33"/>    (.split (:name user) " ")))<br class="calibre33"/>;= #'user/split-name<br class="calibre33"/>; Reflection warning, NO_SOURCE_PATH:3 - call to split can't be resolved.<br class="calibre33"/>(split-name {:name "Chas Emerick"})<br class="calibre33"/>;= {:last "Emerick", :first "Chas"}</tt></span></blockquote><p class="calibre23">If we could only hint let-bound names, we’d have to add a <tt class="calibre22">let</tt> form just to be able to hint a name we give the intermediate <tt class="calibre22">(:name user)</tt> value:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn split-name<br class="calibre33"/>  [user]<br class="calibre33"/>  (let [^String full-name (:name user)]<br class="calibre33"/>    (zipmap [:first :last]<br class="calibre33"/>      (.split full-name " "))))<br class="calibre33"/>;= #'user/split-name</tt></span></blockquote><p class="calibre23">No reflection, but that’s a lot of work. Thankfully, we can hint the <tt class="calibre22">(:name user)</tt> expression:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn split-name<br class="calibre33"/>  [user]<br class="calibre33"/>  (zipmap [:first :last]<br class="calibre33"/>    (.split ^String (:name user) " ")))<br class="calibre33"/>;= #'user/split-name</tt></span></blockquote><p class="calibre23">No reflection, no added verbosity. Similarly, we can hint the return value of functions, so that all of their callers do not need to hint interop calls on their results:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn file-extension<br class="calibre33"/>  [^java.io.File f]<br class="calibre33"/>  (-&gt; (re-seq #"\.(.+)" (.getName f))<br class="calibre33"/>    first<br class="calibre33"/>    second))</tt></span></blockquote><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(.toUpperCase (file-extension (java.io.File. "image.png")))<br class="calibre33"/>; Reflection warning, NO_SOURCE_PATH:1 - reference to field toUpperCase can't be <br class="calibre33"/>  resolved.<br class="calibre33"/>;= "PNG"</tt></span></blockquote><p class="calibre23">Return value hints are added on functions’ <span class="italic">argument vectors</span><a id="filepos1334794"></a>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn file-extension<br class="calibre33"/>  ^String [^java.io.File f]<br class="calibre33"/>  (-&gt; (re-seq #"\.(.+)" (.getName f))<br class="calibre33"/>    first<br class="calibre33"/>    second))</tt></span></blockquote><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(.toUpperCase (file-extension (java.io.File. "image.png")))<br class="calibre33"/>;= "PNG"</tt></span></blockquote><p class="calibre23">Finally, we can provide type metadata <a id="filepos1335277"></a>on var names to indicate the type of value they contain:<a id="filepos1335340"></a></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def a "image.png")<br class="calibre33"/>;= #'user/a<br class="calibre33"/>(java.io.File. a)<br class="calibre33"/>; Reflection warning, NO_SOURCE_PATH:1 - call to java.io.File ctor can't be resolved.<br class="calibre33"/>;= #&lt;File image.png&gt;<br class="calibre33"/>(def ^String a "image.png")<br class="calibre33"/>;= #'user/a<br class="calibre33"/>(java.io.File. a)<br class="calibre33"/>;= #&lt;File image.png&gt;</tt></span></blockquote><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1335860"></a><a href="#filepos1329530"><span class="calibre32">290</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">The technique shown here is useful at the REPL, but you can get the same warnings from your build process if you want, with the benefit of actual line numbers. Refer to </span><a href="#filepos1250762"><span class="calibre10"><span class="calibre5">“AOT compilation as a sanity check”</span></span></a><span class="calibre10"> for details.</span></p><div class="mbppagebreak"></div><p id="filepos1336318" class="calibre6"><span class="calibre4"><span class="bold">Arrays</span></span></p><p id="filepos1336385" class="calibre18">Prior to the introduction of the <tt class="calibre22">java.util</tt> Collections API in Java 1.2, arrays<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1336535"></a><a href="#filepos1342948"><span class="calibre32">291</span></a><span class="calibre32">]</span></small></sup> were one of the few ways you could hold large batches of objects. Now, arrays are rarely used to hold objects, but they remain an important tool when working with numeric and other primitive datasets. In any case, Clojure can handle Java arrays with aplomb, though you’ll generally find that array-handling is one of the rare domains where Clojure is more verbose than Java out of the box given the latter’s purpose-built syntax.</p><p class="calibre3"></p><p class="calibre1"><span class="italic">Table 9-2. Comparison of array operations</span><a id="filepos1337208"></a></p><table border="1" valign="top" class="calibre40"><tr border="1" valign="top" class="calibre27"><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Operation </span></span></span></th><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Clojure expression </span></span></span></th><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Java equivalent </span></span></span></th></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Create an array from a collection </span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">(into-array ["a" "b" "c"])</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">(String[])coll.toArray(new String[list.size()]);</tt></span><span class="calibre21">
</span></p></td></tr><tr border="1" valign="top" class="calibre43"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Create an empty array </span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">(make-array Integer 10 100)</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">new Integer[10][100]</tt></span><span class="calibre21">
</span></p></td></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Create an empty array of primitive  </span><span class="calibre21"><tt class="calibre22">long</tt></span><span class="calibre21">s</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">(long-array 10)</tt></span><span class="calibre21">
</span><span class="calibre21"><tt class="calibre22">(make-array Long/TYPE 10)</tt></span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">new long[10]</tt></span><span class="calibre21">
</span></p></td></tr><tr border="1" valign="top" class="calibre43"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Access an array value </span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">(aget some-array 4)</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">some_array[4]</tt></span><span class="calibre21">
</span></p></td></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Set an array value <sup class="calibre44"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1340693"></a><a href="#filepos1341594"><span class="calibre32">a</span></a><span class="calibre32">]</span></small></sup></span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">(aset some-array 4 "foo")</tt></span><span class="calibre21">
</span><span class="calibre21"><tt class="calibre22">(aset ^ints int-array 4 5)</tt></span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">some_array[4] = 5.6</tt></span><span class="calibre21">
</span></p></td></tr><tr border="1" valign="top" class="calibre27"><td colspan="3" border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre45"><span class="calibre21"> </span></p><p class="calibre42"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1341594"></a><a href="#filepos1340693"><span class="calibre32">a</span></a><span class="calibre32">] </span></small></sup><span class="calibre21">Clojure’s expression-hinting mechanism comes into play when setting values in arrays of primitives; see </span><a href="#filepos1605156"><span class="calibre21"><span class="calibre5">Use Primitive Arrays Judiciously</span></span></a><span class="calibre21"> for details.</span></p></td></tr></table><p class="calibre23">If your Clojure code is simply consuming arrays of objects, probably as returned by existing Java APIs, then there is no need to explicitly convert them to lists or other collections. Arrays are supported by Clojure’s sequence abstraction,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1342286"></a><a href="#filepos1343394"><span class="calibre32">292</span></a><span class="calibre32">]</span></small></sup> so you can use them just like any other seqable collection:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(map #(Character/toUpperCase %) (.toCharArray "Clojure"))<br class="calibre33"/>;= (\C \L \O \J \U \R \E)</tt></span></blockquote><p class="calibre23">However, Clojure does provide some special support for primitive arrays. We cover that topic separately in <a href="#filepos1605156"><span class="calibre5">Use Primitive Arrays Judiciously</span></a>.</p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1342948"></a><a href="#filepos1336535"><span class="calibre32">291</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Don’t confuse Clojure/Java arrays with Ruby’s </span><span class="calibre10"><tt class="calibre22">Array</tt></span><span class="calibre10">. Ruby’s </span><span class="calibre10"><tt class="calibre22">Array</tt></span><span class="calibre10"> is similar to Java’s </span><span class="calibre10"><tt class="calibre22">Vector</tt></span><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1343394"></a><a href="#filepos1342286"><span class="calibre32">292</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Specifically, the </span><span class="calibre10"><tt class="calibre22">seq</tt></span><span class="calibre10"> function that underlies all of Clojure’s various sequence operations will properly return a seq when provided an array.</span></p><div class="mbppagebreak"></div><p id="filepos1343728" class="calibre6"><span class="calibre4"><span class="bold">Defining Classes and Implementing Interfaces</span></span></p><p id="filepos1343833" class="calibre18">Being able to call Java methods and instantiate classes is a good start, but you often need to define classes as well, implementing interfaces and sometimes extending an existing class. Clojure provides an array of class definition facilities, each of which offers a mix of different capabilities suited for different use cases.</p><p class="calibre3"></p><p class="calibre1"><span class="italic">Table 9-3. Comparison of key features of Clojure forms that define Java classes<sup class="calibre30"><small class="calibre31"><span class="calibre32"><span class="italic">[</span></span><a id="filepos1344409"></a><a href="#filepos1351379"><span class="calibre32"><span class="italic">293</span></span></a><span class="calibre32"><span class="italic">]</span></span></small></sup></span><a id="filepos1344522"></a></p><table border="1" valign="top" class="calibre40"><tr border="1" valign="top" class="calibre27"><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7">   </span></span></span></th><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> </span></span></span><span class="calibre21"><tt class="calibre22"><span class="bold"><span class="calibre7">proxy </span></span></tt></span></th><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> </span></span></span><span class="calibre21"><tt class="calibre22"><span class="bold"><span class="calibre7">gen-class </span></span></tt></span></th><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> </span></span></span><span class="calibre21"><tt class="calibre22"><span class="bold"><span class="calibre7">reify </span></span></tt></span></th><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> </span></span></span><span class="calibre21"><tt class="calibre22"><span class="bold"><span class="calibre7">deftype </span></span></tt></span></th><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> </span></span></span><span class="calibre21"><tt class="calibre22"><span class="bold"><span class="calibre7">defrecord </span></span></tt></span></th></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Returns an instance of an anonymous class? </span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><span class="bold">√</span></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><span class="bold">√</span></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span></p></td></tr><a id="filepos1346596"></a><tr border="1" valign="top" class="calibre43"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Defines a named class? </span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><span class="bold">√</span></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><span class="bold">√</span></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><span class="bold">√</span></span><span class="calibre21">
</span></p></td></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Can extend an existing base class? </span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><span class="bold">√</span></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><span class="bold">√</span></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span></p></td></tr><tr border="1" valign="top" class="calibre43"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Can define new fields? </span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><span class="bold">√</span></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><span class="bold">√</span></span><span class="calibre21">
</span></p></td></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Provides default implementations of  </span><span class="calibre21"><tt class="calibre22">Object.equals</tt></span><span class="calibre21">, </span><span class="calibre21"><tt class="calibre22">Object.hashcode</tt></span><span class="calibre21">, and various Clojure interfaces?</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><span class="bold">√</span></span><span class="calibre21">
</span></p></td></tr><tr border="1" valign="top" class="calibre27"><td colspan="6" border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre45"><span class="calibre21"> </span></p><p class="calibre42"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1351379"></a><a href="#filepos1344409"><span class="calibre32">293</span></a><span class="calibre32">] </span></small></sup><span class="calibre21">If you know you need to define a new type in Clojure, but you’re not sure which type-definition form to use, refer to the flowchart designed specifically for this purpose at </span><a href="#filepos2042853"><span class="calibre21"><span class="calibre5">Chapter 18</span></span></a><span class="calibre21">.</span></p></td></tr></table><p class="calibre23">All of these forms can be used to define classes and implement interfaces. Some of these forms—<tt class="calibre22">deftype</tt>, <tt class="calibre22">defrecord</tt>, and <tt class="calibre22">reify</tt>—also serve unique roles within Clojure that are unrelated to interoperability with Java classes and interfaces. Thus, we discuss them separately in <a href="#filepos945443"><span class="calibre5">Chapter 6</span></a>.</p><p class="calibre18">On the other hand, the remaining two—<tt class="calibre22">proxy</tt> and <tt class="calibre22">gen-class</tt>—exist solely to support these usages in interop scenarios; we’ll cover them here.</p><p id="filepos1352402" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Instances of Anonymous Classes: proxy</span></span></span></p><p class="calibre18"><tt class="calibre22">proxy</tt><a id="filepos1352571"></a> produces an instance of an anonymous class that implements any number of Java interfaces and/or a single concrete base class.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1352739"></a><a href="#filepos1403090"><span class="calibre32">294</span></a><span class="calibre32">]</span></small></sup> This anonymous class is generated only once, at compile time, based on the class and interface(s) specified. After that, the cost of each runtime <tt class="calibre22">proxy</tt> invocation is only that of a single call of the constructor of the generated class. This makes <tt class="calibre22">proxy</tt> the equivalent of defining and instantiating an anonymous inner class in Java.</p><p class="calibre18">To demonstrate the usage of <tt class="calibre22">proxy</tt>, let’s see how we would use it to implement a basic least recently used (LRU) cache<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1353379"></a><a href="#filepos1403639"><span class="calibre32">295</span></a><span class="calibre32">]</span></small></sup> with some building blocks available in the Java standard library.</p><p class="calibre18">The JDK provides a hash map implementation, <tt class="calibre22">java.util.LinkedHashMap</tt>, which provides the basic hooks for implementing a simple LRU cache: it can maintain entry iteration order based on last access, and it defines a method, <tt class="calibre22">removeEldestEntry(Map.Entry&lt;K,V&gt;)</tt>, which a subclass can override in order to inform the <tt class="calibre22">LinkedHashMap</tt> whether the oldest entry (based either on insertion or access order) should be removed.</p><p class="calibre18">Doing this with <tt class="calibre22">proxy</tt> allows us to exhibit all of its characteristics:</p><p id="filepos1354131" class="calibre23"></p><p class="calibre23"><span class="italic">Example 9-15. Implementing a simple LRU cache using LinkedHashMap and proxy</span><a id="filepos1354275"></a></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(defn lru-cache                                       </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  [max-size]                                          </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  (proxy [java.util.LinkedHashMap] [16 0.75 true]     </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>    (removeEldestEntry [entry]                        </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>      (&gt; (count this) max-size))))                    </tt></span><a></a><img src="images/00001.jpg" class="calibre36"/></p><p class="calibre101"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">First, we set up a factory function so we can obtain instances of this cache as needed.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">proxy</tt>’s method implementations form closures, so any values bound in the scope of a <tt class="calibre22">proxy</tt> usage are usable within those implementations. Here, we accept a <tt class="calibre22">max-size</tt> argument to the factory function, which our <tt class="calibre22">removeEldestEntry</tt> method implementation closes over. We’ll compare that value to our map’s size as our entry expiration criterion.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">proxy</tt> requires two vectors as its first two arguments:</blockquote><ol class="calibre103"><li value="1" class="calibre16"><blockquote class="calibre100"><blockquote class="calibre37">The names of its superclass and/or implemented interfaces; note that the superclass must come first.</blockquote></blockquote></li><li value="2" class="calibre16"><blockquote class="calibre100"><blockquote class="calibre37">The arguments provided to its superclass’s constructor. In this example, we’re providing <tt class="calibre22">LinkedHashMap</tt>’s default values for initial map size (<tt class="calibre22">16</tt>) and load factor (<tt class="calibre22">0.75</tt>), with a Boolean <tt class="calibre22">true</tt> that indicates that the underlying map should maintain access order rather than its default of insertion order. This is what turns the <tt class="calibre22">LinkedHashMap</tt> into a working LRU cache. Note that we could put any expressions into the vector of constructors, not just literals.</blockquote></blockquote></li></ol><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">proxy</tt> does not require you to provide a first <tt class="calibre22">this</tt> argument in its method implementations (unlike Clojure’s other class-definition forms, <tt class="calibre22">reify</tt>, <tt class="calibre22">defrecord</tt>, and <tt class="calibre22">deftype</tt>). Rather, <tt class="calibre22">this</tt> is implicitly bound to the <tt class="calibre22">proxy</tt> instance…</blockquote><p class="calibre23"><img src="images/00001.jpg" class="calibre36"/></p><blockquote class="calibre37">…which we use to check the map’s size. If it’s grown larger than the closed-over <tt class="calibre22">max-size</tt> value, then we return <tt class="calibre22">true</tt>, indicating that the provided least recently used entry should be evicted from the cache. Of course, any criterion can be used to implement a cache eviction policy, but map size is a reasonable and common baseline.</blockquote><p class="calibre18">Method implementations can be provided to <tt class="calibre22">proxy</tt> in any order.</p><p class="calibre18">Let’s use our simple LRU cache at the REPL, and make sure it’s working as we expect:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def cache (doto (lru-cache 5)                                    </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>             (.put :a :b)))<br class="calibre33"/>;= #'user/cache<br class="calibre33"/>cache<br class="calibre33"/>;= #&lt;LinkedHashMap$0 {:a=:b}&gt;<br class="calibre33"/>(doseq [[k v] (partition 2 (range 500))]                          </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  (get cache :a)                                                  </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  (.put cache k v))                                               </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= nil<br class="calibre33"/>cache<br class="calibre33"/>;= #&lt;LinkedHashMap$0 {492=493, 494=495, 496=497, :a=:b, 498=499}&gt; </tt></span><a></a><img src="images/00001.jpg" class="calibre36"/></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">First, we create a new cache using our <tt class="calibre22">lru-cache</tt> function defined in <a href="#filepos1354131"><span class="calibre5">Example 9-15</span></a>, adding one entry, a mapping between <tt class="calibre22">:a</tt> and <tt class="calibre22">:b</tt>.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1360031"></a><a href="#filepos1404088"><span class="calibre32">296</span></a><span class="calibre32">]</span></small></sup> We’ll access this entry frequently, ensuring that it’s never expired from the cache as the least recently used.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">We assemble a seq of 250 two-element lists using <tt class="calibre22">partition</tt>, each containing monotonically increasing integers as provided by <tt class="calibre22">range</tt>.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1360577"></a><a href="#filepos1404539"><span class="calibre32">297</span></a><span class="calibre32">]</span></small></sup> Each of these two-element lists is destructured<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1360755"></a><a href="#filepos1404948"><span class="calibre32">298</span></a><span class="calibre32">]</span></small></sup> into “key” and “value” bindings with the <tt class="calibre22">[k v]</tt> destructuring form.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">Before adding each new entry to our cache, we access the entry corresponding to our <tt class="calibre22">:a</tt> key. This keeps this entry “hot,” maintaining its position in the <tt class="calibre22">LinkedHashMap</tt> such that it is never offered to the <tt class="calibre22">removeEldestEntry</tt> method for potential eviction.</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">We put each key-value pair from the seq of 250 pairs we built in <img src="images/00007.jpg" class="calibre36"/> into the cache. Once our <tt class="calibre22">max-size</tt> of <tt class="calibre22">5</tt> is exceeded, each <tt class="calibre22">.put</tt> should result in the least recently used entry being expired from the cache.</blockquote><p class="calibre23"><img src="images/00001.jpg" class="calibre36"/></p><blockquote class="calibre37">After finishing our bulk <tt class="calibre22">.put</tt>s, we check the state of the cache…</blockquote><p class="calibre18">…and, yes, the cache contains only five entries, and the <tt class="calibre22">[:a :b]</tt> entry that we kept hot remains; it was never offered to our <tt class="calibre22">proxy</tt>-implemented <tt class="calibre22">removeEldestEntry</tt> method, and was therefore never evicted. Only the <tt class="calibre22">[498 499]</tt> entry has been used more recently used than our <tt class="calibre22">[:a :b]</tt>, as the last time we touched the map was to add the former.</p><p id="filepos1362472" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Defining Named Classes</span></span></span></p><p id="filepos1362584" class="calibre18">While <tt class="calibre22">proxy</tt> allows you to define anonymous classes at runtime within Clojure, there are often cases where you need to provide a static, standalone, named Java class for use by Java-centric consumers.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1362855"></a><a href="#filepos1405314"><span class="calibre32">299</span></a><span class="calibre32">]</span></small></sup> Clojure provides three forms that generate named classes, each of which embodies a different set of tradeoffs.</p><p class="calibre18">In conjunction with protocols, <tt class="calibre22">deftype</tt><a id="filepos1363140"></a> and <tt class="calibre22">defrecord</tt><a id="filepos1363170"></a> represent Clojure’s principled approach to data and domain modeling. As a consequence, they eschew some of the more complicated aspects of the Java object model to make way for Clojure’s idioms. Conversely, in order to be maximally efficient, <tt class="calibre22">deftype</tt> and <tt class="calibre22">defrecord</tt> are structurally the most similar to “regular” Java classes: they allow you to define new (optionally primitive) fields, and their method bodies are inlined into the class files they generate, making them as efficient as classes you might define in Java itself. We might say that <tt class="calibre22">deftype</tt> and <tt class="calibre22">defrecord</tt> reuse “the good parts” of the Java object model. While they can and are used for interop purposes when possible,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1363940"></a><a href="#filepos1406050"><span class="calibre32">300</span></a><span class="calibre32">]</span></small></sup> they have a much broader role within Clojure; thus, we discuss them separately and extensively in <a href="#filepos945443"><span class="calibre5">Chapter 6</span></a>.</p><p class="calibre18">In contrast, <tt class="calibre22">gen-class</tt><a id="filepos1364263"></a> provides more complete support for the Java object model—including defining static methods, subclassing concrete base classes, and defining multiple constructors and new instance methods—but is structurally very different from typical Java classes, with the generated class’s methods delegating their implementation at runtime to regular Clojure functions.</p><p id="filepos1364637" class="calibre23"><span class="calibre53"><span class="bold">gen-class</span></span></p><p class="calibre18"><tt class="calibre22">gen-class</tt><a id="filepos1364753"></a> allows you to define Java classes whose method implementations are backed by regular Clojure functions. It is intended exclusively for interop contexts, and supports a broad subset of the Java object model that makes it possible to fulfill framework and library API requirements with few exceptions. It allows you to:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Generate a Java class in any package and with any name</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Extend an existing base class, with access to the base class’s protected fields</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Implement any number of Java interfaces</blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17">Define any number of constructors</blockquote></li><li value="5" class="calibre16"><blockquote class="calibre17">Define static and additional instance methods, beyond those defined by the superclass and implemented interfaces</blockquote></li><li value="6" class="calibre16"><blockquote class="calibre17">Conveniently generate static factory functions</blockquote></li><li value="7" class="calibre16"><blockquote class="calibre17">Conveniently generate a static <tt class="calibre22">main</tt> method, for classes to operate at the command line</blockquote></li></ul><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10"><tt class="calibre22">gen-class</tt></span><span class="calibre10"> is the only form in Clojure that must be </span><span class="calibre10"><span class="italic">ahead-of-time (AOT) compiled</span></span><span class="calibre10">. Without it, </span><span class="calibre10"><tt class="calibre22">gen-class</tt></span><span class="calibre10"> forms are no-ops, as </span><span class="calibre10"><tt class="calibre22">gen-class</tt></span><span class="calibre10"> does not define a class at runtime like all of Clojure’s other class-definition forms. With AOT compilation, </span><span class="calibre10"><tt class="calibre22">gen-class</tt></span><span class="calibre10"> forms emit Java class files that can be redistributed in </span><span class="calibre10"><span class="italic">.jar</span></span><span class="calibre10"> files and used by other Java libraries, referred to in Java programs, and so on.</span></blockquote><blockquote class="calibre17"><span class="calibre10">Learn more about AOT compilation in </span><a href="#filepos1199448"><span class="calibre10"><span class="calibre5">Ahead-of-Time Compilation</span></span></a><span class="calibre10">. </span><span class="calibre10"><span class="italic">All of the examples in this chapter that use </span></span><span class="calibre10"><tt class="calibre22"><span class="italic">gen-class</span></tt></span><span class="calibre10"><span class="italic"> assume that they’ve been AOT-compiled accordingly.</span></span></blockquote><p class="calibre25">Comprehensively describing all of <tt class="calibre22">gen-class</tt>’s options would likely require its own chapter. Rather, a couple of representative examples of <tt class="calibre22">gen-class</tt> usage will give you a good starting point for understanding how it works. Here’s a Clojure namespace that implements very naive image resizing, which we can package into a self-contained, executable <span class="italic">.jar</span> file thanks to the <tt class="calibre22">gen-class</tt> definition:</p><p id="filepos1368034" class="calibre23"></p><p class="calibre23"><span class="italic">Example 9-16. Providing static methods and a command-line utility via gen-class</span><a id="filepos1368182"></a></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(ns com.clojurebook.imaging<br class="calibre33"/>  (:use [clojure.java.io :only (file)])<br class="calibre33"/>  (:import (java.awt Image Graphics2D)<br class="calibre33"/>           javax.imageio.ImageIO<br class="calibre33"/>           java.awt.image.BufferedImage<br class="calibre33"/>           java.awt.geom.AffineTransform))<br class="calibre33"/><br class="calibre33"/>(defn load-image<br class="calibre33"/>  [file-or-path]<br class="calibre33"/>  (-&gt; file-or-path file ImageIO/read))<br class="calibre33"/><br class="calibre33"/>(defn resize-image<br class="calibre33"/>  ^BufferedImage [^Image original factor]<br class="calibre33"/>  (let [scaled (BufferedImage. (* factor (.getWidth original))<br class="calibre33"/>                               (* factor (.getHeight original))<br class="calibre33"/>                               (.getType original))]<br class="calibre33"/>    (.drawImage ^Graphics2D (.getGraphics scaled)<br class="calibre33"/>                original<br class="calibre33"/>                (AffineTransform/getScaleInstance factor factor)<br class="calibre33"/>                nil)<br class="calibre33"/>    scaled))<br class="calibre33"/><br class="calibre33"/>(gen-class<br class="calibre33"/>  :name ResizeImage                                                    </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  :main true                                                           </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  :methods [^:static [resizeFile [String String double] void]          </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>            ^:static [resize [java.awt.Image double] java.awt.image.BufferedImage]])<br class="calibre33"/><br class="calibre33"/>(def ^:private -resize resize-image)                                   </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/><br class="calibre33"/>(defn- -resizeFile<br class="calibre33"/>  [path outpath factor]<br class="calibre33"/>  (ImageIO/write (-&gt; path load-image (resize-image factor))<br class="calibre33"/>                 "png"<br class="calibre33"/>                 (file outpath)))<br class="calibre33"/><br class="calibre33"/>(defn -main                                                            </tt></span><a></a><img src="images/00001.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  [&amp; [path outpath factor]]<br class="calibre33"/>  (when-not (and path outpath factor)<br class="calibre33"/>    (println "Usage: java -jar example-uberjar.jar ResizeImage [INFILE] [OUTFILE] <br class="calibre33"/>      [SCALE]")<br class="calibre33"/>    (System/exit 1))<br class="calibre33"/>  (-resizeFile path outpath (Double/parseDouble factor)))</tt></span></p><p class="calibre101"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">By default, <tt class="calibre22">gen-class</tt> generates classes with the same name as the namespace they’re found in. In this case, the namespace (<tt class="calibre22">com.clojurebook.imaging</tt>) is Clojure-idiomatic, but does not fit with Java practice and is too long for a command-line tool anyway. Instead, we specify a class name to be generated in the default package, <tt class="calibre22">ResizeImage</tt>.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">We want to be able to use this class as a command-line tool, so we enable <tt class="calibre22">gen-class</tt>’s main-method option. This will produce a <tt class="calibre22">public static void main String(args[])</tt> method, which will delegate to the <tt class="calibre22">-main</tt> function in this namespace.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">Here we define two methods on the generated class, which are provided in the form <tt class="calibre22">[methodName [parameter types] returnType]</tt>. These methods are both static in this case, thanks to the <tt class="calibre22">^:static</tt> metadata on each method’s signature vector.</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">By default, <tt class="calibre22">gen-class</tt> looks for method-implementing functions in the same namespace as the <tt class="calibre22">gen-class</tt> definition, and the same names as the defined methods but with a <tt class="calibre22">-</tt> prefix.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1372952"></a><a href="#filepos1406574"><span class="calibre32">301</span></a><span class="calibre32">]</span></small></sup> The static <tt class="calibre22">resize</tt> method we’ve defined conveniently has the same signature and semantics as our <tt class="calibre22">resize-image</tt> function. Thus, we simply alias the <tt class="calibre22">resize-image</tt> function into a new var with the name that the <tt class="calibre22">resize</tt> method will delegate to (<tt class="calibre22">-resize</tt>). We provide a dedicated implementation for the <tt class="calibre22">resizeFile</tt> method.</blockquote><p class="calibre23"><img src="images/00001.jpg" class="calibre36"/></p><blockquote class="calibre37">Our main method provides some simple usage information, passing command-line arguments on to <tt class="calibre22">-resizeFile</tt>.</blockquote><p class="calibre18">Once we AOT-compile this namespace, we’ll have a <tt class="calibre22">ResizeImage</tt> class file that we can run from the command line or use from within a Java application via its static methods. For example, say we have an image in our current directory called <span class="italic">clojure.png</span>:</p><p class="calibre51"><img src="images/00030.jpg" class="calibre104"/></p><p class="calibre13">We can run our <tt class="calibre22">ResizeImage</tt> utility from the command line:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">java -cp gen-class-1.0.0-standalone.jar ResizeImage clojure.png resized.png 0.5</tt></span></blockquote><p class="calibre23">Yielding our scaled image:</p><p class="calibre51"><img src="images/00004.jpg" class="calibre105"/></p><p class="calibre13">Those static methods on <tt class="calibre22">ResizeImage</tt> are of course accessible to any Java code as well:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">ResizeImage.resizeFile("clojure.png", "resized.png", 0.5);</tt></span></blockquote><p class="calibre23">An important thing to note about <tt class="calibre22">gen-class</tt> is that it does not require you to change anything about your Clojure codebase. That <tt class="calibre22">com.clojurebook.imaging</tt> namespace would be a perfectly fine (albeit small) Clojure API, idiomatic in every sense; we’re just using <tt class="calibre22">gen-class</tt> to provide a Java-friendly bridge to that namespace’s functionality.</p><p id="filepos1375217" class="calibre18"><span class="bold">Defining a custom exception type</span>. <a id="filepos1375287"></a>As we said in <a href="#filepos1311696"><span class="calibre5">“Reusing existing exception types”</span></a>, it is generally the case that Clojure code reuses exception types that are already available in the Java standard library, or in other third-party libraries that a particular application might be using. However, there are some cases where a specialized exception type is called for, especially if you are collaborating extensively with Java-centric colleagues who expect to see a proliferation of exception types for each error condition.</p><p class="calibre18">Let’s look at a custom exception type that allows us to provide a map of data alongside the usual <tt class="calibre22">String</tt> and root-cause <tt class="calibre22">Throwable</tt> that Java exceptions typically carry:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 9-17. Defining a custom exception type using gen-class</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(ns com.clojurebook.CustomException<br class="calibre33"/>  (:gen-class :extends RuntimeException                                           </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>              :implements [clojure.lang.IDeref]                                   </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>              :constructors {[java.util.Map String] [String]                      </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>                             [java.util.Map String Throwable] [String Throwable]}<br class="calibre33"/>              :init init<br class="calibre33"/>              :state info                                                         </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>              :methods [[getInfo [] java.util.Map]                                </tt></span><a></a><img src="images/00001.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>                        [addInfo [Object Object] void]]))<br class="calibre33"/><br class="calibre33"/>(import 'com.clojurebook.CustomException)<br class="calibre33"/><br class="calibre33"/>(defn- -init                                                                      </tt></span><a></a><img src="images/00015.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  ([info message]<br class="calibre33"/>    [[message] (atom (into {} info))])                                            </tt></span><a></a><img src="images/00061.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  ([info message ex]<br class="calibre33"/>    [[message ex] (atom (into {} info))]))<br class="calibre33"/><br class="calibre33"/>(defn- -deref                                                                     </tt></span><a></a><img src="images/00016.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  [^CustomException this]<br class="calibre33"/>  @(.info this))<br class="calibre33"/><br class="calibre33"/>(defn- -getInfo<br class="calibre33"/>  [this]<br class="calibre33"/>  @this)<br class="calibre33"/><br class="calibre33"/>(defn- -addInfo<br class="calibre33"/>  [^CustomException this key value]<br class="calibre33"/>  (swap! (.info this) assoc key value))</tt></span></p><p class="calibre23"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Our exception type subclasses <tt class="calibre22">java.lang.Exception</tt>…</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">…and implements one of Clojure’s interface, <tt class="calibre22">java.lang.IDeref</tt>, allowing it to participate in the <tt class="calibre22">deref</tt> abstraction, which we described in the <a href="#filepos597825"><span class="calibre5">Note</span></a>. Clojure clients will thus be able to use <tt class="calibre22">deref</tt> and <tt class="calibre22">@</tt> on this exception type in order to obtain its map payload, just like any other <tt class="calibre22">deref</tt>erenceable value.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">We define a couple of constructors. The map we’re providing specifies (in part) that our <tt class="calibre22">CustomException(java.util.Map, String)</tt> constructor will call the <tt class="calibre22">Exception(String)</tt> constructor on our superclass. The values that are actually passed to the superclass’s constructor are determined by the <tt class="calibre22">:init</tt> function we identify.</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">Our exception type will have a single final field, which we’ll call <tt class="calibre22">info</tt>. We’ll see how that field is used in a bit.</blockquote><p class="calibre23"><img src="images/00001.jpg" class="calibre36"/></p><blockquote class="calibre37">We define two methods, <tt class="calibre22">getInfo</tt> and <tt class="calibre22">addInfo</tt>. We’ll see shortly how these make for a useful Java API for our custom exception.</blockquote><p class="calibre23"><img src="images/00015.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">gen-class</tt> generates constructors based on the signatures we specify. Those constructors will call the <tt class="calibre22">:init</tt> function here with the same arguments they are provided, where we can do the same kind of initialization work that would be done in a regular Java constructor.</blockquote><p class="calibre23"><img src="images/00061.jpg" class="calibre36"/></p><blockquote class="calibre37">The <tt class="calibre22">:init</tt> function must always return a vector of two elements: the first is a vector of arguments to be passed to the superclass’ constructor; the second is the value that is set on the <tt class="calibre22">:state</tt> final field. We’re storing an atom containing our info <tt class="calibre22">Map</tt> in our <tt class="calibre22">:state</tt> field; since we’re using an atom to coordinate change to that info <tt class="calibre22">Map</tt>, we copy the provided (possibly mutable) <tt class="calibre22">Map</tt> into an immutable Clojure map.</blockquote><p class="calibre23"><img src="images/00016.jpg" class="calibre36"/></p><blockquote class="calibre37">The <tt class="calibre22">-deref</tt> and <tt class="calibre22">-addInfo</tt> functions (implementing the <tt class="calibre22">deref</tt> and <tt class="calibre22">addInfo</tt> methods) show how we can interact with the atom we stored in the <tt class="calibre22">CustomException</tt>’s final <tt class="calibre22">info</tt> field.</blockquote><p class="calibre13">In contrast to the <tt class="calibre22">gen-class</tt> usage we saw in <a href="#filepos1368034"><span class="calibre5">Example 9-16</span></a>, this <tt class="calibre22">com.clojurebook.CustomException</tt> namespace exists solely to define the <tt class="calibre22">CustomException</tt> class. For these sorts of scenarios, you can “inline” the <tt class="calibre22">gen-class</tt> configuration directly in the namespace declaration, leaving the generated class name to inherit the namespace’s name.</p><p class="calibre18">Let’s see how we might use this from Clojure, with the help of some dummy functions that could easily find corollaries in many large applications:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(import 'com.clojurebook.CustomException)<br class="calibre33"/>;= nil<br class="calibre33"/>(defn perform-operation<br class="calibre33"/>  [&amp; [job priority :as args]]<br class="calibre33"/>  (throw (CustomException. {:arguments args} "Operation failed")))      </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #'user/perform-operation<br class="calibre33"/>(defn run-batch-job<br class="calibre33"/>  [customer-id]<br class="calibre33"/>  (doseq [[job priority] {:send-newsletter :low<br class="calibre33"/>                          :verify-billings :critical<br class="calibre33"/>                          :run-payroll :medium}]<br class="calibre33"/>    (try<br class="calibre33"/>      (perform-operation job priority)<br class="calibre33"/>      (catch CustomException e                                          </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>        (swap! (.info e) merge {:customer-id customer-id<br class="calibre33"/>                                :timestamp (System/currentTimeMillis)})<br class="calibre33"/>        (throw e)))))<br class="calibre33"/>;= #'user/run-batch-job<br class="calibre33"/>(try<br class="calibre33"/>  (run-batch-job 89045)<br class="calibre33"/>  (catch CustomException e<br class="calibre33"/>    (println "Error!" (.getMessage) @e)))                               </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>; Error! Operation failed {:timestamp 1309935234556, :customer-id 89045,<br class="calibre33"/>;                          :arguments (:verify-billings :critical)}<br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">perform-operation</tt> is throwing a new <tt class="calibre22">CustomException</tt>, providing an <tt class="calibre22">info</tt> map that contains the arguments that were passed to it as a seq.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">Any higher-level function (<tt class="calibre22">run-batch-job</tt> here) in the call chain can catch <tt class="calibre22">CustomException</tt>s and add new data into the exception’s <tt class="calibre22">info</tt> map. Since we’re in Clojure, we don’t need to rely upon the <tt class="calibre22">addInfo</tt> method we created in our <tt class="calibre22">gen-class</tt> form—we just reach into the atom hanging off of the exception from its <tt class="calibre22">info</tt> field and merge in a map of content information: a customer ID and a timestamp of when the exception occurred.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">Our top-level function can also catch the <tt class="calibre22">CustomException</tt>; rather than adding more information to it, it:</blockquote><ul class="calibre106"><li value="1" class="calibre16"><blockquote class="calibre37">Dereferences (via the <tt class="calibre22">@</tt> reader macro) the exception by using the <tt class="calibre22">deref</tt> method we defined, which returns the accumulated map of information it is carrying.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre37">Obtains the original message provided when the exception was created via the <tt class="calibre22">.getMessage</tt> method. Recall that we did not define this method; the classes generated by <tt class="calibre22">gen-class</tt> inherit methods implemented by their base class, just like regular Java classes.</blockquote></li></ul><p class="calibre18">Being able to pass arbitrary data along with exceptions like this can be very powerful. Depending on the domain, you could even include a function in the payload of an exception being thrown (or rethrown by a function or method in the middle of a call chain) that some higher level code could invoke to retry an operation, perhaps with different arguments.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1387134"></a><a href="#filepos1406959"><span class="calibre32">302</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">Using our new exception type from Java is straightforward as well:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">import com.clojurebook.CustomException;<br class="calibre33"/>import clojure.lang.PersistentHashMap;<br class="calibre33"/><br class="calibre33"/>public class BatchJob {<br class="calibre33"/>    private static void performOperation (String jobId, String priority) {<br class="calibre33"/>        throw new CustomException(PersistentHashMap.create("jobId", jobId,<br class="calibre33"/>                "priority", priority), "Operation failed");<br class="calibre33"/>    }<br class="calibre33"/><br class="calibre33"/>    private static void runBatchJob (int customerId) {<br class="calibre33"/>        try {<br class="calibre33"/>            performOperation("verify-billings", "critical");<br class="calibre33"/>        } catch (CustomException e) {<br class="calibre33"/>            e.addInfo("customer-id", customerId);<br class="calibre33"/>            e.addInfo("timestamp", System.currentTimeMillis());<br class="calibre33"/>            throw e;<br class="calibre33"/>        }<br class="calibre33"/>    }<br class="calibre33"/><br class="calibre33"/>    public static void main (String[] args) {<br class="calibre33"/>        try {<br class="calibre33"/>            runBatchJob(89045);<br class="calibre33"/>        } catch (CustomException e) {<br class="calibre33"/>            System.out.println("Error! " + e.getMessage() + " " + e.getInfo());<br class="calibre33"/>        }<br class="calibre33"/>    }<br class="calibre33"/>}</tt></span></blockquote><p class="calibre23">The only differences here compared to our in-Clojure usage of <tt class="calibre22">CustomException</tt> is that the <tt class="calibre22">.addInfo</tt> method is preferable to attempting to perform the equivalent of <tt class="calibre22">swap!</tt> in Java on the atom we stored in the exception class’s <tt class="calibre22">info</tt> field, and <tt class="calibre22">.getInfo</tt> is better that the <tt class="calibre22">.deref</tt> method, as the former is typed as returning a <tt class="calibre22">java.util.Map</tt>.<a id="filepos1389137"></a></p><p id="filepos1389148" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Annotations</span></span></span></p><p id="filepos1389249" class="calibre18">Annotations in Java are a sort of statically defined metadata that can be attached to class, method, and field declarations. This metadata <a id="filepos1389416"></a>is available either at compile time for use by code-generation facilities and other compile-time processes or at runtime via Java’s reflection mechanisms. Annotations were introduced in Java 5 as a way for users of libraries and frameworks to define behavior and semantics declaratively, but alongside the affected entities. This is in contrast to XML files and other configuration mechanisms that separate valuable metadata from what the metadata was intended to describe. Annotations are now in widespread use in many Java environments, so it’s important for Clojure to be able to fit seamlessly into such contexts.</p><blockquote class="calibre38"></blockquote><blockquote class="calibre39"><span class="calibre10"><span class="bold">ANNOTATIONS ARE FOR INTEGRATION</span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Annotations are one area of Clojure’s JVM host that regularly makes Clojure programmers cringe. Partly, this is because they can be a source of tragic complexity, even in Java. However, the real disconnect is that, compared to the combination of Clojure’s metadata, macro system, and runtime compilation capabilities, Java annotations just don’t do much given the amount of work and verbosity they typically involve.</span></blockquote><blockquote class="calibre17"><span class="calibre10">So, while you’ll find Clojure libraries and applications happily using nearly every other aspect of JVM interoperability that Clojure provides, few will willingly use Java annotations unless doing so is imperative from an integration standpoint.</span></blockquote><p id="filepos1391036" class="calibre75"><span class="calibre53"><span class="bold">Producing annotated JUnit tests</span></span></p><p id="filepos1391129" class="calibre18">Clojure recognizes metadata attached to any of its class-generation forms as annotations of the resulting classes, methods, or fields. Let’s take a look at an example, where we use the <tt class="calibre22">org.junit.Test</tt> method annotation from the popular JUnit test framework (<a href="http://junit.org"><span class="calibre5">http://junit.org</span></a>) to specify which methods defined by a <tt class="calibre22">gen-class</tt> class are to be treated as tests.</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 9-18. Using JUnit annotations to mark gen-class methods as tests</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(ns com.clojurebook.annotations.junit<br class="calibre33"/>  (:import (org.junit Test Assert))<br class="calibre33"/>  (:gen-class<br class="calibre33"/>    :name com.clojurebook.annotations.JUnitTest<br class="calibre33"/>    :methods [[^{org.junit.Test true} simpleTest [] void]              </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>              [^{org.junit.Test {:timeout 2000}} timeoutTest [] void]  </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>              [^{org.junit.Test {:expected NullPointerException}}      </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>                badException [] void]]))<br class="calibre33"/><br class="calibre33"/>(defn -simpleTest<br class="calibre33"/>  [this]<br class="calibre33"/>  (Assert/assertEquals (class this) com.clojurebook.annotations.JUnitTest))<br class="calibre33"/><br class="calibre33"/>(defn -badException<br class="calibre33"/>  [this]<br class="calibre33"/>  (Integer/parseInt (System/getProperty "nonexistent")))               </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/><br class="calibre33"/>(defn -timeoutTest<br class="calibre33"/>  [this]<br class="calibre33"/>  (Thread/sleep 10000))                                                </tt></span><a></a><img src="images/00001.jpg" class="calibre36"/></p><p class="calibre101"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">An annotation on the <tt class="calibre22">simpleTest</tt> method of the generated <tt class="calibre22">gen-class</tt> class. <tt class="calibre22">^{org.junit.Test true}</tt> is equivalent to a bare <tt class="calibre22">@org.junit.Test</tt> annotation on a Java method.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">Here, we’re specifying a value of <tt class="calibre22">2000</tt> milliseconds for the <tt class="calibre22">timeout</tt> field of the <tt class="calibre22">org.junit.Test</tt> annotation for the <tt class="calibre22">timeoutTest</tt> method. This is equivalent to a <tt class="calibre22">@org.junit.Test(timeout=2000)</tt> annotation in Java.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">Similarly, we’re specifying that <tt class="calibre22">badException</tt> should throw a <tt class="calibre22">NullPointerException</tt> when called by providing that class as a value for the <tt class="calibre22">expected</tt> field of the <tt class="calibre22">org.junit.Test</tt> annotation. This is equivalent to <tt class="calibre22">@org.junit.Test(expected=NullPointerException)</tt> in Java.</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">Our implementation for the <tt class="calibre22">badException</tt> method is attempting to parse what will be a nonexistent system property as an integer; this will throw a <tt class="calibre22">NumberFormatException</tt>, not the <tt class="calibre22">NullPointerException</tt> we are indicating in our annotation’s <tt class="calibre22">expected</tt> value.</blockquote><p class="calibre23"><img src="images/00001.jpg" class="calibre36"/></p><blockquote class="calibre37">Our implementation for the <tt class="calibre22">timeoutTest</tt> method will sleep for 10 seconds, longer than the 2 seconds defined as acceptable in our annotation’s <tt class="calibre22">timeout</tt> value.</blockquote><p class="calibre18">AOT compiling this namespace will produce a <tt class="calibre22">com.clojurebook.annotations.JUnitTest</tt> class that you can add to JUnit’s runner. One test will pass (the <tt class="calibre22">simpleTest</tt> assertion will always be true), but the other two will fail due to the configuration we provided in our annotation metadata. The JUnit runner’s output will include:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">There were 2 failures:<br class="calibre33"/>1) timeoutTest(com.clojurebook.annotations.JUnitTest)<br class="calibre33"/>java.lang.Exception: test timed out after 2000 milliseconds<br class="calibre33"/>2) throwsWrongException(com.clojurebook.annotations.JUnitTest)<br class="calibre33"/>java.lang.Exception: Unexpected exception,<br class="calibre33"/>expected&lt;java.lang.NullPointerException&gt; but was&lt;java.lang.NumberFormatException&gt;</tt></span></blockquote><p class="calibre23">The annotations we provided in our <tt class="calibre22">gen-class</tt>
<tt class="calibre22">:methods</tt> declaration completely determined the test criteria applied to the resulting class, and could be dropped into an annotation-driven JUnit test environment as-is.</p><p id="filepos1396434" class="calibre23"><span class="calibre53"><span class="bold">Implementing JAX-RS web service endpoints</span></span></p><p id="filepos1396536" class="calibre18">JAX-RS is one of the more popular web service standards in the Java world. It defines a set of annotation-based APIs useful for creating REST-style services using standard Java classes. Containers that implement the standard use the annotations to discover classes mapped to requested URLs, determine appropriate class methods to invoke based on requests’ HTTP methods, and set things like response <tt class="calibre22">Content-Type</tt>.</p><p class="calibre18">Let’s define a JAX-RS <span class="italic">resource</span> class in Clojure; we could do this using <tt class="calibre22">gen-class</tt> again, but let’s use <tt class="calibre22">deftype</tt> this time to illustrate some of the variety you can apply in using Clojure’s annotation support:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1397292"></a><a href="#filepos1407857"><span class="calibre32">303</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 9-19. A web service implemented using JAX-RS annotations</span><a id="filepos1397524"></a></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(ns com.clojurebook.annotations.jaxrs<br class="calibre33"/>  (:import (javax.ws.rs Path PathParam Produces GET)))<br class="calibre33"/><br class="calibre33"/>(definterface Greeting                                       </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  (greet [^String visitor-name]))<br class="calibre33"/><br class="calibre33"/>(deftype ^{Path "/greet/{visitorname}"} GreetingResource []  </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  Greeting<br class="calibre33"/>  (^{GET true                                                </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>     Produces ["text/plain"]}<br class="calibre33"/>    greet<br class="calibre33"/>    [this ^{PathParam "visitorname"} visitor-name]           </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>    (format "Hello %s!" visitor-name)))</tt></span></p><p class="calibre23"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">We use the <tt class="calibre22">definterface</tt> form to define a single-method interface called <tt class="calibre22">Greeting</tt> for our <tt class="calibre22">deftype</tt> class to implement. It accepts a single String argument.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">A <tt class="calibre22">deftype</tt> class is defined, with a <tt class="calibre22">Path</tt> class annotation that has a value of <tt class="calibre22">"/greet/{visitorname}"</tt>; this means that any request to the JAX-RS container that matches this URL pattern will be routed to our <tt class="calibre22">GreetingResource</tt> class.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">Our <tt class="calibre22">greet</tt> method implementation has two annotations on it: <tt class="calibre22">GET</tt>, which makes this method eligible for <tt class="calibre22">GET</tt> requests, and <tt class="calibre22">Produces</tt>, which defines the <tt class="calibre22">Content-Type</tt> that our JAX-RS container will specify when sending our response. In this case, we’re just returning a string from our <tt class="calibre22">greet</tt> method, so <tt class="calibre22">"text/plain"</tt> is appropriate.</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">The URL pattern we defined in our <tt class="calibre22">Path</tt> class annotation provides for a single parameter, <tt class="calibre22">visitorname</tt>. We specify that that URL parameter should be aligned with our <tt class="calibre22">visitor-name</tt> method argument by adding a <tt class="calibre22">PathParam</tt> annotation with the same name we used in the URL pattern.</blockquote><p class="calibre13">Once AOT-compiled, our <tt class="calibre22">GreetingResource</tt> can be deployed into any JAX-RS container. We can get one running within the REPL, using the Grizzly embedded web server:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(com.sun.jersey.api.container.grizzly.GrizzlyWebContainerFactory/create<br class="calibre33"/>  "http://localhost:8080/"<br class="calibre33"/>  {"com.sun.jersey.config.property.packages" "com.clojurebook.annotations.jaxrs"})</tt></span></blockquote><p class="calibre23">This causes a Grizzly instance to start serving on <tt class="calibre22">localhost:8080</tt>, searching the <tt class="calibre22">com.clojurebook.annotations.jaxrs</tt> package for resource handlers; our <tt class="calibre22">GreetingResource</tt> class will be found and be used as a candidate request handler. Accessing <span class="italic">http://localhost:8080/application.wadl</span> will return the JAX-RS container’s WADL descriptor, where we can see our resource URL, <tt class="calibre22">visitorname</tt> parameter, and <tt class="calibre22">text/plain</tt> media type:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">% curl http://localhost:8080/application.wadl<br class="calibre33"/>&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;<br class="calibre33"/>&lt;application xmlns="http://research.sun.com/wadl/2006/10"&gt;<br class="calibre33"/>    &lt;doc xmlns:jersey="http://jersey.java.net/"<br class="calibre33"/>         jersey:generatedBy="Jersey: 1.8 06/24/2011 12:17 PM"/&gt;<br class="calibre33"/>    &lt;resources base="http://localhost:8080/"&gt;<br class="calibre33"/>        &lt;resource path="/greet/{visitorname}"&gt;<br class="calibre33"/>            &lt;param xmlns:xs="http://www.w3.org/2001/XMLSchema"<br class="calibre33"/>                type="xs:string" style="template" name="visitorname"/&gt;<br class="calibre33"/>            &lt;method name="GET" id="greet"&gt;<br class="calibre33"/>                &lt;response&gt;<br class="calibre33"/>                    &lt;representation mediaType="text/plain"/&gt;<br class="calibre33"/>                &lt;/response&gt;<br class="calibre33"/>            &lt;/method&gt;<br class="calibre33"/>        &lt;/resource&gt;<br class="calibre33"/>    &lt;/resources&gt;<br class="calibre33"/>&lt;/application&gt;</tt></span></blockquote><p class="calibre23"><tt class="calibre22">GET</tt>-ing any URL of the form <span class="italic">http://localhost:8080/greet/&lt;some-name&gt;</span> will produce the result we generate from our annotated JAX-RS resource class:<a id="filepos1402843"></a></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">% curl http://localhost:8080/greet/Jose<br class="calibre33"/>Hello Jose!</tt></span></blockquote><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1403090"></a><a href="#filepos1352739"><span class="calibre32">294</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">If you don’t need to subclass an existing concrete class, you should prefer </span><span class="calibre10"><tt class="calibre22">reify</tt></span><span class="calibre10"> over </span><span class="calibre10"><tt class="calibre22">proxy</tt></span><span class="calibre10">; the former is described in </span><a href="#filepos1019348"><span class="calibre10"><span class="calibre5">Defining anonymous types with reify</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1403639"></a><a href="#filepos1353379"><span class="calibre32">295</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used"><span class="calibre10"><span class="calibre5">http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used</span></span></a><span class="calibre10"> if you are not familiar with LRU caching.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1404088"></a><a href="#filepos1360031"><span class="calibre32">296</span></a><span class="calibre32">] </span></small></sup><span class="calibre10"><tt class="calibre22">:a</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">:b</tt></span><span class="calibre10"> are Clojure keyword literals. Clojure keywords are described in </span><a href="#filepos82628"><span class="calibre10"><span class="calibre5">Keywords</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1404539"></a><a href="#filepos1360577"><span class="calibre32">297</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">An example involving a printable amount of data would be </span><span class="calibre10"><tt class="calibre22">(partition 2 (range 10))</tt></span><span class="calibre10"> ⇒ </span><span class="calibre10"><tt class="calibre22">((0 1) (2 3) (4 5) (6 7) (8 9))</tt></span><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1404948"></a><a href="#filepos1360755"><span class="calibre32">298</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">You can read about Clojure’s destructuring forms in </span><a href="#filepos137243"><span class="calibre10"><span class="calibre5">Destructuring (let, Part 2)</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1405314"></a><a href="#filepos1362855"><span class="calibre32">299</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">These consumers can be Java programmers if you are distributing Clojure code as a library, or existing JVM libraries, frameworks, and servers that require that certain implementation classes be statically named in configuration files and such. One common example of the latter are servlet containers; their </span><span class="calibre10"><span class="italic">web.xml</span></span><span class="calibre10"> file, described in </span><a href="#filepos2003902"><span class="calibre10"><span class="calibre5">Example 17-1</span></span></a><span class="calibre10">, requires the specification of a named servlet class.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1406050"></a><a href="#filepos1363940"><span class="calibre32">300</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">As we’ll see in some examples later in this chapter; see </span><a href="#filepos1396434"><span class="calibre10"><span class="calibre5">Implementing JAX-RS web service endpoints</span></span></a><span class="calibre10"> and </span><a href="#filepos1420028"><span class="calibre10"><span class="calibre5">Using deftype and defrecord Classes</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1406574"></a><a href="#filepos1372952"><span class="calibre32">301</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">You can specify a different prefix by providing a string value to </span><span class="calibre10"><tt class="calibre22">gen-class</tt></span><span class="calibre10"> in a </span><span class="calibre10"><tt class="calibre22">:prefix</tt></span><span class="calibre10"> slot.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1406959"></a><a href="#filepos1387134"><span class="calibre32">302</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Doing this would be a weaker instance of a one-off </span><span class="calibre10"><span class="italic">restart</span></span><span class="calibre10"> mechanism. Restarts are a key feature of </span><span class="calibre10"><span class="italic">condition systems</span></span><span class="calibre10">, a generalization of exception-based error handling, found in Smalltalk and some other Lisps. Such systems allow any code that encounters an exceptional condition to provide one or more restarts that higher level code can opt into invoking. Again, we’d recommend looking at Slingshot if you’d like to experiment with more flexible error handling: </span><a href="https://github.com/scgilardi/slingshot"><span class="calibre10"><span class="calibre5">https://github.com/scgilardi/slingshot</span></span></a></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1407857"></a><a href="#filepos1397292"><span class="calibre32">303</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">For all the details on </span><span class="calibre10"><tt class="calibre22">deftype</tt></span><span class="calibre10">, please refer to </span><a href="#filepos967758"><span class="calibre10"><span class="calibre5">Defining Your Own Types</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos1408219" class="calibre6"><span class="calibre4"><span class="bold">Using Clojure from Java</span></span></p><p id="filepos1408303" class="calibre18">For the moment, let’s assume that you would like to call into a Clojure library from Java, and that library does not define any types or classes.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1408513"></a><a href="#filepos1434974"><span class="calibre32">304</span></a><span class="calibre32">]</span></small></sup> To use that codebase, you’ll need to tap into the Clojure “native” functions and constant values it defines in namespaces. Thankfully, doing so from Java is straightforward:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">Load the Clojure code you want to use. This means reusing the standard <tt class="calibre22">require</tt>, <tt class="calibre22">use</tt>, or <tt class="calibre22">load</tt> functions provided in Clojure’s <tt class="calibre22">clojure.core</tt> namespace.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Obtain references to the vars corresponding with each function or value defined in the namespaces you care about.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Call the functions and use the values however your application requires.</blockquote></li></ol><p class="calibre18">All we need to demonstrate Java→Clojure interop are two vars, one providing a function, the other some value. The value will come from a simple Clojure namespace:</p><p id="filepos1409686" class="calibre23"></p><p class="calibre23"><span class="italic">Example 9-20. Simple Clojure namespace</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(ns com.clojurebook.histogram)<br class="calibre33"/><br class="calibre33"/>(def keywords (map keyword '(a c a d b c a d c d k d a b b b c d e e e f a a a a)))</tt></span></p><p class="calibre13">The function we’ll use is <tt class="calibre22">frequencies</tt> from the <tt class="calibre22">clojure.core</tt> namespace; it accepts any seqable value, and returns a map of the seq’s elements and counts of their frequency of occurrence in the seq.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1410302"></a><a href="#filepos1435398"><span class="calibre32">305</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">Here is a Java class that uses <tt class="calibre22">frequencies</tt> with the <tt class="calibre22">keywords</tt> value as well as many others.</p><p id="filepos1410541" class="calibre23"></p><p class="calibre23"><span class="italic">Example 9-21. Using Clojure code in </span><a href="#filepos1409686"><span class="italic"><span class="calibre5">Example 9-20</span></span></a><span class="italic"> from Java</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">package com.clojurebook;<br class="calibre33"/><br class="calibre33"/>import java.util.ArrayList;<br class="calibre33"/>import java.util.Map;<br class="calibre33"/><br class="calibre33"/>import clojure.lang.IFn;<br class="calibre33"/>import clojure.lang.Keyword;<br class="calibre33"/>import clojure.lang.RT;<br class="calibre33"/>import clojure.lang.Symbol;<br class="calibre33"/>import clojure.lang.Var;<br class="calibre33"/><br class="calibre33"/>public class JavaClojureInterop {<br class="calibre33"/>    private static IFn requireFn = RT.var("clojure.core", "require").fn();             </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>    private static IFn randIntFn = RT.var("clojure.core", "rand-int").fn();<br class="calibre33"/>    static {<br class="calibre33"/>        requireFn.invoke(Symbol.intern("com.clojurebook.histogram"));                  </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>    }<br class="calibre33"/><br class="calibre33"/>    private static IFn frequencies = RT.var("clojure.core", "frequencies").fn();       </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>    private static Object keywords = RT.var("com.clojurebook.histogram",               </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>            "keywords").deref();<br class="calibre33"/><br class="calibre33"/>    @SuppressWarnings({ "unchecked", "rawtypes" })<br class="calibre33"/>    public static void main(String[] args) {<br class="calibre33"/>        Map&lt;Keyword, Integer&gt; sampleHistogram =<br class="calibre33"/>            (Map&lt;Keyword, Integer&gt;)frequencies.invoke(keywords);                       </tt></span><a></a><img src="images/00001.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>        System.out.println("Number of :a keywords in sample histogram: " +<br class="calibre33"/>                sampleHistogram.get(Keyword.intern("a")));                             </tt></span><a></a><img src="images/00015.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>        System.out.println("Complete sample histogram: " + sampleHistogram);<br class="calibre33"/>        System.out.println();<br class="calibre33"/><br class="calibre33"/>        System.out.println("Histogram of chars in 'I left my heart in san fransisco': " +<br class="calibre33"/>                frequencies.invoke("I left my heart in San Fransisco".toLowerCase())); </tt></span><a></a><img src="images/00061.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>        System.out.println();<br class="calibre33"/><br class="calibre33"/>        ArrayList randomInts = new ArrayList();<br class="calibre33"/>        for (int i = 0; i &lt; 500; i++) randomInts.add(randIntFn.invoke(10));<br class="calibre33"/>        System.out.println("Histogram of 500 random ints [0,10): " +<br class="calibre33"/>                frequencies.invoke(randomInts));                                       </tt></span><a></a><img src="images/00016.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>    }<br class="calibre33"/>}</tt></span></p><p class="calibre101"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">First, we grab a couple of standard library functions we’ll use later, <tt class="calibre22">require</tt> and <tt class="calibre22">rand-int</tt>. Notice that we’re using the <tt class="calibre22">fn()</tt> method; this returns a Clojure function (all of which implement the <tt class="calibre22">IFn</tt> interface). The only difference between <tt class="calibre22">fn()</tt> and <tt class="calibre22">deref()</tt> is that the former performs the cast to <tt class="calibre22">IFn</tt> for you.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">Before we attempt to access our non-core Clojure namespace, we need to load it; we use <tt class="calibre22">require</tt> via our <tt class="calibre22">requireFn</tt>
<tt class="calibre22">IFn</tt> reference for that here. This is exactly equivalent to evaluating <tt class="calibre22">(require 'com.clojurebook.histogram)</tt> in Clojure.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">Here, we get a reference to the <tt class="calibre22">clojure.core/frequencies</tt> var; this is equivalent to <tt class="calibre22">#'clojure.core/frequencies</tt> in Clojure.</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">Here, we <tt class="calibre22">deref</tt> the value of the <tt class="calibre22">sample-values</tt> var, which is that seq of keywords shown in <a href="#filepos1409686"><span class="calibre5">Example 9-20</span></a>.</blockquote><p class="calibre23"><img src="images/00001.jpg" class="calibre36"/></p><blockquote class="calibre37">We call the <tt class="calibre22">frequencies</tt> function with our sample data using one of <tt class="calibre22">IFn</tt>’s <tt class="calibre22">invoke()</tt> methods. Note that these methods (just like <tt class="calibre22">Var.deref()</tt>) return an <tt class="calibre22">Object</tt>; Clojure is a dynamic language, so the type of the value in a var can be <span class="italic">anything</span>. This comes quite naturally within Clojure, but it does require some thought in a statically typed environment like Java: here we know that the <tt class="calibre22">frequencies</tt> function returns a <tt class="calibre22">Map</tt>, and we know that the data we provided to it are <tt class="calibre22">Keyword</tt>s, so we can safely cast <tt class="calibre22">frequencies</tt>’s result to <tt class="calibre22">Map&lt;Keyword, Number&gt;</tt>.</blockquote><p class="calibre23"><img src="images/00015.jpg" class="calibre36"/></p><blockquote class="calibre37">Values returned by Clojure are regular Java objects, and we can use them as such. That <tt class="calibre22">Map</tt> of <tt class="calibre22">Keyword</tt>s and <tt class="calibre22">Number</tt>s can be accessed just as if a Java method produced it. Here, we obtain the interned <tt class="calibre22">:a</tt> keyword to see how many times it appears in the seq of sample data.</blockquote><p class="calibre23"><img src="images/00061.jpg" class="calibre36"/><img src="images/00016.jpg" class="calibre36"/></p><blockquote class="calibre37">Thanks to the generic treatment of various concrete types in Clojure, we can call <tt class="calibre22">frequencies</tt> with Java-originated <tt class="calibre22">List</tt>s of random integers and <tt class="calibre22">String</tt>s, and expect useful results.</blockquote><p class="calibre18">After compiling this Java class, running it results in this output:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">% java -cp target/java-clojure-interop-1.0.0-jar-with-dependencies.jar<br class="calibre33"/>       com.clojurebook.JavaClojureInterop<br class="calibre33"/>Number of :a keywords in sample histogram: 8<br class="calibre33"/>Complete sample histogram: {:a 8, :c 4, :d 5, :b 4, :k 1, :e 3, :f 1}<br class="calibre33"/><br class="calibre33"/>Frequences of chars in 'I left my heart in san fransisco':<br class="calibre33"/>{\space 6, \a 3, \c 1, \e 2, \f 2, \h 1, \i 3, \l 1, \m 1,<br class="calibre33"/> \n 3, \o 1, \r 2, \s 3, \t 2, \y 1}<br class="calibre33"/><br class="calibre33"/>Frequences of 500 random ints [0,10):<br class="calibre33"/>{0 60, 1 61, 2 55, 3 46, 4 37, 5 45, 6 47, 7 52, 8 49, 9 48}</tt></span></blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Two potential tripping points are worth mentioning here:</span></blockquote><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17"><span class="calibre10">Loading Clojure code (as we do with </span><span class="calibre10"><tt class="calibre22">require</tt></span><span class="calibre10"> in </span><a href="#filepos1410541"><span class="calibre10"><span class="calibre5">Example 9-21</span></span></a><span class="calibre10">) requires that either the source file(s) or the AOT compiled class files for the namespaces in question are on your classpath.</span></blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17"><span class="calibre10">In general, you should obtain references to the vars you need to access </span><span class="calibre10"><span class="italic">once</span></span><span class="calibre10"> (usually holding them in a static reference). Further, if you don’t expect the values they hold to change,<sup class="calibre58"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1419341"></a><a href="#filepos1435830"><span class="calibre32">306</span></a><span class="calibre32">]</span></small></sup> then it’s wise to obtain their values once (via either </span><span class="calibre10"><tt class="calibre22">fn()</tt></span><span class="calibre10"> or </span><span class="calibre10"><tt class="calibre22">deref()</tt></span><span class="calibre10">). This avoids the (small, but not insignificant) overhead of runtime var lookup.</span></blockquote></li></ul><p class="calibre25">After understanding the above, you’ll be able to do nearly anything you want with Clojure functions and data from within Java. The remainder of the Java→Clojure interop story consists of being able to utilize types and protocols defined in Clojure from Java as well.</p><p id="filepos1420028" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Using deftype and defrecord Classes</span></span></span></p><p id="filepos1420153" class="calibre18">Each of these forms<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1420235"></a><a href="#filepos1436195"><span class="calibre32">307</span></a><span class="calibre32">]</span></small></sup> generates a Java-accessible class. Because of that, you can create and use instances of these classes in Java as if they were written in Java from the start.</p><p class="calibre18">Consider the following namespace:</p><p id="filepos1420557" class="calibre23"></p><p class="calibre23"><span class="italic">Example 9-22. Defining some classes using deftype and defrecord</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(ns com.clojurebook.classes)<br class="calibre33"/><br class="calibre33"/>(deftype Range                                                                </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  [start end]<br class="calibre33"/>  Iterable<br class="calibre33"/>  (iterator [this]<br class="calibre33"/>    (.iterator (range start end))))<br class="calibre33"/><br class="calibre33"/>(defn string-range                                                            </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  "Returns a Range instance based on start and end values provided as Strings<br class="calibre33"/>   in a list / vector / array."<br class="calibre33"/>  [[start end]]<br class="calibre33"/>  (Range. (Long/parseLong start) (Long/parseLong end)))<br class="calibre33"/><br class="calibre33"/>(defrecord OrderSummary                                                       </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  [order-number total])</tt></span></p><p class="calibre13">When it is loaded, Clojure generates two classes, <tt class="calibre22">com.clojurebook.classes.Range</tt> and <tt class="calibre22">com.clojurebook.classes.OrderSummary</tt>. We can use them from Java just as if they were written in Java; you will even see proper code completion in your IDE for every field and method implemented by the Clojure-generated classes.</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 9-23. Using deftype and defrecord classes defined in </span><a href="#filepos1420557"><span class="italic"><span class="calibre5">Example 9-22</span></span></a><span class="italic"> from Java</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">package com.clojurebook;<br class="calibre33"/><br class="calibre33"/>import clojure.lang.IFn;<br class="calibre33"/>import clojure.lang.RT;<br class="calibre33"/>import clojure.lang.Symbol;<br class="calibre33"/>import com.clojurebook.classes.OrderSummary;<br class="calibre33"/>import com.clojurebook.classes.Range;<br class="calibre33"/><br class="calibre33"/>public class ClojureClassesInJava {<br class="calibre33"/>    private static IFn requireFn = RT.var("clojure.core", "require").fn();<br class="calibre33"/>    static {<br class="calibre33"/>        requireFn.invoke(Symbol.intern("com.clojurebook.classes"));<br class="calibre33"/>    }<br class="calibre33"/><br class="calibre33"/>    private static IFn stringRangeFn = RT.var("com.clojurebook.classes",<br class="calibre33"/>            "string-range").fn();<br class="calibre33"/><br class="calibre33"/>    public static void main(String[] args) {<br class="calibre33"/>        Range range = new Range(0, 5);                                        </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>        System.out.print(range.start + "-" + range.end + ": ");               </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>        for (Object i : range) System.out.print(i + " ");                     </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>        System.out.println();<br class="calibre33"/><br class="calibre33"/>        for (Object i : (Range)stringRangeFn.invoke(args))                    </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>            System.out.print(i + " ");<br class="calibre33"/>        System.out.println();<br class="calibre33"/><br class="calibre33"/>        OrderSummary summary = new OrderSummary(12345, "$19.45");             </tt></span><a></a><img src="images/00001.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>        System.out.println(String.format("order number: %s; order total: %s",<br class="calibre33"/>                summary.order_number, summary.total));<br class="calibre33"/>        System.out.println(summary.keySet());<br class="calibre33"/>        System.out.println(summary.values());<br class="calibre33"/>    }<br class="calibre33"/>}</tt></span></p><p class="calibre101"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Here, we create an instance of the <tt class="calibre22">Range</tt>
<tt class="calibre22">deftype</tt> class, providing two arguments as it requires.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">As is detailed in <a href="#filepos995374"><span class="calibre5">Types</span></a>, <tt class="calibre22">deftype</tt> classes do not automatically implement any interfaces; however, we can access its two <tt class="calibre22">final</tt> fields by using the names specified in the <tt class="calibre22">deftype</tt> definition, and…</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">…since <tt class="calibre22">Range</tt> was defined to implement <tt class="calibre22">Iterable</tt>, we can obtain an <tt class="calibre22">Iterator</tt> from it and use it in a <tt class="calibre22">for</tt> loop just like any other <tt class="calibre22">Iterable</tt> instance.</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">deftype</tt> and <tt class="calibre22">defrecord</tt> classes can often require a number of parameters of particular types depending on how those classes are used; thus, it is often wise to provide a factory function that simplifies their instantiation. Here, we’re using the <tt class="calibre22">string-range</tt> factory function that accepts any destructurable collection containing two strings, returning a <tt class="calibre22">Range</tt> instance based on the parsed integer values of those strings. This helps us avoid having to pick apart and parse the numeric input from the command line.</blockquote><p class="calibre23"><img src="images/00001.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">defrecord</tt> classes are just like <tt class="calibre22">deftype</tt> classes, except they provide default implementations of certain interfaces; here, we create a <tt class="calibre22">defrecord</tt> instance, and demonstrate <tt class="calibre22">final</tt> field access as well as its default implementations of a couple of methods from the <tt class="calibre22">java.util.Map</tt> interface.</blockquote><p class="calibre18">Once we compile our Java class, we can run it and see some results:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">% java -cp target/java-clojure-interop-1.0.0-jar-with-dependencies.jar<br class="calibre33"/>     com.clojurebook.ClojureClassesInJava 5 10<br class="calibre33"/>0-5: 0 1 2 3 4<br class="calibre33"/>5 6 7 8 9<br class="calibre33"/>order number: 12345; order total: $19.45<br class="calibre33"/>#{:order-number :total}<br class="calibre33"/>(12345 "$19.45")</tt></span></blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">WHEN DO YOU NEED AHEAD OF TIME (AOT) COMPILATION?</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">If you are using the results of any class-generating Clojure form from Java (including </span><a id="filepos1428027"></a><span class="calibre10"><tt class="calibre22">deftype</tt></span><span class="calibre10">, </span><span class="calibre10"><tt class="calibre22">defrecord</tt></span><span class="calibre10">, </span><span class="calibre10"><tt class="calibre22">defprotocol</tt></span><span class="calibre10">, or </span><span class="calibre10"><tt class="calibre22">gen-class</tt></span><span class="calibre10">), you </span><span class="calibre10"><span class="italic">must</span></span><span class="calibre10"> AOT compile the namespaces containing those forms. Java’s compiler needs to have those class files available on disk in order to compile Java code that uses Clojure-generated classes. This is in contrast to use of </span><span class="calibre10"><tt class="calibre22">defrecord</tt></span><span class="calibre10">, et al., in a Clojure-only scenario; in that case, Clojure simply generates and loads the necessary classes at runtime and loads them into the JVM without ever producing a file on disk.</span></blockquote><blockquote class="calibre17"><span class="calibre10">We discuss AOT compilation in </span><a href="#filepos1199448"><span class="calibre10"><span class="calibre5">Ahead-of-Time Compilation</span></span></a><span class="calibre10"> and the compilation issues related to mixed-source projects in </span><a href="#filepos1252908"><span class="calibre10"><span class="calibre5">Building mixed-source projects</span></span></a><span class="calibre10">.</span><a id="filepos1429238"></a></blockquote><p id="filepos1429258" class="calibre25"><span class="calibre19"><span class="bold"><span class="calibre5">Implementing Protocol Interfaces</span></span></span></p><p id="filepos1429380" class="calibre18">Protocols enable the succinct creation of very flexible domain models within Clojure.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1429528"></a><a href="#filepos1436834"><span class="calibre32">308</span></a><span class="calibre32">]</span></small></sup> While you can extend protocols within Clojure to service existing Java classes and interfaces, you may come to need to have a Java class participate in an existing protocol without modifying your Clojure codebase. For this purpose, protocols generate an interface, which you can have your Java class implement. For example, here’s a Clojure namespace that contains a single protocol and two implementations of it, one for strings, the other a default implementation that will be dispatched to for all <tt class="calibre22">Object</tt>s:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(ns com.clojurebook.protocol)<br class="calibre33"/><br class="calibre33"/>(defprotocol Talkable<br class="calibre33"/>  (speak [this]))<br class="calibre33"/><br class="calibre33"/>(extend-protocol Talkable<br class="calibre33"/>  String<br class="calibre33"/>  (speak [s] s)<br class="calibre33"/>  Object<br class="calibre33"/>  (speak [this]<br class="calibre33"/>    (str (-&gt; this class .getName) "s can't talk!")))</tt></span></blockquote><p class="calibre23">The <tt class="calibre22">Talkable</tt> protocol defines one function, <tt class="calibre22">speak</tt>, and generates a <tt class="calibre22">com.clojurebook.protocol.Talkable</tt> interface that has a single <tt class="calibre22">speak</tt> method. We can implement that interface easily in Java:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 9-24. Implementing a Clojure protocol in Java via its generated interface</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">package com.clojurebook;<br class="calibre33"/><br class="calibre33"/>import clojure.lang.IFn;<br class="calibre33"/>import clojure.lang.RT;<br class="calibre33"/>import clojure.lang.Symbol;<br class="calibre33"/>import com.clojurebook.protocol.Talkable;<br class="calibre33"/><br class="calibre33"/>public class BitterTalkingDog implements Talkable {<br class="calibre33"/><br class="calibre33"/>    public Object speak() {                                                      </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>        return "You probably expect me to say 'woof!', don't you? Typical.";<br class="calibre33"/>    }<br class="calibre33"/><br class="calibre33"/>    Talkable mellow () {<br class="calibre33"/>        return new Talkable () {                                                 </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>            public Object speak() {<br class="calibre33"/>                return "It's a wonderful day, don't you think?";<br class="calibre33"/>            }<br class="calibre33"/>        };<br class="calibre33"/>    }<br class="calibre33"/><br class="calibre33"/>    public static void main(String[] args) {<br class="calibre33"/>        RT.var("clojure.core", "require").invoke(                                </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>            Symbol.intern("com.clojurebook.protocol"));<br class="calibre33"/>        IFn speakFn = RT.var("com.clojurebook.protocol", "speak").fn();<br class="calibre33"/><br class="calibre33"/>        BitterTalkingDog dog = new BitterTalkingDog();<br class="calibre33"/><br class="calibre33"/>        System.out.println(speakFn.invoke(5));<br class="calibre33"/>        System.out.println(speakFn.invoke(<br class="calibre33"/>            "A man may die, nations may rise and fall, but an idea lives on."));<br class="calibre33"/>        System.out.println(dog.speak());<br class="calibre33"/>        System.out.println(speakFn.invoke(dog.mellow()));<br class="calibre33"/>    }<br class="calibre33"/>}</tt></span></p><p class="calibre101"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Our class’s implementation of <tt class="calibre22">Talkable</tt>’s <tt class="calibre22">speak</tt> method.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">The protocol’s generated interface is just like any other Java interface; here, we define and return an instance of an anonymous inner class that implements the protocol’s interface.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">We need to load the <tt class="calibre22">com.clojurebook.protocol</tt> namespace in order for those <tt class="calibre22">String</tt> and <tt class="calibre22">Object</tt> extensions of the protocol to be available, and look up a reference to the <tt class="calibre22">speak</tt> var that the protocol defined.</blockquote><p class="calibre18">As we can see, Clojure provides for bidirectional interoperability. While we’ve demonstrated that Clojure can use and participate in Java’s abstractions, the same applies to Java participating in Clojure’s key abstractions.</p><p class="calibre18">The output of this class’ <tt class="calibre22">main</tt> method when run from the command line:<a id="filepos1434493"></a></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">% java com.clojurebook.BitterTalkingDog<br class="calibre33"/>java.lang.Integers can't talk!<br class="calibre33"/>A man may die, nations may rise and fall, but an idea lives on.<br class="calibre33"/>You probably expect me to say 'woof!', don't you? Typical.<br class="calibre33"/>It's a wonderful day, don't you think?</tt></span></blockquote><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1434974"></a><a href="#filepos1408513"><span class="calibre32">304</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">The techniques shown here apply to any JVM language; simply transliterate the Java code shown in </span><a href="#filepos1410541"><span class="calibre10"><span class="calibre5">Example 9-21</span></span></a><span class="calibre10"> into your preferred language.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1435398"></a><a href="#filepos1410302"><span class="calibre32">305</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">The result is technically a histogram; see </span><a href="http://en.wikipedia.org/wiki/Histogram"><span class="calibre10"><span class="calibre5">http://en.wikipedia.org/wiki/Histogram</span></span></a><span class="calibre10"> for an overview of what histograms are.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1435830"></a><a href="#filepos1419341"><span class="calibre32">306</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="#filepos744558"><span class="calibre10"><span class="calibre5">Dynamic Scope</span></span></a><span class="calibre10"> for details about when and how vars can change value over time.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1436195"></a><a href="#filepos1420235"><span class="calibre32">307</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">We detailed </span><span class="calibre10"><tt class="calibre22">gen-class</tt></span><span class="calibre10"> in </span><a href="#filepos1362472"><span class="calibre10"><span class="calibre5">Defining Named Classes</span></span></a><span class="calibre10">; </span><span class="calibre10"><tt class="calibre22">deftype</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">defrecord</tt></span><span class="calibre10"> are covered in </span><a href="#filepos945443"><span class="calibre10"><span class="calibre5">Chapter 6</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1436834"></a><a href="#filepos1429528"><span class="calibre32">308</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="#filepos945443"><span class="calibre10"><span class="calibre5">Chapter 6</span></span></a><span class="calibre10"> to read all about protocols.</span></p><div class="mbppagebreak"></div><p id="filepos1437114" class="calibre6"><span class="calibre4"><span class="bold">Collaborating Partners</span></span></p><p class="calibre18">While Clojure provides a swarm of compelling features of its own, it is unabashedly a JVM language that takes full advantage of that platform’s assets, including its maturity, efficiency, and reliable operational characteristics. This gives you the opportunity to take advantage of the vast ecosystem of Java libraries, frameworks, and community, as well as contribute back to that ecosystem in equal measure.<a id="filepos1437636"></a></p><div class="mbppagebreak"></div><p id="filepos1437663" class="calibre6"><span class="calibre2"><span class="bold">Chapter 10. REPL-Oriented Programming</span></span></p><p id="filepos1437763" class="calibre13">The quality of your tools is incredibly important, and can make or break the experience with a language, not to mention your degree of success more broadly. Clojure’s REPL, which we picked apart in <a href="#filepos28661"><span class="calibre5">Chapter 1</span></a>, is its most foundational tool—and, as we’ll see, perhaps its most powerful as well.</p><p class="calibre18">As we’ve stressed from the beginning, Clojure is always compiled and has no interpreter. Further, as we learned in <a href="#filepos831506"><span class="calibre5">Chapter 5</span></a>, Clojure’s compiler is fully available at runtime, making the entirety of the language available at runtime—and therefore available in the Clojure REPL. This means that:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Code you load and run in the REPL (say, in your development environment) will work and perform exactly the same as code loaded from files on disk (as they might be in a production environment).</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">You can use a REPL to define and redefine any Clojure construct at any time.</blockquote></li></ul><p class="calibre18">The ramifications of these characteristics make the REPL an absolutely indispensable part of every Clojure programmer’s toolchain in ways that are generally not true for REPLs and interpreters offered by other languages. Here, we’ll explore some of the workflows enabled by the REPL that might just change how you approach developing software.</p><p id="filepos1439418" class="calibre6"><span class="calibre4"><span class="bold">Interactive Development</span></span></p><p class="calibre18"><span class="italic">Interactive development</span><a id="filepos1439560"></a> is a loaded term that has been taken to mean all manner of things, as most modern languages offer some degree of interactivity. Even Java developers can interactively evaluate expressions, for example, when an application is paused on a breakpoint in a debugger. And, of course, Ruby, Python, and others provide REPLs with varying levels of sophistication, although they are generally not integrated with other tools (like your editor), are limited to running in a command line, and their host languages often place significant restrictions on how and what code can be modified or redefined at runtime.</p><p class="calibre18">In contrast, interactive development in Clojure as enabled by its REPL relaxes each of these constraints. As you use Clojure, you’ll find that building applications interactively with the aid of a persistent REPL session is the most productive approach you can choose, with little to nothing between your fingertips and what’s going on inside of the Clojure runtime and the JVM.</p><p id="filepos1440588" class="calibre23"></p><p class="calibre23"><span class="italic">Example 10-1. A tiny Swing “application”</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(ns com.clojurebook.fn-browser<br class="calibre33"/>  (:import (javax.swing JList JFrame JScrollPane JButton)<br class="calibre33"/>           java.util.Vector))<br class="calibre33"/><br class="calibre33"/>(defonce fn-names (-&gt;&gt; (ns-publics 'clojure.core)                                     </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>                    (map key)<br class="calibre33"/>                    sort<br class="calibre33"/>                    Vector.<br class="calibre33"/>                    JList.))<br class="calibre33"/><br class="calibre33"/>(defn show-info [] )                                                                  </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/><br class="calibre33"/>(defonce window (doto (JFrame. "\"Interactive Development!\"")<br class="calibre33"/>                  (.setSize (java.awt.Dimension. 400 300))<br class="calibre33"/>                  (.add (JScrollPane. fn-names))                                      </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>                  (.add java.awt.BorderLayout/SOUTH<br class="calibre33"/>                    (doto (JButton. "Show Info")                                      </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>                      (.addActionListener (reify java.awt.event.ActionListener<br class="calibre33"/>                                            (actionPerformed [_ e] (show-info))))))<br class="calibre33"/>                  (.setVisible true)))</tt></span></p><p class="calibre23"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">fn-names</tt> is a <tt class="calibre22">JList</tt>; the model will contain symbols naming each public var in the <tt class="calibre22">clojure.core</tt> namespace, sorted lexicographically.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">The <tt class="calibre22">show-info</tt> function will remain a no-op for now. We’ll fix that later.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">That list component will be held within a scrollable container that is added to a window that is sized sanely.</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">Also added to the window is a button with a click listener that will call the temporarily no-op <tt class="calibre22">show-info</tt> function.</blockquote><p class="calibre13">You can load this code into a Clojure REPL, or save it into a <span class="italic">com/clojurebook/fn_browser.clj</span> file on your classpath<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1444036"></a><a href="#filepos1455937"><span class="calibre32">309</span></a><span class="calibre32">]</span></small></sup> and load it via <tt class="calibre22">(require 'com.clojurebook.fn-browser)</tt>. In either case, assuming you aren’t using Clojure in a headless environment like a server, you’ll see a Swing window like this one in a pop up:</p><p class="calibre51"><img src="images/00044.jpg" class="calibre107"/></p><p class="calibre13">Unless you’re still using a language that demands a discrete <span class="italic">write→compile→debug</span> cycle, being able to conjure up a UI from a REPL is not a huge revelation. What is a little more interesting is that we can seamlessly make changes to our running environment by just loading more code in any way that is convenient for us.</p><p class="calibre18">To demonstrate, let’s make that <tt class="calibre22">Show Info</tt> button do something, as it is entirely inert so far. To do this, we simply need to redefine the <tt class="calibre22">show-info</tt> function that our click listener is delegating to do something interesting…such as pop up the documentation for the <tt class="calibre22">clojure.core</tt> function that is selected in the list:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(in-ns 'com.clojurebook.fn-browser)<br class="calibre33"/><br class="calibre33"/>(import '(javax.swing JOptionPane JTextArea))<br class="calibre33"/><br class="calibre33"/>(defn show-info<br class="calibre33"/>  []<br class="calibre33"/>  (when-let [selected-fn (.getSelectedValue fn-names)]<br class="calibre33"/>    (JOptionPane/showMessageDialog<br class="calibre33"/>      window<br class="calibre33"/>      (-&gt; (ns-resolve 'clojure.core selected-fn)        </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>        meta                                            </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>        :doc                                            </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>        (JTextArea. 10 40)                              </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>        JScrollPane.)<br class="calibre33"/>      (str "Doc string for clojure.core/" selected-fn)<br class="calibre33"/>      JOptionPane/INFORMATION_MESSAGE)))</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">If a function name has been selected in the list component, we resolve it within the <tt class="calibre22">clojure.core</tt> namespace, using <tt class="calibre22">ns-resolve</tt>. This returns a var…</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">…which we obtain the metadata of…</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">…and get out of that metadata its <tt class="calibre22">:doc</tt> value, which is where Clojure stores documentation strings provided when vars are defined. See <a href="#filepos739715"><span class="calibre5">Docstrings</span></a> for more about documentation strings.</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">The documentation for the function then forms the initial content of a <tt class="calibre22">JTextArea</tt> component, which is used as the “message” in the <tt class="calibre22">JOptionPane</tt> pop-up box.</blockquote><p class="calibre18">You can load this code into the REPL or you can edit the <span class="italic">fn_browser.clj</span> file you created and reload it via <tt class="calibre22">(require 'com.clojurebook.fn-browser :reload)</tt>.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1448057"></a><a href="#filepos1456318"><span class="calibre32">310</span></a><span class="calibre32">]</span></small></sup> In either case, once you redefine <tt class="calibre22">show-info</tt>, the button’s click listener will call the newly defined function <span class="italic">without recreating, modifying, or otherwise touching that button</span>.</p><p class="calibre18">Selecting a function in <tt class="calibre22">clojure.core</tt> that has some documentation and clicking the <tt class="calibre22">Get Info</tt> button will pop up that documentation:</p><p class="calibre51"><img src="images/00033.jpg" class="calibre108"/></p><blockquote class="calibre77"></blockquote><blockquote class="calibre39"><span class="calibre10"><span class="bold">USING DEFONCE TO AVOID VAR CLOBBERING</span></span></blockquote><blockquote id="filepos1448828" class="calibre17"><span class="calibre10">Once you have some code in a file that you are loading and reloading into a Clojure process—whether via the REPL or using the </span><span class="calibre10"><tt class="calibre22">:reload</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">:reload-all</tt></span><span class="calibre10"> options to </span><span class="calibre10"><tt class="calibre22">use</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">require</tt></span><span class="calibre10">—you may have some var definitions that you </span><span class="calibre10"><span class="italic">do not</span></span><span class="calibre10"> want to reevaluate. For example, we would not want to be redefining the </span><span class="calibre10"><tt class="calibre22">window</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">fn-names</tt></span><span class="calibre10"> in </span><a href="#filepos1440588"><span class="calibre10"><span class="calibre5">Example 10-1</span></span></a><span class="calibre10">; doing so would result in the creation of a new window and a new list component every time we reloaded the file.</span></blockquote><blockquote class="calibre17"><span class="calibre10">The solution to this is </span><span class="calibre10"><tt class="calibre22">defonce</tt></span><span class="calibre10">. Just like </span><span class="calibre10"><tt class="calibre22">def</tt></span><span class="calibre10"> and its brethren, </span><span class="calibre10"><tt class="calibre22">defonce</tt></span><span class="calibre10"> defines the value of a var in the current namespace, but it will not redefine any var that already has a value. Using </span><span class="calibre10"><tt class="calibre22">defonce</tt></span><span class="calibre10"> therefore allows us to mix the definition of vars that should remain fixed throughout the lifetime of our application (like </span><span class="calibre10"><tt class="calibre22">window</tt></span><span class="calibre10"> in our example, or perhaps a database connection pool in a web application) and other vars that we may want to readily redefine through the course of development and perhaps into production settings.</span></blockquote><p class="calibre50">This has been a particularly basic example, but hopefully illustrates some of the flexibility that Clojure’s REPL interaction provides. As convenient as it might be to interactively tweak the behavior of user interfaces without restarting the application or rebuilding the window, the same kind of flexibility and immediate feedback applied to the development of data-intensive algorithms or complicated domain models yield immeasurable benefits.</p><p id="filepos1451167" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">The Persistent, Evolving Environment</span></span></span></p><p class="calibre18">To some, what we’ve demonstrated so far may appear to be only an incremental improvement over existing workflows, especially in languages like Ruby, Python, and PHP. After all, these and other languages can interactively load code, and can, in general, redefine various constructs when they are deployed in a long-running environment. The parallels only go so deep, though:</p><p class="calibre18"><span class="bold">Clojure does not require a file-based workflow</span>. Python, Ruby, and PHP require that code be available on disk in order for it to be loaded.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1451909"></a><a href="#filepos1457303"><span class="calibre32">311</span></a><span class="calibre32">]</span></small></sup> While that’s a perfectly reasonable option when using Clojure—as we alluded to in our previous example, you can use the <tt class="calibre22">:reload</tt><a id="filepos1452145"></a> option when requiring a previously loaded namespace—it is by no means required. You can load code into a Clojure process without ever touching disk, either via direct REPL interaction (a.k.a. typing), or by using the REPL-oriented commands provided by your Clojure development environment to load files, namespaces, or entire projects at will.</p><p class="calibre18"><span class="bold">Clojure’s dynamicism is explicitly provided for by the language and runtime</span>. Many of the foundational aspects of Clojure’s design explicitly encourage (or, <span class="italic">do not discourage</span>) dynamic redefinition <a id="filepos1452745"></a>of its constructs at runtime. The reification of namespaces and vars, the primacy of <span class="italic">loading code</span> versus requiring that code be available on disk or in an editor buffer, the widespread use of runtime bytecode generation and class loading, the narrowing of the space between compile time and runtime—these and many other metafeatures of Clojure conspire to make it usable as a persistent canvas upon which you may sketch your vision.</p><p class="calibre18">This may simply sound like hype…unless you have experienced a Clojure development environment equipped with nominal REPL facilities. Such environments allow you to readily pair your text editor to one or more persistent running REPLs. This pairing allows you to effortlessly move between writing code in an editor (or two, or nine)—where you can send single expressions or entire files’ worth of code from that editor to your persistent REPL with a single keystroke—and interacting with the state of the Clojure runtime associated with that REPL in order to check intermediate results, experiment with half-formed ideas without sullying our projects’ “real” source code, and in general interrogate the Clojure runtime to verify your work and guide your next steps. It is not uncommon for Clojure programmers to use the same JVM/Clojure process for days, incrementally modifying the runtime and their application’s loaded code until its behavior meets their expectations and the tests they’ve defined.</p><p class="calibre18">At its best, this experience has sometimes been referred to as <span class="italic">flow</span><a id="filepos1454349"></a>, a state wherein one’s focus, clarity of vision, and ready access to critical information enables a heightened degree of ability, sense of control, and breadth of perspective. Clojure certainly doesn’t have the market on flow cornered; programmers have described enjoying this state when using all sorts of languages. However, it’s not unreasonable to speculate that Clojure enables it more than most, thanks in no small part to its rich REPL capabilities and experience, and thus its tighter feedback loop between program and programmer. This was discussed at length in a talk at the 2010 Clojure Conj:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1455001"></a><a href="#filepos1457620"><span class="calibre32">312</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><span class="italic">Programming with a REPL is more like mentoring a partner in some ways. We can investigate its current state, what is happening with the machine, what our algorithms are doing underneath—all in a very rich way with the REPL.</span></span></blockquote><blockquote class="calibre63"><span class="calibre10">—Tom Faulhaber, </span><span class="calibre10"><span class="italic">Lisp, Functional Programming, and the State of Flow</span></span></blockquote><p class="calibre23">Once you have an understanding of how the REPL works, and a sense of how it might be utilized in your programming practice, the best way to encourage this sort of experience is to make sure your toolchain is in order.<a id="filepos1455833"></a></p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1455937"></a><a href="#filepos1444036"><span class="calibre32">309</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">The organization of Clojure codebases and the classpath concept are both described in </span><a href="#filepos1132603"><span class="calibre10"><span class="calibre5">Chapter 8</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1456318"></a><a href="#filepos1448057"><span class="calibre32">310</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">In the latter case, you would simply add the </span><span class="calibre10"><tt class="calibre22">JOptionPane</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">JTextArea</tt></span><span class="calibre10"> imports to the </span><span class="calibre10"><tt class="calibre22">:import</tt></span><span class="calibre10"> declaration in the file’s </span><span class="calibre10"><tt class="calibre22">ns</tt></span><span class="calibre10"> form; loading the file will cause these additional class dependencies to be imported into the namespace. If you provide the </span><span class="calibre10"><tt class="calibre22">:reload-all</tt></span><span class="calibre10"> flag to </span><span class="calibre10"><tt class="calibre22">require</tt></span><span class="calibre10"> here, it would further cause all </span><span class="calibre10"><tt class="calibre22">:require</tt></span><span class="calibre10">d or </span><span class="calibre10"><tt class="calibre22">:use</tt></span><span class="calibre10">d namespaces to be transitively reloaded as well.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1457303"></a><a href="#filepos1451909"><span class="calibre32">311</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">This isn’t technically true in Ruby’s case, but many tools and the cultural norms surrounding Ruby do push it in this direction.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1457620"></a><a href="#filepos1455001"><span class="calibre32">312</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Video and slides available at </span><a href="http://blip.tv/clojure/tom-faulhaber-lisp-functional-programming-and-the-state-of-flow-4539472"><span class="calibre10"><span class="calibre5">http://blip.tv/clojure/tom-faulhaber-lisp-functional-programming-and-the-state-of-flow-4539472</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos1458065" class="calibre6"><span class="calibre4"><span class="bold">Tooling</span></span></p><p id="filepos1458133" class="calibre18">Because of the complexity and verbosity of Java, “Java tooling” has always implied the use of truly <a id="filepos1458265"></a>Integrated Development Environments (IDEs) like Eclipse and IntelliJ IDEA: extensive code completion, refactoring, class hierarchy visualization, and other features aren’t just niceties, they are hard requirements for most Java programmers. In contrast, dynamic programming languages (including Python and Ruby) generally demand only a capable text editor and a command prompt. Most Clojure programmers hew closer to the latter model,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1458743"></a><a href="#filepos1497252"><span class="calibre32">313</span></a><span class="calibre32">]</span></small></sup> with one key difference: while a capable text editor is a must, having access to a Clojure REPL—preferably well-integrated into one’s editor and other facilities—is at least as important, if not more so.</p><p class="calibre18">Thankfully, accomplishing this is a straightforward task, and so reasonable Clojure support is available for a variety of popular editors (like Emacs, vim, TextMate, jEdit, and so on) as well as IDEs (like Eclipse, Intellij IDEA, and NetBeans). Getting started with any of these options is fairly easy;<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1459417"></a><a href="#filepos1497636"><span class="calibre32">314</span></a><span class="calibre32">]</span></small></sup> all other things being equal, we recommend using the tools you’re already most comfortable with and that fit best into your existing style and workflow.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1459702"></a><a href="#filepos1498023"><span class="calibre32">315</span></a><span class="calibre32">]</span></small></sup> To give you some starting point for comparison, we’ll briefly give an overview of the Clojure support provided by the two most popular tools used in the community that each represent orthogonal approaches to Clojure tooling (and tooling in general, perhaps): Eclipse and Emacs.</p><p class="calibre18">First, let’s take a look at some of the basic practical tools that all Clojure REPLs provide that you’ll want to be familiar with to enhance your programming experience.</p><p id="filepos1460286" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">The Bare REPL</span></span></span></p><p id="filepos1460389" class="calibre18">You’ll be using the Clojure REPL on a daily basis, and that means using its basic utilities. Regardless of whether you’re using the most basic text editor with a REPL in a separate command line or the largest IDE with integrated REPL sessions, these utilities will be available and indispensable.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1460752"></a><a href="#filepos1498636"><span class="calibre32">316</span></a><span class="calibre32">]</span></small></sup></p><p id="filepos1460851" class="calibre18"><span class="bold">REPL-bound vars</span>. <a id="filepos1460904"></a>There are a number of vars that are typically only bound within a REPL session that provide conveniences necessary in an interactive environment.</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">*1</tt>, <tt class="calibre22">*2</tt>, and <tt class="calibre22">*3</tt> hold the values of the most recently evaluated expressions. For example, <tt class="calibre22">*1</tt> corresponds to <tt class="calibre22">_</tt> in Ruby and Python.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">*e</tt> provides the last uncaught exception that occurred in the REPL session. This is similar to the tuple of <tt class="calibre22">sys.last_type</tt>, <tt class="calibre22">sys.last_value</tt>, and <tt class="calibre22">sys.last_traceback</tt> in Python.</blockquote></li></ul><p class="calibre18">These vars and the automatic management of them can be very handy while interactively exploring APIs and your data:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(split-with keyword? [:a :b :c 1 2 3])<br class="calibre33"/>;= [(:a :b :c) (1 2 3)]<br class="calibre33"/>(zipmap (first *1) (second *1))<br class="calibre33"/>;= {:c 3, :b 2, :a 1}<br class="calibre33"/>(apply zipmap (split-with keyword? [:a :b :c 1 2 3]))<br class="calibre33"/>;= {:c 3, :b 2, :a 1}</tt></span></blockquote><p class="calibre23"><tt class="calibre22">clojure.repl/pst</tt> will print the stack trace of any exception provided, but will use the one bound to <tt class="calibre22">*e</tt> by default:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(throw (Exception. "foo"))<br class="calibre33"/>;= Exception foo  user/eval1 (NO_SOURCE_FILE:1)<br class="calibre33"/>(pst)<br class="calibre33"/>; Exception foo<br class="calibre33"/>;   user/eval1 (NO_SOURCE_FILE:1)<br class="calibre33"/>;   clojure.lang.Compiler.eval (Compiler.java:6465)<br class="calibre33"/>; ...</tt></span></blockquote><p class="calibre23"><span class="bold">clojure.repl</span>. <a id="filepos1462720"></a>Speaking of <tt class="calibre22">clojure.repl</tt>, it provides a bunch of utilities that are very handy at the REPL. You saw <tt class="calibre22">pst</tt> above; there’s also <tt class="calibre22">apropos</tt>, which shows you which functions in loaded namespaces match a given regular expression or string:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(apropos #"^ref")<br class="calibre33"/>;= (ref-max-history refer-clojure ref-set <br class="calibre33"/>;=  ref-history-count ref ref-min-history refer)</tt></span></blockquote><p class="calibre23"><tt class="calibre22">find-doc</tt><a id="filepos1463250"></a> does much the same, except it searches within documentation and prints all of the information associated with matching vars.</p><p class="calibre18">There’s also <tt class="calibre22">source</tt><a id="filepos1463444"></a>, which prints the source code of any function that was loaded from source:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(source merge)<br class="calibre33"/>; (defn merge<br class="calibre33"/>;   "Returns a map that consists of the rest of the maps conj-ed onto<br class="calibre33"/>;   the first.  If a key occurs in more than one map, the mapping from<br class="calibre33"/>;   the latter (left-to-right) will be the mapping in the result."<br class="calibre33"/>;   {:added "1.0"<br class="calibre33"/>;    :static true}<br class="calibre33"/>;   [&amp; maps]<br class="calibre33"/>;   (when (some identity maps)<br class="calibre33"/>;     (reduce1 #(conj (or %1 {}) %2) maps)))</tt></span></blockquote><p class="calibre23">Finally, there’s <tt class="calibre22">doc</tt><a id="filepos1464185"></a>, which prints only the documentation for a given var; and <tt class="calibre22">dir</tt>, which prints a list of the public vars declared in the given namespace:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(require 'clojure.string)<br class="calibre33"/>;= nil<br class="calibre33"/>(dir clojure.string)<br class="calibre33"/>; blank?<br class="calibre33"/>; capitalize<br class="calibre33"/>; escape<br class="calibre33"/>; join<br class="calibre33"/>; lower-case<br class="calibre33"/>; replace<br class="calibre33"/>; replace-first<br class="calibre33"/>; reverse<br class="calibre33"/>; split<br class="calibre33"/>; split-lines<br class="calibre33"/>; trim<br class="calibre33"/>; trim-newline<br class="calibre33"/>; triml<br class="calibre33"/>; trimr<br class="calibre33"/>; upper-case</tt></span></blockquote><p class="calibre23">It is a rare Clojure REPL that doesn’t start with <tt class="calibre22">clojure.repl</tt> loaded with its useful functions always available.</p><p id="filepos1464944" class="calibre23"><span class="calibre53"><span class="bold">Introspecting namespaces</span></span></p><p id="filepos1465029" class="calibre18">Namespaces are entities of their own, just as concrete and malleable as any data structure. There are a number of functions you can use to introspect and modify namespaces in the REPL; let’s look at some of them.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1465306"></a><a href="#filepos1499843"><span class="calibre32">317</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">Note that, most of the time, you’ll not have to touch these functions at all. However, if you have mistakenly defined some functions or data in a namespace, you can use these functions to find and potentially remove the offending definitions. This can help you to get out of some situations that would otherwise require restarting your application or REPL session, such as needing to define a <tt class="calibre22">deftype</tt> type with the same name as an existing Java class that you’ve already imported into a namespace.</p><p class="calibre18"><span class="bold">ns-map, ns-imports, ns-refers, ns-publics, ns-aliases, ns-interns</span>. <a id="filepos1466050"></a>These functions all return a map of symbols that have been mapped within the given namespace to either a var or imported class. That is, where <tt class="calibre22">refer</tt> and <tt class="calibre22">import</tt> and <tt class="calibre22">def</tt> register symbols within a namespace, these functions report on those different kinds of mappings.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(ns clean-namespace)<br class="calibre33"/>;= nil<br class="calibre33"/>(ns-aliases *ns*)<br class="calibre33"/>;= {}<br class="calibre33"/>(require '[clojure.set :as set])<br class="calibre33"/>;= nil<br class="calibre33"/>(ns-aliases *ns*)<br class="calibre33"/>;= {set #&lt;Namespace clojure.set&gt;}<br class="calibre33"/>(ns-publics *ns*)<br class="calibre33"/>;= {}<br class="calibre33"/>(def x 0)<br class="calibre33"/>;= #'clean-namespace/x<br class="calibre33"/>(ns-publics *ns*)<br class="calibre33"/>;= {x #'clean-namespace/x}</tt></span></blockquote><p class="calibre23"><span class="bold">ns-unmap, ns-unalias</span>. <a id="filepos1466867"></a>The former can be used to remove mappings of symbols to vars or imported classes, while the latter will remove a namespace alias.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(ns-unalias *ns* 'set)<br class="calibre33"/>;= nil<br class="calibre33"/>(ns-aliases *ns*)<br class="calibre33"/>;= {}<br class="calibre33"/>(ns-unmap *ns* 'x)<br class="calibre33"/>;= nil<br class="calibre33"/>(ns-publics *ns*)<br class="calibre33"/>;= {}</tt></span></blockquote><p class="calibre23"><span class="bold">remove-ns</span>. <a id="filepos1467304"></a>This is the “nuclear option” of namespace management. Where <tt class="calibre22">ns<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1467416"></a><a href="#filepos1500153"><span class="calibre32">318</span></a><span class="calibre32">]</span></small></sup></tt> will create a namespace, <tt class="calibre22">remove-ns</tt> will drop one from Clojure’s authoritative namespace map.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(in-ns 'user)<br class="calibre33"/>;= #&lt;Namespace user&gt;<br class="calibre33"/>(filter #(= 'clean-namespace (ns-name %)) (all-ns))<br class="calibre33"/>;= (#&lt;Namespace clean-namespace&gt;)<br class="calibre33"/>(remove-ns 'clean-namespace)<br class="calibre33"/>;= #&lt;Namespace clean-namespace&gt;<br class="calibre33"/>(filter #(= 'clean-namespace (ns-name %)) (all-ns))<br class="calibre33"/>;= ()</tt></span></blockquote><p class="calibre23">This means that all code and data defined in vars interned in the dropped namespace become inaccessible, and <span class="italic">eligible</span> for garbage collection. Of course, if some reference to a function, protocol, or data defined in the dropped namespace is being held elsewhere, it will not be garbage-collected.</p><blockquote id="filepos1468371" class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">STRUCTURAL EDITING OF CLOJURE SOURCE CODE</span></span></span></blockquote><blockquote id="filepos1468533" class="calibre17"><span class="calibre10">While we are decidedly egalitarian when it comes to others’ choice of text editors, there is one particular facility that is so compelling when editing Clojure source code that we must mention it: </span><span class="calibre10"><span class="italic">paredit</span></span><a id="filepos1468827"></a><span class="calibre10">, an editing mode that originated in the Emacs community that simplifies the editing of s-expressions, and is something that many Clojure programmers consider a must-have.</span></blockquote><blockquote class="calibre17"><span class="calibre10">Most high-quality Java editors provide various structural selection facilities, such as automatically inserting pairs of braces or expanding your selection to include the enclosing element, expression, or scope. paredit provides Clojure equivalents, and most implementations go far beyond the concepts supported in Java editors to include things like moving your cursor or selection one s-expression at a time, moving whole expressions around, and automatically wrapping selected expressions with braces, brackets, or parentheses as needed to ensure that your source code is structurally sound.</span></blockquote><blockquote class="calibre17"><span class="calibre10">In short, if you ever find it difficult to edit Clojure code—for example, easily selecting individual s-expressions or maintaining matching parentheses, braces, or brackets—you would almost certainly benefit from using your editor’s paredit-style features, or switching to an editor that provides them (most do).</span><a id="filepos1470083"></a></blockquote><p id="filepos1470103" class="calibre25"><span class="calibre19"><span class="bold"><span class="calibre5">Eclipse</span></span></span></p><p id="filepos1470200" class="calibre18">Eclipse—paired with Counterclockwise,<a id="filepos1470267"></a><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1470309"></a><a href="#filepos1500424"><span class="calibre32">319</span></a><span class="calibre32">]</span></small></sup> a plug-in that provides Clojure support within Eclipse—provides a comprehensive set of features for Clojure development: editing, code completion, REPL integration, introspection, debugging, and profiling. Eclipse certainly can’t be considered lightweight, but in exchange, it does provide a compelling mix of tooling that is perhaps more approachable and accommodating for many programmers that appreciate familiar and discoverable user interfaces. In addition, if you need to work with Java as well as Clojure, possibly in the same project, then it is hard to beat (or, relinquish) the Java facilities that only IDEs like Eclipse offer.</p><p class="calibre18"><span class="bold">Clojure editing</span>. <a id="filepos1471104"></a>While Counterclockwise’s Clojure editing support is not quite as sophisticated as that provided by Emacs, it is nonetheless very capable and among the best available. It provides a partial implementation of paredit,<a id="filepos1471328"></a><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1471370"></a><a href="#filepos1501101"><span class="calibre32">320</span></a><span class="calibre32">]</span></small></sup> excellent syntax highlighting, and a boatload of useful text-editing facilities it inherits from Eclipse. Each Clojure editor also feeds into Eclipse’s standard “outline” view, which maintains a listing of all of the top-level expressions (usually function definitions) contained in the current file:</p><p class="calibre51"><img src="images/00002.jpg" class="calibre109"/></p><p class="calibre13">Eclipse and Counterclockwise provide a lot of hints within their respective interfaces to help you along in learning things like which commands are available and what the default keyboard shortcuts are in various contexts (some of which are different on different operating systems). For help at any time, refer to the “Clojure” menu (and contextual menu in editors) that Counterclockwise adds to Eclipse, as well as the Clojure editor reference page available by choosing “Dynamic Help” from the “Help” menu when any Clojure file is open.</p><p class="calibre18"><span class="bold">REPL integration</span>. Counterclockwise uses nREPL<a id="filepos1472557"></a><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1472599"></a><a href="#filepos1501454"><span class="calibre32">321</span></a><span class="calibre32">]</span></small></sup> (a Clojure REPL server and client library that is used by other Clojure tooling and is easily embeddable in Clojure applications) as the basis of its REPL integration. This allows you to connect and interact with any Clojure application running an nREPL server, which includes all the Clojure processes that you launch through Eclipse and Counterclockwise. Beyond being able to evaluate expressions, Counterclockwise’s REPLs are integrated with the editor, allowing you to load code from open files and based on current selections, and include support for command history and code completion:</p><p class="calibre51"><img src="images/00008.jpg" class="calibre110"/></p><p class="calibre13">Once you have a running REPL, the same code completion as well as jump-to-definition actions become available in editors associated with the running REPL’s project.</p><p class="calibre18"><span class="bold">Namespace browsing</span>. <a id="filepos1473664"></a>Counterclockwise also provides a graphical namespace browser. This view allows you to browse and search through all of the namespaces and vars loaded and defined in the Clojure environment to which the current REPL is connected:</p><p class="calibre51"><img src="images/00049.jpg" class="calibre111"/></p><p class="calibre13">You can filter the list of vars (optionally using a regular expression as shown above). Hovering over a var name will display its documentation in a pop up; double-clicking will open the file the var is defined within and go to its definition.<a id="filepos1474291"></a></p><p id="filepos1474302" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Emacs</span></span></span></p><p id="filepos1474397" class="calibre18">Emacs (<a href="http://www.gnu.org/s/emacs/"><span class="calibre5">http://www.gnu.org/s/emacs/</span></a>) is a powerful and extensible text editor that has been a mainstay of Lisp programming for decades. Clojure support for Emacs is achieved by combining a number of modular tools and libraries.</p><p class="calibre18">There are two primary ways to work with Clojure in Emacs: <tt class="calibre22">inferior-lisp</tt> and SLIME. Both methods depend on having <tt class="calibre22">clojure-mode</tt> installed.</p><blockquote class="calibre38"></blockquote><blockquote class="calibre39"><span class="calibre10"><span class="bold">A PRIMER ON EMACS JARGON</span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Emacs predates most modern software, and this shows in some of the terminology used to refer to its commands and features.</span></blockquote><table border="1" valign="top" class="calibre40"><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><blockquote class="calibre112"><span class="calibre21">Buffer </span></blockquote></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><blockquote class="calibre112"><span class="calibre21">A named Emacs object that represents something editable, usually a file in your filesystem, but also the Clojure REPL or debugger, for example. </span></blockquote></td></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><blockquote class="calibre112"><span class="calibre21">Window </span></blockquote></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><blockquote class="calibre112"><span class="calibre21">A pane or editing area in Emacs. Emacs can be split to view multiple files (or multiple files + a REPL buffer) at once. </span></blockquote></td></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><blockquote class="calibre112"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">M-x foo</tt></span><span class="calibre21">
</span></blockquote></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><blockquote class="calibre112"><span class="calibre21">Hold the Meta key (usually Alt or Option) on your keyboard, press and release  </span><span class="calibre21"><tt class="calibre22">x</tt></span><span class="calibre21">, then release Meta. A prompt will appear where you can type the command </span><span class="calibre21"><tt class="calibre22">foo</tt></span><span class="calibre21"> and press Enter.</span></blockquote></td></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><blockquote class="calibre112"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">C-k</tt></span><span class="calibre21">
</span></blockquote></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><blockquote class="calibre112"><span class="calibre21">Hold the Control key (usually Control or Ctrl) on your keyboard, press and release  </span><span class="calibre21"><tt class="calibre22">k</tt></span><span class="calibre21">, release Control.</span></blockquote></td></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><blockquote class="calibre112"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">C-M-x</tt></span><span class="calibre21">
</span></blockquote></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><blockquote class="calibre112"><span class="calibre21">Hold both Control and Meta, press and release  </span><span class="calibre21"><tt class="calibre22">x</tt></span><span class="calibre21">, release Control and Meta.</span></blockquote></td></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><blockquote class="calibre112"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">C-x C-e</tt></span><span class="calibre21">
</span></blockquote></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><blockquote class="calibre112"><span class="calibre21">Hold the Control key, press and release  </span><span class="calibre21"><tt class="calibre22">x</tt></span><span class="calibre21">, press and release </span><span class="calibre21"><tt class="calibre22">e</tt></span><span class="calibre21">, and then release Control.</span></blockquote></td></tr></table><blockquote class="calibre35"><span class="calibre10">More information can be found in the Emacs manual at </span><a href="http://www.gnu.org/software/emacs/manual/emacs.html"><span class="calibre10"><span class="calibre5">http://www.gnu.org/software/emacs/manual/emacs.html</span></span></a><span class="calibre10">.</span></blockquote><p id="filepos1479259" class="calibre75"><span class="calibre53"><span class="bold">clojure-mode and paredit</span></span></p><p id="filepos1479345" class="calibre18">Whether you use <tt class="calibre22">inferior-lisp</tt> or SLIME, <tt class="calibre22">clojure-mode</tt> and <tt class="calibre22">paredit</tt> are essential.</p><p class="calibre18"><tt class="calibre22">clojure-mode</tt> (<a href="https://github.com/technomancy/clojure-mode"><span class="calibre5">https://github.com/technomancy/clojure-mode</span></a>) provides Emacs with Clojure-specific editor functionality like syntax-highlighting, indentation, and code navigation. It also includes the helpful <tt class="calibre22">clojure-test-mode</tt>, which provides added shortcuts for automated testing using <tt class="calibre22">clojure.test</tt>. Instructions for setting up <tt class="calibre22">clojure-mode</tt> are found on its main project page.</p><p class="calibre18">In addition to <tt class="calibre22">clojure-mode</tt>, the aforementioned <tt class="calibre22">paredit.el</tt> (<a href="http://www.emacswiki.org/emacs/ParEdit"><span class="calibre5">http://www.emacswiki.org/emacs/ParEdit</span></a>) is a must-have minor mode for Emacs that provides support for automatic handling of parentheses; it is included in Emacs.</p><p id="filepos1480365" class="calibre23"><span class="calibre53"><span class="bold">inferior-lisp</span></span></p><p class="calibre18"><tt class="calibre22">inferior-lisp<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1480519"></a><a href="#filepos1501780"><span class="calibre32">322</span></a><span class="calibre32">]</span></small></sup></tt><a id="filepos1480619"></a> is the most basic way to use Clojure in Emacs. It is used to start a Clojure REPL in a subprocess, and displays this REPL in an Emacs buffer. You can use this REPL like any you might work with on a command line, but <tt class="calibre22">inferior-lisp</tt> also allows you to interactively send Clojure code from open source files in buffers to that REPL.</p><p class="calibre18">One advantage of <tt class="calibre22">inferior-lisp</tt> over SLIME <a id="filepos1481047"></a>is that <tt class="calibre22">inferior-lisp</tt> is built into Emacs, and setup involves setting a single variable in your Emacs configuration file (or via <tt class="calibre22">M-:</tt>) to tell Emacs how to invoke Clojure:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(setq inferior-lisp-program "lein repl")</tt></span></blockquote><p class="calibre23">The value of <tt class="calibre22">inferior-lisp-program</tt> can be a Leiningen invocation as above, an invocation of Java, or any other command that starts a Clojure REPL such as <tt class="calibre22">mvn clojure:repl</tt>, and so on. Once set, a Clojure REPL can then be started by executing the command <tt class="calibre22">C-c C-z</tt>. Note that the command in <tt class="calibre22">inferior-lisp-program</tt> is run in Emacs’ current directory; depending on where you started Emacs, you may need to set its current directory (via <tt class="calibre22">M-x cd</tt>) before starting the <tt class="calibre22">inferior-lisp</tt> process. This is the fastest and easiest way to get Clojure up and running in Emacs:</p><p class="calibre51"><img src="images/00050.jpg" class="calibre113"/></p><p class="calibre13">Editing support is very basic compared to SLIME, but it may be all you need. The most common workflow <a id="filepos1482261"></a>when editing Clojure code in Emacs is to have one or more Emacs windows containing your source code, and an additional Emacs window containing a REPL buffer. Code can be edited in one window, and then sent to the REPL via one of many commands. Both <tt class="calibre22">inferior-lisp</tt> and SLIME offer this capability, though the commands differ (see <a href="#filepos1482677"><span class="calibre5">Table 10-1</span></a>).</p><p id="filepos1482677" class="calibre3"></p><p class="calibre1"><span class="italic">Table 10-1. inferior-lisp</span></p><table border="1" valign="top" class="calibre40"><tr border="1" valign="top" class="calibre27"><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Keystroke </span></span></span></th><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> </span></span></span><span class="calibre21"><tt class="calibre22"><span class="bold"><span class="calibre7">M-x </span></span></tt></span><span class="calibre21"><span class="bold"><span class="calibre7"> command</span></span></span></th><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Description </span></span></span></th></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">C-c C-z</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">run-lisp</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Start the configured  </span><span class="calibre21"><tt class="calibre22">inferior-lisp</tt></span><span class="calibre21"> process with the command set in </span><span class="calibre21"><tt class="calibre22">inferior-lisp-program</tt></span><span class="calibre21">.</span></p></td></tr><tr border="1" valign="top" class="calibre43"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">C-M-x</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">lisp-eval-defun</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Evaluate the top-level form (such as a  </span><span class="calibre21"><tt class="calibre22">defn</tt></span><span class="calibre21"> expression) under the cursor.</span></p></td></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">C-x C-e</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">lisp-eval-last-sexp</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Evaluate the s-expression that precedes the cursor. </span></p></td></tr><tr border="1" valign="top" class="calibre43"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">C-c C-l</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">clojure-load-file</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Load the current file in its entirety. </span></p></td></tr></table><p id="filepos1486252" class="calibre23"><span class="calibre53"><span class="bold">SLIME</span></span></p><p class="calibre18">SLIME<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1486386"></a><a href="#filepos1502315"><span class="calibre32">323</span></a><span class="calibre32">]</span></small></sup><a id="filepos1486481"></a> is an Emacs library that provides advanced editing and REPL capabilities for many Lisps, including (but not limited to) Clojure. SLIME provides a more comprehensive development experience compared to <tt class="calibre22">inferior-lisp</tt> including a persistent command history, code completion, namespace introspection, a debugger, and so on.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Emacs’ extensibility can be both a boon and a bane. Emacs can probably do anything you could possibly imagine a text editor doing, but setting it up to do so can be a daunting task.</span><a id="filepos1487190"></a></blockquote><blockquote class="calibre17"><span class="calibre10">In particular, setup instructions for SLIME and other Clojure-related tools for Emacs have changed repeatedly and rapidly as Clojure support for Emacs has evolved and matured. The Internet is currently littered with old blog posts and wiki entries giving outdated methods for setting up Clojure support in Emacs.</span></blockquote><blockquote class="calibre17"><span class="calibre10">We suggest heading straight to </span><a href="http://dev.clojure.org/display/doc/Getting+Started+with+Emacs"><span class="calibre10"><span class="calibre5">http://dev.clojure.org/display/doc/Getting+Started+with+Emacs</span></span></a><span class="calibre10"> for installation and setup instructions, a wiki page that is consistently kept up to date by the maintainers of the various projects that provide Clojure support within Emacs.</span></blockquote><p class="calibre25">In order to use SLIME, your Clojure project must be configured to provide a <span class="italic">swank</span> server; a corollary to nREPL, swank is SLIME’s REPL interaction protocol. The easiest way to do this is to use <tt class="calibre22">lein</tt> to add <tt class="calibre22">swank-clojure</tt> (a Clojure implementation of swank) as a development-time dependency to your Leiningen project:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">lein plugin install lein-swank 1.4.3</tt></span></blockquote><p class="calibre23">…or, you can add it to your <span class="italic">project.clj</span> file’s vector of plug-ins permanently:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">[lein-swank "1.4.3"]</tt></span></blockquote><p class="calibre23">SLIME can then be invoked from within Emacs via <tt class="calibre22">M-x clojure-jack-in</tt> once you have a file from the project for which you’d like to start the REPL open in the current buffer. If anything goes awry, be sure to check <a href="http://dev.clojure.org/display/doc/Getting+Started+with+Emacs"><span class="calibre5">http://dev.clojure.org/display/doc/Getting+Started+with+Emacs</span></a> for the latest instructions.</p><p class="calibre18">You can use all of the keybindings provided by <tt class="calibre22">inferior-lisp</tt> in SLIME, but the latter provides many more commands for sending code from a buffer to a running REPL and performing various operations and introspections within the context of the current file and within the Clojure/SLIME environment. Some examples are shown in <a href="#filepos1489683"><span class="calibre5">Table 10-2</span></a>.</p><p id="filepos1489683" class="calibre3"></p><p class="calibre1"><span class="italic">Table 10-2. Common SLIME commands and their key bindings</span></p><table border="1" valign="top" class="calibre40"><tr border="1" valign="top" class="calibre27"><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Keystroke </span></span></span></th><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> </span></span></span><span class="calibre21"><tt class="calibre22"><span class="bold"><span class="calibre7">M-x </span></span></tt></span><span class="calibre21"><span class="bold"><span class="calibre7"> command</span></span></span></th><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Description </span></span></span></th></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">C-c C-c</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">slime-compile-defun</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Evaluate the top-level form under the cursor. </span></p></td></tr><tr border="1" valign="top" class="calibre43"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">C-c C-k</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">slime-compile-and-load-file</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Load the current file in its entirety. </span></p></td></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">M-.</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">slime-edit-definition</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Jump to the definition of the symbol under the cursor. </span></p></td></tr><tr border="1" valign="top" class="calibre43"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">C-c C-m</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">slime-macroexpand-1</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">macroexpand-1</tt></span><span class="calibre21"> the expression following the cursor.</span></p></td></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">C-c M-m</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">slime-macroexpand-all</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">macroexpand-all</tt></span><span class="calibre21"> the expression following the cursor.</span></p></td></tr><tr border="1" valign="top" class="calibre43"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">C-c I</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">slime-inspect</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Display a navigable representation of the value of a given symbol or class. </span></p></td></tr></table><p class="calibre23"><span class="bold">The inspector</span>. <a id="filepos1494635"></a>Finding your way through the contours of a data structure or API can sometimes be daunting, especially when using some Java libraries. SLIME provides a way to visualize Clojure collections and Java objects and classes through its <span class="italic">inspector</span>. Just key <tt class="calibre22">C-c I</tt> and type in the symbol or expression for which you would like to inspect the value—or, put your cursor on a symbol of interest and type the keystroke:</p><p class="calibre51"><img src="images/00038.jpg" class="calibre113"/></p><p class="calibre13">You can do the same thing within values and classes included in the output of the inspector (or just hit return with your cursor over a symbol or value of interest), thus making it easy to visually dig through complicated APIs or large data structures.</p><p class="calibre18"><span class="bold">Debugging</span>. <a id="filepos1495518"></a>When an exception is thrown at a SLIME REPL, you’ll be dumped into the SLIME debugger. The debugger can also be invoked by manually setting breakpoints in your code:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn debug-me<br class="calibre33"/>  [x y]<br class="calibre33"/>  (let [z (merge x y)]<br class="calibre33"/>    (swank.core/break)))</tt></span></blockquote><p class="calibre23">Running <tt class="calibre22">(debug-me {:a 5} {"b" 5/6})</tt> will give you something like <a href="#filepos1496059"><span class="calibre5">Figure 10-1</span></a>.</p><blockquote id="filepos1496059" class="calibre47"></blockquote><blockquote class="calibre48"><img src="images/00055.jpg" class="calibre114"/></blockquote><blockquote class="calibre47"><span class="calibre10"><span class="italic"><span class="calibre7">Figure 10-1. The SLIME debugger in action</span></span></span></blockquote><p class="calibre50">Clicking parts of the backtrace causes locals and their values to be displayed as in the inspector, and you can dig into those values in the same ways as well.</p><p class="calibre18">Of course, when a debugger is active, Clojure is still live, and the REPL is still active, so arbitrary expressions can be evaluated: your program’s current state can be inspected or tweaked, functions can be defined or redefined, and so on. In particular, the locals in scope from a <tt class="calibre22">swank.core/break</tt> call can be accessed and manipulated in the SLIME REPL while the thread of execution that hit the breakpoint remains paused. This is a big advantage of programming in an interactive environment.<a id="filepos1497148"></a></p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1497252"></a><a href="#filepos1458743"><span class="calibre32">313</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Many Clojure programming environments provide things like code completion and such as well, but we’re talking about minimum expectations here, not the open set of what exists and what is desirable.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1497636"></a><a href="#filepos1459417"><span class="calibre32">314</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="http://dev.clojure.org/display/doc/Clojure+Tools"><span class="calibre10"><span class="calibre5">http://dev.clojure.org/display/doc/Clojure+Tools</span></span></a><span class="calibre10"> for pointers.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1498023"></a><a href="#filepos1459702"><span class="calibre32">315</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">To stress the point: even if you’re most comfortable with </span><span class="calibre10"><span class="italic">notepad.exe</span></span><span class="calibre10">, you should use it as long as you have a REPL at the ready in a nearby terminal window. We think there are better options, and you may think so as well after a time, but there are few things more frustrating than trying to learn both a new programming language and a new set of tools all at the same time.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1498636"></a><a href="#filepos1460752"><span class="calibre32">316</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">If you happen to be starting your REPL on the command line (i.e., via a direct </span><span class="calibre10"><tt class="calibre22">java</tt></span><span class="calibre10"> invocation) instead of using the REPL provided by Leiningen, Counterclockwise, Emacs, or really any other Clojure tool beyond the console, then you will almost certainly want one of JLine (</span><a href="http://jline.sourceforge.net"><span class="calibre10"><span class="calibre5">http://jline.sourceforge.net</span></span></a><span class="calibre10">) or </span><span class="calibre10"><tt class="calibre22">rlwrap</tt></span><span class="calibre10"> (</span><a href="http://utopia.knoware.nl/~hlub/rlwrap/"><span class="calibre10"><span class="calibre5">http://utopia.knoware.nl/~hlub/rlwrap/</span></span></a><span class="calibre10">). Clojure’s built-in REPL does not provide things like command recall (i.e., hitting cursor-up to bring up the prior line sent to the REPL) or inline editing of the text not yet sent to the REPL; both JLine or </span><span class="calibre10"><tt class="calibre22">rlwrap</tt></span><span class="calibre10"> will add such capabilities to that built-in REPL.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1499843"></a><a href="#filepos1465306"><span class="calibre32">317</span></a><span class="calibre32">] </span></small></sup><span class="calibre10"><tt class="calibre22">(apropos #"(ns-|-ns)")</tt></span><span class="calibre10"> will provide you with a more complete list you can explore on your own.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1500153"></a><a href="#filepos1467416"><span class="calibre32">318</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Or, far less commonly, </span><span class="calibre10"><tt class="calibre22">create-ns</tt></span><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1500424"></a><a href="#filepos1470309"><span class="calibre32">319</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Go to </span><a href="http://dev.clojure.org/display/doc/Getting+Started+with+Eclipse+and+Counterclockwise"><span class="calibre10"><span class="calibre5">http://dev.clojure.org/display/doc/Getting+Started+with+Eclipse+and+Counterclockwise</span></span></a><span class="calibre10"> to get started; the Counterclockwise project home is at </span><a href="http://code.google.com/p/counterclockwise/"><span class="calibre10"><span class="calibre5">http://code.google.com/p/counterclockwise/</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1501101"></a><a href="#filepos1471370"><span class="calibre32">320</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Described earlier in </span><a href="#filepos1468371"><span class="calibre10"><span class="calibre5">“Structural editing of Clojure source code”</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1501454"></a><a href="#filepos1472599"><span class="calibre32">321</span></a><span class="calibre32">] </span></small></sup><a href="http://github.com/clojure/tools.nrepl"><span class="calibre10"><span class="calibre5">http://github.com/clojure/tools.nrepl</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1501780"></a><a href="#filepos1480519"><span class="calibre32">322</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Named as such not to make a connotation regarding its quality, but to indicate that the Lisp being used is in a subprocess started by Emacs: </span><a href="http://www.gnu.org/s/libtool/manual/emacs/External-Lisp.html"><span class="calibre10"><span class="calibre5">http://www.gnu.org/s/libtool/manual/emacs/External-Lisp.html</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1502315"></a><a href="#filepos1486386"><span class="calibre32">323</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">An acronym of </span><span class="calibre10"><span class="italic">Superior Lisp Interaction Mode for Emacs</span></span><span class="calibre10">: </span><a href="http://common-lisp.net/project/slime/"><span class="calibre10"><span class="calibre5">http://common-lisp.net/project/slime/</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos1502723" class="calibre6"><span class="calibre4"><span class="bold">Debugging, Monitoring, and Patching Production in the REPL</span></span></p><p id="filepos1502842" class="calibre18">In <a href="#filepos1451167"><span class="calibre5">The Persistent, Evolving Environment</span></a>, we talked about the “persistent, evolving environment” that the REPL provides in a development context. What was left unsaid there is that those environments to which the REPL connects us are not limited to development contexts. There is no technical reason why a REPL cannot be leveraged in “deployed” contexts—including production—to provide the same kind of dynamicism enjoyed in development.</p><p class="calibre18">Remember that the fundamental unit of interaction between you and a Clojure environment is <span class="italic">loading code</span>: very simply, evaluating expressions, from files on disk or provided as input to a REPL, which define functions and values and effect changes to the environment. No other special requirements apply. While some REPLs are tied to a local operating system process and console (including the default REPL provided by Clojure that we introduced in <a href="#filepos40787"><span class="calibre5">Example 1-1</span></a>), that is by no means universal. In fact, many (if not most) Clojure development tools—including Counterclockwise for Eclipse and SLIME for Emacs—<span class="italic">only</span> use “remote” REPL processes.</p><p class="calibre18">When you start REPLs in these tools, a new JVM process is spawned as you would expect, but that process is initialized to start a REPL server, to which the tool connects: all of the code you load from such tools, and all of the interactions you have using their REPL user interfaces all occurs over a network pipe, albeit one connected to <tt class="calibre22">localhost</tt>. Very simply, these REPL servers accept code sent to them as text, and apply the same <span class="italic">read</span>, <span class="italic">evaluate</span>, <span class="italic">print</span> process to that code as any other REPL, with the printed results sent back to your tool’s REPL UI instead of to <tt class="calibre22">*out*</tt>.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">The Clojure REPL servers used by both Counterclockwise and SLIME—nREPL and swank-clojure, respectively—can be easily integrated into your application so you can open a REPL to deployed instances of your application, wherever they may be running. Both use Clojure libraries that are readily available as Maven dependencies. For details, check the projects’ documentation for embedding at </span><a href="http://github.com/clojure/tools.nrepl"><span class="calibre10"><span class="calibre5">http://github.com/clojure/tools.nrepl</span></span></a><span class="calibre10"> and </span><a href="https://github.com/technomancy/swank-clojure"><span class="calibre10"><span class="calibre5">https://github.com/technomancy/swank-clojure</span></span></a><span class="calibre10">.</span></blockquote><p class="calibre25">In short, as long as you can get your deployed application to start a REPL server, and you can connect your Clojure tooling to it, you can interact with that remote Clojure environment using its REPL as if it were running under your desk. However, it’s safe to say that, except perhaps in very special circumstances, you shouldn’t be using a REPL connection to a deployed, nonlocal development runtime to do new development. Rather, a REPL connection to your production environment can be the most effective monitoring, debugging, and, occasionally, patching tool you could have.</p><p class="calibre18"><span class="bold">Monitoring and runtime analysis</span>. <a id="filepos1506391"></a>Because a REPL provides you with as high-fidelity a connection to a remote environment as you might have to a local Clojure environment, you have the opportunity to collect and monitor runtime data and events in ways that are impossible using other means. For example, capturing key event data in ways that you can access, manipulate, and analyze in the REPL can be very powerful. Here are a couple of trivial functions that enable this kind of usage:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [log-capacity 5000                             </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>      events (agent [])]                            </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  (defn log-event [e]<br class="calibre33"/>    (send events #(if (== log-capacity (count %))<br class="calibre33"/>                    (-&gt; % (conj e) (subvec 1))      </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>                    (conj % e)))<br class="calibre33"/>    e)                                              </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  (defn events [] @events))                         </tt></span><a></a><img src="images/00001.jpg" class="calibre36"/></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">We define a capacity for our “log”—as a hardcoded size here, but this could just as easily be determined from a configuration setting.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">Our “log” is just an agent that holds an empty to vector to start. We’re using an agent so we can update our log vector without potentially causing the thread calling <tt class="calibre22">log-event</tt> to block while updating, for example, an atom.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">When an event is logged, it’s <tt class="calibre22">conj</tt>ed onto the tail of our log vector. If the new event is going to overflow the defined capacity, then we trim the head of our log vector.</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">We return the logged event so that <tt class="calibre22">log-event</tt> can be easily used within threading forms or <tt class="calibre22">comp</tt>osed with other functions.</blockquote><p class="calibre23"><img src="images/00001.jpg" class="calibre36"/></p><blockquote class="calibre37">We define a simple accessor function so that the vector of events can be retrieved from the closure.</blockquote><p class="calibre18">Let’s see what we can do with our event-logging facility. Consider a web application where you’d like to track where your traffic is coming from, in particular to notice new “hot” referrers. To do this, you could capture a subset of each request’s data via <tt class="calibre22">log-event</tt>; we’ll dummy up some data here, simulating the logging of requests from a few referring domains:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(doseq [request (repeatedly 10000 (partial rand-nth [{:referrer "twitter.com"}<br class="calibre33"/>                                                     {:referrer "facebook.com"}<br class="calibre33"/>                                                     {:referrer "twitter.com"}<br class="calibre33"/>                                                     {:referrer "reddit.com"}]))]<br class="calibre33"/>  (log-event request))<br class="calibre33"/>;= nil<br class="calibre33"/>(count (events))<br class="calibre33"/>;= 5000</tt></span></blockquote><p class="calibre23"><tt class="calibre22">log-event</tt> is working properly in retaining a maximum of 5,000 events; the first 5,000 events rolled off the head of the vector. Now, when you connect to your remote web application via a REPL, you can do <span class="italic">anything you want</span> with this data; here, we can perform a simple summation, allowing us to see which referring domain sent us the most traffic over the last 5,000 requests:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(frequencies (events))<br class="calibre33"/>;= {{:referrer "twitter.com"} 2502,<br class="calibre33"/>    {:referrer "facebook.com"} 1280,<br class="calibre33"/>    {:referrer "reddit.com"} 1218}</tt></span></blockquote><p class="calibre23">Twitter was our site’s top referrer over the last 5,000 requests (by dint of our gaming the dummy data by doubling the frequency of Twitter-referred “requests”). Of course, you could do a <span class="italic">lot</span> more than this; immediate improvements would be to capture more than just the referrer’s domain, and perhaps truncate the <tt class="calibre22">events</tt> vector based on request timestamp so as to retain only the last 10 minutes of requests rather than a fixed number.</p><p class="calibre18">In any case, the upshot is that by being able to dig into your remote Clojure application using the REPL, you have all of the facilities of Clojure at your disposal to peek, poke, and analyze its state. Typical approaches to addressing these sorts of requirements—spooling data to disk or a database and analyzing it from there, or building dashboards and other status indicators into your application—are known quantities, but require resources and planning that may not be practical or possible. In any case, there is little that can beat the advantage of having a REPL handy to make <span class="italic">any</span> analysis instantly available.</p><p class="calibre18"><span class="bold">Patching</span>. <a id="filepos1512602"></a>Once you’ve found the cause of a bug and determined the fix for it (presumably validating that fix in some kind of testing environment), getting that patch into a deployed application <span class="italic">without</span> prompting downtime can be a tall order depending on the specifics of your application and relevant local policies. However, with a remote REPL session, patching a deployed application is as simple as loading updated code.</p><p class="calibre18">Some care and preparation should go into this, though. In particular, there are some limitations to what can be updated when loading code in the REPL, as we discuss in <a href="#filepos1518975"><span class="calibre5">Limitations to Redefining Constructs</span></a>. In addition, there can be questions of logistics: if your patch requires changes to multiple files, you need to load them one at a time in the proper order. This is because the REPL you are connected to retains its remote classpath containing all the now-old code; <tt class="calibre22">require</tt> and <tt class="calibre22">use</tt> declarations will not magically find the updated code on your machine.</p><p class="calibre18">Beyond this concept of carefully patching a deployed application, there is the use case of rapidly iterating and updating a “live” environment. There are contexts where user requirements change so rapidly, and turnaround time of solutions is so critical, that it is advantageous to treat “production” as a development environment.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1514098"></a><a href="#filepos1517690"><span class="calibre32">324</span></a><span class="calibre32">]</span></small></sup> In such a situation, being able to jack your local tools into that deployed application with a REPL and push new code out at a breakneck pace is an edge that is hard to ignore.</p><p id="filepos1514374" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Special Considerations for “Deployed” REPLs</span></span></span></p><p class="calibre18">If the concept of having an interactive connection to an application deployed to production is unsettling, we would remind you that JMX (Java Management Extensions) <a id="filepos1514704"></a>have for years provided a widely utilized though comparatively clumsy mechanism for dynamically making changes to a running Java application. That said, there are some things you should consider when using or making available a REPL from a production environment.</p><p class="calibre18"><span class="bold">All changes are temporary</span>. Just as in a development-context REPL, any changes you make within a deployed Clojure environment are strictly transient. Loading code or tweaking data structures via the REPL will impact the current JVM/Clojure process, but will be gone if you, for example, restart the deployed Clojure application. This is in contrast to certain workflows within the development context, where you have the option of making modifications to your project’s source files, and loading that modified code—the next time you start a REPL for that project, that modified code will be what is loaded initially, making its effect persistent.</p><p class="calibre18">This is something to either simply be aware of when you are working in a REPL connected to a deployed application, or something to plan to work around. One workaround might be to ensure that any new code you load into a deployed application is mirrored by the deployment of a new artifact or executable to the remote environment, so that when the application is restarted, the changes you dynamically load via the REPL are always also present in the <span class="italic">.war</span> or <span class="italic">.jar</span> file(s), for example, corresponding to the modified code.</p><p class="calibre18"><span class="bold">Network security and access control</span>. <a id="filepos1516306"></a>No network implementation of a Clojure REPL provides anything in the way of security, including authentication and transport encryption. These issues are generally considered an orthogonal concern.</p><p class="calibre18">An easy way to resolve them in short order is to ensure that the REPL server running in your deployed application is bound to a network port that is safely behind the operating system’s firewall.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1516774"></a><a href="#filepos1518105"><span class="calibre32">325</span></a><span class="calibre32">]</span></small></sup> You would then establish an SSH tunnel or use a VPN to gain access to the remote system, and connect to the running REPL server through that secure gateway.</p><p class="calibre18">Similarly, REPL servers do not enforce any sort of access control: once you have a REPL connection, you have unfettered access to the Clojure runtime and the environment it finds itself in. From a security standpoint, you should treat a REPL connection with the same care as you might treat an SSH session. There are ways to restrict the capabilities of a REPL, though, using an evaluation sandbox.<a id="filepos1517456"></a><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1517498"></a><a href="#filepos1518445"><span class="calibre32">326</span></a><span class="calibre32">]</span></small></sup></p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1517690"></a><a href="#filepos1514098"><span class="calibre32">324</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Though this does exist in proper production environments, the most common example is a “user acceptance testing” context, where the faster you can deploy improvements, the happier your clients, customers, and partners will be.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1518105"></a><a href="#filepos1516774"><span class="calibre32">325</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">This is likely to be the default, insofar as deployed environments typically expose ports used only for common network services, like HTTP, HTTPS, and SSH.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1518445"></a><a href="#filepos1517498"><span class="calibre32">326</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">One such sandbox is </span><span class="calibre10"><span class="italic">clojail</span></span><span class="calibre10">—</span><a href="https://github.com/flatland/clojail"><span class="calibre10"><span class="calibre5">https://github.com/flatland/clojail</span></span></a><span class="calibre10">—which has been battle-tested through the evaluation of snippets of untrusted code in various Clojure IRC channels and on the puzzle site 4clojure.com.</span></p><div class="mbppagebreak"></div><p id="filepos1518975" class="calibre6"><span class="calibre4"><span class="bold">Limitations to Redefining Constructs</span></span></p><p id="filepos1519072" class="calibre18">The ability to interactively redefine parts of your Clojure application is nearly unlimited: everything from functions to top-level data structures to types specified via <tt class="calibre22">deftype</tt> and <tt class="calibre22">defrecord</tt> to protocols and multimethods can be redefined and modified at runtime (within the bounds of each construct’s contract, of course), just by loading new or updated code. This capability is <span class="italic">nearly</span> unlimited though, with the “nearly” being mostly prompted by host limitations.</p><p class="calibre18"><span class="bold">The fixed classpath</span>. The JVM’s classpath <a id="filepos1519680"></a>cannot, in general, be modified or expanded at runtime. This means that you cannot load and use new dependencies that were not anticipated or available when the JVM/Clojure process was started. There are a number of workarounds for this limitation both in the JVM and Clojure communities.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1520010"></a><a href="#filepos1526271"><span class="calibre32">327</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18"><span class="bold">gen-class is never dynamic</span>. <a id="filepos1520173"></a>As described in <a href="#filepos1362472"><span class="calibre5">Defining Named Classes</span></a>, <tt class="calibre22">gen-class</tt> generates a static Java class strictly during ahead-of-time compilation, and at no other time. This class, by definition, cannot be updated at runtime. The JVM ecosystem has evolved approaches to reload and update static classes (like those generated by <tt class="calibre22">gen-class</tt>), but such methods are beyond our scope here.</p><p class="calibre18"><span class="bold">Class instances retain inline implementations forever</span>. Inline interface and protocol implementations in classes <a id="filepos1520764"></a>defined by <tt class="calibre22">deftype</tt><a id="filepos1520798"></a> and <tt class="calibre22">defrecord</tt><a id="filepos1520828"></a> cannot be updated dynamically for existing instances of those classes. Workarounds here include delegating implementations to separate functions that you can readily redefine as necessary (which we did in the <tt class="calibre22">reify</tt>-based implementation of <tt class="calibre22">ActionListener</tt> in <a href="#filepos1440588"><span class="calibre5">Example 10-1</span></a>), and instead of providing functions named by vars when implementing protocols via <tt class="calibre22">extend</tt>, provide the vars themselves using the <tt class="calibre22">#'</tt> notation. Once you update the functions held by the latter, the new functions will be used to support the protocol implementations.</p><p class="calibre18">In addition to the these limitations implied by the JVM, you should keep in mind a couple of Clojure-specific issues:</p><p class="calibre18"><span class="bold">Redefining macros does not reexpand usages of them</span>. <a id="filepos1521702"></a>If you define a macro, and use it in the definition of a function, redefining only the macro will not update the definition of the function. Remember that macros are used only at compile time: in order to have the new macro implementation “applied,” all usages of that macro must be reloaded (and therefore recompiled) as well.</p><p class="calibre18"><span class="bold">Redefining a multimethod does not update the multimethod’s dispatch function</span>. <a id="filepos1522160"></a>As we pointed out in <a href="#filepos1087646"><span class="calibre5">“Redefining a multimethod does not update the multimethod’s dispatch function”</span></a>, <tt class="calibre22">defmulti</tt><a id="filepos1522346"></a> has <tt class="calibre22">defonce</tt><a id="filepos1522374"></a> semantics, so dispatch functions aren’t updated simply by loading a modified <tt class="calibre22">defmulti</tt> form. The workaround is to <tt class="calibre22">ns-unmap</tt> the multimethod’s var—which unfortunately requires reloading each of the multimethod’s method implementations as well.</p><p class="calibre18"><span class="bold">Understand when you’re capturing a value instead of dereferencing a var</span>. <a id="filepos1522763"></a>Remember that <tt class="calibre22">def</tt><a id="filepos1522796"></a> and friends intern a var in the current namespace, and vars contain the actual value you are defining. A var’s symbol evaluates to the value the var holds at that point in time. That is exactly what you want if, for example, you are making a simple function call; however, if you name a var as an argument to another function, you are passing that var’s value as the argument, not the var itself. Thus, if you attempt to redefine the var, the new value will not be taken into account:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn a [b] (+ 5 b))<br class="calibre33"/>;= #'user/a<br class="calibre33"/>(def b (partial a 5))      </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #'user/b<br class="calibre33"/>(b)<br class="calibre33"/>;= 10<br class="calibre33"/>(defn a [b] (+ 10 b))      </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #'user/a<br class="calibre33"/>(b)                        </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= 10</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">We define <tt class="calibre22">b</tt> to be a function, the function in the var <tt class="calibre22">a</tt> with a single argument partially applied.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">We redefine <tt class="calibre22">a</tt>…</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">…but because <tt class="calibre22">b</tt> has captured the original function <tt class="calibre22">a</tt>, our redefinition has no effect.</blockquote><p class="calibre18">The workaround here is again to provide the var itself as the argument:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def b (partial #'a 5))     </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #'user/b<br class="calibre33"/>(b)<br class="calibre33"/>;= 15<br class="calibre33"/>(defn a [b] (+ 5 b))        </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #'user/a<br class="calibre33"/>(b)                         </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= 10</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">We provide <tt class="calibre22">#'a</tt> to <tt class="calibre22">partial</tt>, instead of just <tt class="calibre22">a</tt>; this results in the function returned by <tt class="calibre22">partial</tt> capturing the <span class="italic">var</span>
<tt class="calibre22">a</tt>, and not its value at that time.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">Now we can redefine <tt class="calibre22">a</tt>…</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">…and calling <tt class="calibre22">b</tt> now uses our redefined function now held by <tt class="calibre22">#'a</tt>.</blockquote><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1526271"></a><a href="#filepos1520010"><span class="calibre32">327</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">One is pomegranate (see </span><a href="https://github.com/cemerick/pomegranate"><span class="calibre10"><span class="calibre5">https://github.com/cemerick/pomegranate</span></span></a><span class="calibre10"> for details), which can add </span><span class="calibre10"><span class="italic">.jar</span></span><span class="calibre10"> files to your JVM’s classpath, either directly from disk or by resolving them as Maven dependencies.</span></p><div class="mbppagebreak"></div><p id="filepos1526786" class="calibre6"><span class="calibre4"><span class="bold">In Summary</span></span></p><p class="calibre18">The Clojure REPL is a tool that can be used to smooth the passing of each hour of programming, speed the discovery of the cause of each new bug, and snatch victory from the gummy maw of failure in production environments. Using it effectively is necessary to gain the complete benefits of every quality Clojure toolchain, and understanding the full depth of its potential is part of the defining experience of programming in Clojure.<a id="filepos1527318"></a></p><div class="mbppagebreak"></div><p id="filepos1527345" class="calibre6"><span class="calibre4"><span class="bold">Part IV. Practicums</span></span></p><div class="mbppagebreak"></div><p id="filepos1527443" class="calibre6"><span class="calibre2"><span class="bold">Chapter 11. Numerics and Mathematics</span></span></p><p id="filepos1527542" class="calibre13">Many classes of applications remain safely ignorant of the details and subtleties of mathematics, regardless of the language or runtime being used. In such cases, it is often I/O overhead, database queries, and other factors that define an application’s bottlenecks.</p><p class="calibre18">However, there are domains where numeric performance and/or correctness are critical, and the set of such cases seems to be growing: large-scale data processing, visualization, statistical analysis, and similar classes of applications all often require a degree of mathematical rigor not found elsewhere. Clojure gives you ways to choose how to optimize your application’s usage of numerics to meet these demands along two different axes. Without sacrificing concision, expressiveness, or runtime dynamism, you can opt to:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">Use primitive numerics to obtain maximum performance within the available range of those primitives.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Use boxed numerics to reliably perform arbitrary-precision operations.</blockquote></li></ol><p class="calibre18">In this chapter, we’ll do a deep dive into how Clojure models numbers and implements operations over them.</p><p id="filepos1528941" class="calibre6"><span class="calibre4"><span class="bold">Clojure Numerics</span></span></p><p id="filepos1529018" class="calibre18">Our first step must be to understand the raw materials at hand, Clojure’s numeric representations, shown in <a href="#filepos1529571"><span class="calibre5">Table 11-1</span></a>.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1529258"></a><a href="#filepos1554756"><span class="calibre32">328</span></a><span class="calibre32">]</span></small></sup> A good place to start would be to compare Clojure’s numerics and those in Ruby and Python (those familiar with Java should be immediately comfortable, insofar as Clojure reuses Java’s numeric representations).</p><p id="filepos1529571" class="calibre3"></p><p class="calibre1"><span class="italic">Table 11-1. Clojure’s numeric types, with comparisons to representations in Python and Ruby</span><a id="filepos1529763"></a></p><table border="1" valign="top" class="calibre40"><tr border="1" valign="top" class="calibre27"><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Numeric type </span></span></span></th><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Clojure representation </span></span></span></th><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Python equivalent </span></span></span></th><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Ruby equivalent </span></span></span></th></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> Primitive 64-bit integers</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">long</tt></span><span class="calibre21">
</span></p></td><td colspan="2" rowspan="2" border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">None; Python and Ruby do not provide primitive numerics (all representations in both languages are boxed). </span></p></td></tr><a id="filepos1531000"></a><tr border="1" valign="top" class="calibre43"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Primitive 64-bit IEEE floating-point decimals </span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">double</tt></span><span class="calibre21">
</span></p></td></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> Boxed integers</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">java.lang.Long</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">int</tt></span><span class="calibre21">
<sup class="calibre44"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1532113"></a><a href="#filepos1536449"><span class="calibre32">a</span></a><span class="calibre32">]</span></small></sup></span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">Fixnum</tt></span><span class="calibre21">
<sup class="calibre44"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1532449"></a><a href="#filepos1537174"><span class="calibre32">b</span></a><span class="calibre32">]</span></small></sup></span></p></td></tr><a id="filepos1532563"></a><tr border="1" valign="top" class="calibre43"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> Boxed decimals</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">java.lang.Double</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">float</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">Float</tt></span><span class="calibre21">
</span></p></td></tr><a id="filepos1533418"></a><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">“Big” ints (unbounded arbitrary-precision integers) </span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">java.math.BigInteger</tt></span><span class="calibre21"> and </span><span class="calibre21"><tt class="calibre22">clojure.lang.BigInt</tt></span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">long</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">Bignum</tt></span><span class="calibre21">
</span></p></td></tr><tr border="1" valign="top" class="calibre43"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">“Big” decimals (unbounded arbitrary-precision decimals) </span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">java.math.BigDecimal</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">decimal.Decimal</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">BigDecimal</tt></span><span class="calibre21">
</span></p></td></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Rationals  (often also called </span><span class="calibre21"><span class="italic">ratios</span></span><span class="calibre21">)</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">clojure.lang.Ratio</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">fractions.Fraction</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">Rational</tt></span><span class="calibre21">
</span></p></td></tr><a id="filepos1536230"></a><tr border="1" valign="top" class="calibre27"><td colspan="4" border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1536449"></a><a href="#filepos1532113"><span class="calibre32">a</span></a><span class="calibre32">] </span></small></sup><span class="calibre21">Python’s </span><span class="calibre21"><tt class="calibre22">int</tt></span><span class="calibre21"> is 32 bits wide, and so the closer JVM equivalent is </span><span class="calibre21"><tt class="calibre22">java.lang.Integer</tt></span><span class="calibre21">; however, as noted in the next section, Clojure widens all of its numerics to 64-bit representations, and so </span><span class="calibre21"><tt class="calibre22">long</tt></span><span class="calibre21">s (or, in this case, </span><span class="calibre21"><tt class="calibre22">Long</tt></span><span class="calibre21">s) are always preferred.</span></p><p class="calibre45"><span class="calibre21"> </span></p><p class="calibre42"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1537174"></a><a href="#filepos1532449"><span class="calibre32">b</span></a><span class="calibre32">] </span></small></sup><span class="calibre21">The range of Ruby’s </span><span class="calibre21"><tt class="calibre22">Fixnum</tt></span><span class="calibre21"> is implementation- and machine-dependent, usually 31 or 63 bits wide (the last bit is reserved to implement its fixnum semantics; see </span><a href="#filepos1576207"><span class="calibre21"><span class="calibre5">Object Identity (identical?)</span></span></a><span class="calibre21"> for a brief discussion of fixnums).</span></p></td></tr></table><p class="calibre23">Let’s unpack some terminology and expand on some key facts from this table.</p><p id="filepos1537800" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Clojure Prefers 64-bit (or Larger) Representations</span></span></span></p><p id="filepos1537940" class="calibre18">While the JVM supports many smaller representations—such as 32-bit floating-point decimals and 32- and 16-bit integers (<tt class="calibre22">float</tt>s, <tt class="calibre22">int</tt>s, and <tt class="calibre22">short</tt>s, respectively)—all of Clojure’s reader forms and numeric operations produce 64-bit (or larger) numeric representations. All mathematics operations can work with these narrower types, but Clojure widens return values to their corresponding 64-bit representations. For example, incrementing a 32-bit integer produces a 64-bit long:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(class (inc (Integer. 5)))<br class="calibre33"/>;= java.lang.Long</tt></span></blockquote><p class="calibre23">This simplifies Clojure’s numerics model compared to Java’s, where there are three different integer representations and two different decimal representations.</p><p id="filepos1538811" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Clojure Has a Mixed Numerics Model</span></span></span></p><p id="filepos1538935" class="calibre18">Unlike most dynamic languages (including Ruby and Python), Clojure supports <span class="italic">primitive</span> numerics <a id="filepos1539065"></a>(e.g., <tt class="calibre22">long</tt> and <tt class="calibre22">double</tt>) alongside <span class="italic">boxed</span> numerics.</p><p class="calibre18">Primitives are not objects; they are value types that correspond directly to a machine-level type, to the point where certain numeric operations over primitives are implemented in hardware. Clojure reuses the JVM’s <tt class="calibre22">long</tt> and <tt class="calibre22">double</tt> primitives, which correspond to the C/C++ types <tt class="calibre22">long long</tt> (also called <tt class="calibre22">int64_t</tt>) and <tt class="calibre22">double</tt>, respectively.</p><p class="calibre18">In contrast, boxed numbers <span class="italic">are</span> objects that are defined by classes; <tt class="calibre22">java.lang.Long</tt> is a box class whose sole purpose is to contain a primitive <tt class="calibre22">long</tt>, and <tt class="calibre22">java.lang.Double</tt> is the corollary that contains a primitive <tt class="calibre22">double</tt>.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1539891"></a><a href="#filepos1555132"><span class="calibre32">329</span></a><span class="calibre32">]</span></small></sup> Being objects, they incur a cost for each allocation, and so operations over them are necessarily slower: they must often be <span class="italic">unboxed</span> first (to obtain the primitive value within), and then the result of each operation may need to be boxed again (requiring an allocation of the box class appropriate for the primitive result value).</p><blockquote id="filepos1540328" class="calibre38"></blockquote><blockquote class="calibre39"><span class="calibre10"><span class="bold">WHY DO LONG AND DOUBLE EXIST AT ALL, SINCE THEY DON’T PROVIDE ANY SEMANTIC ADVANTAGES OVER THEIR PRIMITIVE COUNTERPARTS?</span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Considered in isolation, it seems that the </span><span class="calibre10"><tt class="calibre22">Long</tt></span><a id="filepos1540731"></a><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">Double</tt></span><a id="filepos1540802"></a><span class="calibre10"> box classes serve no purpose: using them in mathematical operations implies additional overhead, and they provide no advantages of range or precision like </span><span class="calibre10"><tt class="calibre22">BigInteger</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">BigDecimal</tt></span><span class="calibre10">. The reason </span><span class="calibre10"><tt class="calibre22">Long</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">Double</tt></span><span class="calibre10"> (and the other Java box classes corresponding to the JVM’s primitive types, such as </span><span class="calibre10"><tt class="calibre22">Boolean</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">Short</tt></span><span class="calibre10">) exist is to allow JVM numbers to be used in all the scenarios where objects are useful.</span></blockquote><blockquote class="calibre17"><span class="calibre10">For example, without these box classes, it would be impossible to store numbers in hash maps and other collections. The Java Collections API deals in objects exclusively.</span></blockquote><blockquote class="calibre17"><span class="calibre10">We talk more about boxed numbers, specifically with how they impact Clojure, in </span><a href="#filepos1588398"><span class="calibre10"><span class="calibre5">Optimizing Numeric Performance</span></span></a><span class="calibre10">.</span></blockquote><p class="calibre50">Given the correspondence between primitives and machine types, and the allocation overhead associated with boxed numerics, working with primitives is always going to be faster—sometimes orders of magnitude faster, depending upon the specifics of an algorithm. On the other hand, the 64-bit numeric types natively provided by the JVM do have limits to their range and precision. To fill this gap, Clojure reuses <tt class="calibre22">BigDecimal</tt><a id="filepos1542549"></a> and can work with <tt class="calibre22">BigInteger</tt><a id="filepos1542594"></a>—Java’s two unbounded numeric representations—and provides its own <tt class="calibre22">BigInt</tt><a id="filepos1542689"></a>. These types are defined by classes, and therefore share the overhead associated with boxed numerics, but allow you to safely work with arbitrarily large or arbitrarily precise numbers.</p><p class="calibre18">So, we have two axes by which Clojure’s numeric types may be understood: whether a particular representation is <span class="italic">primitive</span> or <span class="italic">boxed</span>, and whether its range or precision is limited or arbitrary. The different concrete representations of integers and decimals are shown in the matrix in <a href="#filepos1543304"><span class="calibre5">Table 11-2</span></a> based on those axes.</p><p id="filepos1543304" class="calibre3"></p><p class="calibre1"><span class="italic">Table 11-2. Matrix comparison of numeric representations available in Clojure</span></p><table border="1" valign="top" class="calibre40"><tr border="1" valign="top" class="calibre27"><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7">   </span></span></span></th><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Limited range/precision </span></span></span></th><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Arbitrary range/precision </span></span></span></th></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> Primitive types</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">long</tt></span><span class="calibre21">, </span><span class="calibre21"><tt class="calibre22">double</tt></span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><span class="italic">N/A</span></span><span class="calibre21">
</span></p></td></tr><a id="filepos1544566"></a><tr border="1" valign="top" class="calibre43"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> Object types</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">java.lang.Long</tt></span><span class="calibre21">, </span><span class="calibre21"><tt class="calibre22">java.lang.Double</tt></span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21"> </span><span class="calibre21"><tt class="calibre22">clojure.lang.BigInt</tt></span><span class="calibre21">, </span><span class="calibre21"><tt class="calibre22">java.math.BigDecimal</tt></span><span class="calibre21">, </span><span class="calibre21"><tt class="calibre22">java.math.BigInteger</tt></span></p></td></tr><a id="filepos1545396"></a></table><p class="calibre23">While Clojure uses and provides many different numeric types, the semantics of its mathematical operations are consistent across types and when operations are performed with numbers of differing types. For example, <tt class="calibre22">dec</tt><a id="filepos1545666"></a> always decrements its argument, regardless of the type of that argument, and always returns a number of the same concrete type:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(dec 1)<br class="calibre33"/>;= 0<br class="calibre33"/>(dec 1.0)<br class="calibre33"/>;= 0.0<br class="calibre33"/>(dec 1N)<br class="calibre33"/>;= 0N<br class="calibre33"/>(dec 1M)<br class="calibre33"/>;= 0M<br class="calibre33"/>(dec 5/4)<br class="calibre33"/>;= 1/4</tt></span></blockquote><p class="calibre23">Similarly, we can freely mix the types of numbers used in a single operation:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1546184"></a><a href="#filepos1555587"><span class="calibre32">330</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(* 3 0.08 1/4 6N 1.2M)<br class="calibre33"/>;= 0.432<br class="calibre33"/>(&lt; 1 1.6 7/3 9N 14e9000M)<br class="calibre33"/>;= true</tt></span></blockquote><p class="calibre23">When arguments to arithmetic operations are mixed, the type of the result is determined by Clojure’s rules for widening of types. This is discussed in <a href="#filepos1549226"><span class="calibre5">The Rules of Numeric Contagion</span></a>.</p><p id="filepos1546739" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Rationals</span></span></span></p><p id="filepos1546838" class="calibre18">Rational numbers are the set of numbers that can be expressed as a fraction of two integers. For example, <tt class="calibre22">⅓</tt> and <tt class="calibre22">⅗</tt> are both rational numbers (equal to <tt class="calibre22">0.333…</tt> and <tt class="calibre22">0.6</tt>, respectively). Most languages—including Java, Ruby, and Python—support only integer and floating-point number representations and arithmetic. So, when a rational number is encountered, it is immediately “flattened” into the corresponding floating-point approximation:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22"># Ruby<br class="calibre33"/>&gt;&gt; 1.0/3.0<br class="calibre33"/>0.333333333333333<br class="calibre33"/><br class="calibre33"/># Python<br class="calibre33"/>&gt;&gt;&gt; 1.0/3.0<br class="calibre33"/>0.33333333333333331</tt></span></blockquote><p class="calibre23">The perils of floating-point representations when used in various calculations are fairly well known (though rarely well understood). Here’s a common example, back in Clojure:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(+ 0.1 0.1 0.1)<br class="calibre33"/>;= 0.30000000000000004</tt></span></blockquote><p class="calibre23">The error that slips into that result is simply the consequence of how floating-point numbers are represented.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1548091"></a><a href="#filepos1555914"><span class="calibre32">331</span></a><span class="calibre32">]</span></small></sup> Clojure avoids this by (a) allowing for rational number literals, and (b) not forcing rational numbers into an inexact floating-point approximation:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(+ 1/10 1/10 1/10)<br class="calibre33"/>;= 3/10</tt></span></blockquote><p class="calibre23">The flip side of this is that, when it <span class="italic">is</span> possible to flatten rational numbers into an integer without loss of precision, Clojure does so:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(+ 7/10 1/10 1/10 1/10)<br class="calibre33"/>;= 1</tt></span></blockquote><p class="calibre23">Ratios can be explicitly coerced to a floating-point representation:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(double 1/3)<br class="calibre33"/>;= 0.3333333333333333</tt></span></blockquote><p class="calibre23">and floating-point numbers can be converted to a ratio using the <tt class="calibre22">rationalize</tt> function:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(rationalize 0.45)<br class="calibre33"/>;= 9/20</tt></span></blockquote><p id="filepos1549226" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">The Rules of Numeric Contagion</span></span></span></p><p id="filepos1549346" class="calibre18">When an arithmetic operation involves differing types of numbers, the type of the operation’s return value is determined using a fixed hierarchy. Each numeric type has a different degree of <span class="italic">contagion</span>, where the argument to an operation with the highest degree of contagion determines the type of the return value (<a href="#filepos1549770"><span class="calibre5">Figure 11-1</span></a>).</p><blockquote id="filepos1549770" class="calibre47"></blockquote><blockquote class="calibre39"><img src="images/00047.jpg" class="calibre115"/></blockquote><blockquote class="calibre57"><span class="calibre10"><span class="italic"><span class="calibre7">Figure 11-1. Clojure’s numeric types, organized according to their relative degrees of contagion</span></span></span></blockquote><p class="calibre50">Every mathematical operation must return a value of some concrete type, and there must be a defined way in which that type is chosen for operations involving heterogeneous arguments.<a id="filepos1550401"></a> The specific hierarchy that Clojure defines is ordered and implemented such that this coercion of the return value’s type is never “lossy”; for example, every <tt class="calibre22">long</tt> can be coerced to a big int or rational or decimal without impacting the semantics of its value, while the reverse is not true.</p><p class="calibre18">This is trivially demonstrated:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(+ 1 1)    </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= 2<br class="calibre33"/>(+ 1 1.5)  </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= 2.5<br class="calibre33"/>(+ 1 1N)   </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= 2N<br class="calibre33"/>(+ 1.1M 1N)  </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= 2.1M</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Operations with homogeneously typed arguments <a id="filepos1551625"></a>return a result of that type.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">An operation involving a <tt class="calibre22">long</tt> and a <tt class="calibre22">double</tt> will always return a <tt class="calibre22">double</tt>.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">An operation involving a <tt class="calibre22">long</tt> and a <tt class="calibre22">BigInteger</tt> will always return a <tt class="calibre22">BigInteger</tt>.</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">An operation involving a <tt class="calibre22">BigDecimal</tt> and a <tt class="calibre22">BigInteger</tt> will always return a <tt class="calibre22">BigDecimal</tt>.</blockquote><p class="calibre18">The only wrinkle here is that any operation involving a <tt class="calibre22">double</tt> will return a <tt class="calibre22">double</tt>, even though <tt class="calibre22">double</tt>s cannot properly represent the full range of the other numeric representations. This is because:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">double</tt> (following the IEEE floating-point specification) defines some special values that cannot be represented by <tt class="calibre22">BigDecimal</tt>s (specifically, the <tt class="calibre22">Infinity</tt> and <tt class="calibre22">NaN</tt> values).</blockquote></li><a id="filepos1553043"></a><li value="2" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">double</tt> is the only representation that is inherently inexact—it would be questionable for an operation involving an inexact number to return a type of value that implied precision that does not exist.</blockquote></li></ol><p class="calibre18">The concept of contagion extends beyond the arithmetic operations provided by Clojure; they are just functions, and so the same rules apply for functions that you might write that accept numbers as arguments and are implemented using Clojure’s operators. Consider a simple function that computes the sum of the squares:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn squares-sum<br class="calibre33"/>  [&amp; vals]<br class="calibre33"/>  (reduce + (map * vals vals)))<br class="calibre33"/>;= #'user/squares-sum<br class="calibre33"/>(squares-sum 1 4 10)<br class="calibre33"/>;= 117</tt></span></blockquote><p class="calibre23">What happens when we add a double, a big int, a big decimal, or a rational to those being summed? We get a double, a big int, a big decimal, or a rational in return, respectively, regardless of the types of the other values being summed, consistent with the hierarchy of contagion we saw in <a href="#filepos1549770"><span class="calibre5">Figure 11-1</span></a>:<a id="filepos1554351"></a></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(squares-sum 1 4 10 20.5)<br class="calibre33"/>;= 537.25<br class="calibre33"/>(squares-sum 1 4 10 9N)<br class="calibre33"/>;= 198N<br class="calibre33"/>(squares-sum 1 4 10 9N 5.6M)<br class="calibre33"/>;= 229.36M<br class="calibre33"/>(squares-sum 1 4 10 25/2)<br class="calibre33"/>;= 1093/4</tt></span></blockquote><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1554756"></a><a href="#filepos1529258"><span class="calibre32">328</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="#filepos88495"><span class="calibre10"><span class="calibre5">Table 1-2</span></span></a><span class="calibre10"> for a refresher of the reader syntax that corresponds with each numeric type.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1555132"></a><a href="#filepos1539891"><span class="calibre32">329</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Primitives are always denoted by lowercase names (like </span><span class="calibre10"><tt class="calibre22">double</tt></span><span class="calibre10">), whereas boxed representations are always identified by their (capitalized) class name (like </span><span class="calibre10"><tt class="calibre22">Double</tt></span><span class="calibre10">).</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1555587"></a><a href="#filepos1546184"><span class="calibre32">330</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">A pleasant improvement over Java, especially since its mathematical operators cannot be used with numeric types providing arbitrary precision.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1555914"></a><a href="#filepos1548091"><span class="calibre32">331</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Like many other runtimes, the JVM represents floating-point numbers according to the IEEE 754 specification. If you’re interested in how a floating-point number boils down to bits in memory, the overview of the spec at </span><a href="http://en.wikipedia.org/wiki/IEEE_754-2008"><span class="calibre10"><span class="calibre5">http://en.wikipedia.org/wiki/IEEE_754-2008</span></span></a><span class="calibre10"> is a good jumping-off point.</span></p><div class="mbppagebreak"></div><p id="filepos1556474" class="calibre6"><span class="calibre4"><span class="bold">Clojure Mathematics</span></span></p><p id="filepos1556554" class="calibre18">Knowing the types of available numbers and their representations is not sufficient to understand how mathematics is modeled in Clojure. Clojure’s various arithmetic and equality operators provide additional semantic guarantees in order to support sensible results across all the numeric types in play and in the face of many common issues that arise in computational mathematics, such as the handling of overflow and underflow, controlling the promotion of arithmetic results, and collection equality.</p><p id="filepos1557089" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Bounded Versus Arbitrary Precision</span></span></span></p><p id="filepos1557213" class="calibre18">The 64-bit range of longs and doubles is quite expansive; integers ±2<sup class="calibre30"><small class="calibre31"><span class="calibre32">63</span></small></sup>-1 can be represented and operated on, along with decimals ±1.7976931348623157<sup class="calibre30"><small class="calibre31"><span class="calibre32">308</span></small></sup>. Most applications have no need for additional range or precision, so longs and doubles are often perfectly sufficient.</p><p class="calibre18">For those applications that do require additional range and/or precision, <span class="italic">arbitrary precision</span> numeric representations are available. These representations are <span class="italic">always</span> boxed; Clojure uses both <tt class="calibre22">clojure.lang.BigInt</tt> and <tt class="calibre22">java.math.BigInteger</tt> to represent arbitrary-range integers, and <tt class="calibre22">java.math.BigDecimal</tt> for arbitrary-precision decimals.</p><blockquote class="calibre38"></blockquote><blockquote class="calibre39"><span class="calibre10"><span class="bold">WHY DOES CLOJURE HAVE ITS OWN BIGINT CLASS WHEN JAVA ALREADY PROVIDES ONE IN BIGINTEGER?</span></span></blockquote><blockquote class="calibre17"><span class="calibre10">This implementation detail has two origins.</span></blockquote><blockquote class="calibre17"><span class="calibre10">First, </span><span class="calibre10"><tt class="calibre22">BigInteger</tt></span><a id="filepos1558475"></a><span class="calibre10"> is somewhat broken, in that its </span><span class="calibre10"><tt class="calibre22">.hashCode</tt></span><span class="calibre10"> implementation is not consistent with that of </span><span class="calibre10"><tt class="calibre22">Long</tt></span><span class="calibre10">:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(.hashCode (BigInteger. "6948736584"))<br class="calibre33"/>;= -1641197977<br class="calibre33"/>(.hashCode (Long. 6948736584))<br class="calibre33"/>;= -1641198007</tt></span></blockquote><blockquote class="calibre35"><span class="calibre10">This is really bad, causing situations where equivalent values can appear twice in a set (or be mapped to two different values in, for example, a hash map) simply because of the implementation detail of their concrete types.<sup class="calibre58"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1559238"></a><a href="#filepos1573302"><span class="calibre32">332</span></a><span class="calibre32">]</span></small></sup></span></blockquote><blockquote class="calibre17"><span class="calibre10">Second, while all operations involving </span><span class="calibre10"><tt class="calibre22">BigInteger</tt></span><span class="calibre10">s must be performed using its (slower) software-based implementations, Clojure optimizes math involving </span><span class="calibre10"><tt class="calibre22">BigInt</tt></span><a id="filepos1559655"></a><span class="calibre10">s to use primitive (much faster) operations when possible, </span><span class="calibre10"><span class="italic">as long as the values involved are within the range of primitive 64-bit longs</span></span><span class="calibre10">. This means that you often only pay the arbitrary-precision penalty for integer arithmetic when your data actually requires it.</span></blockquote><blockquote class="calibre17"><span class="calibre10">In the end, you end up not generally having to care that there are two concrete arbitrary precision integer types in play; regardless of the types involved, the semantics of all of Clojure’s numeric operations are unaffected by the particular types involved and their results are never a </span><span class="calibre10"><tt class="calibre22">BigInteger</tt></span><span class="calibre10">.</span></blockquote><p class="calibre50">To bring all this talk about precision and range down to earth, let’s see what we can do with these arbitrarily large integers that we can’t do with regular longs. Consider some value in a program that happens to be the maximum that can be represented in a long:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def k Long/MAX_VALUE)<br class="calibre33"/>;= #'user/k<br class="calibre33"/>k<br class="calibre33"/>;= 9223372036854775807</tt></span></blockquote><p class="calibre23">That’s a big number, but sometimes, it’s not big enough:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(inc k)<br class="calibre33"/>;= ArithmeticException integer overflow</tt></span></blockquote><p class="calibre23">Clojure’s primary math operators throw an exception on integer overflow instead of silently “wrapping around” the value, as discussed in <a href="#filepos1564954"><span class="calibre5">Unchecked Ops</span></a>. But, sometimes we really do need to work with values larger than the maximum value allowed by longs and doubles; in such cases, we have a couple of options:</p><p class="calibre18"><span class="bold">Explicitly use arbitrary-precision numbers</span>. Depending on the local requirements and context, this can be done either using the <tt class="calibre22">bigint</tt> and <tt class="calibre22">bigdec</tt> coercion functions:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(inc (bigint k))<br class="calibre33"/>;= 9223372036854775808N<br class="calibre33"/>(* 100 (bigdec Double/MAX_VALUE))<br class="calibre33"/>;= 1.797693134862315700E+310M</tt></span></blockquote><p class="calibre23">or by using appropriate literal notations. Remember from <a href="#filepos88495"><span class="calibre5">Table 1-2</span></a> that an <tt class="calibre22">N</tt> suffix produces a <tt class="calibre22">BigInt</tt>, and an <tt class="calibre22">M</tt> suffix produces a <tt class="calibre22">BigDecimal</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(dec 10223372636454715900N)<br class="calibre33"/>;= 10223372636454715899N<br class="calibre33"/>(* 0.5M 1e403M)<br class="calibre33"/>;= 5E+402M</tt></span></blockquote><p class="calibre23">Additionally, integer literals that exceed the limits of 64-bit <tt class="calibre22">long</tt>s are automatically promoted to be <tt class="calibre22">BigInt</tt>s:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">10223372636454715900<br class="calibre33"/>;= 10223372636454715900N<br class="calibre33"/>(* 2 10223372636454715900)<br class="calibre33"/>;= 20446745272909431800N</tt></span></blockquote><p class="calibre23"><span class="bold">Utilize autopromoting operators for integer calculations</span>. <a id="filepos1562891"></a>Using arbitrary precision explicitly is good if we control the inputs to a particular function; that allows us to use Clojure’s primary arithmetic operators and rely on its (fast) numeric type contagion semantics to provoke the promotion of return values if necessary. If we know a particular calculation will require unbounded precision or range, we can supply arbitrary-precision inputs.</p><p class="calibre18">On the other hand, if we are implementing a calculation or algorithm that only <span class="italic">may</span> exceed the range of <tt class="calibre22">long</tt> integers, and contagion is not sufficient to ensure correct results, we can use the <span class="italic">prime<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1563572"></a><a href="#filepos1573650"><span class="calibre32">333</span></a><span class="calibre32">]</span></small></sup></span> autopromoting variants of Clojure’s arithmetic operators to <span class="italic">auto</span>matically <span class="italic">promote</span>
<tt class="calibre22">long</tt> results to <tt class="calibre22">BigInt</tt>s that would otherwise overflow:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(inc' k)<br class="calibre33"/>;= 9223372036854775808N</tt></span></blockquote><p class="calibre23">These operators promote results <span class="italic">only as necessary</span> though; this ensures that results that are within the bounded range of 64-bit <tt class="calibre22">long</tt>s are not promoted:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(inc' 1)<br class="calibre33"/>;= 2<br class="calibre33"/>(inc' (dec' Long/MAX_VALUE))<br class="calibre33"/>;= 9223372036854775807</tt></span></blockquote><p class="calibre23">Prime variants are available for all of Clojure’s mathematical operators that can cause an integer overflow or underflow: <tt class="calibre22">inc'</tt>, <tt class="calibre22">dec'</tt>, <tt class="calibre22">+'</tt>, <tt class="calibre22">-'</tt>, and <tt class="calibre22">*'</tt>.</p><p class="calibre18">There is a slight overhead associated with using the prime operators;<a id="filepos1564668"></a> each operation involving bounded representations must check the result and potentially redo the operation using <tt class="calibre22">BigInt</tt>s instead of <tt class="calibre22">long</tt>s. Such overhead is the price one must pay in order to obtain guaranteed correct results with a minimum of effort.<a id="filepos1564943"></a></p><p id="filepos1564954" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Unchecked Ops</span></span></span></p><p class="calibre18"><span class="italic">Overflow</span><a id="filepos1565100"></a> and <span class="italic">underflow</span> are conditions where the result of an operation over integers exceeds what that integer’s representation can support. The effects of underflow and overflow are likely familiar to anyone that has worked with numerical data in Java;<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1565396"></a><a href="#filepos1574327"><span class="calibre32">334</span></a><span class="calibre32">]</span></small></sup> for example, this Java code:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">System.out.println(Long.MAX_VALUE);<br class="calibre33"/>System.out.println(Long.MAX_VALUE + 1);</tt></span></blockquote><p class="calibre23">will yield this output:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">9223372036854775807<br class="calibre33"/>-9223372036854775808</tt></span></blockquote><p class="calibre23">Ouch. Of course, none of us are ever intentionally incrementing maximum value constants, but the same thing happens if our calculations (unexpectedly) broach the defined limits of a given numeric representation.</p><p class="calibre18">Thankfully, all of Clojure’s mathematical operators check for overflow and underflow and throw an exception if necessary:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">Long/MIN_VALUE<br class="calibre33"/>;= -9223372036854775808<br class="calibre33"/>(dec Long/MIN_VALUE)<br class="calibre33"/>;= #&lt;ArithmeticException java.lang.ArithmeticException: integer overflow&gt;</tt></span></blockquote><p class="calibre23">This is decidedly better than having to track down bizarre behavior in your application because an operation overflowed <span class="italic">somewhere</span>, returning a semantically evil “wraparound” result.</p><p class="calibre18">However, there are some limited circumstances where you may want to retain the unchecked behavior of Java’s operators:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">You want to retain complete compatibility with Java’s unfortunate semantics in this department—for example, if you’re implementing a new version of some functionality in Clojure that was previously written in Java.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">You want to avoid the (very small) cost associated with Clojure’s overflow/underflow checks.</blockquote></li></ol><p class="calibre18">There are <tt class="calibre22">unchecked-*</tt><a id="filepos1567503"></a> variants of all of Clojure’s operators that do not perform underflow/overflow checks:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(unchecked-dec Long/MIN_VALUE)<br class="calibre33"/>;= 9223372036854775807<br class="calibre33"/>(unchecked-multiply 92233720368547758 1000)<br class="calibre33"/>;= -80</tt></span></blockquote><p class="calibre23">These variants are somewhat verbose (<tt class="calibre22">unchecked-multiply</tt> is pretty rough compared to <tt class="calibre22">*</tt>). An alternative is to <tt class="calibre22">set!</tt>
<tt class="calibre22">*unchecked-math*</tt> to a true value prior to any top-level forms whose mathematical operations should all be unchecked:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(inc Long/MAX_VALUE)<br class="calibre33"/>;= #&lt;ArithmeticException java.lang.ArithmeticException: integer overflow&gt;<br class="calibre33"/>(set! *unchecked-math* true)<br class="calibre33"/>;= true<br class="calibre33"/>(inc Long/MAX_VALUE)<br class="calibre33"/>;= -9223372036854775808<br class="calibre33"/>(set! *unchecked-math* false)<br class="calibre33"/>;= false</tt></span></blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">If you are going to use </span><span class="calibre10"><tt class="calibre22">*unchecked-math*</tt></span><a id="filepos1568743"></a><span class="calibre10">, it is most common to </span><span class="calibre10"><tt class="calibre22">set!</tt></span><span class="calibre10"> it at the top of a source file prior to the forms where unchecked ops should be used, optionally </span><span class="calibre10"><tt class="calibre22">set!</tt></span><span class="calibre10">ing it back to </span><span class="calibre10"><tt class="calibre22">false</tt></span><span class="calibre10"> after those forms. </span><span class="calibre10"><tt class="calibre22">*unchecked-math*</tt></span><span class="calibre10">
</span><span class="calibre10"><span class="italic">is reset for each source file that is loaded</span></span><span class="calibre10">, so you need to set it in each file that you use it; that is, you cannot set it once in a top-level namespace and expect that to take effect throughout subsequently loaded files. If this weren’t the case, forgetting to reset </span><span class="calibre10"><tt class="calibre22">*unchecked-math*</tt></span><span class="calibre10"> back to </span><span class="calibre10"><tt class="calibre22">false</tt></span><span class="calibre10"> at the end of a file would “leak” the unfortunate semantics of unchecked ops throughout your (and others’) code.</span></blockquote><p class="calibre25">Note that you generally cannot use <tt class="calibre22">binding</tt> to set <tt class="calibre22">*unchecked-math*</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(binding [*unchecked-math* true]<br class="calibre33"/>  (inc Long/MAX_VALUE))<br class="calibre33"/>;= #&lt;ArithmeticException java.lang.ArithmeticException: integer overflow&gt;</tt></span></blockquote><p class="calibre23">This is because <tt class="calibre22">*unchecked-math*</tt> controls the operation of the compiler, but the <tt class="calibre22">binding</tt> form does not take effect until it is evaluated. This happens after (sometimes long after) the compiler has had its way with a given top-level form.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1570438"></a><a href="#filepos1574700"><span class="calibre32">335</span></a><span class="calibre32">]</span></small></sup></p><p id="filepos1570537" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Scale and Rounding Modes for Arbitrary-Precision Decimals Ops</span></span></span></p><p id="filepos1570688" class="calibre18">One of the most frustrating things about using <tt class="calibre22">BigDecimal</tt><a id="filepos1570782"></a> in Java is that many operations fail by default:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">new BigDecimal(1).divide(new BigDecimal(3));<br class="calibre33"/><br class="calibre33"/>= java.lang.ArithmeticException:<br class="calibre33"/>=   Non-terminating decimal expansion; no exact representable decimal result.</tt></span></blockquote><p class="calibre23">While this code is already painfully verbose, making it work acceptably by specifying a rounding mode and maximum scale is even worse:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">new BigDecimal(1).divide(new BigDecimal(3), new MathContext(10, RoundingMode.HALF_UP));<br class="calibre33"/><br class="calibre33"/>= 0.3333333333</tt></span></blockquote><p class="calibre23">Ruby’s arbitrary-precision decimal implementation carries roughly the same cost, although the tradeoffs involved are different: instead of forcing you to thread a math context through each operation, math context parameters are set globally in the <tt class="calibre22">Decimal</tt> class.</p><p class="calibre18">Clojure provides a macro, <tt class="calibre22">with-precision</tt><a id="filepos1571870"></a>, which simplifies this significantly. You provide your desired scale (and optionally, a rounding mode), and that information is threaded through all <tt class="calibre22">BigDecimal</tt> operations performed within the scope of <tt class="calibre22">with-precision</tt>
<span class="italic">for you</span>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(/ 22M 7)<br class="calibre33"/>;= #&lt;ArithmeticException java.lang.ArithmeticException:<br class="calibre33"/>;=   Non-terminating decimal expansion; no exact representable decimal result.&gt;<br class="calibre33"/>(with-precision 10 (/ 22M 7))<br class="calibre33"/>;= 3.142857143M<br class="calibre33"/>(with-precision 10 :rounding FLOOR<br class="calibre33"/>  (/ 22M 7))<br class="calibre33"/>;= 3.142857142M</tt></span></blockquote><p class="calibre23">And, if you really want to, you can set the scale and rounding mode without using <tt class="calibre22">with-precision</tt> by setting <tt class="calibre22">*math-context*</tt><a id="filepos1572724"></a> to an appropriate instance of <tt class="calibre22">java.math.MathContext</tt>:<a id="filepos1572793"></a><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1572835"></a><a href="#filepos1575293"><span class="calibre32">336</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(set! *math-context* (java.math.MathContext. 10 java.math.RoundingMode/FLOOR))<br class="calibre33"/>;= #&lt;MathContext precision=10 roundingMode=FLOOR&gt;<br class="calibre33"/>(/ 22M 7)<br class="calibre33"/>;= 3.142857142M</tt></span></blockquote><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1573302"></a><a href="#filepos1559238"><span class="calibre32">332</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="#filepos1583249"><span class="calibre10"><span class="calibre5">Equivalence can preserve your sanity</span></span></a><span class="calibre10"> for an example of this.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1573650"></a><a href="#filepos1563572"><span class="calibre32">333</span></a><span class="calibre32">] </span></small></sup><span class="calibre10"><span class="italic">Prime</span></span><span class="calibre10"> here refers to the convention of using a prime mark (typically represented as an apostrophe, </span><span class="calibre10"><tt class="calibre22">'</tt></span><span class="calibre10">) as a suffix of an operator’s name to denote a variant of the baseline operator. See </span><a href="http://en.wikipedia.org/wiki/Prime_(symbol"><span class="calibre10"><span class="calibre5">http://en.wikipedia.org/wiki/Prime_(symbol</span></span></a><span class="calibre10">) for details of this notation outside of Clojure.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1574327"></a><a href="#filepos1565396"><span class="calibre32">334</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Underflow and overflow are not an issue in languages like Python and Ruby, both of which apply autopromotion at all times to avoid these conditions for all of their mathematical operators.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1574700"></a><a href="#filepos1570438"><span class="calibre32">335</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">An expression provided to </span><span class="calibre10"><tt class="calibre22">eval</tt></span><span class="calibre10"> within such a </span><span class="calibre10"><tt class="calibre22">binding</tt></span><span class="calibre10"> form </span><span class="calibre10"><span class="italic">would</span></span><span class="calibre10"> be compiled and evaluated using unchecked ops, since that compilation would be performed after the dynamic scope is established…although we cannot imagine why you would want to do this.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1575293"></a><a href="#filepos1572835"><span class="calibre32">336</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Since </span><span class="calibre10"><tt class="calibre22">*math-context*</tt></span><span class="calibre10"> is a dynamic var, you can change its value using either </span><span class="calibre10"><tt class="calibre22">set!</tt></span><span class="calibre10"> or </span><span class="calibre10"><tt class="calibre22">alter-var-root</tt></span><span class="calibre10">. Which one you choose depends on whether you want your change to take effect on a thread-local basis or globally, respectively. You can read about dynamic scope in </span><a href="#filepos744558"><span class="calibre10"><span class="calibre5">Dynamic Scope</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos1575967" class="calibre6"><span class="calibre4"><span class="bold">Equality and Equivalence</span></span></p><p id="filepos1576052" class="calibre18">Clojure provides three ways to determine the equality of values, which are embodied in three different predicate functions.</p><p id="filepos1576207" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Object Identity (identical?)</span></span></span></p><p id="filepos1576325" class="calibre18">Object identity, implemented by <tt class="calibre22">identical?</tt> in Clojure, is used to determine if two (or more) objects are exactly the same instance. This corresponds directly to <tt class="calibre22">==</tt> in Java (when used to compare object references), <tt class="calibre22">is</tt> in Python, and <tt class="calibre22">equal?</tt> in Ruby:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(identical? "foot" (str "fo" "ot"))<br class="calibre33"/>;= false<br class="calibre33"/>(let [a (range 10)]<br class="calibre33"/>  (identical? a a))<br class="calibre33"/>;= true</tt></span></blockquote><p class="calibre23">In general, numbers will never be <tt class="calibre22">identical?</tt>, even if provided as literals:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(identical? 5/4 (+ 3/4 1/2))<br class="calibre33"/>;= false<br class="calibre33"/>(identical? 5.4321 5.4321)<br class="calibre33"/>;= false<br class="calibre33"/>(identical? 2600 2600)<br class="calibre33"/>;= false</tt></span></blockquote><p class="calibre23">The exception is that the JVM (and therefore Clojure) provides for a limited range of <span class="italic">fixnums</span><a id="filepos1577339"></a>. Fixnums are a pool of boxed integer values that are always used in preference to allocating a new integer. Ruby’s fixnum semantics cover the entire range of its integers, while Python’s fixnums are available only between –5 and 256.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1577621"></a><a href="#filepos1586922"><span class="calibre32">337</span></a><span class="calibre32">]</span></small></sup> The Oracle JVM’s fixnum range is ±127<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1577792"></a><a href="#filepos1587165"><span class="calibre32">338</span></a><span class="calibre32">]</span></small></sup> and so only results of operations that return integers within this range may be <tt class="calibre22">identical?</tt> to other integers of the same value:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(identical? 127 (dec 128))<br class="calibre33"/>;= true<br class="calibre33"/>(identical? 128 (dec 129))<br class="calibre33"/>;= false</tt></span></blockquote><p class="calibre23">In general, it’s wise to not use <tt class="calibre22">identical?</tt> at all when comparing numbers.</p><p id="filepos1578328" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Reference Equality (=)</span></span></span></p><p id="filepos1578440" class="calibre18">This is what is most commonly referred to as “equality”: a (potentially) type-sensitive, deep comparison of values to determine if they are structurally the same. Clojure’s <tt class="calibre22">=</tt> predicate adopts the equality semantics of Java’s reference equality, defined by <tt class="calibre22">java.lang.Object.equals</tt>.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1578809"></a><a href="#filepos1587549"><span class="calibre32">339</span></a><span class="calibre32">]</span></small></sup><tt class="calibre22">=</tt> in Clojure is functionality equivalent to <tt class="calibre22">==</tt> in both Python and Ruby.</p><p class="calibre18">This yields generally intuitive and convenient results, especially when comparing collections of different concrete types:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(= {:a 1 :b ["hi"]}<br class="calibre33"/>   (into (sorted-map) [[:b ["hi"]] [:a 1]])<br class="calibre33"/>   (doto (java.util.HashMap.)<br class="calibre33"/>     (.put :a 1)<br class="calibre33"/>     (.put :b ["hi"])))<br class="calibre33"/>;= true</tt></span></blockquote><p class="calibre23">Note, however, that collections of different categories will never be <tt class="calibre22">=</tt> to each other. For example, while any sequential collection (e.g., a vector, list, or sequence) may be equal to another sequential collection of a different concrete type, a sequential collection will never be equal to a set, or a map.</p><p class="calibre18">The same dynamic applies to numeric equality. More precisely, <tt class="calibre22">=</tt> will only ever return true when comparing numbers of the same category, even if the numerical value being represented is equivalent. For example, all types of integers are usefully comparable using <tt class="calibre22">=</tt> (even integer types smaller than Clojure’s preferred 64-bit longs), and the limited-precision decimals of different widths play nicely together as well:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(= 1 1N (Integer. 1) (Short. (short 1)) (Byte. (byte 1)))<br class="calibre33"/>;= true<br class="calibre33"/>(= 1.25 (Float. 1.25))<br class="calibre33"/>;= true</tt></span></blockquote><p class="calibre23">However, <tt class="calibre22">=</tt> will <span class="italic">never</span> return true for comparisons of equivalent numbers of different categories:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(= 1 1.0)<br class="calibre33"/>;= false<br class="calibre33"/>(= 1N 1M)<br class="calibre33"/>;= false<br class="calibre33"/>(= 1.25 5/4)<br class="calibre33"/>;= false</tt></span></blockquote><p class="calibre23">Clojure’s <tt class="calibre22">=</tt>
<span class="italic">could</span> obviate these type differences (as Ruby and Python do), but doing so would impose some runtime cost that would be unappreciated by those who need to maximize the performance of programs that work with homogeneous numeric data. Thus, Clojure opts to provide a third notion of equality, specifically to address the need for type-insensitive equivalence tests.</p><p id="filepos1581236" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Numeric Equivalence (==)</span></span></span></p><p id="filepos1581350" class="calibre18">Clojure’s <tt class="calibre22">==</tt> predicate implements <span class="italic">numerical equivalence</span>, a measure of equality that is aligned with our intuitive understanding, unfettered by the artificial categories we use to delineate numeric representations. Where <tt class="calibre22">=</tt> returns false when comparing numbers of different implementation categories, <tt class="calibre22">==</tt> may return true if the values represented by the numbers provided are numerically equivalent:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(== 0.125 0.125M 1/8)<br class="calibre33"/>;= true<br class="calibre33"/>(== 4 4N 4.0 4.0M)<br class="calibre33"/>;= true</tt></span></blockquote><p class="calibre23">Note that even rationals are right at home being compared to their corresponding decimal representations when using <tt class="calibre22">==</tt>.</p><p class="calibre18"><tt class="calibre22">==</tt> requires that all of its arguments be numbers; otherwise, it will throw an exception. This means that if you are not sure what the type of an argument might be, you need to either:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Use <tt class="calibre22">=</tt>.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">If you need the equivalence semantics of <tt class="calibre22">==</tt>, you need to guard its use with checks of its arguments (using <tt class="calibre22">number?</tt> will do here).</blockquote></li></ul><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn equiv?<br class="calibre33"/>  "Same as `==`, but doesn't throw an exception if any arguments are not numbers."<br class="calibre33"/>  [&amp; args]<br class="calibre33"/>  (and (every? number? args)<br class="calibre33"/>       (apply == args)))<br class="calibre33"/>;= #'user/equiv?<br class="calibre33"/>(equiv? "foo" 1)<br class="calibre33"/>;= false<br class="calibre33"/>(equiv? 4 4N 4.0 4.0M)<br class="calibre33"/>;= true<br class="calibre33"/>(equiv? 0.125 0.125M 1/8)<br class="calibre33"/>;= true</tt></span></blockquote><p id="filepos1583249" class="calibre23"><span class="calibre53"><span class="bold">Equivalence can preserve your sanity</span></span></p><p class="calibre18">Java’s notion of numeric equality can really hurt when heterogeneous types of numbers are used in collections. Because Java’s collection implementations depend on each member’s definition of equality (for things like determining membership in a set and locating a map entry given some key), and its numerics are defined to restrict equality based on implementation type, you can end up with degenerate situations like this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">java.util.Map m = new java.util.HashMap();<br class="calibre33"/>m.put(1, "integer");<br class="calibre33"/>m.put(1L, "long");<br class="calibre33"/>m.put(java.math.BigInteger.valueOf(1), "bigint");<br class="calibre33"/>System.out.println(m);<br class="calibre33"/><br class="calibre33"/>&gt;&gt; {1=bigint, 1=long, 1=integer}</tt></span></blockquote><p class="calibre23">Ouch: a map with three keys that we almost certainly would have preferred to have hashed out to the same entry—a recipe for producing incredibly subtle bugs. In contrast, Clojure’s collections use its definition of equivalence for numeric keys and members:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(into #{} [1 1N (Integer. 1) (Short. (short 1))])<br class="calibre33"/>;= #{1}<br class="calibre33"/>(into {}<br class="calibre33"/>      [[1 :long]<br class="calibre33"/>       [1N :bigint]<br class="calibre33"/>       [(Integer. 1) :integer]])<br class="calibre33"/>;= {1 :integer}</tt></span></blockquote><blockquote class="calibre38"></blockquote><blockquote class="calibre39"><span class="calibre10"><span class="bold">BEWARE MIXED FLOATING-POINT EQUALITY TESTS</span></span></blockquote><blockquote id="filepos1584936" class="calibre17"><span class="calibre10">As is always the case with floating-point decimals, care must be taken to account for the details of their representations. Just as simple operations can sometimes produce “incorrect” results:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(+ 0.1 0.2)<br class="calibre33"/>;= 0.30000000000000004</tt></span></blockquote><blockquote class="calibre35"><span class="calibre10">equality comparisons of different types of decimals can yield surprising behavior. Consider:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(== 1.1 (float 1.1))<br class="calibre33"/>;= false</tt></span></blockquote><blockquote class="calibre35"><span class="calibre10">Note that this is false even though we’re using the type-insensitive </span><span class="calibre10"><tt class="calibre22">==</tt></span><span class="calibre10"> equivalency predicate. The issue is that the </span><span class="calibre10"><tt class="calibre22">float</tt></span><span class="calibre10"> (a 32-bit representation) needs to be widened into a </span><span class="calibre10"><tt class="calibre22">double</tt></span><span class="calibre10"> (a 64-bit representation), which cannot be done precisely for </span><span class="calibre10"><tt class="calibre22">1.1</tt></span><span class="calibre10">:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(double (float 1.1))<br class="calibre33"/>;= 1.100000023841858</tt></span></blockquote><blockquote class="calibre35"><span class="calibre10">The same behavior occurs in Java, where this returns </span><span class="calibre10"><tt class="calibre22">false</tt></span><span class="calibre10">:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">1.1f == 1.1d</tt></span></blockquote><blockquote class="calibre35"><span class="calibre10">The causes of this are rooted in the IEEE floating-point specifications. Languages like Ruby and Python sidestep this issue by providing only one limited-precision decimal representation.</span><a id="filepos1586809"></a></blockquote><br class="calibre33"/><hr class="calibre34"/><p class="calibre25"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1586922"></a><a href="#filepos1577621"><span class="calibre32">337</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">This unusual range is an implementation detail of CPython.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1587165"></a><a href="#filepos1577792"><span class="calibre32">338</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">The JVM’s fixnum semantics are defined as part of its boxing conversions for primitive values (discussed in §5.1.7 of the Java Language Spec), and may differ in other versions and implementations.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1587549"></a><a href="#filepos1578809"><span class="calibre32">339</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">And, when comparing non-numbers, Clojure’s </span><span class="calibre10"><tt class="calibre22">=</tt></span><span class="calibre10"> simply delegates to its arguments’ implementation of </span><span class="calibre10"><tt class="calibre22">Object.equals</tt></span><span class="calibre10">. The specifics of </span><span class="calibre10"><tt class="calibre22">Object.equals</tt></span><span class="calibre10"> are far more intricate than our summary here. It is absolutely worth your time to look at the javadocs for it and absorb them fully: </span><a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals%28java.lang.Object%29"><span class="calibre10"><span class="calibre5">http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals%28java.lang.Object%29</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos1588398" class="calibre6"><span class="calibre4"><span class="bold">Optimizing Numeric Performance</span></span></p><p id="filepos1588489" class="calibre18">Clojure provides all the raw materials needed to model and implement data- and mathematics-intensive algorithms clearly and concisely. However, while expressivity is important, performance is often an overriding concern in such cases—it’s what drives programmers everywhere who would otherwise prefer higher-level languages to implement performance-critical sections of their programs in languages like C and Fortran. That’s a fine coping mechanism, and can always be a measure of last resort,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1589051"></a><a href="#filepos1630111"><span class="calibre32">340</span></a><span class="calibre32">]</span></small></sup> but is often a source of integration, build, and deployment complexity (not to mention a sap on developer productivity). Thus, the more we can do in our high-level language, the happier and more productive we’ll be.</p><p class="calibre18">So, how can we maximize the performance of numerics-intensive code in Clojure?</p><p class="calibre18"><span class="bold">Use primitives</span>. As we discussed in <a href="#filepos1538811"><span class="calibre5">Clojure Has a Mixed Numerics Model</span></a>, primitives <a id="filepos1589651"></a>are not burdened by the allocation and garbage-collection costs associated with boxed numbers, and most operations over them are implemented at very low levels (often the hardware itself). All other things being equal, the same algorithm<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1589930"></a><a href="#filepos1630756"><span class="calibre32">341</span></a><span class="calibre32">]</span></small></sup> implemented to utilize primitives will often be an order of magnitude faster than if boxed numbers are used. Doing this within Clojure will allow you to implement algorithms that approach the runtime performance of the same functionality implemented in Java.</p><p class="calibre18"><span class="bold">Avoid collections and seqs</span>. <a id="filepos1590352"></a>A corollary to the notion of using primitives whenever possible where performance is a concern is that you should avoid using collections and sequences in such circumstances. As we mentioned in <a href="#filepos1540328"><span class="calibre5">Why Do Long and Double Exist at All, Since They Don’t Provide Any Semantic Advantages Over Their Primitive Counterparts?</span></a>, collections deal exclusively in objects, and cannot generally store primitive-typed values. When a primitive is added to a collection, it is automatically “promoted” to an instance of its corresponding boxed class—an approach to marrying primitive and object-based type systems called <span class="italic">autoboxing</span><a id="filepos1591040"></a>, a dynamic that Clojure inherits from the JVM.</p><p class="calibre18">For example, adding a <tt class="calibre22">double</tt> to a list results in an instance of its box class (<tt class="calibre22">java.lang.Double</tt>) being allocated and initialized with the primitive <tt class="calibre22">double</tt> value. While allocation and the garbage collection that goes with it is remarkably fast on the JVM, the fastest possible allocation and garbage collection is that which doesn’t happen. Thus, if you really want to push the performance of the hottest parts of your codebase as far as possible, avoiding such costs requires avoiding collections and sequences.</p><p class="calibre18">When you abstain from using collections and sequences, the natural fallback is to use arrays of primitives.</p><p id="filepos1591810" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Declare Functions to Take and Return Primitives</span></span></span></p><p id="filepos1591947" class="calibre18">When Clojure compiles a function, it generates a corresponding class that implements <tt class="calibre22">clojure.lang.IFn</tt>, one of Clojure’s Java interfaces. <tt class="calibre22">IFn</tt><a id="filepos1592135"></a> defines a number of <tt class="calibre22">invoke</tt> methods; these are what are called under the covers when you invoke a Clojure function.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1592301"></a><a href="#filepos1631238"><span class="calibre32">342</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18"><span class="bold">All arguments and return values are Objects at (undecorated) function boundaries</span>. These <tt class="calibre22">invoke</tt><a id="filepos1592539"></a> methods all accept arguments <a id="filepos1592576"></a>and return values <a id="filepos1592601"></a>of the root type <tt class="calibre22">java.lang.Object</tt>. This enables Clojure’s dynamic typing defaults (i.e., your functions’ implementations determine the range of acceptable argument types, not static type declarations that are enforced by the language), but has the side effect of forcing the JVM to box any primitives passed as arguments to or returned as results from those functions. So, if we call a Clojure function with a primitive argument—a <tt class="calibre22">long</tt>, for example—that argument will be boxed into a <tt class="calibre22">Long</tt> object in order to conform to the type signature of the Clojure function’s underlying <tt class="calibre22">invoke</tt> method. Similarly, if a function’s result is a primitive value, the underlying <tt class="calibre22">Object</tt> return type ensures that such primitives are boxed before the caller receives the result.</p><p class="calibre18">While Clojure is unabashedly a dynamic programming language, it recognizes that optionally providing type information in order to optimize runtime performance is a winning tradeoff. Class-based type <span class="italic">hints<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1593696"></a><a href="#filepos1631796"><span class="calibre32">343</span></a><span class="calibre32">]</span></small></sup></span> enable the Clojure complier to avoid reflection when performing Java interop (such as invoking methods on <tt class="calibre22">Object</tt>s and so on), but hints do not change the signature of functions’ implementing methods; those <tt class="calibre22">invoke</tt> methods continue to accept all <tt class="calibre22">Object</tt>s. In contrast, Clojure also provides for statically declaring the functions’ arguments and return values to be primitives: specifically, of type <tt class="calibre22">double</tt> or <tt class="calibre22">long</tt>.</p><p class="calibre18">We can see this by examining the methods of the classes generated by functions. As a baseline, here’s a function that takes a single argument that has no hints or type declarations:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn foo [a] 0)<br class="calibre33"/>;= #'user/foo<br class="calibre33"/>(seq (.getDeclaredMethods (class foo)))<br class="calibre33"/>;= (#&lt;Method public java.lang.Object user$foo.invoke(java.lang.Object)&gt;)</tt></span></blockquote><p class="calibre23">Notice that it declares a single arity of <tt class="calibre22">invoke</tt>; as expected, it accepts one argument of type <tt class="calibre22">Object</tt>, and returns a value of that type as well. We can also see that using a class-based hint does not impact the function’s underlying <tt class="calibre22">invoke</tt> method signature:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn foo [^Double a] 0)<br class="calibre33"/>;= #'user/foo<br class="calibre33"/>(seq (.getDeclaredMethods (class foo)))<br class="calibre33"/>;= (#&lt;Method public java.lang.Object user$foo.invoke(java.lang.Object)&gt;)</tt></span></blockquote><p class="calibre23">Even though <tt class="calibre22">Double</tt> is semantically a number, it’s still a class, and therefore results in an <tt class="calibre22">Object</tt> argument type.</p><p class="calibre18">Let’s try again using the primitive type declarations that are available to us, <tt class="calibre22">^long</tt> and <tt class="calibre22">^double</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn round ^long [^double a] (Math/round a))<br class="calibre33"/>;= #'user/round<br class="calibre33"/>(seq (.getDeclaredMethods (round foo)))<br class="calibre33"/>;= (#&lt;Method public java.lang.Object user$round.invoke(java.lang.Object)&gt;<br class="calibre33"/>;=  #&lt;Method public final long user$round.invokePrim(double)&gt;)</tt></span></blockquote><p class="calibre23">What changed is that Clojure is using the primitive type declarations to compile a primitives-safe fast path into the generated class, in the form of an <tt class="calibre22">invokePrim</tt><a id="filepos1596231"></a> method, which accepts a primitive <tt class="calibre22">double</tt> and returns a primitive <tt class="calibre22">long</tt>. Calling this function now with a <tt class="calibre22">double</tt> will be as fast as if you had written the <tt class="calibre22">invokePrim</tt> method yourself in Java.</p><p class="calibre18">However, it will <span class="italic">not</span> accept a nonconforming argument:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(round "string")<br class="calibre33"/>;= #&lt;ClassCastException java.lang.ClassCastException:<br class="calibre33"/>;=   java.lang.String cannot be cast to java.lang.Number&gt;</tt></span></blockquote><p class="calibre23">Note that the exception complains about <tt class="calibre22">"string"</tt> not being a <tt class="calibre22">Number</tt>. We can indeed pass any boxed number…as long as it fits in the expected range:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn idem ^long [^long x] x)<br class="calibre33"/>;= #'user/long<br class="calibre33"/>(idem 18/5)<br class="calibre33"/>;= 3<br class="calibre33"/>(idem 3.14M)<br class="calibre33"/>;= 3<br class="calibre33"/>(idem 1e15)<br class="calibre33"/>;= 1000000000000000<br class="calibre33"/>(idem 1e150)<br class="calibre33"/>;= #&lt;IllegalArgumentException java.lang.IllegalArgumentException:<br class="calibre33"/>;=   Value out of range for long: 1.0E150&gt;</tt></span></blockquote><p class="calibre23">On the other hand, you might notice that the usual <tt class="calibre22">invoke</tt> method with its <tt class="calibre22">Object</tt> argument and return types remains; this is to support the case when the function is being called with a boxed numeric argument. This means that you can continue to use functions with declared primitive argument types in conjunction with higher-order functions<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1597844"></a><a href="#filepos1632146"><span class="calibre32">344</span></a><span class="calibre32">]</span></small></sup> like <tt class="calibre22">map</tt> and <tt class="calibre22">apply</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(map round [4.5 6.9 8.2])<br class="calibre33"/>;= (5 7 8)<br class="calibre33"/>(apply round [4.2])<br class="calibre33"/>;= 4</tt></span></blockquote><p class="calibre23">Both type hints and type declarations may be used in the specification of fields (and therefore, constructors) in <tt class="calibre22">deftype</tt> and <tt class="calibre22">defrecord</tt> types, which we discussed in detail in <a href="#filepos967758"><span class="calibre5">Defining Your Own Types</span></a>.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">FUNCTIONS SUPPORTING PRIMITIVE TYPES ARE LIMITED TO FOUR ARGUMENTS</span></span></span></blockquote><blockquote id="filepos1598648" class="calibre17"><span class="calibre10">The preceding code looks like a free lunch: all of the expressive power of Clojure paired with the efficiency of the JVM’s primitive numerics. Unfortunately, there is a downside: any Clojure function that is declared to accept or return a primitive type is limited to four arguments:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(defn foo ^long [a b c d e] 0)<br class="calibre33"/>;= #&lt;CompilerException java.lang.IllegalArgumentException:<br class="calibre33"/>;=   fns taking primitives support only 4 or fewer args&gt;</tt></span></blockquote><blockquote class="calibre35"><span class="calibre10">This is due to an implementation detail: in order to tap into the aforementioned efficiency without opting into a strictly static compilation process, each possible primitive-accepting function signature must be defined in a separate interface. With three possible argument and return types (</span><span class="calibre10"><tt class="calibre22">double</tt></span><span class="calibre10">, </span><span class="calibre10"><tt class="calibre22">long</tt></span><span class="calibre10">, and </span><span class="calibre10"><tt class="calibre22">Object</tt></span><span class="calibre10">), even allowing for a maximum of four arguments produces a permutation of hundreds of distinct interfaces.</span></blockquote><p id="filepos1599929" class="calibre25"><span class="calibre53"><span class="bold">Type errors and warnings</span></span></p><p id="filepos1600014" class="calibre18">The ability to declare primitive types for arguments and returns can lead to clearly inconsistent situations. Even though Clojure is a dynamic language, its compiler will throw compilation errors when it can detect a problem, either via direct analysis or type inference:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn foo ^long [^int a] 0)<br class="calibre33"/>;= #&lt;CompilerException java.lang.IllegalArgumentException:<br class="calibre33"/>;=   Only long and double primitives are supported&gt;<br class="calibre33"/>(defn foo ^long [^double a] a)<br class="calibre33"/>;= #&lt;CompilerException java.lang.IllegalArgumentException:<br class="calibre33"/>;=   Mismatched primitive return, expected: long, had: double&gt;</tt></span></blockquote><p class="calibre23">Similarly, if you have <tt class="calibre22">*warn-on-reflection*</tt><a id="filepos1600853"></a> bound to <tt class="calibre22">true</tt>, the compiler will emit warnings when you are attempting to <tt class="calibre22">recur</tt> with values that will require boxing, because their type will not match the binding’s declared (or inferred) type. Consider, a simple loop that counts down from 5 to 0:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(set! *warn-on-reflection* true)<br class="calibre33"/>;= true<br class="calibre33"/>(loop [x 5]<br class="calibre33"/>  (when-not (zero? x)<br class="calibre33"/>    (recur (dec x))))<br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre23"><tt class="calibre22">x</tt> here is inferred to be a <tt class="calibre22">long</tt> based on the literal that is provided, and the <tt class="calibre22">recur</tt> argument (the result of <tt class="calibre22">(dec x)</tt>) will also be a <tt class="calibre22">long</tt>, so there is no inconsistency. However, if we use the autopromoting <tt class="calibre22">dec'</tt> operator, it’s possible that the <tt class="calibre22">recur</tt> argument will be a <tt class="calibre22">BigInt</tt>; Clojure catches this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(loop [x 5]<br class="calibre33"/>  (when-not (zero? x)<br class="calibre33"/>    (recur (dec' x))))<br class="calibre33"/>; NO_SOURCE_FILE:2 recur arg for primitive local:<br class="calibre33"/>;                x is not matching primitive, had: Object, needed: long<br class="calibre33"/>; Auto-boxing loop arg: x<br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre23">The same thing happens if we attempt to <tt class="calibre22">recur</tt> to a <tt class="calibre22">long</tt> binding with an incompatible primitive, such as a <tt class="calibre22">double</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(loop [x 5]<br class="calibre33"/>  (when-not (zero? x)<br class="calibre33"/>    (recur 0.0)))<br class="calibre33"/>; NO_SOURCE_FILE:2 recur arg for primitive local:<br class="calibre33"/>;                x is not matching primitive, had: double, needed: long<br class="calibre33"/>; Auto-boxing loop arg: x<br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre23">These sorts of warnings are not limited to checks of primitive types within the local function body. Here, we have a function that returns <tt class="calibre22">double</tt> that instigates a warning when we attempt to <tt class="calibre22">recur</tt> with that return to a <tt class="calibre22">long</tt> binding:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn dfoo ^double [^double a] a)<br class="calibre33"/>;= #'user/dfoo<br class="calibre33"/>(loop [x 5]<br class="calibre33"/>  (when-not (zero? x)<br class="calibre33"/>    (recur (dfoo (dec x)))))<br class="calibre33"/>; NO_SOURCE_FILE:2 recur arg for primitive local:<br class="calibre33"/>;                x is not matching primitive, had: double, needed: long<br class="calibre33"/>; Auto-boxing loop arg: x<br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre23">In such a situation, we can avoid the boxing and the warning by using <tt class="calibre22">long</tt>, one of the primitive coercion functions, to ensure that a primitive value of the right type is used:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(loop [x 5]<br class="calibre33"/>  (when-not (zero? x)<br class="calibre33"/>    (recur (long (dfoo (dec x))))))<br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre23">Clojure’s coercion functions—<a id="filepos1603947"></a><tt class="calibre22">short</tt>, <tt class="calibre22">int</tt>, <tt class="calibre22">long</tt>, <tt class="calibre22">double</tt>, <tt class="calibre22">float</tt>, and <tt class="calibre22">boolean</tt>—are only useful when you need to eliminate a compiler warning related to reflection or autoboxing.<a id="filepos1604153"></a> For example, the usage of <tt class="calibre22">long</tt> above eliminated the prospect of autoboxing; here, we use <tt class="calibre22">double</tt> to eliminate a reflective call:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn round [v]<br class="calibre33"/>  (Math/round v))<br class="calibre33"/>; Reflection warning, NO_SOURCE_PATH:2 - call to round can't be resolved.<br class="calibre33"/>;= #'user/round<br class="calibre33"/>(defn round [v]<br class="calibre33"/>  (Math/round (double v)))<br class="calibre33"/>;= #'user/round</tt></span></blockquote><p class="calibre23">In particular, when used outside of such contexts, coercion functions <span class="italic">do not</span> return a value corresponding to the type they indicate:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(class (int 5))<br class="calibre33"/>;= java.lang.Long</tt></span></blockquote><p class="calibre23">In this way, they are most akin to type hints (discussed in <a href="#filepos1324665"><span class="calibre5">Type Hinting for Performance</span></a>), and should be used accordingly.<a id="filepos1605145"></a></p><p id="filepos1605156" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Use Primitive Arrays Judiciously</span></span></span></p><p id="filepos1605278" class="calibre18">We already outlined how Java arrays may be used within Clojure in general in <a href="#filepos1336318"><span class="calibre5">Arrays</span></a>, but there are some special considerations that should be taken into account when working with arrays of primitive values.</p><p class="calibre18"><span class="bold">Isolated mutation of local arrays is okay</span>. <a id="filepos1605650"></a>Along the lines of, “If a tree falls in the forest and no one hears it, does it make a sound?,” there are absolutely times where the use of mutable arrays is not only acceptable, but reasonable and entirely in line with Clojure idioms.</p><p class="calibre18">While Clojure strongly encourages the application of functional programming—including the use of immutable data structures, its sequence abstraction, maintaining a discrete split between state and identity, and all the rest described in <a href="#filepos215548"><span class="calibre5">Part I</span></a>—it is fundamentally a practical language that won’t get in the way if you really do need to bash around in a mutable array to get the performance characteristics you require.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1606443"></a><a href="#filepos1632505"><span class="calibre32">345</span></a><span class="calibre32">]</span></small></sup> Further, as long as your usage of mutable arrays is isolated (i.e., you don’t let the mutable array escape from the hot code that needs it) and local (i.e., you’re not mutating any arrays available globally or as an argument to one of your functions), you have a strong claim that your code is still functional in nature because it retains idempotent semantics.</p><p class="calibre18">A basic example where this approach is reasonable is in the construction of a histogram for a dataset. We used Clojure’s <tt class="calibre22">frequencies</tt><a id="filepos1607079"></a> function to obtain histograms for various datasets in <a href="#filepos1409686"><span class="calibre5">Example 9-20</span></a>, but let’s look at what it would take to implement our own function to produce histograms. Assuming for now that we are working with bounded integer data, a vector might be the most appropriate representation:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn vector-histogram<br class="calibre33"/>  [data]<br class="calibre33"/>  (reduce (fn [hist v]<br class="calibre33"/>            (update-in hist [v] inc))<br class="calibre33"/>    (vec (repeat 10 0))<br class="calibre33"/>    data))</tt></span></blockquote><p class="calibre23">Let’s get a sense of what its performance is like:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def data (doall (repeatedly 1e6 #(rand-int 10))))                </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #'user/data<br class="calibre33"/>(time (vector-histogram data))<br class="calibre33"/>; "Elapsed time: 505.409 msecs"<br class="calibre33"/>;= [100383 100099 99120 100694 100003 99940 100247 99731 99681 100102]</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Our dataset is just a sequence of random <tt class="calibre22">Long</tt>s (ensured to be fully realized by using the <tt class="calibre22">doall</tt> function).</blockquote><p class="calibre18"><tt class="calibre22">vector-histogram</tt> is using Clojure’s immutable vector data structure though—very efficient, but perhaps not efficient enough.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1608739"></a><a href="#filepos1633074"><span class="calibre32">346</span></a><span class="calibre32">]</span></small></sup> Let’s try using a primitive array of longs to maintain the counts in our histogram:</p><p id="filepos1608924" class="calibre23"></p><p class="calibre23"><span class="italic">Example 11-1. Building a histogram with a temporary array</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(defn array-histogram<br class="calibre33"/>  [data]<br class="calibre33"/>  (vec<br class="calibre33"/>    (reduce (fn [^longs hist v]<br class="calibre33"/>              (aset hist v (inc (aget hist v)))<br class="calibre33"/>              hist)<br class="calibre33"/>            (long-array 10)<br class="calibre33"/>            data)))</tt></span></p><p class="calibre13">This is <span class="italic">much</span> faster, by a factor of ~20×:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(time (array-histogram data))<br class="calibre33"/>; "Elapsed time: 25.925 msecs"<br class="calibre33"/>;= [100383 100099 99120 100694 100003 99940 100247 99731 99681 100102]</tt></span></blockquote><p class="calibre23">This is a perfect place to use a primitive array:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">It matches the model and usage we need and puts no restrictions on the type of inputs it can work with (the <tt class="calibre22">reduce</tt> will work over any sequential collection, including other arrays).</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">The mutable array is only used locally, and never escapes the function. Thus, <tt class="calibre22">array-histogram</tt> is pure, and perfectly at home among other such functions in Clojure.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Using an array does not change the semantics a user would expect, including returning the same concrete data structure (a vector) as <tt class="calibre22">vector-histogram</tt>.</blockquote></li></ol><p id="filepos1610684" class="calibre23"><span class="calibre53"><span class="bold">The mechanics of primitive arrays</span></span></p><p id="filepos1610778" class="calibre18">If you want to create an array from an existing collection, you can use either <tt class="calibre22">into-array</tt> or <tt class="calibre22">to-array</tt>. The latter always returns an array of objects; the former will return an array of the type of the first value in the provided collection, or an array of a specified supertype:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(into-array ["a" "b" "c"])<br class="calibre33"/>;= #&lt;String[] [Ljava.lang.String;@4413515e&gt;<br class="calibre33"/>(into-array CharSequence ["a" "b" "c"])              </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #&lt;CharSequence[] [Ljava.lang.CharSequence;@5acad437&gt;</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Explicitly producing an array of a supertype of a collection’s values can be particularly handy when interoperating with certain Java APIs that require such arrays.</blockquote><p class="calibre18">You can also use <tt class="calibre22">into-array</tt><a id="filepos1611915"></a> to produce arrays of primitives from collections of boxed values by providing the <tt class="calibre22">Class</tt> corresponding to the desired primitive type:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(into-array Long/TYPE (range 5))<br class="calibre33"/>;= #&lt;long[] [J@21e3cc77&gt;</tt></span></blockquote><p class="calibre23">Clojure provides some helper functions to create primitive or reference arrays: <tt class="calibre22">boolean-array</tt>, <tt class="calibre22">byte-array</tt>, <tt class="calibre22">short-array</tt>, <tt class="calibre22">char-array</tt>, <tt class="calibre22">int-array</tt>, <tt class="calibre22">long-array</tt>, <tt class="calibre22">float-array</tt>, <tt class="calibre22">double-array</tt>, and <tt class="calibre22">object-array</tt>. They take one argument, either the desired size or a collection:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(long-array 10)<br class="calibre33"/>;= #&lt;long[] [J@12ee6d57&gt;<br class="calibre33"/>(long-array (range 10))<br class="calibre33"/>;= #&lt;long[] [J@676982f8&gt;</tt></span></blockquote><p class="calibre23">Alternatively, except for <tt class="calibre22">object-array</tt>, you can provide both a size and a sequence, if the sequence is too short to initialize the whole array, it is padded with the default value for the corresponding type:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(seq (long-array 20 (range 10)))<br class="calibre33"/>;= (0 1 2 3 4 5 6 7 8 9 0 0 0 0 0 0 0 0 0 0)</tt></span></blockquote><p class="calibre23"><tt class="calibre22">make-array</tt><a id="filepos1613300"></a> is used to create new empty arrays of any size or dimensionality, which are initialized to the default value for the type in question (<tt class="calibre22">nil</tt> for object types, <tt class="calibre22">false</tt> for Boolean arrays, and zero for primitive numeric arrays):</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def arr (make-array String 5 5))<br class="calibre33"/>;= #'user/arr<br class="calibre33"/>(aget arr 0 0)<br class="calibre33"/>;= nil<br class="calibre33"/>(def arr (make-array Boolean/TYPE 10))<br class="calibre33"/>;= #'user/arr<br class="calibre33"/>(aget arr 0)<br class="calibre33"/>;= false</tt></span></blockquote><p id="filepos1613851" class="calibre23"><span class="bold">Array classes</span>. <a id="filepos1613902"></a>While <tt class="calibre22">make-array</tt> allows you to create arrays of any dimensionality, there are cases where you need to obtain a <tt class="calibre22">Class</tt> corresponding to an array type; for example, to extend a protocol to an array of a particular type, as shown in <a href="#filepos962584"><span class="calibre5">Example 6-2</span></a>. You can always get the <tt class="calibre22">Class</tt> of an array type using <tt class="calibre22">class</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(class (make-array Character/TYPE 0 0 0))<br class="calibre33"/>;= [[[C</tt></span></blockquote><p class="calibre23">But creating an array just to get a <tt class="calibre22">Class</tt> instance seems wrong somehow, akin to creating an array of some length in order to get a reference to that length’s number.</p><p class="calibre18">Notice how the printed representation of the array <tt class="calibre22">Class</tt> above uses an unusual notation? This is how the JVM names classes corresponding to array types. While every box class provides a static <tt class="calibre22">TYPE</tt> field corresponding to its primitive’s <tt class="calibre22">Class</tt>, there are no predefined <tt class="calibre22">Class</tt>es for nested arrays. Instead, you can use <tt class="calibre22">Class/forName</tt> to look up the <tt class="calibre22">Class</tt> for such types using the JVM’s notation, for example:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(Class/forName "[[Z")<br class="calibre33"/>;= [[Z<br class="calibre33"/>(.getComponentType *1)<br class="calibre33"/>;= [Z<br class="calibre33"/>(.getComponentType *1)<br class="calibre33"/>;= boolean</tt></span></blockquote><p class="calibre23">The notation is a bit arcane, but it is regular. Each prefixed bracket indicates one level in the depth of the array type, so <tt class="calibre22">"[Z"</tt> corresponds to a one-dimensional <tt class="calibre22">boolean</tt> array, <tt class="calibre22">"[[Z"</tt> corresponds to a two-dimensional <tt class="calibre22">boolean</tt> array, and so on. There is a character reserved for each primitive type:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">Z</tt>—<tt class="calibre22">boolean</tt></blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">B</tt>—<tt class="calibre22">byte</tt></blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">C</tt>—<tt class="calibre22">char</tt></blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">J</tt>—<tt class="calibre22">long</tt></blockquote></li><li value="5" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">I</tt>—<tt class="calibre22">int</tt></blockquote></li><li value="6" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">S</tt>—<tt class="calibre22">short</tt></blockquote></li><li value="7" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">D</tt>—<tt class="calibre22">double</tt></blockquote></li><li value="8" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">F</tt>—<tt class="calibre22">float</tt></blockquote></li></ul><p class="calibre18"><span class="bold">Array-specific type hints</span>. <a id="filepos1616809"></a>In general, unless Clojure knows what type of array you’re working with, access and mutation operations will end up happening reflectively, thus working against arrays’ usefulness as a local optimization. There is a set of type hints specifically intended for use with arrays:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">^objects<br class="calibre33"/>^booleans<br class="calibre33"/>^bytes<br class="calibre33"/>^chars<br class="calibre33"/>^longs<br class="calibre33"/>^ints<br class="calibre33"/>^shorts<br class="calibre33"/>^doubles<br class="calibre33"/>^floats</tt></span></blockquote><p class="calibre23">You can see this at work in <tt class="calibre22">array-histogram</tt> in <a href="#filepos1608924"><span class="calibre5">Example 11-1</span></a>; if we hadn’t hinted the <tt class="calibre22">hist</tt> argument to our reduce function, both the <tt class="calibre22">aget</tt> and <tt class="calibre22">aset</tt> operations turn into reflective calls, resulting in a running time <span class="italic">88x worse</span> than the our baseline histogram implementation that used immutable vectors!</p><p class="calibre18"><span class="bold">Access and mutation</span>. <tt class="calibre22">aget</tt><a id="filepos1617816"></a> and <tt class="calibre22">aset</tt><a id="filepos1617841"></a> provide array access and mutation <a id="filepos1617883"></a>operations, respectively:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [arr (long-array 10)]<br class="calibre33"/>  (aset arr 0 50)<br class="calibre33"/>  (aget arr 0))<br class="calibre33"/>;= 50</tt></span></blockquote><p class="calibre23">Both operations require that the array’s type be known in order to avoid reflection, usually provided by a suitable type hint. In this example, <tt class="calibre22">arr</tt> is known to be an array of <tt class="calibre22">long</tt>s since it’s declared locally.</p><p class="calibre18">There are some special considerations when accessing and modifying values in multidimensional arrays, which we’ll get to shortly.</p><p class="calibre18"><span class="bold">map and reduce over arrays</span>. <tt class="calibre22">map</tt><a id="filepos1618605"></a> and <tt class="calibre22">reduce</tt><a id="filepos1618632"></a> are pleasant to use, but they work with sequences that, as generic collections, can only hold objects. Thus, when applied to processing arrays, <tt class="calibre22">map</tt> and <tt class="calibre22">reduce</tt> prompt the liberal boxing of what had been primitive values.</p><p class="calibre18">Anything you can do with <tt class="calibre22">map</tt> and <tt class="calibre22">reduce</tt> can be unrolled into a <tt class="calibre22">loop</tt> expression, which does offer full primitive support. However, writing <tt class="calibre22">loop</tt> forms is error-prone insofar as you must track and manage indices into the array(s) being operated upon.</p><p class="calibre18">To spare us such things, Clojure provides <tt class="calibre22">amap</tt> and <tt class="calibre22">areduce</tt>, macros that are modeled after their functional counterparts but specialized to operate over arrays while avoiding autoboxing:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [a (int-array (range 10))]<br class="calibre33"/>  (amap a i res<br class="calibre33"/>    (inc (aget a i))))<br class="calibre33"/>;= #&lt;int[] [I@eaf261a&gt;<br class="calibre33"/>(seq *1)<br class="calibre33"/>;= (1 2 3 4 5 6 7 8 9 10)</tt></span></blockquote><p class="calibre23"><tt class="calibre22">amap</tt><a id="filepos1619756"></a> expects four arguments: the “source” array to map an expression across, the name to give to the index (<tt class="calibre22">i</tt> here), the name to give to the result array that is initialized as a copy of the source array (<tt class="calibre22">res</tt> here), and then an expression whose result will be set at index <tt class="calibre22">i</tt> in the result array <tt class="calibre22">res</tt>.</p><p class="calibre18"><tt class="calibre22">areduce</tt><a id="filepos1620146"></a> works in a similar way:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(let [a (int-array (range 10))]<br class="calibre33"/>  (areduce a i sum 0<br class="calibre33"/>    (+ sum (aget a i))))<br class="calibre33"/>;= 45</tt></span></blockquote><p class="calibre23"><tt class="calibre22">a</tt> and <tt class="calibre22">i</tt> play the same role as in <tt class="calibre22">amap</tt>. <tt class="calibre22">sum</tt> is the name of the accumulator (corresponding to the first argument of the function provided to <tt class="calibre22">reduce</tt>), followed by the accumulator’s initial value, and then an expression whose value becomes the accumulator value for the next iteration—or, the result of the <tt class="calibre22">areduce</tt> form after the reduction is complete.</p><p class="calibre18"><span class="bold">Multidimensional concerns</span>. <a id="filepos1620889"></a>While <tt class="calibre22">aset</tt><a id="filepos1620915"></a> and <tt class="calibre22">aget</tt><a id="filepos1620940"></a> are easy to use with one-dimensional arrays, some additional care must be taken when working with multidimensional arrays. While the “terminal” values in multidimensional arrays are of the primitive type you specify, the intermediate levels are arrays of objects (other arrays). In addition, because it is impossible for <tt class="calibre22">aget</tt> and <tt class="calibre22">aset</tt> to provide arities for all possible array dimensionalities, they support multidimensional operations by recursively using <tt class="calibre22">apply</tt> to get or set each level of multidimensional arrays.</p><p class="calibre18">All of this adds up to potentially devastating performance for simple operations on multidimensional arrays:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def arr (make-array Double/TYPE 1000 1000))<br class="calibre33"/>;= #'user/arr<br class="calibre33"/>(time (dotimes [i 1000]<br class="calibre33"/>        (dotimes [j 1000]<br class="calibre33"/>          (aset arr i j 1.0)<br class="calibre33"/>          (aget arr i j))))<br class="calibre33"/>; "Elapsed time: 50802.798 msecs"</tt></span></blockquote><p class="calibre23">Because <tt class="calibre22">aset</tt> does not provide a direct arity for N-dimensional arrays, <tt class="calibre22">1.0</tt> is getting boxed by <tt class="calibre22">aset</tt> when it uses <tt class="calibre22">apply</tt> to propagate its rest arguments. Further, there is no way for us to hint or declare that <tt class="calibre22">arr</tt> is an array of primitive arrays; thus, all the operations involved are happening reflectively. The only fast path for both <tt class="calibre22">aget</tt> and <tt class="calibre22">aset</tt> are when operating on a properly hinted one-dimensional array.</p><p class="calibre18">The “fix” is to unpack the multidimensional array manually, providing the necessary hinting:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(time (dotimes [i 1000]<br class="calibre33"/>        (dotimes [j 1000]<br class="calibre33"/>          (let [^doubles darr (aget ^objects arr i)]<br class="calibre33"/>            (aset darr j 1.0)<br class="calibre33"/>            (aget darr j)))))<br class="calibre33"/>; "Elapsed time: 21.543 msecs"<br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre23">Yes, that’s a <span class="italic">2600×</span> performance differential compared to our prior naive usage of <tt class="calibre22">aset</tt> and <tt class="calibre22">aget</tt> with multidimensional arrays, and as fast as the equivalent Java code.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1623299"></a><a href="#filepos1633401"><span class="calibre32">347</span></a><span class="calibre32">]</span></small></sup></p><p id="filepos1623398" class="calibre23"><span class="calibre53"><span class="bold">Automating type hinting of multidimensional array operations</span></span></p><p id="filepos1623519" class="calibre18">So, we know how to get optimal performance, but it involves some perhaps error-prone hinting and more code than we’d like: a separate <tt class="calibre22">let</tt>-binding is needed for each step down into the array. This calls for a couple of macros to automate the unpacking and proper hinting of operations on multidimensional arrays:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1623904"></a><a href="#filepos1633809"><span class="calibre32">348</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 11-2. deep-aget</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(defmacro deep-aget<br class="calibre33"/>  "Gets a value from a multidimensional array as if via `aget`,<br class="calibre33"/>   but with automatic application of appropriate type hints to<br class="calibre33"/>   each step in the array traversal as guided by the hint added<br class="calibre33"/>   to the source array.<br class="calibre33"/><br class="calibre33"/>   e.g. (deep-aget ^doubles arr i j)"<br class="calibre33"/>  ([array idx]<br class="calibre33"/>    `(aget ~array ~idx))                                                      </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  ([array idx &amp; idxs]<br class="calibre33"/>    (let [a-sym (gensym "a")]<br class="calibre33"/>      `(let [~a-sym (aget ~(vary-meta array assoc :tag 'objects) ~idx)]       </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>         (deep-aget ~(with-meta a-sym {:tag (-&gt; array meta :tag)}) ~@idxs)))))</tt></span><a></a><img src="images/00003.jpg" class="calibre36"/></p><p class="calibre23"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">If we are accessing a one-dimensional array (indicated by the single index), then we use <tt class="calibre22">aget</tt> directly, and assume that the <tt class="calibre22">array</tt> symbol is properly hinted.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">If we’re still “above” the terminal array, we obtain the next array down, making sure to hint the <tt class="calibre22">array</tt> argument to <tt class="calibre22">aget</tt> as <tt class="calibre22">^objects</tt>.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">We make a recursive call to <tt class="calibre22">deep-aget</tt> with <tt class="calibre22">a-sym</tt> (that next array down), reapplying the terminal array type hint to it in case it is the terminal array; if it is, the single-index arity of <tt class="calibre22">deep-aget</tt> at &lt;1&gt; will receive the call, and perform the terminal <tt class="calibre22">aget</tt>.</blockquote><p class="calibre13"><tt class="calibre22">deep-aset</tt> has to take a different approach than <tt class="calibre22">deep-aget</tt>, since it needs to use <tt class="calibre22">deep-aget</tt> to efficiently traverse the multidimensional array to get to where it can finally apply <tt class="calibre22">aset</tt> to the terminal array value:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 11-3. deep-aset</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(defmacro deep-aset<br class="calibre33"/>  "Sets a value in a multidimensional array as if via `aset`,<br class="calibre33"/>   but with automatic application of appropriate type hints to<br class="calibre33"/>   each step in the array traversal as guided by the hint added<br class="calibre33"/>   to the target array.<br class="calibre33"/><br class="calibre33"/>   e.g. (deep-aset ^doubles arr i j 1.0)"<br class="calibre33"/>  [array &amp; idxsv]<br class="calibre33"/>  (let [hints '{booleans boolean, bytes byte               </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>                chars char, longs long<br class="calibre33"/>                ints int, shorts short<br class="calibre33"/>                doubles double, floats float}<br class="calibre33"/>        hint (-&gt; array meta :tag)<br class="calibre33"/>        [v idx &amp; sxdi] (reverse idxsv)<br class="calibre33"/>        idxs (reverse sxdi)<br class="calibre33"/>        v (if-let [h (hints hint)] (list h v) v)<br class="calibre33"/>        nested-array (if (seq idxs)<br class="calibre33"/>                       `(deep-aget ~(vary-meta array assoc :tag 'objects) ~@idxs)<br class="calibre33"/>                        array)<br class="calibre33"/>        a-sym (gensym "a")]<br class="calibre33"/>    `(let [~a-sym ~nested-array]<br class="calibre33"/>       (aset ~(with-meta a-sym {:tag hint}) ~idx ~v))))</tt></span></p><p class="calibre23"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">A mapping is maintained between array hint symbols and primitive coercion function names; if <tt class="calibre22">array</tt> is hinted using one of the former, then the corresponding coercion expression will be used in conjunction with <tt class="calibre22">aset</tt> and the value given to <tt class="calibre22">deep-aset</tt>. This allows the user to, for example, set a value in a multidimensional array of <tt class="calibre22">double</tt>s using a <tt class="calibre22">long</tt>, as the <tt class="calibre22">long</tt> will be coerced in the <tt class="calibre22">aset</tt> call via <tt class="calibre22">(double v)</tt>.</blockquote><p class="calibre13">Using <tt class="calibre22">deep-aget</tt> and <tt class="calibre22">deep-aset</tt>, we can get the same performance as we would if we were unpacking and hinting N-dimensional array manually:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(time (dotimes [i 1000]<br class="calibre33"/>        (dotimes [j 1000]<br class="calibre33"/>          (deep-aset ^doubles arr i j 1.0)<br class="calibre33"/>          (deep-aget ^doubles arr i j))))<br class="calibre33"/>; "Elapsed time: 25.033 msecs"</tt></span></blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">When </span><span class="calibre10"><tt class="calibre22">*warn-on-reflection*</tt></span><a id="filepos1629674"></a><span class="calibre10"> is set to </span><span class="calibre10"><tt class="calibre22">true</tt></span><span class="calibre10">, calls to </span><span class="calibre10"><tt class="calibre22">aget</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">aset</tt></span><span class="calibre10"> on arrays whose type can’t be inferred raise a warning…except for multi-dimensional arities!</span><a id="filepos1629998"></a></blockquote><br class="calibre33"/><hr class="calibre34"/><p class="calibre25"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1630111"></a><a href="#filepos1589051"><span class="calibre32">340</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">You can very readily call out to native libraries from within the JVM and Clojure. See </span><a href="https://github.com/Chouser/clojure-jna"><span class="calibre10"><span class="calibre5">https://github.com/Chouser/clojure-jna</span></span></a><span class="calibre10"> for a Clojure library that provides a concise way to use JNA (</span><a href="https://github.com/twall/jna"><span class="calibre10"><span class="calibre5">https://github.com/twall/jna</span></span></a><span class="calibre10">).</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1630756"></a><a href="#filepos1589930"><span class="calibre32">341</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">An exponential-time algorithm will not outperform a polynomial-time algorithm, whether the former uses primitives or not. That’s a long way to say: make sure you’re using the right algorithm first, </span><span class="calibre10"><span class="italic">then</span></span><span class="calibre10"> worry about optimizing it if necessary.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1631238"></a><a href="#filepos1592301"><span class="calibre32">342</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">And the methods you use if you happen to need to call Clojure functions </span><span class="calibre10"><span class="italic">from</span></span><span class="calibre10"> Java; see </span><a href="#filepos1274079"><span class="calibre10"><span class="calibre5">Chapter 9</span></span></a><span class="calibre10"> to learn about some of the finer points of calling into Clojure from Java (or any other JVM-based language, for that matter).</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1631796"></a><a href="#filepos1593696"><span class="calibre32">343</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">We explore type hints extensively in </span><a href="#filepos1324665"><span class="calibre10"><span class="calibre5">Type Hinting for Performance</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1632146"></a><a href="#filepos1597844"><span class="calibre32">344</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="#filepos250238"><span class="calibre10"><span class="calibre5">First-Class and Higher-Order Functions</span></span></a><span class="calibre10"> if you need a refresher on HOFs.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1632505"></a><a href="#filepos1606443"><span class="calibre32">345</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">The same philosophy is what produced transients, described in </span><a href="#filepos492461"><span class="calibre10"><span class="calibre5">Transients</span></span></a><span class="calibre10">, and the pinhole of mutability in </span><span class="calibre10"><tt class="calibre22">deftype</tt></span><span class="calibre10">, covered in </span><a href="#filepos995374"><span class="calibre10"><span class="calibre5">Types</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1633074"></a><a href="#filepos1608739"><span class="calibre32">346</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Using a transient vector instead does provide significant performance gains, but only half that of the forthcoming array-based implementation.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1633401"></a><a href="#filepos1623299"><span class="calibre32">347</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">The equivalent Java code actually does essentially the same work, but Java’s syntax is optimized to support concise array access and mutation, and its static compilation model can easily derive the interim types involved.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1633809"></a><a href="#filepos1623904"><span class="calibre32">348</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">This approach was originally described in </span><a href="http://clj-me.cgrand.net/2009/10/15/multidim-arrays"><span class="calibre10"><span class="calibre5">http://clj-me.cgrand.net/2009/10/15/multidim-arrays</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos1634180" class="calibre6"><span class="calibre4"><span class="bold">Visualizing the Mandelbrot Set in Clojure</span></span></p><p id="filepos1634282" class="calibre18">Let’s take a look at a somewhat more interesting example than the overused Fibonacci and prime number generators that are often used for microbenchmarking numeric performance. Visualizing the Mandelbrot Set<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1634553"></a><a href="#filepos1653007"><span class="calibre32">349</span></a><span class="calibre32">]</span></small></sup> (or really, any fractal shape visualization) has long been a common practicum, and it will serve well here as a demonstration of how to optimize numeric algorithms in Clojure.</p><p class="calibre18">The Mandelbrot Set is defined by a complex polynomial that is applied iteratively:</p><blockquote class="calibre35"><span class="calibre10"><span class="italic">z<sub class="calibre74"><small class="calibre31"><span class="calibre32"><span class="italic">k+1</span></span></small></sub> = z<sub class="calibre74"><small class="calibre31"><span class="calibre32"><span class="italic">k</span></span></small></sub><sup class="calibre58"><small class="calibre31"><span class="calibre32"><span class="italic">2</span></span></small></sup> + c</span></span></blockquote><p class="calibre23">where <span class="italic">c</span> (a complex number) is a member of the Mandelbrot Set if <span class="italic">z<sub class="calibre85"><small class="calibre31"><span class="calibre32"><span class="italic">k+1</span></span></small></sub></span> is bounded as <span class="italic">k</span> increases when <span class="italic">z<sub class="calibre85"><small class="calibre31"><span class="calibre32"><span class="italic">0</span></span></small></sub></span> is initialized to 0. <span class="italic">c</span>’s that produce unbounded results from this calculation are said to <span class="italic">escape</span> to infinity.</p><p class="calibre18">First, let’s look at a naive implementation of the Mandelbrot Set in Clojure,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1635740"></a><a href="#filepos1653856"><span class="calibre32">350</span></a><span class="calibre32">]</span></small></sup> which includes a couple utility functions for rendering the results of that implementation:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 11-4. Mandelbrot Set in Clojure</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(ns clojureprogramming.mandelbrot<br class="calibre33"/>  (:import java.awt.image.BufferedImage<br class="calibre33"/>           (java.awt Color RenderingHints)))<br class="calibre33"/><br class="calibre33"/>(defn- escape<br class="calibre33"/>  "Returns an integer indicating how many iterations were required<br class="calibre33"/>   before the value of z (using the components `a` and `b`) could<br class="calibre33"/>   be determined to have escaped the Mandelbrot set.  If z<br class="calibre33"/>   will not escape, -1 is returned."<br class="calibre33"/>  [a0 b0 depth]                                         <br class="calibre33"/>  (loop [a a0                                       <br class="calibre33"/>         b b0<br class="calibre33"/>         iteration 0]<br class="calibre33"/>    (cond<br class="calibre33"/>      (&lt; 4 (+ (* a a) (* b b))) iteration<br class="calibre33"/>      (&gt;= iteration depth) -1<br class="calibre33"/>      :else (recur (+ a0 (- (* a a) (* b b)))<br class="calibre33"/>                   (+ b0 (* 2 (* a b)))<br class="calibre33"/>                   (inc iteration)))))<br class="calibre33"/><br class="calibre33"/>(defn mandelbrot<br class="calibre33"/>  "Calculates membership within and number of iterations to escape<br class="calibre33"/>   from the Mandelbrot set for the region defined by `rmin`, `rmax`<br class="calibre33"/>   `imin` and `imax` (real and imaginary components of z, respectively).<br class="calibre33"/>   <br class="calibre33"/>   Optional kwargs include `:depth` (maximum number of iterations<br class="calibre33"/>   to calculate escape of a point from the set), `:height` ('pixel'<br class="calibre33"/>   height of the rendering), and `:width` ('pixel' width of the<br class="calibre33"/>   rendering).<br class="calibre33"/><br class="calibre33"/>   Returns a seq of row vectors containing iteration numbers for when<br class="calibre33"/>   the corresponding point escaped from the set. -1 indicates points<br class="calibre33"/>   that did not escape in fewer than `depth` iterations, i.e. they<br class="calibre33"/>   belong to the set.  These integers can be used to drive most common<br class="calibre33"/>   Mandelbrot set visualizations."<br class="calibre33"/>  [rmin rmax imin imax &amp; {:keys [width height depth]<br class="calibre33"/>                          :or {width 80 height 40 depth 1000}}]<br class="calibre33"/>  (let [rmin (double rmin)                                              <br class="calibre33"/>        imin (double imin)<br class="calibre33"/>        stride-w (/ (- rmax rmin) width)<br class="calibre33"/>        stride-h (/ (- imax imin) height)]<br class="calibre33"/>    (loop [x 0<br class="calibre33"/>           y (dec height)<br class="calibre33"/>           escapes []]<br class="calibre33"/>      (if (== x width)<br class="calibre33"/>        (if (zero? y)<br class="calibre33"/>          (partition width escapes)<br class="calibre33"/>          (recur 0 (dec y) escapes))<br class="calibre33"/>        (recur (inc x) y (conj escapes (escape (+ rmin (* x stride-w))  <br class="calibre33"/>                                               (+ imin (* y stride-h))<br class="calibre33"/>                                               depth)))))))<br class="calibre33"/><br class="calibre33"/>(defn render-text<br class="calibre33"/>  "Prints a basic textual rendering of mandelbrot set membership,<br class="calibre33"/>   as returned by a call to `mandelbrot`."<br class="calibre33"/>  [mandelbrot-grid]<br class="calibre33"/>  (doseq [row mandelbrot-grid]<br class="calibre33"/>    (doseq [escape-iter row]<br class="calibre33"/>      (print (if (neg? escape-iter) \* \space)))<br class="calibre33"/>    (println)))<br class="calibre33"/><br class="calibre33"/>(defn render-image<br class="calibre33"/>  "Given a mandelbrot set membership grid as returned by a call to<br class="calibre33"/>   `mandelbrot`, returns a BufferedImage with the same resolution as the<br class="calibre33"/>   grid that uses a discrete grayscale color palette."<br class="calibre33"/>  [mandelbrot-grid]<br class="calibre33"/>  (let [palette (vec (for [c (range 500)]<br class="calibre33"/>                       (Color/getHSBColor 0.0 0.0 (/ (Math/log c) (Math/log 500)))))<br class="calibre33"/>        height (count mandelbrot-grid)<br class="calibre33"/>        width (count (first mandelbrot-grid))<br class="calibre33"/>        img (BufferedImage. width height BufferedImage/TYPE_INT_RGB)<br class="calibre33"/>        ^java.awt.Graphics2D g (.getGraphics img)]<br class="calibre33"/>    (doseq [[y row] (map-indexed vector mandelbrot-grid)<br class="calibre33"/>            [x escape-iter] (map-indexed vector row)]<br class="calibre33"/>      (.setColor g (if (neg? escape-iter)<br class="calibre33"/>                     (palette 0)<br class="calibre33"/>                     (palette (mod (dec (count palette)) (inc escape-iter)))))<br class="calibre33"/>      (.drawRect g x y 1 1))<br class="calibre33"/>    (.dispose g)<br class="calibre33"/>    img))</tt></span></p><p class="calibre13">The <tt class="calibre22">mandelbrot</tt> function returns a grid, each member being the number of iterations of the polynomial that was required before the corresponding point escaped to infinity; points that never escaped to infinity and therefore are members of the set are represented by a –1 iteration count. The simplest (and admittedly crude) visualization of the Mandelbrot Set can be obtained by printing asterisks and spaces to the console, which is implemented in the <tt class="calibre22">render-text</tt><a id="filepos1641569"></a> function:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1641621"></a><a href="#filepos1654556"><span class="calibre32">351</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(render-text (mandelbrot -2.25 0.75 -1.5 1.5 :width 80 :height 40 :depth 100))<br class="calibre33"/>                                                     ***<br class="calibre33"/>                                                   ******<br class="calibre33"/>                                                    ****<br class="calibre33"/>                                           **   *************<br class="calibre33"/>                                           ***********************<br class="calibre33"/>                                          ***********************<br class="calibre33"/>                                         **************************<br class="calibre33"/>                                       ****************************<br class="calibre33"/>                           *******    ******************************<br class="calibre33"/>                         ***********  ******************************<br class="calibre33"/>                        ************* *****************************<br class="calibre33"/>    ************************************************************<br class="calibre33"/>                        ************* *****************************<br class="calibre33"/>                         ***********  ******************************<br class="calibre33"/>                           *******    ******************************<br class="calibre33"/>                                       ****************************<br class="calibre33"/>                                         **************************<br class="calibre33"/>                                          ***********************<br class="calibre33"/>                                           ***********************<br class="calibre33"/>                                           **   *************<br class="calibre33"/>                                                    ****<br class="calibre33"/>                                                   ******<br class="calibre33"/>                                                     ***</tt></span></blockquote><p class="calibre23">However, if we were to zoom in (i.e., change the domain of our visualization to focus in on smaller, interesting subfeatures of the set), we would need to perform many, many more iterations of the <tt class="calibre22">escape</tt> function than the <tt class="calibre22">100</tt> we’re performing here. A quick timing of what that would require—for example, to generate a 1600×1200 image—shows that the implementation above is perhaps not as fast as we’d like:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(do (time (mandelbrot -2.25 0.75 -1.5 1.5<br class="calibre33"/>            :width 1600 :height 1200 :depth 1000))<br class="calibre33"/>  nil)<br class="calibre33"/>; "Elapsed time: 82714.764 msecs"</tt></span></blockquote><p class="calibre23">If you were to build an application to interactively explore the Mandelbrot Set (or perhaps perform some automated exploration of the same), this performance would be totally unacceptable.</p><p class="calibre18">The hottest part of this code is clearly the <tt class="calibre22">loop</tt> in the <tt class="calibre22">escape</tt> function. We can’t do much about the complexity of the calculations it is performing—that is dictated by the Mandelbrot Set’s definitional polynomial—but we can eliminate the numeric boxing that is going on.</p><p class="calibre18">As we discussed in <a href="#filepos1591810"><span class="calibre5">Declare Functions to Take and Return Primitives</span></a>, functions in Clojure are implemented by Java methods that accept <tt class="calibre22">java.lang.Object</tt>s as arguments, so the <tt class="calibre22">a0</tt> and <tt class="calibre22">b0</tt>
<tt class="calibre22">double</tt> primitives that the <tt class="calibre22">mandelbrot</tt> function is calling <tt class="calibre22">escape</tt> with (the real and imaginary components of <tt class="calibre22">z</tt> in the Mandelbrot Set polynomial, respectively) end up getting boxed into <tt class="calibre22">Double</tt> objects. This cascades down to the types of the bindings in the <tt class="calibre22">loop</tt> form and kills the entire function’s performance: initializing <tt class="calibre22">a</tt> and <tt class="calibre22">b</tt> with <tt class="calibre22">a0</tt> and <tt class="calibre22">b0</tt> implicitly types the former bindings as <tt class="calibre22">Double</tt> as well, so every single arithmetic operation in <tt class="calibre22">escape</tt> ends up having to unbox these values, with the results necessarily being boxed when they’re rebound to <tt class="calibre22">a</tt> and <tt class="calibre22">b</tt> in the <tt class="calibre22">recur</tt> form.</p><p class="calibre18">The solution is to eliminate the untyped bindings in the first place; note the <tt class="calibre22">^double</tt> type declarations for the <tt class="calibre22">a0</tt> and <tt class="calibre22">b0</tt> arguments in our revised implementation of <tt class="calibre22">escape</tt>, which is otherwise unchanged.</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 11-5. Revised escape function declaring primitive numeric argument types</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(defn- escape<br class="calibre33"/>  [^double a0 ^double b0 depth]<br class="calibre33"/>  (loop [a a0<br class="calibre33"/>         b b0<br class="calibre33"/>         iteration 0]<br class="calibre33"/>    (cond<br class="calibre33"/>      (&lt; 4 (+ (* a a) (* b b))) iteration<br class="calibre33"/>      (&gt;= iteration depth) -1<br class="calibre33"/>      :else (recur (+ a0 (- (* a a) (* b b)))<br class="calibre33"/>                   (+ b0 (* 2 (* a b)))<br class="calibre33"/>                   (inc iteration)))))</tt></span></p><p class="calibre13">Now the <tt class="calibre22">escape</tt> function’s generated class takes primitive <tt class="calibre22">doubles</tt>s as its first two arguments. Clojure’s type inference does the rest: the <tt class="calibre22">a</tt> and <tt class="calibre22">b</tt> bindings in <tt class="calibre22">loop</tt> are typed as <tt class="calibre22">double</tt> as well, permitting all of the arithmetic to work exclusively with primitive arguments and avoiding the boxing of results when the arguments to <tt class="calibre22">recur</tt> are rebound to their corresponding names in the <tt class="calibre22">loop</tt>.</p><p class="calibre18">What’s the concrete upshot? An order-of-magnitude improvement:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(do (time (mandelbrot -2.25 0.75 -1.5 1.5<br class="calibre33"/>            :width 1600 :height 1200 :depth 1000))<br class="calibre33"/>  nil)<br class="calibre33"/>; "Elapsed time: 8663.841 msecs"</tt></span></blockquote><p class="calibre23">With that improvement, we can reasonably go ahead and start exploring the set, using the <tt class="calibre22">render-image</tt><a id="filepos1648745"></a> function to produce a rasterization <a id="filepos1648789"></a>of the Mandelbrot Set membership grid, shown in Figures <a href="#filepos1648980"><span class="calibre5">11-2</span></a> and <a href="#filepos1649396"><span class="calibre5">11-3</span></a>.</p><blockquote id="filepos1648980" class="calibre47"></blockquote><blockquote class="calibre48"><img src="images/00014.jpg" class="calibre116"/></blockquote><blockquote class="calibre47"><span class="calibre10"><span class="italic"><span class="calibre7">Figure 11-2. (render-image (mandelbrot -2.25 0.75 -1.5 1.5 :width 800 :height 800 :depth 500))</span></span></span></blockquote><blockquote id="filepos1649396" class="calibre117"></blockquote><blockquote class="calibre48"><img src="images/00020.jpg" class="calibre118"/></blockquote><blockquote class="calibre47"><span class="calibre10"><span class="italic"><span class="calibre7">Figure 11-3. (render-image (mandelbrot -1.5 -1.3 -0.1 0.1 :width 800 :height 800 :depth 500))</span></span></span></blockquote><p class="calibre50"><tt class="calibre22">render-image</tt> uses a fixed, discrete grayscale palette. Changing it so that it uses a colorful or continuous palette is left as an exercise.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">If you’re using a typical textual REPL,<sup class="calibre58"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1650246"></a><a href="#filepos1655060"><span class="calibre32">352</span></a><span class="calibre32">]</span></small></sup> then evaluating the above expressions will return a </span><span class="calibre10"><tt class="calibre22">BufferedImage</tt></span><span class="calibre10"> instance. You can save this image to disk using the JDK’s </span><span class="calibre10"><tt class="calibre22">ImageIO</tt></span><span class="calibre10"> class and its </span><span class="calibre10"><tt class="calibre22">write</tt></span><span class="calibre10"> method:</span></blockquote><blockquote class="calibre35"><span class="calibre21"><tt class="calibre22">(javax.imageio.ImageIO/write *1 "png" (java.io.File. "mandelbrot.png"))</tt></span></blockquote><blockquote class="calibre35"><span class="calibre10">which will save the image bound to </span><span class="calibre10"><tt class="calibre22">*1</tt></span><span class="calibre10">​<sup class="calibre58"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1651018"></a><a href="#filepos1655826"><span class="calibre32">353</span></a><span class="calibre32">]</span></small></sup> as a PNG to the file </span><span class="calibre10"><span class="italic">mandelbrot.png</span></span><span class="calibre10"> in your current directory. It would be easy enough to write a function to encapsulate this call.</span></blockquote><p class="calibre25">There are all sorts of more advanced algorithmic techniques for speeding Mandelbrot Set calculations that would improve the running time of <tt class="calibre22">mandelbrot</tt> much further, but those are out of scope here. A few Clojure-specific optimizations might include:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Instead of doing all of the computation within an imperative <tt class="calibre22">loop</tt>, recharacterizing it as a lazy sequence using, for example, <tt class="calibre22">for</tt> would allow you to trivially parallelize the computations using <tt class="calibre22">pmap</tt>.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Returning a grid (seq of rows of point escape iteration numbers) from <tt class="calibre22">mandelbrot</tt> affords a great deal of flexibility. As we’ve seen, we can use the same resulting data structure to produce a text representation or a bitmap; similarly, a 3D renderer could be swapped in without changing <tt class="calibre22">mandelbrot</tt> or <tt class="calibre22">escape</tt>. Producing that grid does carry a cost though, so it might be worthwhile to thread a reference to a callback function through <tt class="calibre22">mandelbrot</tt> into <tt class="calibre22">escape</tt> so that each per-point action (whether that’s printing a character to the console or painting a pixel on a bitmap) can be performed without any of the allocations associated with collections and sequences. Of course, that callback function should have its primitive arguments declared as we just did for <tt class="calibre22">escape</tt> to avoid boxing.</blockquote></li><a id="filepos1652902"></a></ul><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1653007"></a><a href="#filepos1634553"><span class="calibre32">349</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="http://en.wikipedia.org/wiki/Mandlebrot_set"><span class="calibre10"><span class="calibre5">http://en.wikipedia.org/wiki/Mandlebrot_set</span></span></a><span class="calibre10"> for a gentle introduction to the Mandelbrot Set, the mathematics behind it, and how you can go about generating visualizations of it. We’d also be remiss if we didn’t point you toward Jonathan Coulton’s fantastic song and music video about the Mandelbrot Set and its creator/discoverer Benoît Mandelbrot: </span><a href="http://www.youtube.com/watch?v=ES-yKOYaXq0"><span class="calibre10"><span class="calibre5">http://www.youtube.com/watch?v=ES-yKOYaXq0</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1653856"></a><a href="#filepos1635740"><span class="calibre32">350</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Simpler implementations are possible; for example, by using the </span><span class="calibre10"><tt class="calibre22">iterate</tt></span><span class="calibre10"> function to lazily calculate the result of the complex polynomial, and </span><span class="calibre10"><tt class="calibre22">take</tt></span><span class="calibre10">-ing only as many results from the head of that lazy seq as dictated by our maximum iteration count. Such approaches are much more concise, but because they utilize lazy seqs and collections, the results of our calculations will be boxed—and thus, much slower.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1654556"></a><a href="#filepos1641621"><span class="calibre32">351</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">The nature of text—where characters are taller than they are wide—necessitates using a skewed aspect ratio (</span><span class="calibre10"><tt class="calibre22">80</tt></span><span class="calibre10"> × </span><span class="calibre10"><tt class="calibre22">40</tt></span><span class="calibre10"> here) so the results look similar to image renderings that generally have 1:1 aspect ratios.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1655060"></a><a href="#filepos1650246"><span class="calibre32">352</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Clojure REPLs that support the display of mixed content are starting to appear; in such a REPL, evaluating </span><span class="calibre10"><tt class="calibre22">render-image</tt></span><span class="calibre10"> would immediately display the generated image without you having to save it to disk or otherwise get the image data out of the REPL. For an example of this, see </span><a href="http://cemerick.com/2011/10/26/enabling-richer-interactions-in-the-clojure-repl"><span class="calibre10"><span class="calibre5">http://cemerick.com/2011/10/26/enabling-richer-interactions-in-the-clojure-repl</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1655826"></a><a href="#filepos1651018"><span class="calibre32">353</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Remember that </span><span class="calibre10"><tt class="calibre22">*1</tt></span><span class="calibre10"> is always bound to the value of the last-evaluated expression in the REPL. See </span><a href="#filepos1460851"><span class="calibre10"><span class="calibre5">“REPL-bound vars”</span></span></a><span class="calibre10"> for details and similar handy vars.</span></p><div class="mbppagebreak"></div><p id="filepos1656269" class="calibre6"><span class="calibre2"><span class="bold">Chapter 12. Design Patterns</span></span></p><p class="calibre13"><span class="italic">Design patterns</span><a id="filepos1656409"></a> are generic, reusable solutions to recurring problems. A hallmark of object-oriented programming, they provide a common vocabulary that many in the Java and Ruby worlds are familiar with.</p><p class="calibre18">On the other hand, patterns can be a source of verbosity and boilerplate. To this point, Paul Graham observed that the existence and use of design patterns in a language are indicative of a weakness in the language itself, rather than a consequence of solving the problem at hand:</p><blockquote class="calibre35"><span class="calibre10"><span class="italic">When I see patterns in my programs, I consider it a sign of trouble. The shape of a program should reflect only the problem it needs to solve. Any other regularity in the code is a sign, to me at least, that I’m using abstractions that aren’t powerful enough…</span></span></blockquote><blockquote class="calibre63"><span class="calibre10">—Paul Graham, </span><span class="calibre10"><span class="italic">http://www.paulgraham.com/icad.html</span></span></blockquote><p class="calibre23">Graham was hardly the first to make this observation; Peter Norvig demonstrated some time ago (<a href="http://www.norvig.com/design-patterns/"><span class="calibre5">http://www.norvig.com/design-patterns/</span></a>) that Lisps in particular either simplify or make invisible most design patterns. Clojure continues this tradition: thanks to powerful constructs like first-class functions, dynamic typing, and immutable values, many of the most common design patterns evaporate into thin air. And, with macros, Clojure gives you the tools you need to avoid creating boilerplate of your own.</p><p class="calibre18">Examples of Clojure code subsuming common design patterns are scattered throughout this book:</p><p class="calibre18"><span class="bold">Listener, Observer</span>. A victim of first-class functions and dynamic typing, these are just functions that are called when a relevant event occurs; this can be seen with watches on references types in <a href="#filepos655851"><span class="calibre5">Watches</span></a>. Outside of reference types, the preferred use of immutable values means that the scope of mutable things that you need to track is greatly minimized.</p><p class="calibre18"><span class="bold">Abstract Factory, Strategy, Command</span>. If you have multiple implementations of any sort of functionality—whether it’s to produce values of differing types or configurations, or to implement variations on an algorithm—there is no need to produce a <tt class="calibre22">FactoryFactory<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1658968"></a><a href="#filepos1670769"><span class="calibre32">354</span></a><span class="calibre32">]</span></small></sup></tt> or a context to invoke your algorithm implementations. In both cases, just another function will do.</p><p class="calibre18"><span class="bold">Iterator</span>. Iterators <a id="filepos1659229"></a>are completely supersetted by sequences, described in <a href="#filepos354167"><span class="calibre5">Sequences</span></a>, and their use is effortless and declarative via functions like <tt class="calibre22">map</tt>.</p><p class="calibre18"><span class="bold">Adapter, Wrapper, Delegate</span>. Made necessary by inflexible type hierarchies elsewhere, these are made unnecessary by protocols, which allow you orthogonally define new behavior for existing types without appeals to inheritance, adaptation, or wrapping. See <a href="#filepos945443"><span class="calibre5">Chapter 6</span></a>.</p><p class="calibre18"><span class="bold">Memento</span>. Layering a common API over top the mutation of an object solves the most mechanical of problems (API generality), but does nothing to address the glaring complexity of the mutable state itself. Immutable collections and records invert this strategy: mutable state is barred from values, retaining prior versions of those values is cheap and easy, and state transitions are left to reference types (each of which provides a different API to suit its respective concurrency and change semantics).</p><p class="calibre18"><span class="bold">Template Method</span>. The limitations of class inheritance <a id="filepos1660431"></a>are well-known and felt daily by millions, yet it is used widely, often as the sole way to compose functionality within many languages. This dubious mingling of concerns is better recast as a higher-order function that can accept functions implementing the variable behavior while providing a canonical implementation of shared functionality. For example, if we needed to be able to call equivalent HTTP APIs offered by different providers based on some application-internal data structure, a HOF would allow us to define the provider-specific functionality as a separate function, while keeping the universal HTTP plumbing in one place:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn- update-status*<br class="calibre33"/>  [service-name service-endpoint-url request-data-fn]<br class="calibre33"/>  (fn [new-status]<br class="calibre33"/>    (log (format "Updating status @ %s to %s" service-name new-status))<br class="calibre33"/>    (let [http-request-data (request-data-fn new-status)<br class="calibre33"/>          connection (-&gt; service-endpoint-url java.net.URL. .openConnection)]<br class="calibre33"/>      ;; ...set request method, parameters, body on `connection`<br class="calibre33"/>      ;; ...perform actual request<br class="calibre33"/>      ;; ...return result based on HTTP response status<br class="calibre33"/>      )))<br class="calibre33"/><br class="calibre33"/>(def update-facebook-status (update-status* "Facebook" "http://facebook.com/apis/..."<br class="calibre33"/>                              (fn [status]<br class="calibre33"/>                                {:params {:_a "update_status"<br class="calibre33"/>                                          :_t status}<br class="calibre33"/>                                 :method "GET"})))<br class="calibre33"/><br class="calibre33"/>(def update-twitter-status ...)<br class="calibre33"/>(def update-google-status ...)</tt></span></blockquote><p class="calibre23">Let’s dig into some other common patterns in more detail, a couple of which are now so baked into common programming practice in other languages, it may take a little work to sift them out again.</p><p id="filepos1662597" class="calibre6"><span class="calibre4"><span class="bold">Dependency Injection</span></span></p><p id="filepos1662678" class="calibre18">In many object-oriented languages, <span class="italic">dependency injection</span> is a way to decouple a class from other objects upon which that class depends. Instead of an object initializing other objects internally, it accepts those objects as parameters that are often automagically supplied by the runtime or application container that is hosting your program.</p><p class="calibre18">In a static language like Java,<a id="filepos1663117"></a> this is accomplished by programming to interfaces rather than concrete classes. Consider this implementation of the ubiquitous pet store concept:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">interface IDog {<br class="calibre33"/>    public String bark();<br class="calibre33"/>}<br class="calibre33"/><br class="calibre33"/>class Chihuahua implements IDog {<br class="calibre33"/>    public String bark() {<br class="calibre33"/>        return "Yip!";<br class="calibre33"/>    }<br class="calibre33"/>}<br class="calibre33"/><br class="calibre33"/>class Mastiff implements IDog {<br class="calibre33"/>    public String bark() {<br class="calibre33"/>        return "Woof!";<br class="calibre33"/>    }<br class="calibre33"/>}<br class="calibre33"/><br class="calibre33"/>class PetStore {<br class="calibre33"/>    private IDog dog;<br class="calibre33"/>    public PetStore() {<br class="calibre33"/>        this.dog = new Mastiff();<br class="calibre33"/>    }<br class="calibre33"/><br class="calibre33"/>    public IDog getDog() {<br class="calibre33"/>        return dog;<br class="calibre33"/>    }<br class="calibre33"/>}<br class="calibre33"/><br class="calibre33"/>static class MyApp {<br class="calibre33"/>    public static void main(String[] args) {<br class="calibre33"/>        PetStore store = new PetStore();<br class="calibre33"/>        System.out.println(store.getDog().bark());<br class="calibre33"/>    }<br class="calibre33"/>}</tt></span></blockquote><p class="calibre23">Our pet store only works with mastiffs. If we want to change it to support different types of dogs, we have to alter and recompile the <tt class="calibre22">PetStore</tt> class. To make <tt class="calibre22">PetStore</tt> more reusable, we might rewrite <tt class="calibre22">PetStore</tt> like so:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">class PetStore {<br class="calibre33"/>    private IDog dog;<br class="calibre33"/>    public PetStore(IDog dog) {<br class="calibre33"/>        this.dog = dog;<br class="calibre33"/>    }<br class="calibre33"/><br class="calibre33"/>    public IDog getDog() {<br class="calibre33"/>        return dog;<br class="calibre33"/>    }<br class="calibre33"/>}<br class="calibre33"/><br class="calibre33"/>class MyApp {<br class="calibre33"/>    public static void main(String[] args) {<br class="calibre33"/>        PetStore store = new PetStore(new Chihuahua());<br class="calibre33"/>        System.out.println(store.getDog().bark());<br class="calibre33"/>    }<br class="calibre33"/>}</tt></span></blockquote><p class="calibre23">Now the store’s dog type has been parameterized. A particular type of dog is “injected” into our <tt class="calibre22">PetStore</tt> via its constructor; <tt class="calibre22">PetStore</tt> won’t need to be recompiled each time we want to use a different dog. We can even use <tt class="calibre22">PetStore</tt> with classes that didn’t exist when <tt class="calibre22">PetStore</tt> was written; we just have to implement the <tt class="calibre22">IDog</tt> interface and we’re done. This allows us to easily create mock dog types for testing, for example.</p><p class="calibre18">The injection of dependencies is usually done by a “container” that uses runtime configuration to automatically initialize key objects with implementations of interfaces automatically discovered on the classpath or specified in its configuration. Depending upon the container implementation you’re working with, this configuration usually takes the form of a separately managed set of configuration code or XML files.</p><p class="calibre18">Clojure turns this problem inside-out. Where <tt class="calibre22">bark</tt> is a method defined by our <tt class="calibre22">IDog</tt> classes in Java, Clojure code would define <tt class="calibre22">bark</tt> as a protocol method, detached from any concrete types.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defprotocol Bark<br class="calibre33"/>  (bark [this]))<br class="calibre33"/><br class="calibre33"/>(defrecord Chihuahua [weight price]<br class="calibre33"/>  Bark<br class="calibre33"/>  (bark [this] "Yip!"))<br class="calibre33"/><br class="calibre33"/>(defrecord Mastiff []<br class="calibre33"/>  Bark<br class="calibre33"/>  (bark [this] "Woof!"))</tt></span></blockquote><p class="calibre23">Now, our pet store would look like this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defrecord PetStore [dog])<br class="calibre33"/><br class="calibre33"/>(defn main<br class="calibre33"/>  [dog]<br class="calibre33"/>  (let [store (PetStore. dog)]<br class="calibre33"/>    (println (bark (:dog store)))))<br class="calibre33"/><br class="calibre33"/>(main (Chihuahua.))<br class="calibre33"/>;= Yip!<br class="calibre33"/><br class="calibre33"/>(main (Mastiff.))<br class="calibre33"/>;= Woof!</tt></span></blockquote><p class="calibre23">Yes, that’s it! Our <tt class="calibre22">PetStore</tt> is now one short line of code.</p><p class="calibre18">In Java, <tt class="calibre22">PetStore</tt> is limited to objects that implement the <tt class="calibre22">IDog</tt> interface. In Clojure, <tt class="calibre22">PetStore</tt> has no such limitation: it accepts any kind of parameter. As long as the <tt class="calibre22">Bark</tt> protocol is implemented for that type, things will work just fine. This allows us to do things that Java would never allow, such as extending <tt class="calibre22">Bark</tt> to classes we don’t control. With this simple code:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(extend-protocol Bark<br class="calibre33"/>  java.util.Map<br class="calibre33"/>  (bark [this]<br class="calibre33"/>    (or (:bark this)<br class="calibre33"/>        (get this "bark"))))</tt></span></blockquote><p class="calibre23">…we can now use any <tt class="calibre22">Map</tt> as a dog, including a Clojure <tt class="calibre22">IPersistentMap</tt> or a Java <tt class="calibre22">HashMap</tt>, where the <tt class="calibre22">bark</tt> string can be mapped to either <tt class="calibre22">:bark</tt> or <tt class="calibre22">"bark"</tt>:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1668241"></a><a href="#filepos1671218"><span class="calibre32">355</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(main (doto (java.util.HashMap.)<br class="calibre33"/>        (.put "bark" "Ouah!")))<br class="calibre33"/>;= Ouah!<br class="calibre33"/><br class="calibre33"/>(main {:bark "Wan-wan!"})<br class="calibre33"/>;= Wan wan!</tt></span></blockquote><p class="calibre23">If you’re using records, all of the fields are dynamic (unless declared to be primitive), so there are no types to drive automagical configuration as with dependency injection containers (either a good or bad thing depending upon your perspective). The upside is that, without a container,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1668944"></a><a href="#filepos1671662"><span class="calibre32">356</span></a><span class="calibre32">]</span></small></sup> the options available for configuration <span class="italic">expand</span>. For example, here’s a suitable “configuration file” (really, just a file containing Clojure-readable data that we’ll only read and not evaluate):</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 12-1. petstore-config.clj</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">{:dog #user.Chihuahua{:weight 12, :price "$84.50"}}</tt></span></p><p class="calibre13">Recall from <a href="#filepos986303"><span class="calibre5">“Readable representation”</span></a> that this <tt class="calibre22">#user.Chihuahua{...}</tt> notation is the readable representation of the named record type. We believe this compares <span class="italic">very</span> well to alternatives such configuring Spring beans using XML, <tt class="calibre22">@Bean</tt> annotations, or similar approaches offered by other dependency injection containers.</p><p class="calibre18">An augmented <tt class="calibre22">PetStore</tt> factory function could read the configuration for our particular environment:</p><p id="filepos1670049" class="calibre23"></p><p class="calibre23"><span class="italic">Example 12-2. configured-petstore</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(defn configured-petstore<br class="calibre33"/>  []<br class="calibre33"/>  (-&gt; "petstore-config.clj"<br class="calibre33"/>    slurp<br class="calibre33"/>    read-string<br class="calibre33"/>    map-&gt;PetStore))</tt></span></p><p class="calibre13">Now we’ll always get a properly “injected” <tt class="calibre22">PetStore</tt>:<a id="filepos1670481"></a></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(configured-petstore)<br class="calibre33"/>;= #user.PetStore{:dog #user.Chihuahua{:weight 12, :price "$84.50"}}</tt></span></blockquote><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1670769"></a><a href="#filepos1658968"><span class="calibre32">354</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Leave such things to the factory-building experts: </span><a href="http://discuss.joelonsoftware.com/default.asp?joel.3.219431.12"><span class="calibre10"><span class="calibre5">http://discuss.joelonsoftware.com/default.asp?joel.3.219431.12</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1671218"></a><a href="#filepos1668241"><span class="calibre32">355</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Other dog bark onomatopoeia courtesy of </span><a href="https://en.wikipedia.org/wiki/Bark_%28utterance%29#Representation"><span class="calibre10"><span class="calibre5">https://en.wikipedia.org/wiki/Bark_%28utterance%29#Representation</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1671662"></a><a href="#filepos1668944"><span class="calibre32">356</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Note that you can absolutely opt to use “legacy” dependency injection containers (like Spring, Guice, et al.) with Clojure types and records.</span></p><div class="mbppagebreak"></div><p id="filepos1671945" class="calibre6"><span class="calibre4"><span class="bold">Strategy Pattern</span></span></p><p id="filepos1672022" class="calibre18">Another common design pattern is the <span class="italic">strategy</span> pattern. This pattern allows the selection of a method or algorithm dynamically. Suppose we want to select a sorting algorithm at runtime:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">interface ISorter {<br class="calibre33"/>    public sort (int[] numbers);<br class="calibre33"/>}<br class="calibre33"/><br class="calibre33"/>class QuickSort implements ISorter {<br class="calibre33"/>    public sort (int[] numbers) { ... }<br class="calibre33"/>}<br class="calibre33"/><br class="calibre33"/>class MergeSort implements ISorter {<br class="calibre33"/>    public sort (int[] numbers) { ... }<br class="calibre33"/>}<br class="calibre33"/><br class="calibre33"/>class Sorter {<br class="calibre33"/>    private ISorter sorter;<br class="calibre33"/>    public Sorter (ISorter sorter) {<br class="calibre33"/>        this.sorter = sorter;<br class="calibre33"/>    }<br class="calibre33"/><br class="calibre33"/>    public execute (int[] numbers) {<br class="calibre33"/>        sorter.sort(numbers);<br class="calibre33"/>    }<br class="calibre33"/>}<br class="calibre33"/><br class="calibre33"/>class App {<br class="calibre33"/>    public ISorter chooseSorter () {<br class="calibre33"/>        if (...) {<br class="calibre33"/>            return new QuickSort();<br class="calibre33"/>        } else {<br class="calibre33"/>            return new MergeSort();<br class="calibre33"/>        }<br class="calibre33"/>    }<br class="calibre33"/>    public static void main(String[] args) {<br class="calibre33"/>        int[] numbers = {5,1,4,2,3};<br class="calibre33"/><br class="calibre33"/>        Sorter s = new Sorter(chooseSorter());<br class="calibre33"/><br class="calibre33"/>        s.execute(numbers);<br class="calibre33"/><br class="calibre33"/>        //... now use sorted numbers<br class="calibre33"/>    }<br class="calibre33"/>}</tt></span></blockquote><p class="calibre23">Clojure has a very simple advantage over Java in this case. Whereas in Java, we need to put methods into classes, functions are first-class objects in Clojure. Translated literally, our Clojure code might look like this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn quicksort [numbers] ...)<br class="calibre33"/><br class="calibre33"/>(defn mergesort [numbers] ...)<br class="calibre33"/><br class="calibre33"/>(defn choose-sorter<br class="calibre33"/>  []<br class="calibre33"/>  (if ...<br class="calibre33"/>    quicksort<br class="calibre33"/>    mergesort))<br class="calibre33"/><br class="calibre33"/>(defn main<br class="calibre33"/>  []<br class="calibre33"/>  (let [numbers [...]]<br class="calibre33"/>    ((choose-sorter) numbers)))</tt></span></blockquote><p class="calibre23">There are no classes in sight. Each function implementing the semantics of our algorithm can be called directly, without class definitions getting in the way of our specifying behavior.</p><p class="calibre18">You don’t even have to give your sorting algorithm a name—an anonymous function works just as well. For example, the composition of Clojure’s built-in <tt class="calibre22">sort</tt> function and then <tt class="calibre22">reverse</tt> to reverse the sort order is an anonymous function:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">((comp reverse sort) [2 1 3])<br class="calibre33"/>;= (3 2 1)</tt></span></blockquote><div class="mbppagebreak"></div><p id="filepos1674973" class="calibre6"><span class="calibre4"><span class="bold">Chain of Responsibility</span></span></p><p id="filepos1675057" class="calibre18">While Clojure’s facilities make many patterns unnecessary or invisible, a select few remain relevant and continue to impact our design and implementation of Clojure programs. One of these is a common form of flow control called <span class="italic">chain of responsibility</span>. In this pattern, an event is sent off to be processed by some set handlers. A handler can process the event or pass the event on to another processing handler. These handlers form a chain, and the event is passed down the chain until one of the handlers determines that the event should not be propagated further.</p><p class="calibre18">Chain of command is useful because it allows a process to be defined in multiple parts that can be composed and combined. No step needs to know anything about other steps in the process, other than how to pass control down the chain.</p><p class="calibre18">This concept shows up in many areas. Unix pipes are an example where textual data is passed from process to process. Filters on Java Servlets are another, where web requests are passed through a series of filters until or before a response is generated.</p><p class="calibre18">In Java, a chain of responsibility can be constructed by defining a series of “processor” objects and then initializing each with a pointer to the next processor.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">abstract class Processor {<br class="calibre33"/>    protected Processor next;<br class="calibre33"/>    public addToChain(Processor p) {<br class="calibre33"/>        next = p;<br class="calibre33"/>    }<br class="calibre33"/>    public runChain(data) {<br class="calibre33"/>        Boolean continue = this.process(data);<br class="calibre33"/>        if(continue and next != null) {<br class="calibre33"/>            next.runChain(data);<br class="calibre33"/>        }<br class="calibre33"/>    }<br class="calibre33"/>    abstract public boolean process(String data);<br class="calibre33"/>}<br class="calibre33"/><br class="calibre33"/>class FooProcessor extends Processor {<br class="calibre33"/>    public boolean process(String data) {<br class="calibre33"/>        System.out.println("FOO says pass...");<br class="calibre33"/>        return true;<br class="calibre33"/>    }<br class="calibre33"/>}<br class="calibre33"/><br class="calibre33"/>class BarProcessor extends Processor {<br class="calibre33"/>    public boolean process(String data) {<br class="calibre33"/>        System.out.println("BAR " + data + " and let's stop here");<br class="calibre33"/>        return false;<br class="calibre33"/>    }<br class="calibre33"/>}<br class="calibre33"/><br class="calibre33"/>class BazProcessor extends Processor {<br class="calibre33"/>    public boolean process(String data) {<br class="calibre33"/>        System.out.println("BAZ?");<br class="calibre33"/>        return true;<br class="calibre33"/>    }<br class="calibre33"/>}<br class="calibre33"/><br class="calibre33"/>Processor chain = new FooProcessor().addToChain(<br class="calibre33"/>    new BarProcessor).addToChain(new BazProcessor);<br class="calibre33"/>chain.run("data123");</tt></span></blockquote><p class="calibre23">In this example, we use a simple protocol of returning Boolean <tt class="calibre22">true</tt> to indicate that set of data is unhandled, and <tt class="calibre22">false</tt> to continue passing data through the chain.</p><p class="calibre18">In Clojure, our basic unit of execution is the function rather than the class or method. This means we can implement something like a chain of responsibility by using simple function composition.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn foo [data]<br class="calibre33"/>  (println "FOO passes")<br class="calibre33"/>  true)<br class="calibre33"/><br class="calibre33"/>(defn bar [data]<br class="calibre33"/>  (println "BAR" data "and let's stop here")<br class="calibre33"/>  false)<br class="calibre33"/><br class="calibre33"/>(defn baz [data]<br class="calibre33"/>  (println "BAZ?")<br class="calibre33"/>  true)<br class="calibre33"/><br class="calibre33"/>(defn wrap [f1 f2]<br class="calibre33"/>  (fn [data]<br class="calibre33"/>    (when (f1 data)<br class="calibre33"/>      (f2 data))))<br class="calibre33"/><br class="calibre33"/>(def chain (reduce wrap [foo bar baz]))</tt></span></blockquote><p class="calibre23">Here we define a function <tt class="calibre22">wrap</tt>, which takes two functions and composes them in a way similar to our Java example: <tt class="calibre22">f1</tt> is run and if it returns <tt class="calibre22">true</tt>, <tt class="calibre22">f2</tt> is run next. We can build a pipeline of functions in this way, which will run until a function terminates the chain or the chain runs out. We can then compose a series of functions by using a simple <tt class="calibre22">reduce</tt>.</p><p id="filepos1679367" class="calibre18"><span class="bold">Ring</span>. A more real-world example of a chain of command in Clojure is the Ring library, which we’ll discuss in detail in <a href="#filepos1878886"><span class="calibre5">Chapter 16</span></a>. Ring is a library to process requests to a web server. A handler for a request is a function that accepts a request object in the form of a Clojure map, and returns a response object as another Clojure map.</p><p class="calibre18">Functions that modify and process these responses and requests are called <span class="italic">middleware</span><a id="filepos1679921"></a>. Middleware can be composed in much the same way we did above in our example. Imagine we begin with a simple handler:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn my-app<br class="calibre33"/>  [request]<br class="calibre33"/>  {:status 200<br class="calibre33"/>   :headers {"Content-type" "text/html"}<br class="calibre33"/>   :body (format "&lt;html&gt;&lt;body&gt;You requested: %s&lt;/body&gt;&lt;/html&gt;"<br class="calibre33"/>           (:uri request))})</tt></span></blockquote><p class="calibre23">We can then “wrap” this handler with middleware that performs a variety of other functions. One piece of middleware might parse web cookie data in the request and add a <tt class="calibre22">:cookie</tt> key to the request or response map. Another bit of middleware might do something similar for <tt class="calibre22">:session</tt> data. These kinds of middleware are already provided by Ring for your use, but it doesn’t offer logging middleware that can log the request to a logfile; defining this middleware might look like so:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn wrap-logger<br class="calibre33"/>  [handler]<br class="calibre33"/>  (fn [request]<br class="calibre33"/>    (println (:uri request))<br class="calibre33"/>    (handler request)))</tt></span></blockquote><p class="calibre23">Depending upon the objectives of a piece of middleware, it can perform actions before or after passing the processing of the <tt class="calibre22">request</tt> to the next <tt class="calibre22">handler</tt> in the chain—or, if appropriate, not pass on the <tt class="calibre22">request</tt> at all. Our naive logging middleware simply dumps each <tt class="calibre22">request</tt>
<tt class="calibre22">:uri</tt> to <tt class="calibre22">stdout</tt> before calling the next handler.</p><p class="calibre18">We can then use the cookies and session middleware provided by Ring along with the logging middleware we defined:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(require '[ring.middleware cookies session])<br class="calibre33"/><br class="calibre33"/>(def my-app (-&gt; my-app<br class="calibre33"/>                wrap-cookies<br class="calibre33"/>                wrap-session<br class="calibre33"/>                wrap-logger))</tt></span></blockquote><p class="calibre23">This method of composition is very similar to <tt class="calibre22">comp</tt>, which we explored in <a href="#filepos284265"><span class="calibre5">Composition of Function(ality)</span></a>, insofar as it yields a function that processes each bit of middleware in the reverse order of how they are included as arguments in the <tt class="calibre22">-&gt;</tt> form. Because <tt class="calibre22">wrap-logger</tt> was the last middleware function to be invoked, the function it returns forms the outermost extent of the composed function, with <tt class="calibre22">my-app</tt> being the innermost piece.<a id="filepos1682600"></a></p><div class="mbppagebreak"></div><p id="filepos1682627" class="calibre6"><span class="calibre4"><span class="bold">Aspect-Oriented Programming</span></span></p><p id="filepos1682715" class="calibre18">Aspect-oriented programming (AOP) is a methodology that allows separation of cross-cutting concerns. In object-oriented code, a behavior or process is often repeated in multiple classes, or spread across multiple methods. AOP is a way to abstract this behavior and apply it to classes and methods without using inheritance.</p><p class="calibre18">A common example is metrics. It’s often desirable to produce and record timing metrics or other debugging information for running code. There is no easy way to compose this behavior into existing functionality in object-oriented codebases, so timing code ends up being added to particular methods of interest and then (hopefully!) commented out when it’s no longer being used:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">public class Foo<br class="calibre33"/>    public void expensiveComputation () {<br class="calibre33"/>        long start = System.currentTimeMillis();<br class="calibre33"/>        try {<br class="calibre33"/>            // do computation<br class="calibre33"/>        } catch (Exception e) {<br class="calibre33"/>            // log error<br class="calibre33"/>        } finally {<br class="calibre33"/>            long stop = System.currentTimeMillis();<br class="calibre33"/>            System.out.println("Run time: " + (stop - start) + "ms");<br class="calibre33"/>        }<br class="calibre33"/>    }<br class="calibre33"/>}</tt></span></blockquote><p class="calibre23">Logging the runtime for a method requires altering the method, edits that we’d have to make repeatedly in order to instrument multiple methods. What we’d really like is a generally applicable way to “wrap” a method with some behavior. A function or method that does this is sometimes called <span class="italic">advice</span><a id="filepos1684494"></a>.</p><p class="calibre18">If we have the capability to define advice separate from the methods that that advice will apply to, we gain a lot of flexibility:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">We can selectively apply<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1684843"></a><a href="#filepos1695038"><span class="calibre32">357</span></a><span class="calibre32">]</span></small></sup> the advice on a per-method basis without modifying the methods themselves; debugging or other development-time advice (such as benchmarks or tracing) can be disabled entirely by changing a single configuration or choosing to simply not apply AOP transformations entirely.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">We can alter the behavior of the advice in one place rather than across multiple methods, so, for example, enhancements to code used to provide timings or other metrics need only be made once.</blockquote></li></ul><p class="calibre18">One implementation of AOP in Java is AspectJ (<a href="http://www.eclipse.org/aspectj/"><span class="calibre5">http://www.eclipse.org/aspectj/</span></a>), an extension to Java that provides access to additional Java-like constructs for AOP. AspectJ provides its own compiler, which compiles AspectJ code into Java classes, which can then be weaved into your application’s classes based on specifications of which methods and classes should be affected (called <span class="italic">pointcuts</span><a id="filepos1686025"></a>). Let’s look at an AspectJ <a id="filepos1686062"></a>example, starting with a class that contains a method for which we might want to obtain metrics:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">public class AspectJExample {<br class="calibre33"/>    public void longRunningMethod () {<br class="calibre33"/>        System.out.println("Starting long-running method");<br class="calibre33"/>        try {<br class="calibre33"/>            Thread.sleep((long)(1000 + Math.random() * 2000));<br class="calibre33"/>        } catch (InterruptedException e) {<br class="calibre33"/>        }<br class="calibre33"/>    }<br class="calibre33"/>}</tt></span></blockquote><p class="calibre23">Next, we define a <tt class="calibre22">Timing</tt> aspect that will apply to all methods in this class:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">public aspect Timing {<br class="calibre33"/>    pointcut profiledMethods(): call(* AspectJExample.* (..));   </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/><br class="calibre33"/>    long time;<br class="calibre33"/><br class="calibre33"/>    before(): profiledMethods() {                                </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>        time = System.currentTimeMillis();<br class="calibre33"/>    }<br class="calibre33"/><br class="calibre33"/>    after(): profiledMethods() {                                 </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>        System.out.println("Call to " + thisJoinPoint.getSignature() +<br class="calibre33"/>                " took " + (System.currentTimeMillis() - time) + "ms");<br class="calibre33"/>    }<br class="calibre33"/>}</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">AspectJ has its own syntax for matching packages, classes, and method signatures; this pointcut matches all methods in the <tt class="calibre22">AspectJExample</tt> class, which we’ll use to guide the application of the <tt class="calibre22">before</tt> and <tt class="calibre22">after</tt> advice.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">The aspect code that runs before affected methods obtains the current time so we can make a comparison to the time after the method returns.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">Code that is run after affected methods, wherein we naively dump the runtime of the method to stdout.</blockquote><p class="calibre18">If we run a program that calls <tt class="calibre22">AspectJExample.longRunningMethod</tt>, then we’ll see output similar to this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">Starting long-running method<br class="calibre33"/>Call to void com.clojurebook.AspectJExample.longRunningMethod() took 1599ms</tt></span></blockquote><p class="calibre23">Rather than potentially making modifications throughout our codebase in order to change or elide “profiling,” changing the behavior of the AspectJ advice can be done in one place, or suspended entirely by just modifying the pointcut or not weaving the aspect into our methods or application to begin with.</p><p class="calibre18"><span class="bold">Robert Hooke</span>. In Clojure, a superset of the functionality of aspect-oriented programming is easy to obtain thanks to vars and first-class functions. Functions can easily be passed as arguments to other functions, and Clojure allows vars to be redefined at runtime; these two features combine to allow easy “wrapping” of functions with other functions to modify behavior or results however you like.</p><p class="calibre18">The Robert Hooke library <a id="filepos1689982"></a>(<a href="https://github.com/technomancy/robert-hooke"><span class="calibre5">https://github.com/technomancy/robert-hooke</span></a>) provides a simple and powerful way to define advice (referred to as <span class="italic">hooks</span>) for functions. Back to our example above, setting up a hook to time a function is easy:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn time-it [f &amp; args]<br class="calibre33"/>  (let [start (System/currentTimeMillis)]<br class="calibre33"/>    (try<br class="calibre33"/>      (apply f args)<br class="calibre33"/>      (finally<br class="calibre33"/>       (println "Run time: " (- (System/currentTimeMillis) start) "ms")))))</tt></span></blockquote><p class="calibre23"><tt class="calibre22">time-it</tt><a id="filepos1690691"></a> is a regular Clojure function. It takes as its two arguments another function <tt class="calibre22">ƒ</tt> and some set of arguments <tt class="calibre22">args</tt>, which will be the arguments the caller intended to pass to <tt class="calibre22">ƒ</tt>. Our advice can do anything before or after calling <tt class="calibre22">ƒ</tt> (if it decides to call <tt class="calibre22">ƒ</tt> at all); in this case, we just record running time.</p><p class="calibre18">There’s no contortion needed to allow <tt class="calibre22">time-it</tt> to invoke <tt class="calibre22">ƒ</tt>; it simply calls it via <tt class="calibre22">apply</tt>, passing it the arguments in <tt class="calibre22">args</tt>. Note that thanks to variadic arguments, <tt class="calibre22">time-it</tt> works for any function regardless of how many arguments that function might require.</p><p class="calibre18">This advice can be applied to a function like so:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(require 'robert.hooke)<br class="calibre33"/><br class="calibre33"/>(defn foo [x y]<br class="calibre33"/>  (Thread/sleep (rand-int 1000))<br class="calibre33"/>  (+ x y))<br class="calibre33"/><br class="calibre33"/>(robert.hooke/add-hook #'foo time-it)  </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">The <tt class="calibre22">robert.hooke</tt> calls to add <tt class="calibre22">time-it</tt> hook to the var <tt class="calibre22">#'foo</tt>, which will affect all calls of its function.</blockquote><p class="calibre18">And now when we invoke <tt class="calibre22">foo</tt>, we see the result of our <tt class="calibre22">time-it</tt> code running:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(foo 1 2)<br class="calibre33"/>; Run time:  772 ms<br class="calibre33"/>;= 3</tt></span></blockquote><p class="calibre23">Robert Hooke also provides the ability to temporarily or permanently disable or remove hooks:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(robert.hooke/with-hooks-disabled foo (foo 1 2))  </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= 3<br class="calibre33"/><br class="calibre33"/>(robert.hooke/remove-hook #'foo time-it)          </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #&lt;user$foo user$foo@4f13f501&gt;<br class="calibre33"/>(foo 1 2)<br class="calibre33"/>;= 3</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">with-hooks-disabled</tt> allows you to temporarily suspend the invocation of hooks on a particular named var.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">remove-hook</tt> will remove a particular hook from a var.</blockquote><p class="calibre18">Note that this is all done at a REPL. Adding, removing, and temporarily suspending the invocation of hooks on a var can be determined entirely at runtime using whatever criteria are most suitable for your application.</p><p class="calibre18">Finally, because the addition and removal of hooks is done using regular functions (i.e., <tt class="calibre22">add-hook</tt> and <tt class="calibre22">remove-hook</tt>) on regular vars, there is no need for anything like the idiosyncratic AspectJ pointcut syntax we saw earlier. Excellent tools are available to introspect on the Clojure environment, so we can do things like add a hook to all vars in a namespace:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(require 'clojure.set)<br class="calibre33"/>;= nil<br class="calibre33"/>(doseq [var (-&gt;&gt; (ns-publics 'clojure.set)<br class="calibre33"/>                 (map val))]<br class="calibre33"/>  (robert.hooke/add-hook var time-it))<br class="calibre33"/>;= nil<br class="calibre33"/>(clojure.set/intersection (set (range 100000))<br class="calibre33"/>                          (set (range -100000 10)))<br class="calibre33"/>; Run time:  97 ms<br class="calibre33"/>;= #{0 1 2 3 4 5 6 7 8 9}</tt></span></blockquote><p class="calibre23">All of this is done without any special language or compiler support, as is needed by AspectJ. In fact, the Robert Hooke library is a mere 100 lines of plain Clojure code; if it didn’t exist already, you could write it yourself.<a id="filepos1694934"></a></p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1695038"></a><a href="#filepos1684843"><span class="calibre32">357</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">The application of advice or other aspect transformations is often called </span><span class="calibre10"><span class="italic">weaving</span></span><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos1695309" class="calibre6"><span class="calibre4"><span class="bold">Final Thoughts</span></span></p><p class="calibre18">As we have seen, many common design patterns are trivial in Clojure, and in most cases, simply disappear into the language and its libraries entirely. Thanks to a focus on separating functions and data, along with first-class functions and the tools to combine and compose them, it’s typical to complete designs and architectures in Clojure without appeal to design patterns that generally aim to manage and mitigate the relative complexity of object-oriented approaches like those embodied by Java and Ruby.<a id="filepos1695922"></a></p><div class="mbppagebreak"></div><p id="filepos1695949" class="calibre6"><span class="calibre2"><span class="bold">Chapter 13. Testing</span></span></p><p id="filepos1696031" class="calibre13">Conceptually, testing in Clojure is largely the same as it is in Java, Python, or Ruby. Regardless of the language you use, the objective is always to:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">Construct a suitable environment.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Run some code.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Verify that the code behaved or returned as expected.</blockquote></li></ol><p class="calibre18">Of course, the details of each piece of this task can vary greatly between languages and testing frameworks. In this chapter, we’ll survey ways to test in Clojure, focusing on <tt class="calibre22">clojure.test</tt>, the test framework that is included in the language’s standard library.</p><p id="filepos1696947" class="calibre6"><span class="calibre4"><span class="bold">Immutable Values and Pure Functions</span></span></p><p id="filepos1697043" class="calibre18">In an object-oriented language like Java or Python or Ruby, testing can be a complicated matter. Objects tend to have numerous, subtle interactions with each other. Mutating one object may end up mutating any number of other objects, or the behavior of one object may implicitly rely upon the state of others. These interactions are often combinatorial in nature, making it difficult to reliably account for all the environmental characteristics that can change our programs’ behavior, and therefore more difficult to test.</p><p class="calibre18">As we detailed in <a href="#filepos215673"><span class="calibre5">Chapter 2</span></a>, Clojure encourages the use of immutable values and pure functions. Code written in line with such sensibilities is greatly simplified from a testing perspective: if your functions’ results are determined only by their arguments, then simple unit tests are all that are required to ensure suitable test coverage. Of course, integration and functional testing will still be necessary for those parts of your applications that consist of more than pure functions.</p><p id="filepos1698179" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Mocking</span></span></span></p><p id="filepos1698276" class="calibre18">In object-oriented languages, a common test aid is to resort to <span class="italic">mock</span> objects, which simulate the behavior of real objects <a id="filepos1698433"></a>or services upon which some code depends. Given a suitably constructed mock, code under test can be more effectively isolated to prevent possible bugs or variable behavior in the dependency from unduly affecting test results.</p><p class="calibre18">Mock objects can be a lesson in incidental complexity, especially in statically typed languages. Interfaces may need to be created for the express purpose of being able to create mock objects, and mock-motivated data types are often necessary to present a uniform API for data obtained either from a live service or a mock of that service.</p><p class="calibre18">Mocks are often not necessary when testing in Clojure. Given immutable collections and records, there is simply never any reason to mock data per se; you can go so far as to capture data from production environments, persist it, and reuse it as test data, without any wrappers, conversions, or type gymnastics.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1699413"></a><a href="#filepos1702787"><span class="calibre32">358</span></a><span class="calibre32">]</span></small></sup> “Mock data” in Clojure is just…more data.</p><p class="calibre18">One relevant corollary to mocking in other languages is the need to mock Clojure <span class="italic">functions</span>. Consider a function that looks up the address for a given username:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn get-address<br class="calibre33"/>  [username]<br class="calibre33"/>  ;; access database<br class="calibre33"/>  )</tt></span></blockquote><p class="calibre23">This function will fail in any environment where the source database isn’t available or hasn’t been configured suitably, and tests involving this function will fail if a database <span class="italic">is</span> available, but contains different data than what the tests expect.</p><p class="calibre18"><tt class="calibre22">with-redefs</tt><a id="filepos1700266"></a> is one solution to this problem. It temporarily replaces the root values of a set of named vars with some other values, executes its body, and then resets the original root values of those vars; effectively, the affected vars are mocked:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(with-redefs [address-lookup (constantly "123 Main St.")]<br class="calibre33"/>  (println (address-lookup)))<br class="calibre33"/>; 123 Main St.</tt></span></blockquote><p class="calibre23">You can use <tt class="calibre22">binding</tt><a id="filepos1700781"></a>—described in <a href="#filepos744558"><span class="calibre5">Dynamic Scope</span></a>—in much the same way, but <tt class="calibre22">with-redefs</tt> is more appropriate in many cases, especially when testing:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">with-redefs</tt> imposes no limitations on the vars that may be affected, in contrast to <tt class="calibre22">binding</tt>, which will only work on vars marked as <tt class="calibre22">^:dynamic</tt>.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">with-redefs</tt> has none of the thread-local semantics of dynamic bindings, that is, all threads, agents, futures, etc. see the temporary root value of the affected vars.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Dynamic vars affected by <tt class="calibre22">binding</tt> can have their bound value <tt class="calibre22">set!</tt>ed. This doesn’t prevent <tt class="calibre22">alter-var-root</tt> from being used on vars temporarily modified using <tt class="calibre22">with-redefs</tt>, but not having <tt class="calibre22">set!</tt> available when it’s not necessary can be a reasonable precaution.</blockquote></li></ul><p class="calibre18">In short, the length of rope dynamic vars and <tt class="calibre22">binding</tt> provide is often longer than you need when testing, enabling cleverness that might not be desirable within that context.</p><p class="calibre18">In any case, both <tt class="calibre22">with-redefs</tt> and <tt class="calibre22">binding</tt> can be used in conjunction with the fixture facility provided by <tt class="calibre22">clojure.test</tt> to ensure that key vars are mocked as necessary for the scope of testing, either to have functions return known constant values, or to retarget operations, for example, to access a particular database based on local test configuration. We’ll talk more about fixtures later in <a href="#filepos1720516"><span class="calibre5">Fixtures</span></a>.</p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1702787"></a><a href="#filepos1699413"><span class="calibre32">358</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Some testing situations have a special need for </span><span class="calibre10"><span class="italic">generated</span></span><span class="calibre10"> test data—a concept that has gained some exposure thanks to Haskell’s QuickCheck—but such data remains immutable and amenable to all the generic data-manipulation facilities in Clojure. There are many Clojure libraries that provide various test data generation facilities, including </span><span class="calibre10"><tt class="calibre22">test.generative</tt></span><span class="calibre10"> (</span><a href="https://github.com/clojure/test.generative/"><span class="calibre10"><span class="calibre5">https://github.com/clojure/test.generative/</span></span></a><span class="calibre10">), ClojureCheck (</span><a href="https://bitbucket.org/kotarak/clojurecheck"><span class="calibre10"><span class="calibre5">https://bitbucket.org/kotarak/clojurecheck</span></span></a><span class="calibre10">), and </span><span class="calibre10"><tt class="calibre22">re-rand</tt></span><span class="calibre10"> (</span><a href="https://github.com/weavejester/re-rand"><span class="calibre10"><span class="calibre5">https://github.com/weavejester/re-rand</span></span></a><span class="calibre10">).</span></p><div class="mbppagebreak"></div><p id="filepos1703991" class="calibre6"><span class="calibre4"><span class="bold">clojure.test</span></span></p><p class="calibre18"><tt class="calibre22">clojure.test</tt><a id="filepos1704113"></a> is the “official” Clojure test framework. It’s a simple library, but one that is sufficient for many tasks.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">There are other popular test frameworks for Clojure that provide more sophisticated semantics and capabilities. The most popular of these is Midje, available at </span><a id="filepos1704583"></a><a href="https://github.com/marick/Midje"><span class="calibre10"><span class="calibre5">https://github.com/marick/Midje</span></span></a><span class="calibre10">.</span></blockquote><p class="calibre25">Assertions in <tt class="calibre22">clojure.test</tt> use the <tt class="calibre22">is</tt><a id="filepos1704837"></a> macro. <tt class="calibre22">is</tt> evaluates a single expression, tests whether the result is logically true, and returns that value. <tt class="calibre22">is</tt> will report any failures, including the actual values that were obtained, along with the (optional) message provided with the assertion, if any:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(use 'clojure.test)<br class="calibre33"/><br class="calibre33"/>(is (= 5 (+ 4 2)) "I never was very good at math...")<br class="calibre33"/>; FAIL in clojure.lang.PersistentList$EmptyList@1 (NO_SOURCE_FILE:1)<br class="calibre33"/>; I was never very good at math...<br class="calibre33"/>; expected: (= 5 (+ 4 2))<br class="calibre33"/>;   actual: (not (= 5 6))<br class="calibre33"/>;= false<br class="calibre33"/><br class="calibre33"/>(is (re-find #"foo" "foobar"))<br class="calibre33"/>;= "foo"</tt></span></blockquote><p class="calibre23"><tt class="calibre22">is</tt> defines a number of special assertions that can be used within expressions.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1705756"></a><a href="#filepos1730061"><span class="calibre32">359</span></a><span class="calibre32">]</span></small></sup> For example, <tt class="calibre22">thrown?</tt> will test that a certain type of error is thrown in the course of the expression’s evaluation:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(is (thrown? ArithmeticException (/ 1 0)))                         </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #&lt;ArithmeticException java.lang.ArithmeticException: Divide by zero&gt;<br class="calibre33"/>(is (thrown? ArithmeticException (/ 1 1)))<br class="calibre33"/>; FAIL in clojure.lang.PersistentList$EmptyList@1 (NO_SOURCE_FILE:1)<br class="calibre33"/>; expected: (thrown? ArithmeticException (/ 1 1))<br class="calibre33"/>;   actual: nil<br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">is</tt> returns the exception when a <tt class="calibre22">thrown?</tt> assertion passes.</blockquote><p class="calibre18"><tt class="calibre22">thrown-with-msg?</tt> is similar, but also tests that some regular expression can be found within the error’s message:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(is (thrown-with-msg? ArithmeticException #"zero" (/ 1 0)))<br class="calibre33"/>;= #&lt;ArithmeticException java.lang.ArithmeticException: Divide by zero&gt;<br class="calibre33"/>(is (thrown-with-msg? ArithmeticException #"zero" (inc Long/MAX_VALUE)))      </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>; FAIL in clojure.lang.PersistentList$EmptyList@1 (NO_SOURCE_FILE:1)<br class="calibre33"/>; expected: (thrown-with-msg? ArithmeticException #"zero" (inc Long/MAX_VALUE))<br class="calibre33"/>;   actual: #&lt;ArithmeticException java.lang.ArithmeticException: integer overflow&gt;<br class="calibre33"/>;= #&lt;ArithmeticException java.lang.ArithmeticException: integer overflow&gt;</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Clojure throws an <tt class="calibre22">ArithmeticException</tt> when a nonpromoting operator will result in an overflow condition; this exception has a message that doesn’t contain <tt class="calibre22">#"zero"</tt>, so the assertion fails.</blockquote><p class="calibre18">You can document tests and augment failure reports by using the <tt class="calibre22">testing</tt> macro, which causes the description of a failing test’s scope to be included in the error report:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(testing "Strings"<br class="calibre33"/>  (testing "regex"<br class="calibre33"/>    (is (re-find #"foo" "foobar"))<br class="calibre33"/>    (is (re-find #"foo" "bar")))<br class="calibre33"/>  (testing ".contains"<br class="calibre33"/>    (is (.contains "foobar" "foo"))))<br class="calibre33"/>; FAIL in clojure.lang.PersistentList$EmptyList@1 (NO_SOURCE_FILE:1)<br class="calibre33"/>; Strings regex<br class="calibre33"/>; expected: (re-find #"foo" "bar")<br class="calibre33"/>;   actual: (not (re-find #"foo" "bar"))</tt></span></blockquote><p id="filepos1708891" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Defining Tests</span></span></span></p><p id="filepos1708995" class="calibre18">There are two ways to define tests. First and probably most useful, tests can be defined as standalone functions via the <tt class="calibre22">deftest</tt> macro. This macro simply defines a zero-argument function for you (as per <tt class="calibre22">defn</tt>) with some metadata attached to its var that marks it as a test. <tt class="calibre22">deftest</tt> tests are otherwise identical to normal functions, can be called from the REPL, and so on:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(deftest test-foo<br class="calibre33"/>  (is (= 1 1)))<br class="calibre33"/>;= #'user/test-foo<br class="calibre33"/>(test-foo)<br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre23">It’s common to define tests in a set of namespaces separate from your library or application, often in a <tt class="calibre22">test</tt> subdirectory of your project. As we described in <a href="#filepos1132603"><span class="calibre5">Chapter 8</span></a>, Clojure’s most commonly used build tools look in these directories for tests and can run them for you.</p><p class="calibre18">All <tt class="calibre22">clojure.test</tt> tests are actually defined as vars that have a function located in the <tt class="calibre22">:test</tt> slot of their metadata. We can see this in the test we defined above:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(:test (meta #'test-foo))<br class="calibre33"/>;= #&lt;user$fn__366 user$fn__366@4e842e74&gt;</tt></span></blockquote><p class="calibre23">The function you call via <tt class="calibre22">(test-foo)</tt> just delegates to this <tt class="calibre22">:test</tt> function. This may seem like a silly detail, but it makes it possible to do things like bundle tests with the functions they are testing, something the <tt class="calibre22">with-test</tt> macro helps you do.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1710704"></a><a href="#filepos1730792"><span class="calibre32">360</span></a><span class="calibre32">]</span></small></sup> It takes any form that defines a var as its first argument, and any number of other forms as additional arguments that will comprise the body of a test function that is stored in the metadata of that var:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(with-test<br class="calibre33"/>  (defn hello [name]<br class="calibre33"/>    (str "Hello, " name))<br class="calibre33"/>  (is (= (hello "Brian") "Hello, Brian"))<br class="calibre33"/>  (is (= (hello nil) "Hello, nil")))<br class="calibre33"/>;= #'user/hello</tt></span></blockquote><p class="calibre23">Defined this way, we can call and use <tt class="calibre22">hello</tt> in our application however we need to without running any tests:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(hello "Judy")<br class="calibre33"/>;= "Hello, Judy"</tt></span></blockquote><p class="calibre23">The body provided to <tt class="calibre22">with-test</tt> after the var-defining form is bundled up into a function that is stored in the <tt class="calibre22">:test</tt> slot of the var’s metadata; this is the test function:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">((:test (meta #'hello)))<br class="calibre33"/>; FAIL in clojure.lang.PersistentList$EmptyList@1 (NO_SOURCE_FILE:5)<br class="calibre33"/>; expected: (= (hello nil) "Hello, nil")<br class="calibre33"/>;   actual: (not (= "Hello, " "Hello, nil"))<br class="calibre33"/>;= false</tt></span></blockquote><p class="calibre23">Helpfully, the <tt class="calibre22">clojure.test/run-tests</tt> function uses this metadata to dynamically find tests in one or more namespaces and run them all. Thus, it can find tests in a loaded source file as well as tests defined at the REPL:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(run-tests)     </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>; Testing user<br class="calibre33"/>;<br class="calibre33"/>; FAIL in (hello) (NO_SOURCE_FILE:5)<br class="calibre33"/>; expected: (= (hello nil) "Hello, nil")<br class="calibre33"/>;   actual: (not (= "Hello, " "Hello, nil"))<br class="calibre33"/>;<br class="calibre33"/>; Ran 2 tests containing 3 assertions.<br class="calibre33"/>; 1 failures, 0 errors.<br class="calibre33"/>;= {:type :summary, :pass 2, :test 2, :error 0, :fail 1}</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">If no namespaces are specified, <tt class="calibre22">run-tests</tt> searches for vars with <tt class="calibre22">:test</tt> functions in <tt class="calibre22">*ns*</tt>.</blockquote><p class="calibre18">In contrast to the build-compile-test cycle in many languages, Clojure makes it easy to test functions as they’re written via utilities like <tt class="calibre22">run-tests</tt>.</p><p class="calibre18">One caveat of this approach is that, once defined, tests stay defined as long as the JVM is alive. Loading a file from disk or requiring a namespace containing tests will not drop and redefine those tests, so unwanted tests will persist and <tt class="calibre22">run-tests</tt> will continue to find and run them until you restart the JVM—something we’d like to avoid if possible. Thankfully, you can undefine a var (and thus its test) using <tt class="calibre22">ns-unmap</tt><a id="filepos1713904"></a>:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1713947"></a><a href="#filepos1731308"><span class="calibre32">361</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(ns-unmap *ns* 'hello)<br class="calibre33"/>;= nil<br class="calibre33"/>(run-tests)<br class="calibre33"/>; Testing user<br class="calibre33"/>;<br class="calibre33"/>; Ran 1 tests containing 1 assertions.<br class="calibre33"/>; 0 failures, 0 errors.<br class="calibre33"/>;= {:type :summary, :pass 1, :test 1, :error 0, :fail 0}</tt></span></blockquote><p class="calibre23">Alternatively, we could have altered the metadata on <tt class="calibre22">hello</tt> to not contain the <tt class="calibre22">:test</tt> function; for vars, we define in conjunction with <tt class="calibre22">with-test</tt>, this will allow us to continue to use the underlying function:<a id="filepos1714648"></a></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(with-test<br class="calibre33"/>  (defn hello [name]<br class="calibre33"/>    (str "Hello, " name))<br class="calibre33"/>  (is (= (hello "Brian") "Hello, Brian"))<br class="calibre33"/>  (is (= (hello nil) "Hello, nil")))<br class="calibre33"/>;= #'user/hello<br class="calibre33"/>(alter-meta! #'hello dissoc :test)<br class="calibre33"/>;= {:ns #&lt;Namespace user&gt;, :name hello, :arglists ([name]),<br class="calibre33"/>;=  :line 2, :file "NO_SOURCE_PATH"}<br class="calibre33"/>(run-tests *ns*)<br class="calibre33"/>; Testing user<br class="calibre33"/>;<br class="calibre33"/>; Ran 1 tests containing 1 assertions.<br class="calibre33"/>; 0 failures, 0 errors.<br class="calibre33"/>;= {:type :summary, :pass 1, :test 1, :error 0, :fail 0}<br class="calibre33"/>(hello "Rebecca")<br class="calibre33"/>;= "Hello, Rebecca"</tt></span></blockquote><p id="filepos1715417" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Test “Suites”</span></span></span></p><p id="filepos1715524" class="calibre18">You can call other test functions from within tests without a problem:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(deftest a<br class="calibre33"/>  (is (== 0 (- 3 2))))<br class="calibre33"/>;= #'user/a<br class="calibre33"/>(deftest b (a))<br class="calibre33"/>;= #'user/b<br class="calibre33"/>(deftest c (b))<br class="calibre33"/>;= #'user/c<br class="calibre33"/>(c)<br class="calibre33"/>; FAIL in (c b a) (NO_SOURCE_FILE:2)   </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>; expected: (== 0 (- 3 2))<br class="calibre33"/>;   actual: (not (== 0 1))</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Failure reports helpfully include the “stack” of test functions that led to the failure; the stack here is the list <tt class="calibre22">(c b a)</tt>.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1716439"></a><a href="#filepos1731895"><span class="calibre32">362</span></a><span class="calibre32">]</span></small></sup></blockquote><p class="calibre18">Defining “suites” of tests in this way is convenient, but clashes with the default behavior of <tt class="calibre22">run-tests</tt> (and therefore with the test-running functionality of Clojure build tools): because it invokes the <tt class="calibre22">:test</tt> function from the metadata of all vars, it will run subtests directly, even if they are being called as part of the “suite.” At best, this will lead to longer test runtimes as tests are invoked redundantly; at worst, you’ll get a proliferation of duplicated failure reports:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(run-tests)<br class="calibre33"/>; Testing user<br class="calibre33"/>;<br class="calibre33"/>; FAIL in (b a) (NO_SOURCE_FILE:2)<br class="calibre33"/>; expected: (== 0 (- 3 2))<br class="calibre33"/>;   actual: (not (== 0 1))<br class="calibre33"/>;<br class="calibre33"/>; FAIL in (c b a) (NO_SOURCE_FILE:2)<br class="calibre33"/>; expected: (== 0 (- 3 2))<br class="calibre33"/>;   actual: (not (== 0 1))<br class="calibre33"/>;<br class="calibre33"/>; FAIL in (a) (NO_SOURCE_FILE:2)<br class="calibre33"/>; expected: (== 0 (- 3 2))<br class="calibre33"/>;   actual: (not (== 0 1))<br class="calibre33"/>;<br class="calibre33"/>; Ran 6 tests containing 3 assertions.<br class="calibre33"/>; 3 failures, 0 errors.<br class="calibre33"/>;= {:type :summary, :pass 0, :test 6, :error 0, :fail 3}</tt></span></blockquote><p class="calibre23">There are a couple of ways to avoid this. First, you can define a primary entry point for <tt class="calibre22">run-tests</tt> on a per-namespace basis; this entry point must be a function called <tt class="calibre22">test-ns-hook</tt>, and it must have a zero-argument arity. When <tt class="calibre22">test-ns-hook</tt> is present, it will be the only function in its namespace that <tt class="calibre22">run-tests</tt> will invoke. This gives you complete control over which tests are run and how they are composed:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn test-ns-hook [] (c))<br class="calibre33"/>;= #'user/test-ns-hook<br class="calibre33"/>(run-tests)<br class="calibre33"/>; Testing user<br class="calibre33"/>;<br class="calibre33"/>; FAIL in (c b a) (NO_SOURCE_FILE:2)<br class="calibre33"/>; expected: (== 0 (- 3 2))<br class="calibre33"/>;   actual: (not (== 0 1))<br class="calibre33"/>;<br class="calibre33"/>; Ran 3 tests containing 1 assertions.<br class="calibre33"/>; 1 failures, 0 errors.<br class="calibre33"/>;= {:type :summary, :pass 0, :test 3, :error 0, :fail 1}</tt></span></blockquote><p class="calibre23">Alternatively, you can just put subordinate assertions in regular functions. These won’t have <tt class="calibre22">:test</tt> metadata, and therefore won’t be found and invoked by <tt class="calibre22">run-tests</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(ns-unmap *ns* 'test-ns-hook)          </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= nil<br class="calibre33"/>(defn a<br class="calibre33"/>  []<br class="calibre33"/>  (is (== 0 (- 3 2))))<br class="calibre33"/>;= #'user/a<br class="calibre33"/>(defn b [] (a))<br class="calibre33"/>;= #'user/b<br class="calibre33"/>(deftest c (b))<br class="calibre33"/>;= #'user/c<br class="calibre33"/>(run-tests)<br class="calibre33"/>; Testing user<br class="calibre33"/>;<br class="calibre33"/>; FAIL in (c) (NO_SOURCE_FILE:3)       </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>; expected: (== 0 (- 3 2))<br class="calibre33"/>;   actual: (not (== 0 1))<br class="calibre33"/>;<br class="calibre33"/>; Ran 1 tests containing 1 assertions.<br class="calibre33"/>; 1 failures, 0 errors.<br class="calibre33"/>;= {:type :summary, :pass 0, :test 1, :error 0, :fail 1}</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Let’s first drop the <tt class="calibre22">test-ns-hook</tt> we defined earlier.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">Notice that the test “stack” for this failure is only <tt class="calibre22">(c)</tt> and not <tt class="calibre22">(c b a)</tt> as before. This is because <tt class="calibre22">run-tests</tt> only tracks test scope, not that of regular functions like <tt class="calibre22">a</tt> and <tt class="calibre22">b</tt>.</blockquote><p id="filepos1720516" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Fixtures</span></span></span></p><p id="filepos1720614" class="calibre18">Fixtures provide a way to set up and then tear down services, database state, function mocks, and test data, thereby ensuring that all the tests within a namespace are invoked within a controlled context. They are similar to the <tt class="calibre22">setUp</tt> and <tt class="calibre22">tearDown</tt> methods (or <tt class="calibre22">@Before</tt> and <tt class="calibre22">@After</tt> annotations) found in xUnit unit testing libraries, but offer essentially unbounded control over the test environment.</p><p class="calibre18">A fixture is simply a higher-order function that accepts a single function argument that is the test or set of tests that should be invoked within the context established and torn down by the fixture. Fixtures can be defined anywhere, reused across test namespaces, and any number of them can be utilized for each namespace.</p><p class="calibre18">You can apply fixtures to a namespace in two ways:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Fixtures can be invoked for <span class="italic">each</span> test found in a namespace. For a namespace that contains <span class="italic">n</span> tests, your fixture will be called <span class="italic">n</span> times, each time with a function corresponding to a single test.</blockquote></li><a id="filepos1721865"></a><li value="2" class="calibre16"><blockquote class="calibre17">Alternatively, fixtures can be invoked <span class="italic">once</span> for an entire namespace, where the context it establishes will apply to all test functions in that namespace. For a namespace that contains <span class="italic">n</span> tests, your fixture will be called only once with a function that will invoke all of the namespace’s test functions.</blockquote></li><a id="filepos1722284"></a></ul><p class="calibre18">In either case, fixture implementations take this general form:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn some-fixture<br class="calibre33"/>  [f]<br class="calibre33"/>  (try<br class="calibre33"/>    ;; set up database connections, load test data,<br class="calibre33"/>    ;; mock out functions using `with-redefs` or `binding`, etc.<br class="calibre33"/>    (f)<br class="calibre33"/>    (finally<br class="calibre33"/>      ;; clean up database connections, files, etc.<br class="calibre33"/>      )))</tt></span></blockquote><p class="calibre23">Whether you choose the <span class="italic">each</span> or <span class="italic">once</span> option for a given fixture, the behavior of fixture implementations is highly dependent upon what you’re testing and the details of your test environment(s).</p><p class="calibre18">The <span class="italic">each</span> or <span class="italic">once</span> options cover most requirements, but they do mean that fixtures in <tt class="calibre22">clojure.test</tt> offer a subset of the flexibility available when you define your own <tt class="calibre22">test-ns-hook</tt>. Whereas fixtures have two defined “life cycles,” you have <span class="italic">complete</span> control over what runs, when it runs, and what is performed before and after each test within a <tt class="calibre22">test-ns-hook</tt> implementation. Fixtures happen to be more convenient most of the time; in particular, using them does not force you to explicitly manage the search for and invocation of test functions in a namespace, bookkeeping that you implicitly take on when using <tt class="calibre22">test-ns-hook</tt>.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Fixtures and </span><span class="calibre10"><tt class="calibre22">test-ns-hook</tt></span><span class="calibre10"> are mutually exclusive; if you define the latter, then the former will </span><span class="calibre10"><span class="italic">not</span></span><span class="calibre10"> be applied.</span></blockquote><p class="calibre25">To get our hands dirty with fixtures, let’s look back at <tt class="calibre22">configured-petstore</tt>, a function we defined in <a href="#filepos1670049"><span class="calibre5">Example 12-2</span></a> and repeated below with some supporting records and a protocol:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defprotocol Bark<br class="calibre33"/>  (bark [this]))<br class="calibre33"/><br class="calibre33"/>(defrecord Chihuahua [weight price]<br class="calibre33"/>  Bark<br class="calibre33"/>  (bark [this] "Yip!"))<br class="calibre33"/><br class="calibre33"/>(defrecord PetStore [dog])<br class="calibre33"/><br class="calibre33"/>(defn configured-petstore<br class="calibre33"/>  []<br class="calibre33"/>  (-&gt; "petstore-config.clj"<br class="calibre33"/>    slurp<br class="calibre33"/>    read-string<br class="calibre33"/>    map-&gt;PetStore))</tt></span></blockquote><p class="calibre23">A test for <tt class="calibre22">configured-petstore</tt> is easy to write; we just need to compare the <tt class="calibre22">PetStore</tt> it produces to a known value:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def ^:private dummy-petstore (PetStore. (Chihuahua. 12 "$84.50")))<br class="calibre33"/><br class="calibre33"/>(deftest test-configured-petstore<br class="calibre33"/>  (is (= (configured-petstore) dummy-petstore)))</tt></span></blockquote><p class="calibre23"><tt class="calibre22">configured-petstore</tt> loads a record from a particular file on disk, <tt class="calibre22">"petstore-config.clj"</tt> in the current directory. Therefore, this test will fail without if that file doesn’t exist or isn’t populated with data properly corresponding to our expected <tt class="calibre22">dummy-petstore</tt> value:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(run-tests)<br class="calibre33"/>; Testing user<br class="calibre33"/>;<br class="calibre33"/>; ERROR in (test-configured-petstore) (FileInputStream.java:-2)<br class="calibre33"/>; expected: (= (configured-petstore) dummy-petstore)<br class="calibre33"/>;   actual: java.io.FileNotFoundException: petstore-config.clj <br class="calibre33"/>     (No such file or directory)<br class="calibre33"/>;  at java.io.FileInputStream.open (FileInputStream.java:-2)<br class="calibre33"/>;     ...<br class="calibre33"/>;<br class="calibre33"/>; Ran 1 tests containing 1 assertions.<br class="calibre33"/>; 0 failures, 1 errors.<br class="calibre33"/>;= {:type :summary, :pass 0, :test 1, :error 1, :fail 0}</tt></span></blockquote><p class="calibre23">We need to ensure that a suitable file is present so that the result of calling <tt class="calibre22">configured-petstore</tt> can be verified. This calls for a fixture. We already have an expected <tt class="calibre22">PetStore</tt> instance (held in <tt class="calibre22">dummy-petstore</tt>); having our fixture dump the readable representation of that record and its fields to the file that <tt class="calibre22">configured-petstore</tt> requires is a simple matter:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn petstore-config-fixture<br class="calibre33"/>  [f]<br class="calibre33"/>  (let [file (java.io.File. "petstore-config.clj")]<br class="calibre33"/>    (try<br class="calibre33"/>      (spit file (with-out-str (pr dummy-petstore)))  </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>      (f)                                             </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>      (finally<br class="calibre33"/>        (.delete file)))))                            </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Here’s where we write the readable representation of <tt class="calibre22">dummy-petstore</tt> to <tt class="calibre22">"petstore-config.clj"</tt>. Note that we’re using <tt class="calibre22">pr</tt> here instead of <tt class="calibre22">print</tt> or <tt class="calibre22">println</tt>; the latter functions produce human-readable output, whereas <tt class="calibre22">pr</tt> and <tt class="calibre22">prn</tt> produce Clojure <tt class="calibre22">read</tt>able output.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">f</tt> here is either a test function, or a function that will call all test functions within the namespace. Which one it is depends on whether our fixture is registered to run <tt class="calibre22">:once</tt> for a namespace, or once for <tt class="calibre22">:each</tt> test function within a namespace.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">It’s good form to clean up a fixture’s effects as much as possible. If we didn’t do this, then <tt class="calibre22">"petstore-config.clj"</tt> would persist across test runs, perhaps falsely enabling other tests to pass.</blockquote><p class="calibre18">With our fixture defined,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1728974"></a><a href="#filepos1732673"><span class="calibre32">363</span></a><span class="calibre32">]</span></small></sup> all that remains is to register it. We’ll use the <tt class="calibre22">:once</tt> life cycle:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(use-fixtures :once petstore-config-fixture)</tt></span></blockquote><p class="calibre23">With our fixture registered, we can be sure that <tt class="calibre22">configured-petstore</tt> will be invoked with known data in place, thus allowing the test to pass:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(run-tests)<br class="calibre33"/>; Testing user<br class="calibre33"/>;<br class="calibre33"/>; Ran 1 tests containing 1 assertions.<br class="calibre33"/>; 0 failures, 0 errors.<br class="calibre33"/>;= {:type :summary, :pass 1, :test 1, :error 0, :fail 0}</tt></span></blockquote><p class="calibre23">We could just as easily have registered <tt class="calibre22">petstore-config-fixture</tt> as an <tt class="calibre22">:each</tt> fixture, so that it would be applied once for each test function in the namespace.<a id="filepos1729957"></a></p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1730061"></a><a href="#filepos1705756"><span class="calibre32">359</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">You can add your own special assertions to </span><span class="calibre10"><tt class="calibre22">is</tt></span><span class="calibre10"> too, by defining a new method for the </span><span class="calibre10"><tt class="calibre22">clojure.test/assert-expr</tt></span><span class="calibre10"> multimethod. See the documentation for the </span><span class="calibre10"><tt class="calibre22">clojure.test</tt></span><span class="calibre10"> namespace for details: </span><a href="http://clojure.github.com/clojure/clojure.test-api.html"><span class="calibre10"><span class="calibre5">http://clojure.github.com/clojure/clojure.test-api.html</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1730792"></a><a href="#filepos1710704"><span class="calibre32">360</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">You can think of this approach as a more structured version of Python’s </span><span class="calibre10"><tt class="calibre22">doctest</tt></span><span class="calibre10"> module or the Ruby corollary, </span><span class="calibre10"><tt class="calibre22">rubydoctest</tt></span><span class="calibre10">, with the commonality being the co-location of tests with the definition of the functions under test.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1731308"></a><a href="#filepos1713947"><span class="calibre32">361</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">We talk more about </span><span class="calibre10"><tt class="calibre22">ns-unmap</tt></span><span class="calibre10"> and other namespace introspection and manipulation functions in </span><a href="#filepos1134534"><span class="calibre10"><span class="calibre5">Defining and Using Namespaces</span></span></a><span class="calibre10"> and </span><a href="#filepos1464944"><span class="calibre10"><span class="calibre5">Introspecting namespaces</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1731895"></a><a href="#filepos1716439"><span class="calibre32">362</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">The unfortunate notation here indicates the call chain—</span><span class="calibre10"><tt class="calibre22">c</tt></span><span class="calibre10"> called </span><span class="calibre10"><tt class="calibre22">b</tt></span><span class="calibre10"> called </span><span class="calibre10"><tt class="calibre22">a</tt></span><span class="calibre10">—</span><span class="calibre10"><span class="italic">not</span></span><span class="calibre10"> a single call, that is, evaluating </span><span class="calibre10"><tt class="calibre22">(c b a)</tt></span><span class="calibre10"> will fail, since functions defined via </span><span class="calibre10"><tt class="calibre22">deftest</tt></span><span class="calibre10"> take no arguments, including the one named </span><span class="calibre10"><tt class="calibre22">c</tt></span><span class="calibre10"> above.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1732673"></a><a href="#filepos1728974"><span class="calibre32">363</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">There is technically no need to define fixtures in top-level vars; you could just as easily pass fixtures as function literals to </span><span class="calibre10"><tt class="calibre22">use-fixtures</tt></span><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos1733007" class="calibre6"><span class="calibre4"><span class="bold">Growing an HTML DSL</span></span></p><p id="filepos1733087" class="calibre18">As a live example of testing during development, let’s use tests to help us build a library to generate HTML. The result will be a simple-minded version of Hiccup <a id="filepos1733280"></a>(<a href="https://github.com/weavejester/hiccup"><span class="calibre5">https://github.com/weavejester/hiccup</span></a>), a library that produces HTML that mirrors the structure of defined or generated Clojure collections.</p><p class="calibre18">Our goal is to be able to write HTML snippets like this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">[:html<br class="calibre33"/> [:head [:title "Propaganda"]]<br class="calibre33"/> [:body [:p "Visit us at "<br class="calibre33"/>         [:a {:href "http://clojureprogramming.com"}<br class="calibre33"/>          "our website"]<br class="calibre33"/>         "."]]]</tt></span></blockquote><p class="calibre23">And compile them into HTML like this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">&lt;html&gt;<br class="calibre33"/>  &lt;head&gt;&lt;title&gt;Propaganda&lt;/title&gt;&lt;/head&gt;<br class="calibre33"/>  &lt;body&gt;<br class="calibre33"/>    &lt;p&gt;Visit us at &lt;a href="http://clojurebook.com"&gt;our website&lt;/a&gt;.&lt;/p&gt;<br class="calibre33"/>  &lt;/body&gt;<br class="calibre33"/>&lt;/html&gt;</tt></span></blockquote><p class="calibre23">Here, vectors <a id="filepos1734386"></a>(or really, any sequential collection) represent HTML elements where the first value is the element name, the second is an optional map of its attributes, and remaining values are the contents of the element, which can be either strings or additional vectors representing child elements.</p><p class="calibre18">Let’s write some tests to get started. We know that our eventual HTML-generating function is going to be pure; it’s going to accept some input, and produce some result without any external dependency or effect. We’d hate to have to write <tt class="calibre22">(is (= expected (ƒ input)))</tt> over and over; so, most of our tests will likely use <tt class="calibre22">are</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(deftest test-addition<br class="calibre33"/>  (are [x y z] (= x (+ y z))<br class="calibre33"/>    10 7 3<br class="calibre33"/>    20 10 10<br class="calibre33"/>    100 89 11))</tt></span></blockquote><p class="calibre23"><tt class="calibre22">are</tt> is a helper macro in <tt class="calibre22">clojure.test</tt> that templatizes assertions. For example, the <tt class="calibre22">are</tt> form above macroexpands into this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(do<br class="calibre33"/>  (clojure.test/is (= 10 (+ 7 3)))<br class="calibre33"/>  (clojure.test/is (= 20 (+ 10 10)))<br class="calibre33"/>  (clojure.test/is (= 100 (+ 89 11))))</tt></span></blockquote><p class="calibre23"><tt class="calibre22">are</tt> helps to minimize the repetition of each assertion, but we’ll still need to repeat the transformation, for example <tt class="calibre22">(= expected (ƒ input))</tt>. A short macro will help us avoid that as well:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defmacro are* [f &amp; body]<br class="calibre33"/>  `(are [x# y#] (~'= (~f x#) y#)<br class="calibre33"/>     ~@body))</tt></span></blockquote><p class="calibre23">Now we can write tests like this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(deftest test-tostring<br class="calibre33"/>  (are* str<br class="calibre33"/>    10 "10"<br class="calibre33"/>    :foo ":foo"<br class="calibre33"/>    "identity" "identity"))</tt></span></blockquote><p class="calibre23">Let’s assume we’ll have a function <tt class="calibre22">html</tt> that accepts a sequential collection and returns a string containing HTML. We’ll further assume a helper function <tt class="calibre22">attrs</tt><a id="filepos1736648"></a> that produces attribute strings for inclusion in HTML elements. We’ll implement those functions incrementally to match the expectations we codify in our tests.</p><p class="calibre18">These tests should be a sensible starting point:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(require 'clojure.string)<br class="calibre33"/><br class="calibre33"/>(declare html attrs)<br class="calibre33"/><br class="calibre33"/>(deftest test-html<br class="calibre33"/>  (are* html<br class="calibre33"/>    [:html]<br class="calibre33"/>    "&lt;html&gt;&lt;/html&gt;"<br class="calibre33"/><br class="calibre33"/>    [:a [:b]]<br class="calibre33"/>    "&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;"<br class="calibre33"/><br class="calibre33"/>    [:a {:href "/"} "Home"]<br class="calibre33"/>    "&lt;a href=\"/\"&gt;Home&lt;/a&gt;"<br class="calibre33"/><br class="calibre33"/>    [:div "foo" [:span "bar"] "baz"]<br class="calibre33"/>    "&lt;div&gt;foo&lt;span&gt;bar&lt;/span&gt;baz&lt;/div&gt;"))<br class="calibre33"/><br class="calibre33"/>(deftest test-attrs<br class="calibre33"/>  (are* (comp clojure.string/trim attrs)   </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>    nil ""<br class="calibre33"/><br class="calibre33"/>    {:foo "bar"}<br class="calibre33"/>    "foo=\"bar\""<br class="calibre33"/><br class="calibre33"/>    (sorted-map :a "b" :c "d")<br class="calibre33"/>    "a=\"b\" c=\"d\""))</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">We’re cheating a bit here; <tt class="calibre22">trim</tt> will allow us to ignore leading or trailing whitespace emitted by <tt class="calibre22">attrs</tt>, which we know ends up being handy for certain edge cases.</blockquote><p class="calibre18">Now for our code. A good first try:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn attrs<br class="calibre33"/>  [attr-map]<br class="calibre33"/>  (-&gt;&gt; attr-map<br class="calibre33"/>    (mapcat (fn [[k v]] [k " =\"" v "\""]))<br class="calibre33"/>    (apply str)))<br class="calibre33"/><br class="calibre33"/>(defn html<br class="calibre33"/>  [x]<br class="calibre33"/>  (if-not (sequential? x)<br class="calibre33"/>    (str x)<br class="calibre33"/>    (let [[tag &amp; body] x<br class="calibre33"/>          [attr-map body] (if (map? (first body))<br class="calibre33"/>                            [(first body) (rest body)]<br class="calibre33"/>                            [nil body])]<br class="calibre33"/>      (str "&lt;" (name tag) (attrs attr-map) "&gt;"<br class="calibre33"/>           (apply str (map html body))<br class="calibre33"/>           "&lt;/" (name tag) "&gt;"))))</tt></span></blockquote><p class="calibre23">Let’s see how it does with our tests.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(run-tests)<br class="calibre33"/>; Testing user<br class="calibre33"/>;<br class="calibre33"/>; FAIL in (test-html) (NO_SOURCE_FILE:6)<br class="calibre33"/>; expected: (= (html [:a {:href "/"} "Home"]) "&lt;a href=\"/\"&gt;Home&lt;/a&gt;")<br class="calibre33"/>;   actual: (not (= "&lt;a:href =\"/\"&gt;Home&lt;/a&gt;" "&lt;a href=\"/\"&gt;Home&lt;/a&gt;"))<br class="calibre33"/>;<br class="calibre33"/>; FAIL in (test-attrs) (NO_SOURCE_FILE:20)<br class="calibre33"/>; expected: (= ((comp clojure.string/trim attrs) {:foo "bar"}) "foo=\"bar\"")<br class="calibre33"/>;   actual: (not (= ":foo =\"bar\"" "foo=\"bar\""))<br class="calibre33"/>;<br class="calibre33"/>; FAIL in (test-attrs) (NO_SOURCE_FILE:20)<br class="calibre33"/>; expected: (= ((comp clojure.string/trim attrs)<br class="calibre33"/>;               (sorted-map :a "b" :c "d"))<br class="calibre33"/>;             "a=\"b\" c=\"d\"")<br class="calibre33"/>;   actual: (not (= ":a =\"b\":c =\"d\"" "a=\"b\" c=\"d\""))<br class="calibre33"/>;<br class="calibre33"/>; Ran 2 tests containing 7 assertions.<br class="calibre33"/>; 3 failures, 0 errors.<br class="calibre33"/>;= {:type :summary, :pass 4, :test 2, :error 0, :fail 3}</tt></span></blockquote><p class="calibre23">Oh no…what’s wrong? It looks like <tt class="calibre22">attrs</tt> might be the source of all the trouble. We have what look like Clojure keywords in our results, for example <tt class="calibre22">(attrs {:foo "bar"})</tt> is emitting <tt class="calibre22">":foo =\":bar\""</tt>. We should be calling <tt class="calibre22">name</tt> on those keywords to get a bare string for attribute names. Let’s fix that, along with the spurious space between attribute names and the <tt class="calibre22">=</tt> character:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn attrs<br class="calibre33"/>  [attrs]<br class="calibre33"/>  (-&gt;&gt; attrs<br class="calibre33"/>    (mapcat (fn [[k v]] [(name k) "=\"" v "\""]))<br class="calibre33"/>    (apply str)))</tt></span></blockquote><p class="calibre23">Now we can rerun just <tt class="calibre22">test-attrs</tt> to see how it works since we’re focused on fixing this <tt class="calibre22">attrs</tt> function:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(test-attrs)<br class="calibre33"/>; FAIL in (test-attrs) (NO_SOURCE_FILE:20)<br class="calibre33"/>; expected: (= ((comp clojure.string/trim attrs)<br class="calibre33"/>;               (sorted-map :a "b" :c "d"))<br class="calibre33"/>;             "a=\"b\" c=\"d\"")<br class="calibre33"/>;   actual: (not (= ":a =\"b\":c =\"d\"" "a=\"b\" c=\"d\""))</tt></span></blockquote><p class="calibre23">Better, but it looks like we forgot the space before each attribute. A simple fix:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn attrs<br class="calibre33"/>  [attrs]<br class="calibre33"/>  (-&gt;&gt; attrs<br class="calibre33"/>    (mapcat (fn [[k v]] [\space (name k) "=\"" v "\""]))<br class="calibre33"/>    (apply str)))</tt></span></blockquote><p class="calibre23">How are we doing now?</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(test-attrs)<br class="calibre33"/>;= nil<br class="calibre33"/>(run-tests)<br class="calibre33"/>; Testing user<br class="calibre33"/>;<br class="calibre33"/>; Ran 2 tests containing 7 assertions.<br class="calibre33"/>; 0 failures, 0 errors.<br class="calibre33"/>;= {:type :summary, :pass 7, :test 2, :error 0, :fail 0}</tt></span></blockquote><p class="calibre23">Excellent, it looks like we’ve got some clean code. Let’s see what it produces for our original example:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1742535"></a><a href="#filepos1744744"><span class="calibre32">364</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(html [:html<br class="calibre33"/>         [:head [:title "Propaganda"]]<br class="calibre33"/>         [:body [:p "Visit us at "<br class="calibre33"/>                 [:a {:href "http://clojurebook.com"}<br class="calibre33"/>                  "our website"]<br class="calibre33"/>                 "."]]])<br class="calibre33"/>;= "&lt;html&gt;<br class="calibre33"/>;=    &lt;head&gt;&lt;title&gt;Propaganda&lt;/title&gt;&lt;/head&gt;<br class="calibre33"/>;=    &lt;body&gt;<br class="calibre33"/>;=      &lt;p&gt;Visit us at &lt;a href=\"http://clojurebook.com\"&gt;our website&lt;/a&gt;.&lt;/p&gt;<br class="calibre33"/>;=    &lt;/body&gt;<br class="calibre33"/>;= &lt;/html&gt;"</tt></span></blockquote><p class="calibre23">The nice thing about a templating DSL like this is that, because HTML is represented by regular Clojure data structures end-to-end, we have all of the great facilities available for working with those data structures—and therefore HTML:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(html (list* :ul (for [author ["Chas Emerick" "Christophe Grand" "Brian Carper"]]<br class="calibre33"/>                   [:li author])))<br class="calibre33"/>;= "&lt;ul&gt;&lt;li&gt;Chas Emerick&lt;/li&gt;&lt;li&gt;Christophe Grand&lt;/li&gt;&lt;li&gt;Brian Carper&lt;/li&gt;&lt;/ul&gt;"</tt></span></blockquote><p class="calibre23">That’s a whole lot more attractive than using what typically passes for an API to an HTML DOM, or committing atrocities like putting strings of HTML into your code and interpolating data into them. In the realm of options for producing HTML in Clojure, solutions like this (where Hiccup is the canonical implementation) represent one extreme, whereas other options like Enlive (which we use in examples in <a href="#filepos1878886"><span class="calibre5">Chapter 16</span></a>) represent a more traditional model where HTML content generally starts life as a template asset that is then programmatically populated.<a id="filepos1744640"></a></p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1744744"></a><a href="#filepos1742535"><span class="calibre32">364</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">No, </span><span class="calibre10"><tt class="calibre22">html</tt></span><span class="calibre10"> doesn’t provide pretty-printing; we formatted out the string literal a bit so it would fit well on the page.</span></p><div class="mbppagebreak"></div><p id="filepos1745054" class="calibre6"><span class="calibre4"><span class="bold">Relying upon Assertions</span></span></p><p id="filepos1745138" class="calibre18">Our HTML generation functions are decent, but someone somewhere will inevitably attempt to abuse the API. For example, the Clojure-standard representation of XML (as produced by <span class="italic">clojure.xml</span>) looks like this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">{:tag :a, :attrs {:href "http://clojure.org"}, :content ["Clojure"]}</tt></span></blockquote><p class="calibre23">That’s quite different than our vector-based HTML representation. Unsurprisingly, <tt class="calibre22">html</tt> will do odd things with this map, since it’s not at all what it’s expecting:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(html {:tag :a, :attrs {:href "http://clojure.org"}, :content ["Clojure"]})<br class="calibre33"/>;= "{:content [\"Clojure\"], :attrs {:href \"http://clojure.org\"}, :tag :a}"</tt></span></blockquote><p class="calibre23">Cripes, it returns a string! That’s appropriate insofar as we somewhat lazily use <tt class="calibre22">html</tt> recursively to process the contents of element vectors, but this particular result is clearly not useful if we imagine a user that (perhaps reasonably) thinks she might be able to serialize a <span class="italic">clojure.xml</span> data structure to an HTML string using our <tt class="calibre22">html</tt> function. This is a situation where we’d like to fail as quickly as possible.</p><p class="calibre18">Enter assertions. Assertions test a condition and throw an error if the condition is not true:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn attrs<br class="calibre33"/>  [attrs]<br class="calibre33"/>  (assert (or (map? attr-map)                                    </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>              (nil? attr-map)) "attr-map must be nil, or a map")<br class="calibre33"/>  (-&gt;&gt; attrs<br class="calibre33"/>    (mapcat (fn [[k v]] [\space (name k) "=\"" v "\""]))<br class="calibre33"/>    (apply str)))<br class="calibre33"/><br class="calibre33"/>(attrs "hi")<br class="calibre33"/>;= #&lt;AssertionError java.lang.AssertionError:<br class="calibre33"/>;=   Assert failed: attr-map must be nil, or a map<br class="calibre33"/>;=   (or (map? attr-map) (nil? attr-map))&gt;</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">We’re using <tt class="calibre22">assert</tt> to verify the types of arguments, but it can be used anywhere in your code to enforce any invariant you can express.</blockquote><p class="calibre18">Because assertions throw an error, they may not be the best tool to use in production code, where you might not want to pay the runtime costs associated with verifying assertions. Clojure allows us to enable and disable assertions by setting the <tt class="calibre22">*assert*</tt> var <tt class="calibre22">true</tt> or <tt class="calibre22">false</tt>, respectively.</p><p class="calibre18">Because <tt class="calibre22">assert</tt> is a macro, <tt class="calibre22">*assert*</tt> should be set before you <span class="italic">compile</span> code that uses it. When <tt class="calibre22">*assert*</tt> is <tt class="calibre22">false</tt>, calls to <tt class="calibre22">assert</tt> will be elided from the compiled function entirely, yielding no runtime cost.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(set! *assert* false)    </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= false<br class="calibre33"/>(defn attrs<br class="calibre33"/>  [attr-map]<br class="calibre33"/>  (assert (or (map? attr-map)<br class="calibre33"/>              (nil? attr-map)) "attr-map must be nil, or a map")<br class="calibre33"/>  (-&gt;&gt; attr-map<br class="calibre33"/>    (mapcat (fn [[k v]] [\space (name k) "=\"" v "\""]))<br class="calibre33"/>    (apply str)))<br class="calibre33"/>;= #'user/attrs<br class="calibre33"/>(attrs "hi")<br class="calibre33"/>;= #&lt;UnsupportedOperationException java.lang.UnsupportedOperationException:<br class="calibre33"/>;=   nth not supported on this type: Character&gt;<br class="calibre33"/>(set! *assert* true)     </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= true</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">The state of <tt class="calibre22">*assert*</tt> can be set at any time: on a per-namespace basis, for your entire application based on a system property or environment variable, or, as we do here, at the REPL.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">We set <tt class="calibre22">*assert*</tt> back to <tt class="calibre22">true</tt> to support later examples.</blockquote><p class="calibre18"><tt class="calibre22">attrs</tt> above is compiled with assertions disabled, so we’re now getting much less helpful <tt class="calibre22">nth not supported on this type</tt> errors, due to the function passed to <tt class="calibre22">mapcat</tt> attempting to sequentially destructure the string’s characters. On the other hand, within an application that has been well-tested—perhaps using a mixture of assertions, unit tests, and functional testing—disabling assertions in production environments would eliminate the former’s runtime cost.</p><p id="filepos1750353" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Preconditions and Postconditions</span></span></span></p><p id="filepos1750475" class="calibre18">The two most common use cases for assertions are testing inputs and outputs to functions. Because of Clojure’s emphasis on the use of pure functions, many functions’ inputs and outputs may be all there really is to test.</p><p class="calibre18"><tt class="calibre22">fn</tt><a id="filepos1750770"></a> (and therefore derivatives like <tt class="calibre22">defn</tt>) has direct support for writing assertions to test inputs for <span class="italic">preconditions</span> and test output for <span class="italic">postconditions</span>. Preconditions are evaluated before the body of the function; postconditions are evaluated after the body of the function has been executed, but before the return value is delivered to the caller. If any condition evaluates logically false, then an error is thrown. This facility can be used to ensure that function arguments and return values meet defined criteria at runtime without cluttering the function body with checks and inconsistent throwing of exceptions while potentially reusing validation functionality across a codebase.</p><p class="calibre18">If the first value in the body of a Clojure function is a map with <tt class="calibre22">:pre</tt> or <tt class="calibre22">:post</tt> keys, this map is considered a map of pre- and/or postcondition expressions, and will be expanded to calls to <tt class="calibre22">assert</tt> when the function is compiled.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1751806"></a><a href="#filepos1756705"><span class="calibre32">365</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">The values for <tt class="calibre22">:pre</tt> and <tt class="calibre22">:post</tt> should be vectors, where each item in the vector is a separate assertion. Function parameters can be referred to in the preconditions. The value being returned from the function is bound to <tt class="calibre22">%</tt> in postconditions, similar to how the first argument in a function literal is denoted. Let’s recast our definition of <tt class="calibre22">attrs</tt> and <tt class="calibre22">html</tt> using reasonable pre- and postconditions:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn attrs<br class="calibre33"/>  [attr-map]<br class="calibre33"/>  {:pre [(or (map? attr-map)                                  </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>             (nil? attr-map))]}<br class="calibre33"/>  (-&gt;&gt; attr-map<br class="calibre33"/>    (mapcat (fn [[k v]] [\space (name k) "=\"" v "\""]))<br class="calibre33"/>    (apply str)))<br class="calibre33"/><br class="calibre33"/>(defn html<br class="calibre33"/>  [x]<br class="calibre33"/>  {:pre [(if (sequential? x)                                  </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>           (some #(-&gt; x first %) [keyword? symbol? string?])<br class="calibre33"/>           (not (map? x)))]                                   </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>   :post [(string? %)]}                                       </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  (if-not (sequential? x)<br class="calibre33"/>    (str x)<br class="calibre33"/>    (let [[tag &amp; body] x<br class="calibre33"/>          [attr-map body] (if (map? (first body))<br class="calibre33"/>                            [(first body) (rest body)]<br class="calibre33"/>                            [nil body])]<br class="calibre33"/>      (str "&lt;" (name tag) (attrs attr-map) "&gt;"<br class="calibre33"/>           (apply str (map html body))<br class="calibre33"/>           "&lt;/" (name tag) "&gt;"))))</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">As before, we’ll require that <tt class="calibre22">attrs</tt> will only accept <tt class="calibre22">nil</tt> or map arguments.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">The precondition for <tt class="calibre22">html</tt> is a little more complicated. If its argument is a sequential collection, its first argument must be a string, keyword, or symbol. Otherwise…</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">…it can be anything other than a map.</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">The postcondition for <tt class="calibre22">html</tt> only requires that its return value be a string. This could get a lot fancier here and do things like verify that the generated HTML parses cleanly, is compliant based on some DTD, and so on.</blockquote><p class="calibre18">These conditions will help flag some common errors. Looking back at the case where someone might use a <span class="italic">clojure.xml</span> element map to produce HTML using our function:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(html {:tag :a, :attrs {:href "http://clojure.org"}, :content ["Clojure"]})<br class="calibre33"/>;= #&lt;AssertionError java.lang.AssertionError:<br class="calibre33"/>;=   Assert failed: (if (sequential? x)<br class="calibre33"/>;=                    (some (fn* [p1__843#] (-&gt; x first p1__843#))<br class="calibre33"/>;=                          [keyword? symbol? string?])<br class="calibre33"/>;=                    (not (map? x)))&gt;</tt></span></blockquote><p class="calibre23">Note that pre- and postconditions compile down into <tt class="calibre22">assert</tt>s within the body of their host function. This means that conditions are affected by the state of <tt class="calibre22">*assert*</tt> in the same way, and that it is impossible to add, remove, or change a function’s conditions after it is compiled.<a id="filepos1756471"></a><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1756513"></a><a href="#filepos1757035"><span class="calibre32">366</span></a><span class="calibre32">]</span></small></sup></p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1756705"></a><a href="#filepos1751806"><span class="calibre32">365</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">If a map is the only expression in a function body, it is treated as the function’s return value, rather than a map of pre- and postconditions.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1757035"></a><a href="#filepos1756513"><span class="calibre32">366</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">One workaround for this is Trammel, a library focused on providing support for dynamic </span><span class="calibre10"><span class="italic">contracts programming</span></span><span class="calibre10"> in Clojure that uses conditions heavily along with record and type invariants to ensure program correctness: </span><a href="https://github.com/fogus/trammel"><span class="calibre10"><span class="calibre5">https://github.com/fogus/trammel</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos1757595" class="calibre6"><span class="calibre2"><span class="bold">Chapter 14. Using Relational Databases</span></span></p><p id="filepos1757696" class="calibre13">Relational databases are a mainstay of software development, and have been for decades now. It is a rare organization that does not use an RDBMS somewhere, and a rare programmer that does not find herself needing to get data in and out of one at least occasionally. Java has a rich history of quality support for relational databases via JDBC; thanks to its close relationship via the JVM, Clojure easily and fully takes advantage of that history.</p><p class="calibre18">We have many options for interacting with relational databases from Clojure. <tt class="calibre22">clojure.java.jdbc</tt> is a simple yet powerful library that acts as a thin layer between Clojure and JDBC. Korma is another Clojure library that provides a more Clojure-native interface. And finally, if Clojure’s libraries do not suit your style or if you are looking to mix Clojure into an existing Java-based application, you can always fall back to one of the many mature and robust Java database libraries or frameworks. In this chapter, we’ll explore setting up and using Hibernate from Clojure.</p><p id="filepos1758793" class="calibre6"><span class="calibre4"><span class="bold">clojure.java.jdbc</span></span></p><p id="filepos1758871" class="calibre18">Whether you use a native Java library or one of Clojure’s many libraries, connecting to a database in Clojure will always utilize JDBC, the lowest-level API abstraction for interacting with relational databases in Java. The <tt class="calibre22">clojure.java.jdbc</tt> (<a href="https://github.com/clojure/java.jdbc"><span class="calibre5">https://github.com/clojure/java.jdbc</span></a>) library wraps JDBC, so it is easier to use from Clojure:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">[org.clojure/java.jdbc "0.1.1"]</tt></span></blockquote><p class="calibre23">In terms of dependencies,<a id="filepos1759497"></a> you need to pair JDBC and <tt class="calibre22">clojure.java.jdbc</tt> with a JDBC driver corresponding with the database you are using. There are hundreds of JDBC drivers for nearly every database in existence, so finding one for your needs should be easy enough. Here are some Leiningen coordinates for JDBC drivers for popular databases:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">[org.xerial/sqlite-jdbc "3.7.2"]          ; SQLite<br class="calibre33"/>[mysql/mysql-connector-java "2.0.14"]     ; MySQL<br class="calibre33"/>[postgresql "9.0-801.jdbc4"]              ; PostgreSQL</tt></span></blockquote><p class="calibre23">All our examples will use the SQLite <a id="filepos1760183"></a>(<a href="http://sqlite.org"><span class="calibre5">http://sqlite.org</span></a>) driver. Since SQLite is an “embedded” database—that is, the database engine runs in-process, with database files stored wherever you specify, rather than connecting to a potentially remote database server—all the code we show will work without having to set up and run a separate database. Thanks to the abstraction provided by JDBC, only minimal modifications would be required to use the same code with MySQL, PostgreSQL, Oracle, and others.</p><p class="calibre18">With <tt class="calibre22">clojure.java.jdbc</tt> and the <tt class="calibre22">org.xerial/sqlite-jdbc</tt> JDBC driver (<a href="http://www.xerial.org/trac/Xerial/wiki/SQLiteJDBC"><span class="calibre5">http://www.xerial.org/trac/Xerial/wiki/SQLiteJDBC</span></a>) library added to a project, we can dig into working with a database from the Clojure REPL.</p><p class="calibre18">All <tt class="calibre22">clojure.java.jdbc</tt> operations require a “spec” to operate:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(require '[clojure.java.jdbc :as jdbc])<br class="calibre33"/>;= nil<br class="calibre33"/>(def db-spec {:classname "org.sqlite.JDBC"<br class="calibre33"/>              :subprotocol "sqlite"<br class="calibre33"/>              :subname "test.db"})<br class="calibre33"/>;= #'user/db</tt></span></blockquote><p class="calibre23">Here, <tt class="calibre22">db-spec</tt> is a map of configuration data that <tt class="calibre22">clojure.java.jdbc</tt> will use to:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">Locate our JDBC driver (via the <tt class="calibre22">:classname</tt> value).</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Configure that driver and the connections it produces as we require.</blockquote></li></ol><p class="calibre18">Each JDBC driver will require a slightly different spec. For example, the spec for a MySQL session may look similar to this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">{:classname "com.mysql.jdbc.Driver"<br class="calibre33"/> :subprotocol "mysql"<br class="calibre33"/> :subname "//localhost:3306/databasename"<br class="calibre33"/> :username "login"<br class="calibre33"/> :password "password"}</tt></span></blockquote><p class="calibre23">Alternatively, <tt class="calibre22">clojure.java.jdbc</tt> specs may be created to specify a <tt class="calibre22">javax.sql.DataSource</tt> directly:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">{:datasource datasource-instance<br class="calibre33"/> :username "login"<br class="calibre33"/> :password "password"}</tt></span></blockquote><p class="calibre23">…find one via JNDI:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">{:name "java:/comp/env/jdbc/postgres"<br class="calibre33"/> :environment {}} ; optional JNDI parameters for initializing <br class="calibre33"/>   javax.naming.InitialContext</tt></span></blockquote><p class="calibre23">…or, for many popular databases,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1763138"></a><a href="#filepos1780887"><span class="calibre32">367</span></a><span class="calibre32">]</span></small></sup> you can dispense with the map convention and provide a URI-style connection string like this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">"mysql://login:password@localhost:3306/databasename"</tt></span></blockquote><p class="calibre23">If you are already familiar with JDBC, any of these methods should seem familiar; deriving an appropriate URI connection string or database spec from a JDBC-style connection string should be trivial.</p><p class="calibre18">Once you have your database spec settled, you can start using the <tt class="calibre22">clojure.java.jdbc</tt> API:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(jdbc/with-connection db-spec)<br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre23"><tt class="calibre22">with-connection</tt> is used to open a connection to our database. With no further body provided to <tt class="calibre22">with-connection</tt>, a connection will be opened and immediately closed; this is a useful sanity-check at the REPL, as an incorrect username, password, or database URL will result in an exception.</p><p class="calibre18">All expressions within the scope of <tt class="calibre22">with-connection</tt> are executed in the context of a live, open database connection. The connection is closed or freed automatically when control exits that scope.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1764556"></a><a href="#filepos1781174"><span class="calibre32">368</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">We can use <tt class="calibre22">create-table</tt> to create a table named “authors” and define a couple of columns. Keywords or strings can be used for table and column names; the latter are most appropriate for table/column names containing characters that cannot be represented as keyword literals:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(jdbc/with-connection db-spec<br class="calibre33"/>  (jdbc/create-table :authors<br class="calibre33"/>    [:id "integer primary key"]<br class="calibre33"/>    [:first_name "varchar"]<br class="calibre33"/>    [:last_name "varchar"]))<br class="calibre33"/>;= (0)</tt></span></blockquote><p class="calibre23"><tt class="calibre22">insert-records</tt><a id="filepos1765323"></a> is a simple function that inserts data into the database, returning a seq of maps containing the keys generated for each inserted record. Keys in the maps correspond to columns in our table:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(jdbc/with-connection db-spec<br class="calibre33"/>  (jdbc/insert-records :authors<br class="calibre33"/>    {:first_name "Chas" :last_name "Emerick"}<br class="calibre33"/>    {:first_name "Christophe" :last_name "Grand"}<br class="calibre33"/>    {:first_name "Brian" :last_name "Carper"}))<br class="calibre33"/>;= ({:last_insert_rowid() 1}<br class="calibre33"/>;=  {:last_insert_rowid() 2}<br class="calibre33"/>;=  {:last_insert_rowid() 3})</tt></span></blockquote><p class="calibre23"><tt class="calibre22">with-query-results</tt><a id="filepos1766043"></a> is used to fetch data from the database. The use of <tt class="calibre22">doall</tt> here is important; we’ll explain it in detail shortly, in <a href="#filepos1770317"><span class="calibre5">“Dealing with laziness”</span></a>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(jdbc/with-connection db-spec<br class="calibre33"/>  (jdbc/with-query-results res ["SELECT * FROM authors"]<br class="calibre33"/>    (doall res)))<br class="calibre33"/>;= ({:id 1, :first_name "Chas", :last_name "Emerick"}<br class="calibre33"/>;=  {:id 2, :first_name "Christophe", :last_name "Grand"}<br class="calibre33"/>;=  {:id 3, :first_name "Brian", :last_name "Carper"})</tt></span></blockquote><p class="calibre23">Note that throughout this example, we’re dealing exclusively with native Clojure data types. Table and column names are keywords; database handles are maps; maps are used to insert data into the database, and querying the database returns a seq of maps. This fits with Clojure’s design philosophy of having a few generic data types with many functions that operate on them.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1767130"></a><a href="#filepos1781932"><span class="calibre32">369</span></a><span class="calibre32">]</span></small></sup> Accessing fields in each row of the result set is a simple keyword lookup in a map. For example, we can produce the full name of each author in the table via a simple <tt class="calibre22">map</tt>.</p><p id="filepos1767410" class="calibre23"></p><p class="calibre23"><span class="italic">Example 14-1. Transforming a result set using map</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(jdbc/with-connection db-spec<br class="calibre33"/>  (jdbc/with-query-results res ["SELECT * FROM authors"]<br class="calibre33"/>    (doall (map #(str (:first_name %) " " (:last_name %)) res))))<br class="calibre33"/>;= ("Chas Emerick" "Christophe Grand" "Brian Carper")</tt></span></p><p class="calibre13">You can apply any of the facilities available to you in Clojure to processing result sets.</p><p id="filepos1767974" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">with-query-results Explained</span></span></span></p><p class="calibre18"><tt class="calibre22">with-query-results</tt><a id="filepos1768147"></a> is the primary way you’ll get data out of your database. <tt class="calibre22">(with-query-results res query &amp; body)</tt> will execute the <tt class="calibre22">query</tt> within the database, and then evaluate <tt class="calibre22">body</tt> where the query’s result set is bound to a local called <tt class="calibre22">res</tt>. The result set itself is a lazy sequence of Clojure maps.</p><p class="calibre18"><tt class="calibre22">with-query-results</tt> supports <span class="italic">parameterized queries</span><a id="filepos1768576"></a>, a common feature of SQL libraries where string query templates contain placeholders for query parameters that are provided separately and then interpolated by the database. Parameterized queries promote query reuse, which can increase the performance of queries that are run multiple times, and are also a boon to security compared to the dangerous equivalent: building queries via string concatenation, thereby opening the door to SQL injection attacks.</p><p class="calibre18">Queries should be a vector where the first item is a string of SQL, and subsequent values correspond to each parameter placeholder in the string query. For example:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(jdbc/with-connection db-spec<br class="calibre33"/>  (jdbc/with-query-results res ["SELECT * FROM authors WHERE id = ?" 2]  </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>    (doall res)))<br class="calibre33"/>;= ({:id 2, :first_name "Christophe", :last_name "Grand"})</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">?</tt> in the query represents a parameter, and <tt class="calibre22">2</tt> is the value we bind to this parameter.</blockquote><p class="calibre18">Note that the types of the values you provide to be bound to parameters isn’t of critical importance. Clojure being a dynamic language, the values you provide will be interpolated into the base SQL statement as appropriate. If you pass in a value of an unacceptable type (e.g., a type your JDBC driver is unable to coerce into the proper type), JDBC will throw an exception.</p><p id="filepos1770317" class="calibre18"><span class="bold">Dealing with laziness</span>. You may have noted the use of <tt class="calibre22">doall</tt><a id="filepos1770420"></a> in conjunction with <tt class="calibre22">with-query-results</tt>. The result set <a id="filepos1770492"></a>returned by <tt class="calibre22">with-query-results</tt> is a lazy sequence,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1770593"></a><a href="#filepos1782256"><span class="calibre32">370</span></a><span class="calibre32">]</span></small></sup> each record within it is realized only as it is needed. This means that we can process positively huge datasets returned by queries without necessarily running into resource limitations, but we need to tread carefully, since the source of that data is a transient database connection. Consider this seemingly straightforward example:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(jdbc/with-connection db-spec<br class="calibre33"/>  (jdbc/with-query-results res ["SELECT * FROM authors"]<br class="calibre33"/>    res))<br class="calibre33"/>;= ({:id 1, :first_name "Chas", :last_name "Emerick"})</tt></span></blockquote><p class="calibre23">Whoa, that query only returned one row when we should expect three. The problem is that <tt class="calibre22">with-query-results</tt> returns <tt class="calibre22">res</tt>, our lazy result set, without evaluating it. The REPL eventually tries to print the lazy seq, which finally forces evaluation of its contents. But now it’s too late: the database handle has been closed (because we have left the scope of <tt class="calibre22">with-connection</tt>) and we end up seeing incomplete (or no) results.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1771813"></a><a href="#filepos1782554"><span class="calibre32">371</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">The solution is to consume everything we need from the result set while the connection to the database is still alive. Certain operations, like <tt class="calibre22">reduce</tt>, will implicitly force the realization of the result set seq; transforming the result set seq using other operations that produce lazy seqs will themselves need to be wrapped in a call to <tt class="calibre22">doall</tt>, as we did in <a href="#filepos1767410"><span class="calibre5">Example 14-1</span></a>.</p><p class="calibre18">If all we want is to run a query and fetch the results in their entirety, we can easily set up a utility function to do this for us:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn fetch-results [db-spec query]<br class="calibre33"/>  (jdbc/with-connection db-spec<br class="calibre33"/>    (jdbc/with-query-results res query<br class="calibre33"/>      (doall res))))<br class="calibre33"/>;= #'user/fetch-results<br class="calibre33"/>(fetch-results db-spec ["SELECT * FROM authors"])<br class="calibre33"/>;= ({:id 1, :first_name "Chas", :last_name "Emerick"}<br class="calibre33"/>;=  {:id 2, :first_name "Christophe", :last_name "Grand"}<br class="calibre33"/>;=  {:id 3, :first_name "Brian", :last_name "Carper"})</tt></span></blockquote><p id="filepos1773112" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Transactions</span></span></span></p><p id="filepos1773214" class="calibre18">Performing database operations as a single transaction is a simple matter of wrapping your code in a <tt class="calibre22">transaction</tt> form. <tt class="calibre22">transaction</tt> accepts any number of forms and executes each in turn as part of a single transaction. If an exception is thrown, or if the operation(s) performed will violate a constraint established in your database schema, the transaction will be rolled back. If the body of <tt class="calibre22">transaction</tt> finishes executing without error, the transaction is committed.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(jdbc/with-connection db-spec<br class="calibre33"/>  (jdbc/transaction<br class="calibre33"/>    (jdbc/delete-rows :authors ["id = ?" 1])<br class="calibre33"/>    (throw (Exception. "Abort transaction!"))))         </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= ; Exception Abort transaction!<br class="calibre33"/>(fetch-results ["SELECT * FROM authors where id = ?" 1])<br class="calibre33"/>;= ({:id 1, :first_name "Chas", :last_name "Emerick"})        </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Here we throw an exception to forcibly abort our transaction.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">Data in our database is untouched.</blockquote><p class="calibre18"><tt class="calibre22">transaction</tt> is a macro that handles the minutiae of starting a transaction and ensuring the transaction is rolled back in the case of an exception. It also handles the drudgery of disabling autocommit on your JDBC connection object if necessary, restoring its original value when the <tt class="calibre22">transaction</tt> form’s evaluation is complete.</p><p class="calibre18">Suppose we wanted to set the transaction isolation level of our connection to <tt class="calibre22">TRANSACTION_SERIALIZABLE</tt>. <tt class="calibre22">clojure.java.jdbc</tt> doesn’t directly support this, but thanks to Clojure’s dynamic nature, good Java interop support, and philosophy of avoiding data-hiding, we can still do it.</p><p class="calibre18"><tt class="calibre22">TRANSACTION_SERIALIZABLE</tt><a id="filepos1775580"></a> itself is a static member in the <tt class="calibre22">java.sql.Connection</tt> class, so it can be referenced in Clojure as <tt class="calibre22">java.sql.Connection/TRANSACTION_SERIALIZABLE</tt>. We can access the dynamically bound current connection within the scope of <tt class="calibre22">with-connection</tt> via <tt class="calibre22">clojure.java.jdbc</tt>’s <tt class="calibre22">connection</tt> function. Knowing this, we can set our transaction isolation level like so:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(jdbc/with-connection db-spec<br class="calibre33"/>  (.setTransactionIsolation (jdbc/connection) <br class="calibre33"/>    java.sql.Connection/TRANSACTION_SERIALIZABLE)<br class="calibre33"/>  (jdbc/transaction<br class="calibre33"/>    (jdbc/delete-rows :authors ["id = ?" 2])))</tt></span></blockquote><p id="filepos1776310" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Connection Pooling</span></span></span></p><p class="calibre18"><tt class="calibre22">with-connection</tt><a id="filepos1776470"></a> is easy to use, but by default it opens and closes a new database connection every time it’s called. This is straightforward, but can be a big bottleneck.</p><p class="calibre18">Connection pooling is a means of creating a cache of database connections that can be reused over and over again. Many application servers provide <tt class="calibre22">DataSource</tt>-based connection pooling,<a id="filepos1776858"></a> often addressable via JNDI. If you aren’t using an application server, you’ll likely want to use c3p0 (<a href="http://www.mchange.com/projects/c3p0"><span class="calibre5">http://www.mchange.com/projects/c3p0</span></a>), one popular lightweight connection pooling library that can be deployed in any context:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">[c3p0/c3p0 "0.9.1.2"]</tt></span></blockquote><p class="calibre23">With c3p0 added as a dependency in our project, we can easily set up a simple function to take a map-style database spec and return a <tt class="calibre22">DataSource</tt> that is backed by a c3p0 connection pool:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(import 'com.mchange.v2.c3p0.ComboPooledDataSource)<br class="calibre33"/>; Feb 05, 2011 2:26:40 AM com.mchange.v2.log.MLog &lt;clinit&gt;<br class="calibre33"/>; INFO: MLog clients using java 1.4+ standard logging.<br class="calibre33"/>;= com.mchange.v2.c3p0.ComboPooledDataSource<br class="calibre33"/><br class="calibre33"/>(defn pooled-spec<br class="calibre33"/>  [{:keys [classname subprotocol subname username password] :as other-spec}]<br class="calibre33"/>  (let [cpds (doto (ComboPooledDataSource.)                                   </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>                     (.setDriverClass classname)<br class="calibre33"/>                     (.setJdbcUrl (str "jdbc:" subprotocol ":" subname))<br class="calibre33"/>                     (.setUser username)<br class="calibre33"/>                     (.setPassword password))]<br class="calibre33"/>    {:datasource cpds}))</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">c3p0’s <tt class="calibre22">ComboPooledDataSource</tt> is a <tt class="calibre22">DataSource</tt> (Java’s standard interface for any database connection source), so it can be used without modification with <tt class="calibre22">with-connection</tt>.</blockquote><p class="calibre18">Connections will be initialized when first used, and then retained (based on the configuration of the pool) for use by subsequent calls to <tt class="calibre22">with-connection</tt>.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def pooled-db (pooled-spec db-spec))<br class="calibre33"/>; Dec 27, 2011 8:49:28 AM com.mchange.v2.c3p0.C3P0Registry banner<br class="calibre33"/>; INFO: Initializing c3p0-0.9.1.2 [built 21-May-2007 15:04:56; debug? true; trace: 10]<br class="calibre33"/>;= #'user/pooled-db<br class="calibre33"/><br class="calibre33"/>(fetch-results pooled-db ["SELECT * FROM authors"])<br class="calibre33"/>; Dec 27, 2011 8:56:40 AM com.mchange.v2.c3p0.impl.AbstractPoolBackedDataSource <br class="calibre33"/>  getPoolManager<br class="calibre33"/>; INFO: Initializing c3p0 pool... com.mchange.v2.c3p0.ComboPooledDataSource<br class="calibre33"/>; [ acquireIncrement -&gt; 3, acquireRetryAttempts -&gt; 30, acquireRetryDelay -&gt; 1000, ...<br class="calibre33"/>;= ({:id 1, :first_name "Chas", :last_name "Emerick"}<br class="calibre33"/>;=  {:id 2, :first_name "Christophe", :last_name "Grand"}<br class="calibre33"/>;=  {:id 3, :first_name "Brian", :last_name "Carper"})<br class="calibre33"/><br class="calibre33"/>(fetch-results pooled-db ["SELECT * FROM authors"])<br class="calibre33"/>;= ({:id 1, :first_name "Chas", :last_name "Emerick"}<br class="calibre33"/>;=  {:id 2, :first_name "Christophe", :last_name "Grand"}<br class="calibre33"/>;=  {:id 3, :first_name "Brian", :last_name "Carper"})</tt></span></blockquote><p class="calibre23">The second query will reuse the same connection as the first (as is hinted by the lack of initialization logging on the second <tt class="calibre22">fetch-results</tt> call). c3p0’s default configuration is suitable for many applications, but we recommend taking advantage of the plethora of configuration options it offers in your local implementation of <tt class="calibre22">pooled-spec</tt> so as to maximize throughput.<a id="filepos1780783"></a></p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1780887"></a><a href="#filepos1763138"><span class="calibre32">367</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">As of this writing, a connection string may be used with PostgreSQL, MySQL, SQLite, HSQLDB, and Derby.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1781174"></a><a href="#filepos1764556"><span class="calibre32">368</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">A common idiom in Clojure, this is just one example of automatic resource management. You will find many similar </span><span class="calibre10"><tt class="calibre22">with-*</tt></span><span class="calibre10"> functions for opening and closing file handles, network connections, and so on. See </span><a href="#filepos1315176"><span class="calibre10"><span class="calibre5">with-open, finally’s Lament</span></span></a><span class="calibre10"> for a discussion of </span><span class="calibre10"><tt class="calibre22">with-open</tt></span><span class="calibre10">, the most commonly used </span><span class="calibre10"><tt class="calibre22">with-*</tt></span><span class="calibre10"> function in Clojure.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1781932"></a><a href="#filepos1767130"><span class="calibre32">369</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Perlis is relevant here, see </span><a href="#filepos337805"><span class="calibre10"><span class="calibre5">Abstractions over Implementations</span></span></a></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1782256"></a><a href="#filepos1770593"><span class="calibre32">370</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="#filepos368238"><span class="calibre10"><span class="calibre5">Lazy seqs</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1782554"></a><a href="#filepos1771813"><span class="calibre32">371</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Other JDBC drivers will throw an exception when you attempt to read data from a closed connection; the SQLite driver appears to prefetch the first row for us, thus the single-row result.</span></p><div class="mbppagebreak"></div><p id="filepos1782878" class="calibre6"><span class="calibre4"><span class="bold">Korma</span></span></p><p class="calibre18">Korma<a id="filepos1782977"></a> (<a href="http://sqlkorma.com"><span class="calibre5">http://sqlkorma.com</span></a>) is an up-and-coming domain-specific language for working with relational databases in Clojure. It aims to provide a “batteries included” and Clojure-native database interaction experience; to that end, it takes care of generating SQL for many different popular databases, and handles administrative tasks like managing connection pooling via c3p0. For those familiar with Ruby’s ActiveRecord or a similar object-relational mapper, Korma should seem familiar, although it is decidedly not an Object-Relational Mapping framework.</p><p class="calibre18">To use Korma, we need to first add a dependency for it to our project:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">[korma "0.3.0"]</tt></span></blockquote><p id="filepos1783806" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Prelude</span></span></span></p><p id="filepos1783903" class="calibre18">Let’s set up some tables and insert some data to work with, using <tt class="calibre22">clojure.java.jdbc</tt>.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(require '[clojure.java.jdbc :as jdbc])<br class="calibre33"/><br class="calibre33"/>(def db-spec {:classname "org.sqlite.JDBC"<br class="calibre33"/>              :subprotocol "sqlite"<br class="calibre33"/>              :subname "test.db"})<br class="calibre33"/><br class="calibre33"/>(defn setup<br class="calibre33"/>  []<br class="calibre33"/>  (jdbc/with-connection db-spec<br class="calibre33"/>    (jdbc/create-table :country<br class="calibre33"/>                       [:id "integer primary key"]<br class="calibre33"/>                       [:country "varchar"])<br class="calibre33"/>    (jdbc/create-table :author<br class="calibre33"/>                       [:id "integer primary key"]<br class="calibre33"/>                       [:country_id "integer constraint fk_country_id <br class="calibre33"/>                                     references country (id)"]<br class="calibre33"/>                       [:first_name "varchar"]<br class="calibre33"/>                       [:last_name "varchar"])<br class="calibre33"/>    (jdbc/insert-records :country<br class="calibre33"/>                         {:id 1 :country "USA"}<br class="calibre33"/>                         {:id 2 :country "Canada"}<br class="calibre33"/>                         {:id 3 :country "France"})<br class="calibre33"/>    (jdbc/insert-records :author<br class="calibre33"/>                         {:first_name "Chas" :last_name "Emerick" :country_id 1}<br class="calibre33"/>                         {:first_name "Christophe" :last_name "Grand" :country_id 3}<br class="calibre33"/>                         {:first_name "Brian" :last_name "Carper" :country_id 2}<br class="calibre33"/>                         {:first_name "Mark" :last_name "Twain" :country_id 1})))<br class="calibre33"/><br class="calibre33"/>(setup)<br class="calibre33"/>;= ({:id 1, :country_id 1, :first_name "Chas", :last_name "Emerick"}<br class="calibre33"/>;=  {:id 2, :country_id 3, :first_name "Christophe", :last_name "Grand"}<br class="calibre33"/>;=  {:id 3, :country_id 2, :first_name "Brian", :last_name "Carper"}<br class="calibre33"/>;=  {:id 4, :country_id 1, :first_name "Mark", :last_name "Twain"})</tt></span></blockquote><p class="calibre23">Our tables are defined as having a many-to-one relationship <a id="filepos1786423"></a>between authors and countries. Setting up Korma to use our database is easy:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(use '[korma db core])<br class="calibre33"/>(defdb korma-db db-spec)</tt></span></blockquote><p class="calibre23"><tt class="calibre22">defdb</tt><a id="filepos1786693"></a> defines a connection that Korma can use; this command accepts the same arguments as the connection maps we pass to <tt class="calibre22">clojure.java.jdbc</tt>, so we reuse our <tt class="calibre22">db</tt> map here.</p><p class="calibre18">The <tt class="calibre22">defdb</tt> form evaluated most recently is set as the “default” connection, which will be used for all queries. This is handy if you have only one database to connect to, which covers the majority of use cases. <tt class="calibre22">defdb</tt> also helpfully sets up a connection pool for your database connection, letting you avoid the bookwork of doing it manually.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1787309"></a><a href="#filepos1798244"><span class="calibre32">372</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">The next step to set up Korma is to define <span class="italic">entities</span>, which are specifications to tell Korma the properties of your database tables. Entities are similar to “models” in Ruby’s ActiveRecord. Our entities might look like this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(declare author)<br class="calibre33"/><br class="calibre33"/>(defentity country<br class="calibre33"/>  (pk :id)<br class="calibre33"/>  (has-many author))<br class="calibre33"/><br class="calibre33"/>(defentity author<br class="calibre33"/>  (pk :id)<br class="calibre33"/>  (table :author)<br class="calibre33"/>  (belongs-to country))</tt></span></blockquote><p class="calibre23"><tt class="calibre22">defentity</tt> defines, among other things, the relationship between our tables in the database.</p><p id="filepos1788119" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Queries</span></span></span></p><p id="filepos1788216" class="calibre18">Having defined our table relationships, queries are straightforward:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(select author<br class="calibre33"/>  (with country)<br class="calibre33"/>  (where {:first_name "Chas"}))<br class="calibre33"/>;= [{:id 1, :country_id 1, :first_name "Chas", <br class="calibre33"/>     :last_name "Emerick", :id_2 1, :country "USA"}]</tt></span></blockquote><p class="calibre23">Korma’s <tt class="calibre22">select</tt><a id="filepos1788671"></a> macro is a DSL for doing SQL <tt class="calibre22">SELECT</tt> queries. <tt class="calibre22">select</tt> accepts a variety of functions that can be used to build queries. The <tt class="calibre22">with</tt><a id="filepos1788832"></a> function we use here, for example, tells Korma to include a relation, which we previously defined with <tt class="calibre22">defentity</tt>. Note the <tt class="calibre22">country</tt> key/value pair included in our results.</p><p class="calibre18">A more complex query:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(select author<br class="calibre33"/>  (with country)<br class="calibre33"/>  (where (like :first_name "Ch%"))<br class="calibre33"/>  (order :last_name :asc)<br class="calibre33"/>  (limit 1)<br class="calibre33"/>  (offset 1))<br class="calibre33"/>;= [{:id 2, :country_id 3, :first_name "Christophe", <br class="calibre33"/>     :last_name "Grand", :id_2 3, :country "France"}]</tt></span></blockquote><p class="calibre23"><tt class="calibre22">order</tt>, <tt class="calibre22">limit</tt>, and <tt class="calibre22">offset</tt> are straightforward representations of corresponded SQL clauses. More interesting is the <tt class="calibre22">where</tt><a id="filepos1789667"></a> function, which is itself a miniature DSL for building SQL <tt class="calibre22">WHERE</tt> clauses. <tt class="calibre22">where</tt> can handle fairly complex conditions:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(select author<br class="calibre33"/>     (fields :first_name :last_name)<br class="calibre33"/>     (where (or (like :last_name "C%")<br class="calibre33"/>                (= :first_name "Mark"))))<br class="calibre33"/>;= [{:first_name "Brian", :last_name "Carper"}<br class="calibre33"/>;=  {:first_name "Mark", :last_name "Twain"}]</tt></span></blockquote><p class="calibre23">If we’d like to take a look under the hood to see the raw SQL produced by Korma, we can use the <tt class="calibre22">sql-only</tt> function:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(println (sql-only (select author<br class="calibre33"/>                     (with country)<br class="calibre33"/>                     (where (like :first_name "Ch%"))<br class="calibre33"/>                     (order :last_name :asc)<br class="calibre33"/>                     (limit 1)<br class="calibre33"/>                     (offset 1))))<br class="calibre33"/>;= ; SELECT "author".* FROM "author" LEFT JOIN "country"<br class="calibre33"/>;= ; ON "country"."id" = "author"."country_id"<br class="calibre33"/>;= ; WHERE "author"."first_name" LIKE ?<br class="calibre33"/>;= ; ORDER BY "author"."last_name" ASC LIMIT 1 OFFSET 1</tt></span></blockquote><p id="filepos1791091" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Why Bother with a DSL?</span></span></span></p><p id="filepos1791203" class="calibre18">Of course, you could run SQL queries from Clojure via strings of raw SQL statements. This is exactly what <tt class="calibre22">clojure.java.jdbc</tt> requires you to do, in fact. But there are advantages to Korma’s approach.</p><p class="calibre18">A string of SQL is structureless, and manipulating such a string is difficult. Given <tt class="calibre22">SELECT * FROM foo ORDER BY bar</tt>, how would you alter this query to select something other than <tt class="calibre22">*</tt>? How would you add a <tt class="calibre22">WHERE</tt> clause? We would most likely need a full SQL parser.</p><p class="calibre18">Instead of structureless strings, Korma represents queries as simple Clojure maps. In fact, we can build these queries ourselves piece by piece, using <tt class="calibre22">select*</tt> instead of <tt class="calibre22">select</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def query (-&gt; (select* author)<br class="calibre33"/>             (fields :last_name :first_name)<br class="calibre33"/>             (limit 5)))<br class="calibre33"/>;= #'user/query</tt></span></blockquote><p class="calibre23">Let’s see what that <tt class="calibre22">query</tt> map looks like:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">{:group [],<br class="calibre33"/> :from<br class="calibre33"/> [{:table "author",<br class="calibre33"/>   :name "author",<br class="calibre33"/>   :pk :id,<br class="calibre33"/>   :db nil,<br class="calibre33"/>   :transforms (),<br class="calibre33"/>   :prepares (),<br class="calibre33"/>   :fields [],<br class="calibre33"/>   :rel<br class="calibre33"/>   {"country"<br class="calibre33"/>    #&lt;Delay@54f690e4:<br class="calibre33"/>      {:table "country",<br class="calibre33"/>       :alias nil,<br class="calibre33"/>       :rel-type :belongs-to,<br class="calibre33"/>       :pk {:korma.sql.utils/generated "\"country\".\"id\""},<br class="calibre33"/>       :fk<br class="calibre33"/>       {:korma.sql.utils/generated "\"author\".\"country_id\""}}&gt;}}],<br class="calibre33"/> :joins [],<br class="calibre33"/> :where [],<br class="calibre33"/> :ent<br class="calibre33"/> {:table "author",<br class="calibre33"/>  :name "author",<br class="calibre33"/>  :pk :id,<br class="calibre33"/>  :db nil,<br class="calibre33"/>  :transforms (),<br class="calibre33"/>  :prepares (),<br class="calibre33"/>  :fields [],<br class="calibre33"/>  :rel<br class="calibre33"/>  {"country"<br class="calibre33"/>   #&lt;Delay@54f690e4:<br class="calibre33"/>     {:table "country",<br class="calibre33"/>      :alias nil,<br class="calibre33"/>      :rel-type :belongs-to,<br class="calibre33"/>      :pk {:korma.sql.utils/generated "\"country\".\"id\""},<br class="calibre33"/>      :fk {:korma.sql.utils/generated "\"author\".\"country_id\""}}&gt;}},<br class="calibre33"/> :limit 5,<br class="calibre33"/> :type :select,<br class="calibre33"/> :alias nil,<br class="calibre33"/> :options nil,<br class="calibre33"/> :fields (:last_name :first_name),<br class="calibre33"/> :results :results,<br class="calibre33"/> :table "author",<br class="calibre33"/> :order [],<br class="calibre33"/> :modifiers [],<br class="calibre33"/> :db nil,<br class="calibre33"/> :aliases #{}}</tt></span></blockquote><p class="calibre23">Altering a query is now as simple as manipulating the baseline Clojure map produced by <tt class="calibre22">select*</tt>, which is what Korma functions like <tt class="calibre22">order</tt>, <tt class="calibre22">limit</tt>, and <tt class="calibre22">offset</tt> do. Now, rather than constantly defining them in their entirety, we can build queries incrementally and execute them when we like by using the <tt class="calibre22">exec</tt> function; this lets us reuse parts of queries and encapsulate query transformations in reusable functions, all ways to cut down on code repetition.</p><p class="calibre18">The latest versions of Ruby on Rails’ venerable ActiveRecord (version 3.0 as of this writing) has moved to a very similar method of forming SQL queries using method calls on query objects. In Ruby on Rails, you might write something like this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">employees = Person.where(:type =&gt; "employee")<br class="calibre33"/># ... later ...<br class="calibre33"/>managers = employees.where(:role =&gt; "manager").order(:last_name)<br class="calibre33"/>managers.all.each do |e|<br class="calibre33"/>  ...<br class="calibre33"/>end</tt></span></blockquote><p class="calibre23">Doing this with Korma is very similar:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def employees (where (select* employees) {:type "employee"}))<br class="calibre33"/><br class="calibre33"/>;; ... later ...<br class="calibre33"/>(let [managers (-&gt; employees<br class="calibre33"/>                 (where {:role "manager"})<br class="calibre33"/>                 (order :last_name))]<br class="calibre33"/>  (doseq [e (exec managers)]<br class="calibre33"/>    ; ... process results ...<br class="calibre33"/>    ))</tt></span></blockquote><p class="calibre23"><span class="bold">Pseudolaziness</span>. Queries built this way are “lazy,” in that data isn’t fetched from the database until the query is explicitly executed using Korma’s <tt class="calibre22">select</tt> function. This is a different sort of laziness from Clojure’s lazy data structures; it might more accurately be called “query-on-demand.”</p><p class="calibre18">Suppose we have a table of all humans who ever lived. We could specify that we always want records from this table to be sorted by date of birth. Then before fetching the data, we can narrow it down with predicates and apply <tt class="calibre22">LIMIT</tt> and <tt class="calibre22">OFFSET</tt> to paginate the query.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def humans (-&gt; (select* humans)<br class="calibre33"/>                (order :date_of_birth)))   </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/><br class="calibre33"/>(let [kings-of-germany (-&gt; humans<br class="calibre33"/>                         (where {:country "Germany" :profession "King"}))]   </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  (doseq [start (range 0 100 10)<br class="calibre33"/>          k (select kings-of-germany                                         </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>              (offset start)<br class="calibre33"/>              (limit 10))]<br class="calibre33"/>    ...)</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">If we were to execute this query as-is, the result set would be billions-of-records large. However, <tt class="calibre22">humans</tt> captures the ordering we intend to enforce throughout our usage.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">Within a particular context, we can refine our query parameters as necessary…</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">…and use that refinement as the basis for even more fine-grained queries—like pagination—without having to restate all of the criteria that we’d previously accumulated in our query map.<a id="filepos1798131"></a></blockquote><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1798244"></a><a href="#filepos1787309"><span class="calibre32">372</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">You can use Korma’s </span><span class="calibre10"><tt class="calibre22">get-connection</tt></span><span class="calibre10"> function to obtain a connection from the pool it set up, for example, </span><span class="calibre10"><tt class="calibre22">(get-connection korma-db)</tt></span><span class="calibre10">. This allows you to reuse Korma’s connection pool if you happen to need to do something that requires using </span><span class="calibre10"><tt class="calibre22">clojure.java.jdbc</tt></span><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos1798802" class="calibre6"><span class="calibre4"><span class="bold">Hibernate</span></span></p><p id="filepos1798872" class="calibre18">If you are already using Java or another JVM language for RDBMS work, it’s likely that you’re using Hibernate (<a href="http://www.hibernate.org"><span class="calibre5">http://www.hibernate.org</span></a>), easily the most popular Java object/relational mapping library. One of the advantages of Clojure is being able to use Java libraries and frameworks seamlessly, and Hibernate is no exception.</p><p class="calibre18">Hibernate has a very different philosophy from Clojure: it operates by creating objects, mutating them, and translating those mutations into database queries. However, Clojure is flexible enough to allow Hibernate to work with very little fuss.</p><p id="filepos1799580" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Setup</span></span></span></p><p id="filepos1799675" class="calibre18">Let’s set up Hibernate to let us create, access, and update the <tt class="calibre22">authors</tt> table from earlier in the chapter. First, we’ll need to add Hibernate as a project dependency:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">[org.hibernate/hibernate-core "4.0.0.Final"]</tt></span></blockquote><p class="calibre23">Most usage of Hibernate from Clojure will likely involve using domain objects already built in Java.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1800175"></a><a href="#filepos1817807"><span class="calibre32">373</span></a><span class="calibre32">]</span></small></sup> Here’s a vanilla Java class that represents author name data, using a mix of Hibernate and JPA annotations to indicate that it represents a database entity and specify the usual autoincrementing behavior of the <tt class="calibre22">id</tt> field:</p><p class="calibre8"></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">package com.clojurebook.hibernate;<br class="calibre33"/><br class="calibre33"/>import javax.persistence.GeneratedValue;<br class="calibre33"/>import javax.persistence.Id;<br class="calibre33"/>import javax.persistence.Entity;<br class="calibre33"/>import org.hibernate.annotations.GenericGenerator;<br class="calibre33"/><br class="calibre33"/>@Entity<br class="calibre33"/>public class Author {<br class="calibre33"/>    private Long id;<br class="calibre33"/>    private String firstName;<br class="calibre33"/>    private String lastName;<br class="calibre33"/><br class="calibre33"/>    public Author () {}<br class="calibre33"/><br class="calibre33"/>    public Author (String firstName, String lastName) {<br class="calibre33"/>        this.firstName = firstName;<br class="calibre33"/>        this.lastName = lastName;<br class="calibre33"/>    }<br class="calibre33"/><br class="calibre33"/>    @Id<br class="calibre33"/>    @GeneratedValue(generator="increment")<br class="calibre33"/>    @GenericGenerator(name="increment", strategy = "increment")<br class="calibre33"/>    public Long getId () {<br class="calibre33"/>        return this.id;<br class="calibre33"/>    }<br class="calibre33"/>    public String getFirstName () {<br class="calibre33"/>        return this.firstName;<br class="calibre33"/>    }<br class="calibre33"/>    public String getLastName () {<br class="calibre33"/>        return this.lastName;<br class="calibre33"/>    }<br class="calibre33"/><br class="calibre33"/>    public void setId (Long id) {<br class="calibre33"/>        this.id = id;<br class="calibre33"/>    }<br class="calibre33"/>    public void setFirstName (String firstName) {<br class="calibre33"/>        this.firstName = firstName;<br class="calibre33"/>    }<br class="calibre33"/>    public void setLastName (String lastName) {<br class="calibre33"/>        this.lastName = lastName;<br class="calibre33"/>    }<br class="calibre33"/>}</tt></span></blockquote><p class="calibre23">Rather than spec maps like those accepted by <tt class="calibre22">clojure.java.jdbc</tt> or Korma, Hibernate is generally configured using a <span class="italic">hibernate.cfg.xml</span> XML file. This one specifies that it should target an in-memory SQLite database.</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 14-2. rsrc/hibernate.cfg.xml</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">&lt;!DOCTYPE hibernate-configuration SYSTEM<br class="calibre33"/>"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;<br class="calibre33"/>&lt;hibernate-configuration&gt;<br class="calibre33"/>  &lt;session-factory&gt;<br class="calibre33"/>    &lt;property name="hibernate.connection.driver_class"&gt;org.sqlite.JDBC&lt;/property&gt;<br class="calibre33"/>    &lt;property name="hibernate.connection.url"&gt;jdbc:sqlite::memory:&lt;/property&gt;<br class="calibre33"/>    &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.HSQLDialect&lt;/property&gt;<br class="calibre33"/>    &lt;!-- Drop and re-create the database schema on startup --&gt;<br class="calibre33"/>    &lt;property name="hbm2ddl.auto"&gt;create&lt;/property&gt;<br class="calibre33"/>    &lt;mapping class="com.clojurebook.hibernate.Author"/&gt;<br class="calibre33"/>  &lt;/session-factory&gt;<br class="calibre33"/>&lt;/hibernate-configuration&gt;</tt></span></p><p class="calibre13">Finally, if we’re using Leiningen, we just need to add a couple of keys to our <span class="italic">project.clj</span>; one to indicate the source root for Java code we’d like it to compile (i.e., <span class="italic">Author.java</span>), and another to indicate the resources root, where we placed our <span class="italic">hibernate.cfg.xml</span> file:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">:java-source-path "java"<br class="calibre33"/>:resources-path "rsrc"</tt></span></blockquote><p class="calibre23">This leaves our project structure looking like so:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">|-- project.clj<br class="calibre33"/>|-- rsrc<br class="calibre33"/>|   `-- hibernate.cfg.xml<br class="calibre33"/>|-- java<br class="calibre33"/>|   `-- com<br class="calibre33"/>|       `-- clojurebook<br class="calibre33"/>|           `-- hibernate<br class="calibre33"/>|               |-- Author.java</tt></span></blockquote><p class="calibre23">We can now compile our Java class and start a REPL to start seeing how we can use Hibernate from Clojure:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">% lein javac<br class="calibre33"/>...<br class="calibre33"/>% lein repl</tt></span></blockquote><p class="calibre23">We first need to import the required Java classes from Hibernate, and our new <tt class="calibre22">Author</tt> class:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(import 'org.hibernate.SessionFactory<br class="calibre33"/>        'org.hibernate.cfg.Configuration<br class="calibre33"/>        'com.clojurebook.hibernate.Author)</tt></span></blockquote><p class="calibre23">Hibernate requires setting up a session factory <a id="filepos1805054"></a>object to allow us to open and close database sessions and run queries. It’s important that the factory be instantiated only once. In Java, we might make a utility class with a <tt class="calibre22">static final</tt> member representing the session factory. The factory would be instantiated at the time the class was loaded. This kind of Java code is not uncommon, and is in fact straight from Hibernate’s documentation (<a href="http://docs.jboss.org/hibernate/core/3.3/reference/en/html/tutorial.html"><span class="calibre5">http://docs.jboss.org/hibernate/core/3.3/reference/en/html/tutorial.html</span></a>):</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">public class HibernateUtil {<br class="calibre33"/>    private static final SessionFactory sessionFactory = buildSessionFactory();<br class="calibre33"/><br class="calibre33"/>    private static SessionFactory buildSessionFactory() {<br class="calibre33"/>        try {<br class="calibre33"/>            return new Configuration().configure().buildSessionFactory();<br class="calibre33"/>        }<br class="calibre33"/>        catch (Throwable ex) {<br class="calibre33"/>            System.err.println("Initial SessionFactory creation failed." + ex);<br class="calibre33"/>            throw new ExceptionInInitializerError(ex);<br class="calibre33"/>        }<br class="calibre33"/>    }<br class="calibre33"/><br class="calibre33"/>    public static SessionFactory getSessionFactory() {<br class="calibre33"/>        return sessionFactory;<br class="calibre33"/>    }<br class="calibre33"/>}</tt></span></blockquote><p class="calibre23">In Clojure, we can have a much simpler solution, using <tt class="calibre22">defonce</tt> and <tt class="calibre22">delay</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defonce session-factory<br class="calibre33"/>  (delay (-&gt; (Configuration.)<br class="calibre33"/>           .configure<br class="calibre33"/>           .buildSessionFactory)))</tt></span></blockquote><p class="calibre23">As the name implies, <tt class="calibre22">defonce</tt><a id="filepos1806975"></a> behaves like <tt class="calibre22">def</tt>, defining a var to have some value, but leaving any existing definition intact, even if we reload the namespace that contains the <tt class="calibre22">session-factory</tt> definition. <tt class="calibre22">delay</tt> ensures that the <tt class="calibre22">-&gt;</tt> expression that actually creates and configures the session factory isn’t evaluated until it is <tt class="calibre22">deref</tt>erenced; this allows us to load or AOT-compile the source file without unintentionally attempting to connect to our configured database.<a id="filepos1807471"></a></p><p id="filepos1807482" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Persisting Data</span></span></span></p><p id="filepos1807587" class="calibre18">Our <span class="italic">hibernate.cfg.xml</span> is set up to use an in-memory SQLite database, so it is bare when our REPL starts up. A typical approach to doing this in Java might go like this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">public static void saveAuthors (Author... authors) {<br class="calibre33"/>  Session session = sessionFactory.openSession();<br class="calibre33"/>  session.beginTransaction();<br class="calibre33"/>  for (Author author : authors) {<br class="calibre33"/>    session.save(author);<br class="calibre33"/>  }<br class="calibre33"/>  session.getTransaction().commit();<br class="calibre33"/>  session.close();<br class="calibre33"/>}<br class="calibre33"/><br class="calibre33"/>saveAuthors(new Author("Christophe", "Grand"), new Author("Brian", "Carper"), ...);</tt></span></blockquote><p class="calibre23">A naive translation of this to Clojure would be something like <tt class="calibre22">add-authors</tt> here:</p><p id="filepos1808451" class="calibre23"></p><p class="calibre23"><span class="italic">Example 14-3. add-authors</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(defn add-authors<br class="calibre33"/>  [&amp; authors]<br class="calibre33"/>  (with-open [session (.openSession @session-factory)]<br class="calibre33"/>    (let [tx (.beginTransaction session)]<br class="calibre33"/>      (doseq [author authors]<br class="calibre33"/>        (.save session author))<br class="calibre33"/>      (.commit tx))))<br class="calibre33"/><br class="calibre33"/>(add-authors (Author. "Christophe" "Grand") (Author. "Brian" "Carper") <br class="calibre33"/>  (Author. "Chas" "Emerick"))</tt></span></p><p id="filepos1809055" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Running Queries</span></span></span></p><p id="filepos1809160" class="calibre18">Now that we have persisted some data, let’s try to fetch a list of rows in our <tt class="calibre22">authors</tt> table and print their names. In Java, we might do something like this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">Session session = HibernateUtil.getSessionFactory().openSession();<br class="calibre33"/><br class="calibre33"/>try {<br class="calibre33"/>  return (List&lt;Author&gt;)newSession.createQuery("from Author").list();<br class="calibre33"/>} finally {<br class="calibre33"/>  session.close();<br class="calibre33"/>}</tt></span></blockquote><p class="calibre23">This code can be translated to Clojure in a very straightforward way:</p><p id="filepos1809783" class="calibre23"></p><p class="calibre23"><span class="italic">Example 14-4. get-authors</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(defn get-authors<br class="calibre33"/>  []<br class="calibre33"/>  (with-open [session (.openSession @session-factory)]<br class="calibre33"/>    (-&gt; session<br class="calibre33"/>      (.createQuery "from Author")<br class="calibre33"/>      .list)))</tt></span></p><p class="calibre13">Of course, since we’re in Clojure, we have a fair bit more flexibility in terms of manipulating the data we obtain from our Hibernate query:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(for [{:keys [firstName lastName]} (map bean (get-authors))]  </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  (str lastName ", " firstName))<br class="calibre33"/>;= ("Carper, Brian" "Emerick, Chas" "Grand, Christophe")</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">bean</tt> here converts any JavaBean-style Java object into a Clojure hash map, with each getter corresponding to a slot in that map with keyword keys of the same name as the getters in that JavaBean.</blockquote><p class="calibre18">The <tt class="calibre22">.list</tt> method on the Hibernate query object returns a <tt class="calibre22">java.util.ArrayList</tt> of results. We are able loop over it using <tt class="calibre22">doseq</tt> because Clojure ensures that all <tt class="calibre22">java.util.List</tt>s are seqable.</p><p id="filepos1811316" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Removing Boilerplate</span></span></span></p><p id="filepos1811426" class="calibre18">Our Clojure code works, but it can be improved.</p><p class="calibre18">Note the repetition in our two functions. Opening and closing the session and beginning and committing transactions are two things we’ll have to do over and over.</p><p class="calibre18">In Java, you might be stuck retyping this code over and over; not so in Clojure. A good first step was using the Clojure built-in <tt class="calibre22">with-open</tt><a id="filepos1811877"></a> macro, which allows us to automatically open a connection or handle object, run some code, and then ensure that the handle or connection is closed once we’re done using it. Because Hibernate sessions are closed with a standard <tt class="calibre22">.close</tt> method, <tt class="calibre22">with-open</tt> works on Hibernate sessions.</p><p class="calibre18">However, we can do better. <tt class="calibre22">with-open</tt> requires us to specify a name for the <tt class="calibre22">session</tt> local; with a macro on top of <tt class="calibre22">with-open</tt>, we can simply say that as a matter of convention, it will always be named <tt class="calibre22">session</tt> within the body of that macro:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defmacro with-session<br class="calibre33"/>  [session-factory &amp; body] </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  `(with-open [~'session (.openSession ~(vary-meta session-factory assoc <br class="calibre33"/>                                          :tag 'SessionFactory))] </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>     ~@body))</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">The first argument, <tt class="calibre22">session-factory</tt>, is a form that will be used to obtain an open session. All further arguments are forms executed in the context of that session being open.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">Without hinting <tt class="calibre22">session-factory</tt>, the compiler will not know that <tt class="calibre22">(.openSession factory#)</tt> will return a Hibernate <tt class="calibre22">Session</tt>, and so all calls involving <tt class="calibre22">session</tt> will be reflective. However, we can’t just hint the unquoted <tt class="calibre22">session-factory</tt> symbol, as that would apply to the <tt class="calibre22">~session-factory</tt> form, and not to the user-provided symbol bound to <tt class="calibre22">session-factory</tt> within the macro. The fix is to modify the metadata of the symbol bound to <tt class="calibre22">session-factory</tt>, so that value will be hinted appropriately. Note that the value of <tt class="calibre22">:tag</tt> is itself a <span class="italic">symbol</span>, not a class.</blockquote><p class="calibre18">Rather than use a gensym to establish a “safe” local binding that will not shadow existing bindings or “leak” into user code within the body of <tt class="calibre22">with-session</tt>, we <span class="italic">want</span> to have <tt class="calibre22">session</tt> bound within that scope to the Hibernate <tt class="calibre22">Session</tt>. To do this, we force the emission of an unqualified (un-namespaced) symbol using <tt class="calibre22">~'session</tt>.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1814652"></a><a href="#filepos1818630"><span class="calibre32">374</span></a><span class="calibre32">]</span></small></sup> A bare <tt class="calibre22">session</tt> symbol in the macro at this point would have caused a compilation error, as macroexpansion would have automatically qualified the symbol to the current namespace, e.g., <tt class="calibre22">user/session</tt>, which cannot be used as names for local bindings.</p><p class="calibre18">With this macro in place, we can rewrite <a href="#filepos1809783"><span class="calibre5">Example 14-4</span></a> to be somewhat more concise:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn get-authors<br class="calibre33"/>  []<br class="calibre33"/>  (with-session @session-factory<br class="calibre33"/>    (-&gt; session<br class="calibre33"/>      (.createQuery "from Author")<br class="calibre33"/>      .list)))</tt></span></blockquote><p class="calibre23">That’s not a <span class="italic">huge</span> benefit on its own, but multiplied over dozens, hundreds, or thousands of Hibernate interactions involving an open session, it’s some progress. More significant would be a corollary macro for executing operations within the context of a Hibernate transaction:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defmacro with-transaction<br class="calibre33"/>  [&amp; body]<br class="calibre33"/>  `(let [~'tx (.beginTransaction ~'session)]  </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>     ~@body<br class="calibre33"/>     (.commit ~'tx)))</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Because Hibernate <tt class="calibre22">Transaction</tt> objects provide useful methods (just like <tt class="calibre22">Session</tt> objects), we implicitly bind the current <tt class="calibre22">Transaction</tt> to the <tt class="calibre22">tx</tt> local so user code can access it easily. This makes <tt class="calibre22">with-transaction</tt> an anaphoric macro as well.</blockquote><p class="calibre18">Here, <tt class="calibre22">session</tt> is a name that we expect to be already bound to the value of a currently open session; thus, <tt class="calibre22">with-transaction</tt> will work seamlessly with the anaphoric <tt class="calibre22">session</tt> name bound in <tt class="calibre22">with-session</tt>. The generated code will begin a transaction, execute additional forms in <tt class="calibre22">body</tt>, and then commit the transaction. This allows us to produce a <span class="italic">much</span> simpler implementation of <a href="#filepos1808451"><span class="calibre5">Example 14-3</span></a>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn add-authors<br class="calibre33"/>  [&amp; authors]<br class="calibre33"/>  (with-session @session-factory<br class="calibre33"/>    (with-transaction<br class="calibre33"/>      (doseq [author authors]<br class="calibre33"/>        (.save session author)))))</tt></span></blockquote><p class="calibre23">Pushing boilerplate and syntactic complexity like that involved in the bookkeeping of sessions and transactions out of the codebase we need to touch on a daily basis can make it easier to read, more enjoyable to work with, and perhaps most important, less prone to error.<a id="filepos1817703"></a></p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1817807"></a><a href="#filepos1800175"><span class="calibre32">373</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">You </span><span class="calibre10"><span class="italic">are</span></span><span class="calibre10"> able to write Hibernate/JPA </span><span class="calibre10"><tt class="calibre22">Entity</tt></span><span class="calibre10"> classes using Clojure, quite easily. Refer to </span><a href="#filepos1389148"><span class="calibre10"><span class="calibre5">Annotations</span></span></a><span class="calibre10"> for other examples of using Java framework annotations in conjunction with Clojure type definition facilities. In the case of Hibernate/JPA, you will need to use </span><span class="calibre10"><tt class="calibre22">gen-class</tt></span><span class="calibre10">, since entities require a default/no-argument constructor to create entity instances when performing queries.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1818630"></a><a href="#filepos1814652"><span class="calibre32">374</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">By establishing an implicit binding visible to user code, </span><span class="calibre10"><tt class="calibre22">with-session</tt></span><span class="calibre10"> is an </span><span class="calibre10"><span class="italic">anaphoric</span></span><span class="calibre10"> (sometimes referred to as </span><span class="calibre10"><span class="italic">unhygienic</span></span><span class="calibre10">) macro. See </span><a href="#filepos881435"><span class="calibre10"><span class="calibre5">Hygiene</span></span></a><span class="calibre10"> and </span><a href="#filepos894757"><span class="calibre10"><span class="calibre5">Letting the User Pick Names</span></span></a><span class="calibre10"> for more about anaphoric macros.</span></p><div class="mbppagebreak"></div><p id="filepos1819329" class="calibre6"><span class="calibre4"><span class="bold">Final Thoughts</span></span></p><p class="calibre18">Clojure has excellent support for working with relational databases. The JVM and JDBC provides a great foundation of comprehensive database support to build upon, pure Clojure options offer powerful and composable layers of additional functionality on top, and, if the need arises, it is easy and practical to fall back to mature Java frameworks like Hibernate.<a id="filepos1819793"></a></p><div class="mbppagebreak"></div><p id="filepos1819820" class="calibre6"><span class="calibre2"><span class="bold">Chapter 15. Using Nonrelational Databases</span></span></p><p id="filepos1819924" class="calibre13">After years of relational databases being the only functionally available choice for application developers needing to persist data, a number of new classes of databases have come to be regarded as legitimate alternatives to the ubiquitous RDBMS. These databases are each generally very different from each other. Despite their differences, key-value stores and column- and document-oriented databases share a common thread of presenting alternatives to the orthodoxy of the relational data model that has dominated for so long; thus, they are often collectively referred to as nonrelational databases.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1820589"></a><a href="#filepos1824209"><span class="calibre32">375</span></a><span class="calibre32">]</span></small></sup> These data stores’ unique capabilities and increasing popularity make them common components in new Clojure applications, so it’s worth seeing what such a combination looks like.</p><p class="calibre18">CouchDB is a document-oriented nonrelational database that defines a data model and architecture that fits well with Clojure’s strengths and world view. The combination is particularly potent, allowing for the relatively simple implementation of many types of applications, from typical web frontends to pleasantly extensible messaging systems.</p><p class="calibre18">To start, it would be helpful to describe a couple of CouchDB features that are particularly relevant to Clojure:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Its data model consists exclusively of JSON documents, which are trivially converted to and from Clojure’s data structures.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">It uses an append-only btree-based storage system that defaults to ensuring data durability and operational atomicity.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">It uses <span class="italic">MVCC</span> for coping with concurrent modifications from multiple clients, the same optimistic, versioned change-management model that Clojure’s software transaction memory uses.</blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17">It allows for the definition of nontrivial queries in terms of data transformations called views, which may be implemented in nearly any language, including Clojure.</blockquote></li></ul><p class="calibre18">Clojure’s persistent data structures and focus on well-defined concurrency semantics make it a very natural pairing with CouchDB, which is similarly defined in terms of immutable documents that have clear semantics around the durability, atomicity, and conflict-management of changes.</p><p id="filepos1822730" class="calibre6"><span class="calibre4"><span class="bold">Getting Set Up with CouchDB and Clutch</span></span></p><p id="filepos1822829" class="calibre18">CouchDB is a very mature database (despite its <tt class="calibre22">1.2.0</tt> version label, which we’ll be using in our examples), and extensive documentation may be found for it both online at its Apache project site<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1823096"></a><a href="#filepos1824458"><span class="calibre32">376</span></a><span class="calibre32">]</span></small></sup> and in the O’Reilly book.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1823254"></a><a href="#filepos1824826"><span class="calibre32">377</span></a><span class="calibre32">]</span></small></sup> Those looking to completely understand it should refer to those resources.</p><p class="calibre18">To get started using CouchDB from Clojure, you’ll first need to have CouchDB running locally.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1823586"></a><a href="#filepos1825241"><span class="calibre32">378</span></a><span class="calibre32">]</span></small></sup> In all of our examples, we’ll be using the API provided by Clutch (<a href="https://github.com/ashafa/clutch"><span class="calibre5">https://github.com/ashafa/clutch</span></a>), a Clojure library that provides comprehensive support for CouchDB’s facilities. To use Clutch, just add it as a dependency to your project:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">[com.ashafa/clutch "0.3.0"]</tt></span></blockquote><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1824209"></a><a href="#filepos1820589"><span class="calibre32">375</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Or, more popularly (and unfortunately) as “NoSQL” databases.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1824458"></a><a href="#filepos1823096"><span class="calibre32">376</span></a><span class="calibre32">] </span></small></sup><a href="http://couchdb.apache.org"><span class="calibre10"><span class="calibre5">http://couchdb.apache.org</span></span></a><span class="calibre10">—(the wiki is a particularly rich trove of detailed information).</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1824826"></a><a href="#filepos1823254"><span class="calibre32">377</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Written by members of the CouchDB development team and available free online and in print at </span><a href="http://guide.couchdb.org"><span class="calibre10"><span class="calibre5">http://guide.couchdb.org</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1825241"></a><a href="#filepos1823586"><span class="calibre32">378</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Or, you can use a free hosted CouchDB instance from Cloudant for everything but the Clojure view server examples: </span><a href="https://cloudant.com"><span class="calibre10"><span class="calibre5">https://cloudant.com</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos1825622" class="calibre6"><span class="calibre4"><span class="bold">Basic CRUD Operations</span></span></p><p id="filepos1825704" class="calibre18">Let’s explore CouchDB from the REPL, starting with the basics: creating, updating, and deleting documents.</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 15-1. Simple CouchDB interaction in a REPL</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(use '[com.ashafa.clutch :only (create-database with-db put-document<br class="calibre33"/>                                get-document delete-document)<br class="calibre33"/>                         :as clutch])<br class="calibre33"/><br class="calibre33"/>(def db (create-database "repl-crud"))                                </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/><br class="calibre33"/>(put-document db {:_id "foo" :some-data "bar"})                       </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= {:_rev "1-2bd2719826", :some-data "bar", :_id "foo"}<br class="calibre33"/>(put-document db (assoc *1 :other-data "quux"))                       </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= {:other-data "quux", :_rev "2-9f29b39770", :some-data "bar", :_id "foo"}<br class="calibre33"/>(get-document db "foo")                                               </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= {:_id "foo", :_rev "2-9f29b39770", :other-data "quux", :some-data "bar"}<br class="calibre33"/>(delete-document db *1)                                               </tt></span><a></a><img src="images/00001.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= {:ok true, :id "foo", :rev "3-3e98dd1028"}<br class="calibre33"/>(get-document db "foo")                                               </tt></span><a></a><img src="images/00015.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= nil</tt></span></p><p class="calibre101"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">First, we create a scratch database for our REPL interaction.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">Here we create a document using a Clojure map. <tt class="calibre22">put-document</tt> returns the created document, which will be the same as the map provided, except for the addition of the <tt class="calibre22">:_rev</tt> slot. Note that we’re defining <tt class="calibre22">:_id</tt> here, which serves as the “primary key” for the document; if we leave that undefined, CouchDB will assign our new document a UUID <tt class="calibre22">:_id</tt>.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">An update operation. Notice that the <tt class="calibre22">:_rev</tt> slot’s value has been updated in the return value, because we’ve updated that document.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1829038"></a><a href="#filepos1832047"><span class="calibre32">379</span></a><span class="calibre32">]</span></small></sup></blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">A simple get operation, which always returns the latest revision of the requested document; you can optionally request prior document revisions.</blockquote><p class="calibre23"><img src="images/00001.jpg" class="calibre36"/></p><blockquote class="calibre37">A delete operation. Though we’re providing the full document map in this case, note that we only really need to provide a map containing <tt class="calibre22">:_id</tt> and <tt class="calibre22">:_rev</tt> values that match the latest version of an existing document.</blockquote><p class="calibre23"><img src="images/00015.jpg" class="calibre36"/></p><blockquote class="calibre37">A get operation returns <tt class="calibre22">nil</tt> if no document with the specified key exists.</blockquote><p class="calibre18">The direct parallels between their respective data representations make interactions between Clojure and CouchDB very natural. CouchDB uses JSON <a id="filepos1830231"></a>throughout for data representation (key/value maps with string keys and scalar, array, or other key/value map as values), which maps onto Clojure’s maps, vectors, and scalars perfectly. Fortunately, the JSON parser that Clutch uses (<a href="https://github.com/clojure/data.json"><span class="calibre5">https://github.com/clojure/data.json</span></a>) converts the string keys of JSON maps into Clojure keywords; this allows for easy lookup of key/value pairs and traversal of nested structures using functions like <tt class="calibre22">get-in</tt>, or Clojure’s threading macros, <tt class="calibre22">-&gt;</tt>, <tt class="calibre22">-&gt;&gt;</tt>, and so on.</p><p class="calibre18">The consequences of this can be illustrated by seeing how we can trivially drill into a document retrieved from CouchDB:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(clutch/create-document {:_id "foo"<br class="calibre33"/>                         :data ["bar" {:details ["bat" false 42]}]})<br class="calibre33"/>;= {:_id "foo", :data ["bar" {:details ["bat" false 42]}],<br class="calibre33"/>;=  :_rev "1-6d7460947434b90bf88f033785f81cdd"}<br class="calibre33"/>(-&gt;&gt; (get-document db "foo")<br class="calibre33"/>  :data<br class="calibre33"/>  second<br class="calibre33"/>  :details<br class="calibre33"/>  (filter number?))<br class="calibre33"/>;= (42)</tt></span></blockquote><p class="calibre23">The upshot is that documents stored in and retrieved from CouchDB <span class="italic">are</span> “Clojure-native” data structures for all intents and purposes, and therefore amenable to all of Clojure’s idiomatic facilities for querying and processing data. This simplifies application code significantly and brings relative clarity and ease to data modeling, often one of the most difficult aspects of database usage.</p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1832047"></a><a href="#filepos1829038"><span class="calibre32">379</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Remember that </span><span class="calibre10"><tt class="calibre22">*1</tt></span><span class="calibre10"> is a REPL-bound var that holds the value of the last-evaluated expression, similar to </span><span class="calibre10"><tt class="calibre22">_</tt></span><span class="calibre10"> in Ruby’s IRB and in the Python interpreter. See </span><a href="#filepos1460851"><span class="calibre10"><span class="calibre5">“REPL-bound vars”</span></span></a><span class="calibre10"> for more about REPL-bound vars.</span></p><div class="mbppagebreak"></div><p id="filepos1832599" class="calibre6"><span class="calibre4"><span class="bold">Views</span></span></p><p id="filepos1832665" class="calibre18">CouchDB does not offer SQL or anything similar for performing ad-hoc queries. On their own, documents may only be indexed by a single “primary” string key.</p><p class="calibre18">The alternative provided by CouchDB is called <span class="italic">views</span>. Views are very similar in concept to the materialized views offered by some relational database systems. Views:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Are stored and accessed separately from their “source” database</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Are defined programmatically (using almost any language, including Clojure as we’ll see shortly) and ahead of time</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Reflect changes to the source database’s documents upon access</blockquote></li></ul><p class="calibre18">The primary insight behind CouchDB’s views is that nearly all of an application’s data access can be enumerated, and so the flexibility (and attendant runtime cost) associated with SQL and other ad-hoc query mechanisms is generally unwarranted. In contrast, CouchDB views must always be defined in the database prior to accessing them,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1834035"></a><a href="#filepos1855159"><span class="calibre32">380</span></a><span class="calibre32">]</span></small></sup> with the benefit that accessing them will always be extremely fast, regardless of the amount of processing needed to produce the views’ data.</p><p class="calibre18">To get started with views, let’s load a dataset of hypothetical logging messages into a new database, named <span class="italic">logging</span>. We’ll use Clutch’s <tt class="calibre22">bulk-update</tt> function for this, which hooks into CouchDB’s <tt class="calibre22">_bulk_docs</tt> API; this is the most efficient route for loading large amounts of data into CouchDB:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(clutch/bulk-update (create-database "logging")<br class="calibre33"/>  [{:evt-type "auth/new-user" :username "Chas"}<br class="calibre33"/>   {:evt-type "auth/new-user" :username "Dave"}<br class="calibre33"/>   {:evt-type "sales/purchase" :username "Chas" :products ["widget1"]}<br class="calibre33"/>   {:evt-type "sales/purchase" :username "Robin" :products ["widget14"]}<br class="calibre33"/>   {:evt-type "sales/RFQ" :username "Robin" :budget 20000}])</tt></span></blockquote><p id="filepos1835139" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">A Simple (JavaScript) View</span></span></span></p><p id="filepos1835255" class="calibre18">By default, CouchDB views are defined using JavaScript; we’ll start there to get familiarized with accessing views from Clojure, and then go on to implement a couple of views in Clojure itself.</p><p class="calibre18">Regardless of what language you use to implement views, they are defined by a map function, and an optional reduce function.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">The </span><span class="calibre10"><span class="italic">reduce</span></span><a id="filepos1835864"></a><span class="calibre10"> concept is defined somewhat differently in CouchDB than it is in Clojure and other functional programming languages, as well as in other data processing systems such as Hadoop and the MapReduce model popularized by Google. The semantics of reduce (and the CouchDB-specific notion of </span><span class="calibre10"><span class="italic">rereduce</span></span><span class="calibre10">) is tied to CouchDB’s B-Tree data indexing strategy. See </span><a href="http://wiki.apache.org/couchdb/Introduction_to_CouchDB_views#Reduce_Functions"><span class="calibre10"><span class="calibre5">http://wiki.apache.org/couchdb/Introduction_to_CouchDB_views#Reduce_Functions</span></span></a><span class="calibre10"> in the CouchDB documentation/book for more information.</span></blockquote><p class="calibre25">Our first view will cover an obvious usecase: report on how many log message of each type have been lodged. Implementing this requires defining a map and a reduce function:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">function(doc) {<br class="calibre33"/>  emit(doc["evt-type"], null);<br class="calibre33"/>}<br class="calibre33"/><br class="calibre33"/>function (keys, vals, rereduce) {<br class="calibre33"/>  return rereduce ? sum(vals) : vals.length;<br class="calibre33"/>}</tt></span></blockquote><p class="calibre23">You can create this view using <span class="italic">Futon</span><a id="filepos1837156"></a>, the administrative frontend provided with CouchDB,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1837250"></a><a href="#filepos1855552"><span class="calibre32">381</span></a><span class="calibre32">]</span></small></sup> or via Clutch like so:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(clutch/save-view "logging" "jsviews"            </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  (clutch/view-server-fns :javascript            </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>    {:type-counts                                </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>     {:map "function(doc) {<br class="calibre33"/>              emit(doc['evt-type'], null);<br class="calibre33"/>            }"<br class="calibre33"/>     :reduce "function (keys, vals, rereduce) {<br class="calibre33"/>                 return rereduce ? sum(vals) : vals.length;<br class="calibre33"/>              }"}}))</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">jsviews</tt> specifies the name of the <span class="italic">design document</span> where our view will be stored. Design documents are special documents within a CouchDB database that are dedicated to holding code to drive views, filters, and other in-database functionality.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">This view is implemented using JavaScript, which we must specify so that the design document may be configured properly.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">type-counts</tt> is the name of the view; you can provide many views at once to <tt class="calibre22">view-server-fns</tt>, just by adding another entry to the provided map.</blockquote><p class="calibre18">Now we’re ready to query our view:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(clutch/get-view "logging" "jsviews" :type-counts {:group true})<br class="calibre33"/>;= ({:key "auth/new-user", :value 2}<br class="calibre33"/>;=  {:key "sales/purchase", :value 2}<br class="calibre33"/>;=  {:key "sales/RFQ", :value 1})</tt></span></blockquote><p class="calibre23">And there are our record counts, keyed on the log messages’ <tt class="calibre22">:evt-type</tt> slot. <tt class="calibre22">get-view</tt> returns a lazy sequence of result documents from the named view; this means that view results of thousands or millions of documents may be consumed and processed from Clojure without difficulty. And again, these view result documents are just more Clojure maps and values, making it easy for us to produce a slightly more useful aggregated form with some Clojure seq processing:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(-&gt;&gt; (clutch/get-view "logging" "jsviews" :type-counts {:group true})<br class="calibre33"/>  (map (juxt :key :value))<br class="calibre33"/>  (into {}))<br class="calibre33"/>;= {"auth/new-user" 2, "sales/purchase" 2, "sales/RFQ" 1}</tt></span></blockquote><p class="calibre23">As you might expect, these counts are updated as necessary as new log messages stream into the database.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">The </span><span class="calibre10"><tt class="calibre22">:group</tt></span><span class="calibre10"> query option we’re using above is a shortcut that reduces the view’s values for each uniquely keyed record. Without it, we’d get a single result, with a value of </span><span class="calibre10"><tt class="calibre22">5</tt></span><span class="calibre10">. Views have all sorts of query options that we won’t touch on here; please refer to the CouchDB documentation (</span><a href="http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options"><span class="calibre10"><span class="calibre5">http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options</span></span></a><span class="calibre10">) for more information.</span><a id="filepos1841465"></a></blockquote><p id="filepos1841485" class="calibre25"><span class="calibre19"><span class="bold"><span class="calibre5">Views in Clojure</span></span></span></p><p id="filepos1841591" class="calibre18">Writing CouchDB views in JavaScript is convenient, insofar as just about everyone knows JavaScript, and CouchDB comes with a JavaScript <span class="italic">view server</span> implementation out of the box.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">CouchDB views are produced by feeding the source code defining a set of views along with JSON corresponding to “source” documents into a separate process called a </span><span class="calibre10"><span class="italic">view server</span></span><span class="calibre10">. View servers simply read this data from </span><span class="calibre10"><tt class="calibre22">stdin</tt></span><span class="calibre10"> and emit what should be stored for the view results on </span><span class="calibre10"><tt class="calibre22">stdout</tt></span><span class="calibre10">. The simplicity of implementation means that it is very straightforward to implement a view server in almost any programming language.</span></blockquote><blockquote class="calibre17"><span class="calibre10">You’ll almost certainly never need to consider writing a new view server: there are implementations for dozens of languages, including Clutch’s implementation for writing views in Clojure.</span></blockquote><p class="calibre25">However, there are very good reasons for using a non-JavaScript view server, all of which are certainly true when it comes to the Clojure view server provided by Clutch:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">You can take advantage of a richer, likely more familiar language.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Your chosen view server’s language almost surely has access to higher quality, more comprehensive libraries than are available in CouchDB’s prepackaged JavaScript view server</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">If your views involve any kind of intensive processing, your chosen view server’s language likely provides a more efficient runtime than JavaScript’s.</blockquote></li></ul><p class="calibre18">Configuring your local CouchDB instance to use Clutch’s view server for Clojure views usually requires using the <tt class="calibre22">configure-view-server</tt><a id="filepos1843947"></a> function in your Clutch-enabled REPL:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1844027"></a><a href="#filepos1855943"><span class="calibre32">382</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(use '[com.ashafa.clutch.view-server :only (view-server-exec-string)])<br class="calibre33"/><br class="calibre33"/>(clutch/configure-view-server "http://localhost:5984" (view-server-exec-string))</tt></span></blockquote><p class="calibre23">The <tt class="calibre22">configure-view-server</tt> function creates a Clojure view server entry in your CouchDB instance, with a shell command that CouchDB will use to run the view server as necessary.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1844628"></a><a href="#filepos1856658"><span class="calibre32">383</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">First, let’s take a look at a port of our simple JavaScript view to a Clojure view. Here, we’re using Clutch to save the view to a different design document (<tt class="calibre22">clj-views</tt> instead of <tt class="calibre22">jsviews</tt>, which we used above for the JavaScript view):</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(clutch/save-view "logging" "clj-views"<br class="calibre33"/>  (clutch/view-server-fns :clojure<br class="calibre33"/>    {:type-counts<br class="calibre33"/>     {:map (fn [doc]<br class="calibre33"/>             [[(:evt-type doc) nil]])<br class="calibre33"/>       :reduce (fn [keys vals rereduce]<br class="calibre33"/>                 (if rereduce<br class="calibre33"/>                   (reduce + vals)<br class="calibre33"/>                   (count vals)))}}))</tt></span></blockquote><p class="calibre23">CouchDB’s (and therefore Clutch’s) view API is the same, regardless of which language your views are implemented in, so outside of specifying the different design document, our code for accessing the Clojure view is unchanged from before:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(-&gt;&gt; (clutch/get-view "logging" "clj-views" :type-counts {:group true})<br class="calibre33"/>     (map (juxt :key :value))<br class="calibre33"/>     (into {}))<br class="calibre33"/>;= {"auth/new-user" 2, "sales/purchase" 2, "sales/RFQ" 1}</tt></span></blockquote><p class="calibre23">Simply swapping braces for parens is not the objective here though; by writing views in Clojure, we can take advantage of all of its facilities when producing data for a view, including using any existing Clojure and Java libraries as necessary.</p><p class="calibre18">Consider the problem domain associated with our dataset, that of event logging from what we can suppose is a sort of e-commerce application. The concrete event types we see here appear to be related in some hierarchy (e.g., <tt class="calibre22">sales/purchase</tt> and <tt class="calibre22">sales/RFQ</tt> clearly being related). It would be trivial (regardless of the language you are writing views in) to split event types on the slash character and use CouchDB’s view collation features (<a href="http://wiki.apache.org/couchdb/View_collation"><span class="calibre5">http://wiki.apache.org/couchdb/View_collation</span></a>) to naturally group the emitted counts based on the implicit hierarchy. While that would be reasonably useful, it forces our event types into a strict hierarchy. Getting around this through creative event type naming or using some kind of manifold event typing (e.g., making <tt class="calibre22">:evt-type</tt> an array of types) is possible, but inelegant, less flexible, and more complex.</p><p class="calibre18">A better solution would be to define our event types <a id="filepos1847496"></a>in terms of Clojure’s ad hoc hierarchies;<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1847581"></a><a href="#filepos1857184"><span class="calibre32">384</span></a><span class="calibre32">]</span></small></sup> for example:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 15-2. Defining our event hierarchy</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(ns eventing.types)<br class="calibre33"/><br class="calibre33"/>(derive 'sales/purchase 'sales/all)<br class="calibre33"/>(derive 'sales/purchase 'finance/accounts-receivable)<br class="calibre33"/>(derive 'finance/accounts-receivable 'finance/all)<br class="calibre33"/>(derive 'finance/all 'events/all)<br class="calibre33"/>(derive 'sales/all 'events/all)<br class="calibre33"/>(derive 'sales/RFQ 'sales/lead-generation)<br class="calibre33"/>(derive 'sales/lead-generation 'sales/all)<br class="calibre33"/>(derive 'auth/new-user 'sales/lead-generation)<br class="calibre33"/>(derive 'auth/new-user 'security/all)<br class="calibre33"/>(derive 'security/all 'events/all)</tt></span></p><p class="calibre13">We can then use that representation in our view server to expand each concrete event type into all of its parent types, some of which may never actually appear as a log message’s <tt class="calibre22">:evt-type</tt>, but that may represent something significant to the business in question. Taking this route allows us to succinctly provide for event types that impact multiple concerns. Here is a Clojure view implementing this strategy:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 15-3. A hierarchy-augmented Clojure view</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(clutch/save-view "logging" "clj-views"<br class="calibre33"/>  (clutch/view-server-fns :clojure<br class="calibre33"/>    {:type-counts<br class="calibre33"/>     {:map (do<br class="calibre33"/>             (require 'eventing.types)                                  </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>             (fn [doc]<br class="calibre33"/>               (let [concrete-type (-&gt; doc :evt-type symbol)]           </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>                 (for [evtsym (cons concrete-type                       </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>                                    (ancestors concrete-type))]<br class="calibre33"/>                   [(str evtsym) nil]))))<br class="calibre33"/>      :reduce (fn [keys vals rereduce]                                  </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>                (if rereduce<br class="calibre33"/>                  (reduce + vals)<br class="calibre33"/>                  (count vals)))}}))<br class="calibre33"/><br class="calibre33"/>(-&gt;&gt; (clutch/with-db "logging"<br class="calibre33"/>          (clutch/get-view "clj-views" :type-counts {:group true}))<br class="calibre33"/>     (map (juxt :key :value))<br class="calibre33"/>     (into {}))<br class="calibre33"/>;= {"events/all" 5,<br class="calibre33"/>;=  "sales/all" 5,<br class="calibre33"/>;=  "finance/all" 2,<br class="calibre33"/>;=  "finance/accounts-receivable" 2,<br class="calibre33"/>;=  "sales/lead-generation" 3,<br class="calibre33"/>;=  "sales/purchase" 2,<br class="calibre33"/>;=  "sales/RFQ" 1,<br class="calibre33"/>;=  "security/all" 2,<br class="calibre33"/>;=  "auth/new-user" 2}</tt></span></p><p class="calibre23"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">First, we ensure that the namespace that defines the relationships between our known concrete event types and their “ancestral” types is loaded. This happens only once, when the view map is materialized in the view server and before any documents are processed. Note that the required namespace (<tt class="calibre22">eventing.types</tt> in this case) must be on the view server’s classpath.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">We convert each <tt class="calibre22">:evt-type</tt> string into a symbol, so that…</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">…that symbol’s ancestors in the defined hierarchy can be obtained. A single view result is emitted for each symbol, including one for the concrete <tt class="calibre22">:evt-type</tt>.</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">The reduce function remains unchanged from our previous simple counting view.</blockquote><p class="calibre13">The results of the view are now a lot more interesting. By defining our event type hierarchy in Clojure, not only have we been able to get “departmental” rollups of event counts, but the cross-functional events are treated far more usefully than a lexicographical naming scheme would allow for:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">auth/new-user</tt> events are properly related to lead generation in addition to their natural alignment under security.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">The scope of <tt class="calibre22">sales/purchase</tt> events have been broadened to include accounts receivable and finance.</blockquote></li></ul><p class="calibre18">Even better, our hierarchy of event types in Clojure can be added to or reorganized as needed, entirely independent of the different modules or applications that are producing the actual events. For example, when new auditing requirements dictate that user registrations are to be tracked and retained along with a broad spectrum of other business data, the <tt class="calibre22">security/all</tt> parent may be declared a child of a new <tt class="calibre22">audit/all</tt> event type, thereby including <tt class="calibre22">auth/new-users</tt> in the audit scope without the user authentication system changing anything about how it emits those <tt class="calibre22">auth/new-user</tt> events.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">VIEW FUNCTIONS MUST BE PURE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">One thing to remember when writing views is that </span><span class="calibre10"><span class="italic">you are not in control of when your view is invoked, or how many times it is invoked</span></span><span class="calibre10">. This CouchDB implementation detail is irrelevant when writing views using JavaScript, because it provides no facilities for doing I/O or other side-effecting operations. However, when writing views in Clojure (or really, any other non-JavaScript language), you need to ensure the functions you write are pure.<sup class="calibre58"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1854532"></a><a href="#filepos1857538"><span class="calibre32">385</span></a><span class="calibre32">]</span></small></sup> For example, sending a notification email every time your view processed an event of type </span><span class="calibre10"><tt class="calibre22">sales/purchase</tt></span><span class="calibre10"> would be a disaster: that email would be sent every time a purchase event document changed, or when the database is compacted, or (just to drive the point home) any time CouchDB decides it needs to invalidate the view results for that purchase document.</span><a id="filepos1855046"></a></blockquote><br class="calibre33"/><hr class="calibre34"/><p class="calibre25"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1855159"></a><a href="#filepos1834035"><span class="calibre32">380</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">While you can create temporary views in an ad-hoc fashion, such views will always be </span><span class="calibre10"><span class="italic">far</span></span><span class="calibre10"> slower than “regular” views configured and stored ahead of time.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1855552"></a><a href="#filepos1837250"><span class="calibre32">381</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">If you’re running CouchDB locally, you can access Futon at </span><a href="http://localhost:5984/_utils"><span class="calibre10"><span class="calibre5">http://localhost:5984/_utils</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1855943"></a><a href="#filepos1844027"><span class="calibre32">382</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">ClojureScript (see </span><a href="#filepos2072318"><span class="calibre10"><span class="calibre5">ClojureScript</span></span></a><span class="calibre10">) can be used with Clutch to define Clojure views in CouchDB that do not require the configuration of a new view server—very convenient, especially if your CouchDB is hosted by Cloudant or elsewhere: </span><a href="https://github.com/clojure-clutch/clutch-clojurescript"><span class="calibre10"><span class="calibre5">https://github.com/clojure-clutch/clutch-clojurescript</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1856658"></a><a href="#filepos1844628"><span class="calibre32">383</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">This setup invocation is a convenience for REPL use only; please refer to the Clutch README at </span><a href="http://github.com/ashafa/clutch"><span class="calibre10"><span class="calibre5">http://github.com/ashafa/clutch</span></span></a><span class="calibre10"> for more information about setting up CouchDB to be Clojure view server ready in general terms.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1857184"></a><a href="#filepos1847581"><span class="calibre32">384</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Read more about hierarchies and multimethods in Clojure in </span><a href="#filepos1073489"><span class="calibre10"><span class="calibre5">Chapter 7</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1857538"></a><a href="#filepos1854532"><span class="calibre32">385</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="#filepos316677"><span class="calibre10"><span class="calibre5">Pure Functions</span></span></a><span class="calibre10"> for a discussion about referential transparency and pure functions.</span></p><div class="mbppagebreak"></div><p id="filepos1857861" class="calibre6"><span class="calibre4"><span class="bold">_changes: Abusing CouchDB as a Message Queue</span></span></p><p id="filepos1857966" class="calibre18">CouchDB provides a change notification API (called <tt class="calibre22">_changes</tt>) that allows clients a great deal of flexibility in defining how to react in response to data flows.</p><p class="calibre18">Briefly, <tt class="calibre22">_changes</tt> works like so:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">An HTTP connection is opened to the <tt class="calibre22">_changes</tt> URL for the CouchDB database of interest.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Wait. When any change occurs in the database in question (any document creation, deletion, or update), a JSON map is sent to the client describing the affected document ID and revision.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">If you have elected to be notified of changes continuously, repeat from 2.</blockquote></li></ol><p class="calibre18">The simplest of all <tt class="calibre22">_changes</tt> usage via Clojure might be using Clutch’s <tt class="calibre22">watch-changes</tt> function to echo all change notifications to <tt class="calibre22">*out*</tt>. Here, we’ll create a new database for our <tt class="calibre22">_changes</tt> experimentation, set up a Clutch watch function for that database, and add a few documents to see what happens:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(clutch/create-database "changes")<br class="calibre33"/>(clutch/watch-changes "changes" :echo (partial println "changes:"))         </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/><br class="calibre33"/>(clutch/bulk-update "changes" [{:_id "doc1"} {:_id "doc2"}])                </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= [{:id "doc1", :rev "5-f36e792166"}<br class="calibre33"/>;=  {:id "doc2", :rev "3-5570e8bbb3"}]<br class="calibre33"/>; change: {:seq 7, :id doc1, :changes [{:rev 5-f36e792166}]}<br class="calibre33"/>; change: {:seq 8, :id doc2, :changes [{:rev 3-5570e8bbb3}]}<br class="calibre33"/>(clutch/delete-document "changes" (zipmap [:_id :_rev]<br class="calibre33"/>                                    ((juxt :id :rev) (first *1))))<br class="calibre33"/>;= {:ok true, :id "doc1", :rev "6-616e3df68"}<br class="calibre33"/>; change: {:seq 9, :id doc1, :changes [{:rev 6-616e3df68}], :deleted true}<br class="calibre33"/>(clutch/stop-changes "changes" :echo)                                       </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Register a new watch function with the name <tt class="calibre22">:echo</tt> on the <tt class="calibre22">changes</tt> database; this one will just echo <tt class="calibre22">_changes</tt> notifications to <tt class="calibre22">*out*</tt>.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">We’ll now be notified of all changes made in the database we’re watching; these notifications correspond to calls to the echo function we registered.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">stop-changes</tt> will unsubscribe our watch function from the database’s <tt class="calibre22">_changes</tt> feed.</blockquote><p class="calibre18">This mechanism is exactly analogous to the watches<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1861662"></a><a href="#filepos1864448"><span class="calibre32">386</span></a><span class="calibre32">]</span></small></sup> that are available for Clojure-native reference types such as atoms, vars, refs, and agents. Conceptually, each CouchDB database is contained within a separate atom; when a change is made to the database, that change is sent off to an agent associated with your <tt class="calibre22">watch-changes</tt> call.</p><p class="calibre18">In addition, CouchDB allows for the definition of “filter” functions <a id="filepos1862153"></a>that allows you to opt into a programmatic filtering of the documents that will be included in the feed of changes delivered by <tt class="calibre22">_changes</tt>. These filter functions can be defined using any language—just as with view functions—and their application can be parameterized when you start receiving notifications from <tt class="calibre22">_changes</tt> via Clutch’s <tt class="calibre22">watch-changes</tt>, as we’ll see shortly.</p><p class="calibre18">The possibilities for building very flexible event-driven applications using these facilities are quite boundless. From a systems perspective, the fact that CouchDB effectively serves as both a message queue (or perhaps more precisely, provides a superset of event queue functionality) and your likely primary data store (or “system of record” in data warehousing parlance), has a variety of attractive characteristics as well, including:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">The lack of any synchronization overhead or impedance mismatch between a primary database and a separate dedicated message queue (such as RabbitMQ, ActiveMQ, or one of the various JMS implementations).</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Simplified operational considerations: all things being equal, running one system is always easier than running two.</blockquote></li></ul><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Just because you </span><span class="calibre10"><span class="italic">can</span></span><span class="calibre10"> use CouchDB as the basis for a bespoke message queue does not mean that you </span><span class="calibre10"><span class="italic">should</span></span><span class="calibre10">; with great power comes great responsibility, and all that. Off-the-shelf message queues are extraordinarily good at what they do, and they address many common use cases very well. That said, it is our opinion that a savvy practitioner should always be on the watch for alternatives that might solve unique problems elegantly or typical problems more simply.</span></blockquote><br class="calibre33"/><hr class="calibre34"/><p class="calibre25"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1864448"></a><a href="#filepos1861662"><span class="calibre32">386</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="#filepos655851"><span class="calibre10"><span class="calibre5">Watches</span></span></a><span class="calibre10"> for more details on watches.</span></p><div class="mbppagebreak"></div><p id="filepos1864725" class="calibre6"><span class="calibre4"><span class="bold">À la Carte Message Queues</span></span></p><p id="filepos1864812" class="calibre18">Let’s combine all of what we’ve learned about how to effectively use CouchDB from Clojure to implement an asynchronous work queue based on the events being emitted into the <span class="italic">logging</span> database <a id="filepos1865041"></a>we considered earlier. First, a refresher on what that data looks like:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 15-4. Sample event data</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">{:evt-type "auth/new-user" :username "Chas"}<br class="calibre33"/>{:evt-type "auth/new-user" :username "Dave"}<br class="calibre33"/>{:evt-type "sales/purchase" :username "Chas" :products ["widget1"]}<br class="calibre33"/>{:evt-type "sales/purchase" :username "Robin" :products ["widget14"]}<br class="calibre33"/>{:evt-type "sales/RFQ" :username "Robin" :budget 20000}</tt></span></p><p class="calibre13">Now, you could add a single watch for changes in the <span class="italic">logging</span> database, and instead of echoing those events to <tt class="calibre22">*out*</tt>, do something useful with them; that’s a perfectly valid thing to do, especially if your requirements are relatively simple. However, most real-world systems need some additional levers to pull to control event processing loads and more ably support modular design requirements.</p><p class="calibre18">We can assume that our typical website or application will be generating all sorts of events; some will only need to be retained for some period of time, some will need to go into a long-term archive, and others will need to be acted upon as soon as possible. Earlier, we defined a hierarchy over the concrete event types in our sample dataset. Let’s now build a parallel hierarchy that defines how different types of events should be consumed:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 15-5. Defining a partial event processing hierarchy</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(ns eventing.processing)<br class="calibre33"/><br class="calibre33"/>(derive 'sales/lead-generation 'processing/realtime)<br class="calibre33"/>(derive 'sales/purchase 'processing/realtime)<br class="calibre33"/><br class="calibre33"/>(derive 'security/all 'processing/archive)<br class="calibre33"/>(derive 'finance/all 'processing/archive)</tt></span></p><blockquote class="calibre89"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Take note that three of the four declarations here make no reference to concrete event types at all, but the hierarchies that are rooted at our processing “levels” fully apply to them nonetheless by dint of the relationships we defined earlier between the concrete event types and our broader event type categories (such as </span><span class="calibre10"><tt class="calibre22">'security/all</tt></span><span class="calibre10">). In our example, this saves a fair bit of typing, but the real win comes when multiple teams are independently building separate modules or applications that are all emitting event data: each team can maintain its own event type hierarchies (representing functional, business, or organizational relationships as necessary) without necessarily coordinating with whomever is writing the module(s) or application(s) that will be coordinating the processing of those events.</span></blockquote><p class="calibre25">We can now create a <tt class="calibre22">_changes</tt> filter that will allow us to select events whose type <tt class="calibre22">isa?<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1868236"></a><a href="#filepos1877535"><span class="calibre32">387</span></a><span class="calibre32">]</span></small></sup></tt> is another type that we’ve defined:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 15-6. Creating a message-type _changes filter</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(clutch/save-filter "logging" "event-filters"<br class="calibre33"/>  (clutch/view-server-fns :clojure<br class="calibre33"/>    {:event-isa? (do<br class="calibre33"/>                   (require '[eventing types processing])<br class="calibre33"/>                   (fn [doc request]<br class="calibre33"/>                     (let [req-type (-&gt; request :query :type)<br class="calibre33"/>                           evt-type (:evt-type doc)]<br class="calibre33"/>                       (and req-type evt-type<br class="calibre33"/>                         (isa? (symbol evt-type) (symbol req-type))))))}))</tt></span></p><p class="calibre13">This filter is parameterized (note the usage of the query param held by the <tt class="calibre22">request</tt> object), so we can pick and choose which events to be included in the stream delivered from <tt class="calibre22">_changes</tt> based on the hierarchies we’ve defined. Before we go any further, let’s echo <tt class="calibre22">_changes</tt> again, but with some additions:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(clutch/watch-changes "logging" :echo-leads (partial println "change:") </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  :filter "event-filters/event-isa?"                                    </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  :type "sales/lead-generation"                                         </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  :include_docs true)                                                   </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/><br class="calibre33"/>(clutch/put-document "logging"                                          </tt></span><a></a><img src="images/00001.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  {:evt-type "sales/RFQ" :username "Lilly" :budget 20000})<br class="calibre33"/>;= {:_id "8f264da359f887ec3e86c8d34801704b",<br class="calibre33"/>;=  :_rev "1-eb10044985c9dccb731bd5f31d0188c6",<br class="calibre33"/>;=  :budget 20000, :evt-type "sales/RFQ", :username "Lilly"}<br class="calibre33"/>; change: {:seq 26, :id 8f264da359f887ec3e86c8d34801704b,               </tt></span><a></a><img src="images/00015.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;          :changes [{:rev 1-eb10044985c9dccb731bd5f31d0188c6}],<br class="calibre33"/>;          :doc {:_id 8f264da359f887ec3e86c8d34801704b,<br class="calibre33"/>;                :_rev 1-eb10044985c9dccb731bd5f31d0188c6,<br class="calibre33"/>;                :budget 20000,<br class="calibre33"/>;                :evt-type sales/RFQ,<br class="calibre33"/>;                :username Lilly}}<br class="calibre33"/>(clutch/stop-changes "logging" :echo-leads)<br class="calibre33"/>;= nil</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Similar to before, we’ll watch for changes on the <span class="italic">logging</span> database…</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">…specifying our hierarchy-aware filter…</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">…parameterizing that filter so that only changes to lead-generation events are emitted…</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">…and requesting that the full contents of documents are included in the change notification objects, rather than the default of only their <tt class="calibre22">:_id</tt> and <tt class="calibre22">:_rev</tt> slots.</blockquote><p class="calibre23"><img src="images/00001.jpg" class="calibre36"/></p><blockquote class="calibre37">When we create a new document, with an <tt class="calibre22">:evt-type</tt> that is a descendant of our specified lead-generation type…</blockquote><p class="calibre23"><img src="images/00015.jpg" class="calibre36"/></p><blockquote class="calibre37">…our watch receives the notification as we’d expect, along with the full content of the associated event.</blockquote><p class="calibre18">This is all driven by the fact that, thanks to the hierarchies we’ve defined, <tt class="calibre22">(isa? 'sales/RFQ 'sales/lead-generation)</tt> returns true in our filter.</p><p class="calibre18">We can set up as many database watches as we need to correspond with various service or event priority levels, or simply to meet processing demands (especially if the processing involved is idempotent). Each watch serves as a discrete queue, at least from our application’s perspective. And, again enabled by the hierarchies, processing implementations can be contributed by any number of potentially domain-specific modules.</p><p class="calibre18">Let’s implement such a system. First, we define a multimethod<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1874061"></a><a href="#filepos1877917"><span class="calibre32">388</span></a><span class="calibre32">]</span></small></sup> in some central location:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(ns eventing.processing)<br class="calibre33"/><br class="calibre33"/>(defmulti process-event :evt-type)</tt></span></blockquote><p class="calibre23">Then, we add <tt class="calibre22">process-event</tt> implementations as necessary, aligned with the hierarchies we’ve defined. At this point, all of the facilities of multimethods are available to us. Our <tt class="calibre22">process-event</tt> implementations simply echo some descriptive text to <tt class="calibre22">*out*</tt>; of course, real implementations of such methods would do something far more substantial: for our scenario, they’d send an invoice, cause product to be drop-shipped, add a lead to a CRM system, and so on.</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 15-7. Implementing processing of sales-related “realtime” events</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(ns salesorg.event-handling<br class="calibre33"/>  (use [eventing.processing :only (process-event)]))<br class="calibre33"/><br class="calibre33"/>(defmethod process-event 'sales/purchase<br class="calibre33"/>  [evt]<br class="calibre33"/>  (println (format "We made a sale of %s to %s!" (:products evt) (:username evt))))<br class="calibre33"/><br class="calibre33"/>(defmethod process-event 'sales/lead-generation<br class="calibre33"/>  [evt]<br class="calibre33"/>  (println "Add prospect to CRM system: " evt))</tt></span></p><p class="calibre13">Finally, we can set up our watch, which will drive the processing of each event, after pulling out the actual document that triggered the event in the first place, removing the CouchDB-specific <tt class="calibre22">:_id</tt> and <tt class="calibre22">:_rev</tt> slots, and converting the concrete <tt class="calibre22">:evt-type</tt> string into a symbol so its dispatch within the <tt class="calibre22">process-event</tt> multimethod is driven by the hierarchy we’ve built up and not the strings returned to us by CouchDB. We’ll do that at the REPL here, and then again recreate the five events we’ve been looking at:<a id="filepos1876087"></a></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(require 'eventing.processing 'salesorg.event-handling)<br class="calibre33"/><br class="calibre33"/>(clutch/watch-changes "logging" :process-events<br class="calibre33"/>  #(-&gt; %<br class="calibre33"/>     :doc<br class="calibre33"/>     (dissoc :_id :_rev)<br class="calibre33"/>     (update-in [:evt-type] symbol)<br class="calibre33"/>     eventing.processing/process-event)<br class="calibre33"/>  :filter "event-filters/event-isa?"<br class="calibre33"/>  :type "processing/realtime"<br class="calibre33"/>  :include_docs true)<br class="calibre33"/><br class="calibre33"/>(clutch/bulk-update "logging"<br class="calibre33"/>  [{:evt-type "auth/new-user" :username "Chas"}<br class="calibre33"/>   {:evt-type "auth/new-user" :username "Dave"}<br class="calibre33"/>   {:evt-type "sales/purchase" :username "Chas" :products ["widget1"]}<br class="calibre33"/>   {:evt-type "sales/purchase" :username "Robin" :products ["widget14"]}<br class="calibre33"/>   {:evt-type "sales/RFQ" :username "Robin" :budget 20000}])<br class="calibre33"/>; Add prospect to CRM system:  {:evt-type auth/new-user, :username Chas}<br class="calibre33"/>; Add prospect to CRM system:  {:evt-type auth/new-user, :username Dave}<br class="calibre33"/>; We made a sale of ["widget1"] to Chas!<br class="calibre33"/>; We made a sale of ["widget14"] to Robin!<br class="calibre33"/>; Add prospect to CRM system:  {:budget 20000, :evt-type sales/RFQ, :username Robin}</tt></span></blockquote><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1877535"></a><a href="#filepos1868236"><span class="calibre32">387</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="#filepos1073489"><span class="calibre10"><span class="calibre5">Chapter 7</span></span></a><span class="calibre10"> for details of </span><span class="calibre10"><tt class="calibre22">isa?</tt></span><span class="calibre10"> semantics.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1877917"></a><a href="#filepos1874061"><span class="calibre32">388</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="#filepos1073489"><span class="calibre10"><span class="calibre5">Chapter 7</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos1878169" class="calibre6"><span class="calibre4"><span class="bold">Final Thoughts</span></span></p><p class="calibre18">Clojure and CouchDB are both well-suited to dealing with heterogeneous, loosely structured datasets—a defining characteristic of dynamic, prototype-driven, ready-fire-aim development processes as well as an often much-needed salve for applications needing to integrate well with unchangeable legacy systems. Together, they are a potent combination, with Clojure bringing a great deal to the table in terms of maximizing the utility of CouchDB’s views and filters and providing a number of facilities that enable you to make the most of CouchDB’s features, model, and extensibility.<a id="filepos1878859"></a></p><div class="mbppagebreak"></div><p id="filepos1878886" class="calibre6"><span class="calibre2"><span class="bold">Chapter 16. Clojure and the Web</span></span></p><p id="filepos1878980" class="calibre13">Web development can easily be considered the ubiquitous domain: with rare exception, if you are a programmer today, not only do you know how to build web applications, you probably build or work on them regularly. This being the case, any ostensibly general-purpose language had better offer a compelling workflow and set of tools for building web apps. Clojure clears that bar handily.</p><p class="calibre18">Being hosted on the JVM and sporting excellent interop features, Clojure didn’t have to start from scratch with bare sockets or an Apache module: all the good parts of the battle-tested array of Java web infrastructure was waiting to be leveraged. At the same time, the Clojure ecosystem has evolved its own set of idioms and principles of good web app architecture that contrasts significantly with typical Java practice.</p><p id="filepos1879854" class="calibre6"><span class="calibre4"><span class="bold">The “Clojure Stack”</span></span></p><p id="filepos1879938" class="calibre18">We’ve consistently repeated the mantra of good Clojure design: emphasizing common abstractions over concrete types and implementation details, pure functions with immutable data over side-effecting methods with mutable state, and the flexible assembly of these fundamentals into composites that are themselves reliable building blocks. It should then come as no surprise that there is no definitive “Clojure stack,” at least compared to the monolithic framework bonanza that often constitutes web “stacks” in other languages. Instead, the Clojure community has grown a number of modular libraries over the years that collectively satisfy all of the requirements of the web developer, but that leverage Clojure’s fundamental abstractions and emphasis on functional programming. You and your team can use those parts to build a stack that works for you and your applications, domain, and personal style and skills.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1880925"></a><a href="#filepos1884773"><span class="calibre32">389</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">This philosophy may seem counterintuitive to many experienced Rails, Django, or Lift developers. The features that are in such “complete stacks” are there for a reason: people tend to re-implement them if they’re not there. However, given the context these frameworks operate within—full of object-oriented models with explicit controllers and views—there are few common abstractions, so effectively and efficiently composing small focused modules is often nigh on impossible. Given how easy this is in Clojure, such towering frameworks just don’t save as much work as they do elsewhere. In short, if you’re used to a fuller stack, try to keep an open mind until you’ve worked through a few apps; we suspect you’ll not find a lot to want for.</p><p class="calibre18">We’ll talk about web applications in three parts,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1881930"></a><a href="#filepos1885189"><span class="calibre32">390</span></a><span class="calibre32">]</span></small></sup> where each piece can be addressed by a different library (often chosen from a number of options):</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Request and response plumbing are those bits that either run an HTTP server or hook your application up to one, build request objects corresponding to incoming requests, and then produce an HTTP response as required.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Routing is how requests get to the handler code you designate.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Templating is how the response your handler produces is serialized to HTML (or whichever output media type you require).</blockquote></li></ul><p class="calibre18">What we’d like to show you is one particularly popular combination of libraries:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Ring for the foundational request and response plumbing</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Compojure for routing</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Enlive for templating</blockquote></li></ul><p class="calibre18">Others quite happily mix and match other options to suit particular requirements or personal taste. Moustache<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1883562"></a><a href="#filepos1885744"><span class="calibre32">391</span></a><span class="calibre32">]</span></small></sup> is another good option for routing. For templating, Hiccup<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1883751"></a><a href="#filepos1886066"><span class="calibre32">392</span></a><span class="calibre32">]</span></small></sup> is a popular choice, clostache<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1883912"></a><a href="#filepos1886671"><span class="calibre32">393</span></a><span class="calibre32">]</span></small></sup> borrows the Mustache<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1884063"></a><a href="#filepos1886987"><span class="calibre32">394</span></a><span class="calibre32">]</span></small></sup> templating style available in many other languages’ frameworks, and it’s even straightforward to use things like JSPs, Velocity, stringtemplate, or other libraries from the pure Java web space.</p><p class="calibre18">If after trying the constellation we demonstrate here you’d like to explore some of these other options, a good starting point for comparing them is <a href="http://brehaut.net/blog/2011/ring_introduction"><span class="calibre5">http://brehaut.net/blog/2011/ring_introduction</span></a>.</p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1884773"></a><a href="#filepos1880925"><span class="calibre32">389</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Alternatively, you can start with one of the newer “batteries-included” web frameworks that have emerged of late; we mention these at the </span><a href="#filepos1987734"><span class="calibre10">end of the chapter</span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1885189"></a><a href="#filepos1881930"><span class="calibre32">390</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">There can certainly be more or less depending on your requirements, to address authentication, form validation, content negotiation, and on and on. There are quality Clojure libraries for all of these requirements, but covering all of the nooks and crannies of web development would require a separate book. For now, we’d just like to get you started down a good path.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1885744"></a><a href="#filepos1883562"><span class="calibre32">391</span></a><span class="calibre32">] </span></small></sup><a href="https://github.com/cgrand/moustache"><span class="calibre10"><span class="calibre5">https://github.com/cgrand/moustache</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1886066"></a><a href="#filepos1883751"><span class="calibre32">392</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Available at </span><a href="https://github.com/weavejester/hiccup"><span class="calibre10"><span class="calibre5">https://github.com/weavejester/hiccup</span></span></a><span class="calibre10">. To get an immediate flavor for Hiccup, look at </span><a href="#filepos1733007"><span class="calibre10"><span class="calibre5">Growing an HTML DSL</span></span></a><span class="calibre10"> again, where we reimplemented a naive subset of it as an exercise in testing.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1886671"></a><a href="#filepos1883912"><span class="calibre32">393</span></a><span class="calibre32">] </span></small></sup><a href="https://github.com/fhd/clostache"><span class="calibre10"><span class="calibre5">https://github.com/fhd/clostache</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1886987"></a><a href="#filepos1884063"><span class="calibre32">394</span></a><span class="calibre32">] </span></small></sup><a href="http://mustache.github.com/"><span class="calibre10"><span class="calibre5">http://mustache.github.com/</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos1887246" class="calibre6"><span class="calibre4"><span class="bold">The Foundation: Ring</span></span></p><p id="filepos1887327" class="calibre18">As you’ve seen throughout this book, Clojure excels at data transformation. However, we are actually most fortunate when there is no need for a transformation to occur: that is, when a suitable format exists for your domain, don’t go out of your way to invent a new one. In that spirit, and with some inspiration from Python’s WSGI and Ruby’s Rack, Ring’s<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1887757"></a><a href="#filepos1916131"><span class="calibre32">395</span></a><span class="calibre32">]</span></small></sup> SPEC<a id="filepos1887857"></a> defines a standard data schema to represent web requests and responses using Clojure data structures, and a couple of key architectural concepts based on function composition: <span class="italic">adapters</span>, <span class="italic">handlers</span>, and <span class="italic">middleware</span>.</p><p class="calibre18">Understanding the Ring SPEC<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1888191"></a><a href="#filepos1916447"><span class="calibre32">396</span></a><span class="calibre32">]</span></small></sup> is crucial to being able to effectively build web applications in Clojure. We’ll explore each of its aspects here, including some parts of the SPEC verbatim as appropriate.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1888496"></a><a href="#filepos1916832"><span class="calibre32">397</span></a><span class="calibre32">]</span></small></sup> We encourage you to read the Ring SPEC in its entirety at least once, and keep it close at hand as you learn to work with the data and abstractions it defines.</p><p id="filepos1888755" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Requests and Responses</span></span></span></p><p id="filepos1888867" class="calibre18">Whereas many other frameworks define fixed APIs for accessing web request data—like the requested URI, request headers, query and post parameters, body content, and so on—and still other APIs for sending web responses, Ring represents both requests and responses as regular Clojure maps. In both cases, these maps must contain certain slots, may contain others, and can be used to hold any other data you require in the course of processing them.</p><p class="calibre18">Ring request maps (<a href="#filepos1889531"><span class="calibre5">Table 16-1</span></a>) contain these keys (optional slots <tt class="calibre22"><span class="italic">italicized</span></tt>).</p><p id="filepos1889531" class="calibre3"></p><p class="calibre1"><span class="italic">Table 16-1. Ring request maps</span></p><table border="1" valign="top" class="calibre40"><tr border="1" valign="top" class="calibre27"><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Key </span></span></span></th><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Description of value </span></span></span></th></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">:server-port</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">The port on which the request is being handled. </span></p></td></tr><a id="filepos1890436"></a><tr border="1" valign="top" class="calibre43"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">:server-name</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">The resolved server name, or the server IP address as a string. </span></p></td></tr><a id="filepos1890920"></a><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">:remote-addr</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">The IP address of the client or the last proxy that sent the request. </span></p></td></tr><a id="filepos1891414"></a><tr border="1" valign="top" class="calibre43"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">:uri</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">The request URI, as a string. Must start with “/”. </span></p></td></tr><a id="filepos1891881"></a><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">:scheme</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">The transport protocol, must be one of  </span><span class="calibre21"><tt class="calibre22">:http</tt></span><span class="calibre21"> or </span><span class="calibre21"><tt class="calibre22">:https</tt></span><span class="calibre21">.</span></p></td></tr><a id="filepos1892462"></a><tr border="1" valign="top" class="calibre43"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">:request-method</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">The HTTP request method, must be one of  </span><span class="calibre21"><tt class="calibre22">:get</tt></span><span class="calibre21">, </span><span class="calibre21"><tt class="calibre22">:head</tt></span><span class="calibre21">, </span><span class="calibre21"><tt class="calibre22">:options</tt></span><span class="calibre21">, </span><span class="calibre21"><tt class="calibre22">:put</tt></span><span class="calibre21">, </span><span class="calibre21"><tt class="calibre22">:post</tt></span><span class="calibre21">, or </span><span class="calibre21"><tt class="calibre22">:delete</tt></span><span class="calibre21">.</span></p></td></tr><a id="filepos1893291"></a><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">:headers</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">A Clojure map of downcased header name Strings to corresponding header value Strings. </span></p></td></tr><a id="filepos1893797"></a><tr border="1" valign="top" class="calibre43"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22"><span class="italic">:content-type</span></tt></span><span class="calibre21"><span class="italic">
</span></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">The MIME type of the request body as a string, if known. </span></p></td></tr><a id="filepos1894312"></a><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22"><span class="italic">:content-length</span></tt></span><span class="calibre21"><span class="italic">
</span></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">The number of bytes in the request body, if known. </span></p></td></tr><a id="filepos1894827"></a><tr border="1" valign="top" class="calibre43"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22"><span class="italic">:character-encoding</span></tt></span><span class="calibre21"><span class="italic">
</span></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">The name of the character encoding used in the request body as a string, if known. </span></p></td></tr><a id="filepos1895374"></a><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22"><span class="italic">:query-string</span></tt></span><span class="calibre21"><span class="italic">
</span></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">The query string, if present. </span></p></td></tr><a id="filepos1895866"></a><tr border="1" valign="top" class="calibre43"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22"><span class="italic">:body</span></tt></span><span class="calibre21"><span class="italic">
</span></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">A  </span><span class="calibre21"><tt class="calibre22">java.io.InputStream</tt></span><span class="calibre21"> for the request body, if present.</span></p></td></tr><a id="filepos1896425"></a></table><p class="calibre23">This schema encapsulates the fundamental data associated with a single HTTP request. For example, say you tried to access the URL <span class="italic">https://company.com:8080/accounts?q=Acme</span>; the corresponding Ring request map would look something like this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">{:remote-addr "127.0.0.1",<br class="calibre33"/> :scheme :http,<br class="calibre33"/> :request-method :get,<br class="calibre33"/> :query-string "q=Acme",<br class="calibre33"/> :content-type nil,<br class="calibre33"/> :uri "/accounts",<br class="calibre33"/> :server-name "company.com",<br class="calibre33"/> :content-length nil,<br class="calibre33"/> :server-port 8080,<br class="calibre33"/> :body #&lt;ByteArrayInputStream java.io.ByteArrayInputStream@604fd0e9&gt;,  </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/> :headers<br class="calibre33"/> {"user-agent" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6) Firefox/8.0.1",<br class="calibre33"/>  "accept-charset" "ISO-8859-1,utf-8;q=0.7,*;q=0.7",<br class="calibre33"/>  "accept" "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",<br class="calibre33"/>  "accept-encoding" "gzip, deflate",<br class="calibre33"/>  "accept-language" "en-us,en;q=0.5",<br class="calibre33"/>  "connection" "keep-alive"}}</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Because this is a simple <tt class="calibre22">GET</tt> request, the <tt class="calibre22">:body</tt>
<tt class="calibre22">InputStream</tt> will be empty; thus, both <tt class="calibre22">:content-type</tt> and <tt class="calibre22">:content-length</tt> are <tt class="calibre22">nil</tt>.</blockquote><p class="calibre18">This is a regular Clojure map, and can be processed and augmented just like every other map you’ve seen.</p><p class="calibre18">Likewise, Ring responses are also maps (<a href="#filepos1898353"><span class="calibre5">Table 16-2</span></a>); they require only two slots, and an optional <tt class="calibre22">:body</tt>.</p><p id="filepos1898353" class="calibre3"></p><p class="calibre1"><span class="italic">Table 16-2. Ring response maps</span></p><table border="1" valign="top" class="calibre40"><tr border="1" valign="top" class="calibre27"><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Key </span></span></span></th><th valign="top" class="calibre41"><span class="calibre21"><span class="bold"><span class="calibre7"> Description of value </span></span></span></th></tr><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">:status</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">The HTTP status code, must be greater than or equal to 100. </span></p></td></tr><a id="filepos1899266"></a><tr border="1" valign="top" class="calibre43"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22">:headers</tt></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">A Clojure map of HTTP header names to header values. These values may be either Strings, in which case one name/value header will be sent in the HTTP response, or a seq of Strings, in which case a name/value header will be sent for each such String value. </span></p></td></tr><a id="filepos1899938"></a><tr border="1" valign="top" class="calibre27"><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">  </span><span class="calibre21"><tt class="calibre22"><span class="italic">:body</span></tt></span><span class="calibre21"><span class="italic">
</span></span><span class="calibre21">
</span></p></td><td border="1" valign="top" class="calibre28"><span class="calibre21"> </span><p class="calibre42"><span class="calibre21">Optionally a String, a Clojure sequence of strings, a  </span><span class="calibre21"><tt class="calibre22">java.io.File</tt></span><span class="calibre21">, or a </span><span class="calibre21"><tt class="calibre22">java.io.InputStream</tt></span><span class="calibre21">.</span></p></td></tr><a id="filepos1900592"></a></table><p class="calibre23">Perhaps now you can start to see the outlines of how web requests are handled with Ring: your code will take whatever actions are appropriate for a given request map and return a suitable response map. For example, the preceding <tt class="calibre22">GET</tt> request we considered might reasonably evoke a page of HTML from a web application; this response would look something like this:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">{:status 200<br class="calibre33"/> :headers {"Content-Type" "text/html"}<br class="calibre33"/> :body "&lt;html&gt;...&lt;/html&gt;"}</tt></span></blockquote><p class="calibre23">Alternatively, we can provide other types of response <tt class="calibre22">:body</tt>; if a response should correspond to a static file we have on disk, we can provide that directly:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">{:status 200<br class="calibre33"/> :headers {"Content-Type" "image/png"}<br class="calibre33"/> :body (java.io.File. "/path/to/file.png")}</tt></span></blockquote><p class="calibre23">Finally, as we’ll see in detail later, Ring is entirely capable of servicing HTTP API calls that don’t necessarily require a body. If an HTTP <tt class="calibre22">PUT</tt> request was received to upload a file, an appropriate response might be to indicate that it was accepted and the corresponding server-side resource was created by simply returning a 201 HTTP status code:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">{:status 201 :headers {}}</tt></span></blockquote><p class="calibre23">At this point, you might reasonably wonder how we get ahold of these maps that represent requests, and how we get our web servers to turn Ring response maps into proper HTTP responses. That particular piece of glue is provided by an <span class="italic">adapter</span>.</p><p id="filepos1902382" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Adapters</span></span></span></p><p id="filepos1902480" class="calibre18">A Ring adapter provides a bridge between a Ring application and the local implementation details of the HTTP protocol and/or server. In short, when an HTTP request is received, an adapter deconstructs it into a request map and passes it to the Ring application to be processed. That invocation must return a response map, which the adapter uses to send an HTTP response back to the client.</p><p class="calibre18">You’ll likely never need to write your own adapter, but it’s important to know how they fit into the overall Ring architecture. Many adapter implementations exist, allowing Ring applications to sit behind various different HTTP servers and HTTP APIs:</p><p class="calibre18"><span class="bold">Servlets</span>. <a id="filepos1903233"></a>Ring itself includes an adapter that allows Ring applications to surface as Java servlets, suitable for deployment into any Java web application server. This is discussed in more detail in <a href="#filepos2000202"><span class="calibre5">Web Application Packaging</span></a>.</p><p class="calibre18"><span class="bold">ring-jetty-adapter</span>. <a id="filepos1903570"></a>Also included with Ring is the <tt class="calibre22">ring-jetty-adapter</tt>, an adapter that uses an embedded Jetty (<a href="http://jetty.codehaus.org/jetty/"><span class="calibre5">http://jetty.codehaus.org/jetty/</span></a>) HTTP server to service requests. This is the most common way to run Ring applications, and we’ll see it in action shortly.</p><p class="calibre18"><span class="bold">ring-httpcore-adapter</span>. <a id="filepos1903974"></a>This adapter (<a href="https://github.com/mmcgrana/ring-httpcore-adapter"><span class="calibre5">https://github.com/mmcgrana/ring-httpcore-adapter</span></a>) is very similar to <tt class="calibre22">ring-jetty-adapter</tt>, but uses an embedded Apache HTTPCore server instead of Jetty.</p><p class="calibre18"><span class="bold">Aleph</span>. <a id="filepos1904295"></a>If you get the impression that Ring is <span class="italic">really</span> lightweight, you’d be right. In fact, the core contribution of Ring is not any of its particular implementations of anything (which are, indeed, slight); rather, it is the well-considered definition of the request/response data schema and key concepts of <span class="italic">adapters</span>, <span class="italic">middleware</span>, and <span class="italic">handlers</span> that makes it important. Indeed, thanks to these abstractions, Ring—the canonical implementation of which is fundamentally synchronous in nature to suit the synchronous nature of most web applications—can itself be swapped out for other Ring-compatible implementations. A notable example is Aleph,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1905004"></a><a href="#filepos1917095"><span class="calibre32">398</span></a><span class="calibre32">]</span></small></sup> which offers a Ring-compatible adapter that uses Netty<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1905189"></a><a href="#filepos1917413"><span class="calibre32">399</span></a><span class="calibre32">]</span></small></sup> to serve responses to clients <span class="italic">asynchronously</span>, without requiring any changes to your Ring application.</p><p class="calibre18">Other adapters have also been written to bridge Ring applications to, for example, Mongrel and FastCGI-capable servers.</p><p class="calibre18">Now we are ready to look at the part that does the “real” work in a Ring application, <span class="italic">handlers</span>, and how we can bring them together with our preferred adapter to start building web apps.</p><p id="filepos1905776" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Handlers</span></span></span></p><p id="filepos1905874" class="calibre18">A Ring handler is just a function that accepts a request map and returns a response map. All Ring applications consist of a bunch of handler functions, chained and composed and delegated to as necessary to support the desired behavior and functionality.</p><p class="calibre18">Let’s start with a simple echo server. First, add a dependency for Ring to a project:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1906309"></a><a href="#filepos1917717"><span class="calibre32">400</span></a><span class="calibre32">]</span></small></sup></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">[ring "1.0.0"]</tt></span></blockquote><p class="calibre23">Now we can fire up a REPL<a id="filepos1906557"></a> and write a web app:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 16-1. Starting a Ring application from the REPL</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(use '[ring.adapter.jetty :only (run-jetty)])<br class="calibre33"/>;= nil<br class="calibre33"/>(defn app                                                 </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  [{:keys [uri]}]<br class="calibre33"/>  {:body (format "You requested %s" uri)})<br class="calibre33"/>;= #'user/app<br class="calibre33"/>(def server (run-jetty #'app {:port 8080 :join? false}))  </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #'user/server                                          </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/></p><p class="calibre101"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Our handler function. All handlers take a single Ring request map argument, and must return a Ring response map. To start, we’re simply echoing back the URI of the request as plain text.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">We’re using the Jetty adapter. All adapters are implemented as a function that takes two arguments: the Ring handler function to use to service requests, and a map of options for the adapter. Here we’re requesting that Jetty run on port <tt class="calibre22">8080</tt>, and that we should not “join” on the thread that Jetty will use; not specifying this would cause our REPL to block waiting for the Jetty server to shut down.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">We opted to retain a reference to the Jetty server in the <tt class="calibre22">server</tt> var. This gives us the option (if we so choose) to stop the Jetty server by calling <tt class="calibre22">(.stop server)</tt>.</blockquote><p class="calibre18">We can now visit our running Ring web app:</p><p class="calibre51"><img src="images/00048.jpg" class="calibre119"/></p><p class="calibre13">That’s nice, but notice that the URI does not include our query parameters, <tt class="calibre22">?at=world</tt>. Because we started the Jetty adapter with our handler’s var (i.e., <tt class="calibre22">#'app</tt>) rather than passing our handler function itself, we can readily redefine the handler without restarting Jetty:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn app<br class="calibre33"/>  [{:keys [uri query-string]}]<br class="calibre33"/>  {:body (format "You requested %s with query %s" uri query-string)})<br class="calibre33"/>;= #'user/app</tt></span></blockquote><p class="calibre23">The results are immediately available:</p><p class="calibre51"><img src="images/00010.jpg" class="calibre120"/></p><p class="calibre13">Surely we can do better than that, though. It would be quite horrible to have to pick apart query parameters ourselves from a string. However, the Ring SPEC for request maps doesn’t say anything about query and form parameters being available in any other form.</p><p class="calibre18">Thankfully, we’re far from being stuck. A particular bit of Ring <span class="italic">middleware</span> addresses this common requirement.</p><p id="filepos1910180" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Middleware</span></span></span></p><p id="filepos1910280" class="calibre18">Middleware is any enhancement or modification of the effect of handlers. Remember that, because Ring requests and responses are Clojure maps, they can be transformed readily, and since handlers are just functions, it is trivial to produce composites of different functions to yield aggregate behavior. This typically manifests in middleware as a higher-order function that accepts one or more handlers (maybe with some configuration), which returns a new handler with whatever composite functionality is desired.</p><p class="calibre18">Let’s make that really concrete. As we just saw, Ring requests do not by default contain any kind of structured representation of query parameters. We can change this by adding a bit of middleware to our application; it is the middleware that will decorate the original request map it receives from the Jetty adapter with our query parameters usefully broken down into a map:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(use '[ring.middleware.params :only (wrap-params)])<br class="calibre33"/>;= nil<br class="calibre33"/>(defn app*                                                      </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  [{:keys [uri params]}]                                        </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  {:body (format "You requested %s with query %s" uri params)})<br class="calibre33"/>;= #'user/app*<br class="calibre33"/>(def app (wrap-params app*))                                    </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= #'user/app</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">We’re now defining our handler as <tt class="calibre22">app*</tt>, so the middleware-enhanced handler can be placed in the <tt class="calibre22">app</tt> var, the one the Jetty adapter has retained.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">Instead of looking for <tt class="calibre22">:query-string</tt> in the request map, our handler now expects a value in <tt class="calibre22">:params</tt>.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">The composition of our handler and the middleware happens via a simple HOF call. A new handler is returned by <tt class="calibre22">wrap-params</tt>, which now forms the outermost layer of our application—after doing its work to parse out all of the parameters in the request’s query string and <tt class="calibre22">POST</tt> body (if any), it will call the handler function we provide with the request map, newly decorated with all of the parameters in the <tt class="calibre22">:params</tt> slot.</blockquote><p class="calibre18">Let’s take a look:</p><p class="calibre51"><img src="images/00064.jpg" class="calibre121"/></p><p class="calibre13">Fabulous, we now have parameters upon which we can base application behavior.</p><p class="calibre18">Ring includes a bunch of different bits of middleware that you can mix into your web application as desired, from parsing cookies and session data out of request headers to short-circuiting requests for static files to supporting multipart form submissions and file uploads.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1913988"></a><a href="#filepos1918266"><span class="calibre32">401</span></a><span class="calibre32">]</span></small></sup> While Ring doesn’t apply any middleware to handlers by default, some other Ring-based web frameworks do.</p><p class="calibre18">Finally, since middleware is really just a form of function composition, creating new middleware is extraordinarily easy. An example of some trivial middleware is included in <a href="#filepos1679367"><span class="calibre5">Ring</span></a>. Due to its ease of implementation and degree of flexibility, you’ll find that many extensions to Ring are implemented in terms of middleware.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Conceptually, Ring middleware is similar to Java servlet filters: both approaches allow for the post-hoc modification of web requests and responses. On the other hand, the implementation and use of middleware is staggeringly easy—just the definition and then invocation of a higher-order function—compared to the relatively maze-like adventure that is implementing the various interfaces associated with servlet filters and configuring them as necessary upon deployment. More significantly though, servlet filters often cannot be effectively composed because of conflicting custom </span><a id="filepos1915374"></a><span class="calibre10"><tt class="calibre22">ServletRequest</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">ServletResponse</tt></span><span class="calibre10"> types, and if a servlet happens to imperatively send content out the door on the wire of a </span><span class="calibre10"><tt class="calibre22">ServletResponse</tt></span><span class="calibre10">, a filter is helpless to stop it. This is where middleware shines: benefiting from the Ring model where requests and responses are immutable collections that always hew to a single common abstraction, middleware can </span><span class="calibre10"><span class="italic">always</span></span><span class="calibre10"> be composed effectively…after all, they’re just functions!</span><a id="filepos1916018"></a></blockquote><br class="calibre33"/><hr class="calibre34"/><p class="calibre25"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1916131"></a><a href="#filepos1887757"><span class="calibre32">395</span></a><span class="calibre32">] </span></small></sup><a href="https://github.com/mmcgrana/ring"><span class="calibre10"><span class="calibre5">https://github.com/mmcgrana/ring</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1916447"></a><a href="#filepos1888191"><span class="calibre32">396</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Published at </span><a href="https://github.com/mmcgrana/ring/blob/master/SPEC"><span class="calibre10"><span class="calibre5">https://github.com/mmcgrana/ring/blob/master/SPEC</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1916832"></a><a href="#filepos1888496"><span class="calibre32">397</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Ring and its SPEC are MIT-licensed, Copyright © 2009–2010 Mark McGranaghan.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1917095"></a><a href="#filepos1905004"><span class="calibre32">398</span></a><span class="calibre32">] </span></small></sup><a href="https://github.com/ztellman/aleph"><span class="calibre10"><span class="calibre5">https://github.com/ztellman/aleph</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1917413"></a><a href="#filepos1905189"><span class="calibre32">399</span></a><span class="calibre32">] </span></small></sup><a href="http://www.jboss.org/netty"><span class="calibre10"><span class="calibre5">http://www.jboss.org/netty</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1917717"></a><a href="#filepos1906309"><span class="calibre32">400</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Please don’t be spooked by the prevalence of </span><span class="calibre10"><tt class="calibre22">"1.0.0"</tt></span><span class="calibre10"> version numbers here. All of the projects mentioned have been in heavy use for many years; the </span><span class="calibre10"><tt class="calibre22">"1.0.0"</tt></span><span class="calibre10"> designation was recently bestowed on many of them all at once, in part to recognize their stability.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1918266"></a><a href="#filepos1913988"><span class="calibre32">401</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Look on Ring’s main GitHub page for a full list of included middleware: </span><a href="https://github.com/mmcgrana/ring"><span class="calibre10"><span class="calibre5">https://github.com/mmcgrana/ring</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos1918631" class="calibre6"><span class="calibre4"><span class="bold">Routing Requests with Compojure</span></span></p><p id="filepos1918723" class="calibre18">So far, we’ve defined a single function that handled all requests; aside from the simplest of applications, this will never do.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1918915"></a><a href="#filepos1951124"><span class="calibre32">402</span></a><span class="calibre32">]</span></small></sup> We want to be able to structure our applications naturally, separating logically distinct functionality into different Ring handlers in potentially different namespaces, pulling them all together in just the right arrangement. We could try to pick apart request URI strings to delegate request handling to other functions; however, just as we composed our Ring handler with some middleware to augment our application, there are better ways to achieve our ends.</p><p class="calibre18">Very simply, <span class="italic">routing</span> is the selection of a handler that should be used to respond to a web request, and <span class="italic">routes</span> are patterns of incoming request attributes that are used to drive that selection process. Abstractly, you can easily imagine defining web applications in terms of a table of routes that correspond to particular handlers defined in various namespaces (<a href="#filepos1919953"><span class="calibre5">Figure 16-1</span></a>).</p><blockquote id="filepos1919953" class="calibre47"></blockquote><blockquote class="calibre39"><img src="images/00012.jpg" class="calibre122"/></blockquote><blockquote class="calibre57"><span class="calibre10"><span class="italic"><span class="calibre7">Figure 16-1. Pairing routes up with handlers</span></span></span></blockquote><p class="calibre50">When a <tt class="calibre22">GET</tt><a id="filepos1920367"></a> request is received for the root of the application (<tt class="calibre22">/</tt>), that request will be routed to the <tt class="calibre22">homepage</tt> handler. When a <tt class="calibre22">PUT</tt><a id="filepos1920522"></a> request is received for any URI with a single segment (represented by <tt class="calibre22">:id</tt> in the diagram), that request will be routed to the <tt class="calibre22">retain</tt> handler; the same goes for any <tt class="calibre22">POST</tt> request to the root of the application, and so on.</p><p class="calibre18">Let’s build a complete web application that has routes matching the diagram in <a href="#filepos1919953"><span class="calibre5">Figure 16-1</span></a>. The result will be a simple URL-shortening HTTP service,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1921049"></a><a href="#filepos1951461"><span class="calibre32">403</span></a><span class="calibre32">]</span></small></sup> similar to bit.ly, tinyurl.com, and so on; such services allow users to specify and use shorter URLs that redirect to their canonical counterparts. To do this, we’ll use Compojure <a id="filepos1921327"></a>(<a href="https://github.com/weavejester/compojure"><span class="calibre5">https://github.com/weavejester/compojure</span></a>), the most popular library for defining <span class="italic">routes</span> for Ring applications, and one that has taken cues from the URL routing features in many frameworks you may be familiar with already, including Ruby on Rails and Django.</p><p class="calibre18">Let’s start a new REPL session with Compojure included in our project’s dependencies, which should now include both Compojure and Ring:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">[compojure "1.0.1"]<br class="calibre33"/>[ring "1.0.1"]</tt></span></blockquote><p class="calibre23">We should first consider what kind of model we should have for storing URLs and their shorter identifiers. We want to focus on building the web side of things, so let’s just keep this state in a map in memory using a reference type.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1922280"></a><a href="#filepos1952162"><span class="calibre32">404</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">Which reference types <a id="filepos1922429"></a>should we use? We’ll allow users to request the assignment of short URL identifiers, so we need to protect against conflicts where an identifier is already taken, and we need to coordinate changes to our map so that concurrent requests can’t add identically keyed entries. This calls for holding our primary mapping in a ref: each modification to the map will be performed transactionally, so we’ll be able to safely avoid clobbering already-registered identifiers, and concurrent conflicting requests (e.g., if two clients both want to register a URL for the same shorter identifier) will never produce inconsistencies in our model.</p><p class="calibre18">On the other hand, we don’t need such stringent guarantees for the automatically generated identifiers we use for when users <span class="italic">don’t</span> provide an identifier of their own. We could go with some form of hashing or random identifiers, but the easiest approach is to use an incrementing counter. An atom is the perfect candidate for maintaining that counter.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1923503"></a><a href="#filepos1952719"><span class="calibre32">405</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">So, we have our in-memory model, a counter in an atom, and a map in a ref:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(def ^:private counter (atom 0))<br class="calibre33"/><br class="calibre33"/>(def ^:private mappings (ref {}))</tt></span></blockquote><p class="calibre23">We should have a couple of dedicated functions for working with this state. Not only will they make it trivial to test our core functionality outside of a web context, if we were going to transition to building a database backend, our only work would consist of reimplementing these two functions:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn url-for<br class="calibre33"/>  [id]<br class="calibre33"/>  (@mappings id))<br class="calibre33"/><br class="calibre33"/>(defn shorten!<br class="calibre33"/> "Stores the given URL under a new unique identifier, or the given identifier<br class="calibre33"/>  if provided.  Returns the identifier as a string.<br class="calibre33"/>  Modifies the global mapping accordingly."<br class="calibre33"/> ([url]<br class="calibre33"/>  (let [id (swap! counter inc)                 </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>        id (Long/toString id 36)]              </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>    (or (shorten! url id)                      </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>        (recur url))))<br class="calibre33"/> ([url id]<br class="calibre33"/>   (dosync<br class="calibre33"/>     (when-not (@mappings id)                  </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>       (alter mappings assoc id url)<br class="calibre33"/>       id))))</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">swap!</tt> will return the new value in the <tt class="calibre22">counter</tt> atom, which is guaranteed to be unique for this invocation of <tt class="calibre22">shorten!</tt>.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">This <tt class="calibre22">Long/toString</tt> call converts the numeric ID to a base-36 string, which is much more compact for larger values than a simple base-10 <tt class="calibre22">str</tt> of the ID.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">We reuse the other arity of <tt class="calibre22">shorten!</tt> to attempt to store the automatically generated ID ⇒ URL mapping. If it fails (because the ID already exists in <tt class="calibre22">mappings</tt>), then we simply <tt class="calibre22">recur</tt> to retry.</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">When the ID we are aiming to add doesn’t exist yet, we <tt class="calibre22">assoc</tt> it with the canonical URL in the map and return the short identifier, or <tt class="calibre22">nil</tt> otherwise.</blockquote><p class="calibre18">Let’s see how well our model works:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(shorten! "http://clojurebook.com")<br class="calibre33"/>;= "1"<br class="calibre33"/>(shorten! "http://clojure.org" "clj")<br class="calibre33"/>;= "clj"<br class="calibre33"/>(shorten! "http://id-already-exists.com" "clj")<br class="calibre33"/>;= nil<br class="calibre33"/>@mappings<br class="calibre33"/>;= {"clj" "http://clojure.org", "1" "http://clojurebook.com"}</tt></span></blockquote><p class="calibre23">Looking good so far. Now let’s build out a couple of functions to handle the sorts of HTTP requests we can expect. <tt class="calibre22">retain</tt> will be the web “frontend” to <tt class="calibre22">shorten!</tt><a id="filepos1927495"></a>; it delegates the actual interaction with our mappings to <tt class="calibre22">shorten!</tt>, and returns appropriate response maps based on whether a URL (and optional provided ID) could be stored:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn retain<br class="calibre33"/>  [&amp; [url id :as args]]<br class="calibre33"/>  (if-let [id (apply shorten! args)]<br class="calibre33"/>    {:status 201                                                      </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>     :headers {"Location" id}<br class="calibre33"/>     :body (list "URL " url " assigned the short identifier " id)}    </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>    {:status 409 :body (format "Short URL %s is already taken" id)})) </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">If we successfully store a URL with a particular ID, then <tt class="calibre22">retain</tt> will return a Ring response with a <tt class="calibre22">:status</tt> of 201 (an HTTP response code indicating that a resource was successfully created), along with a <tt class="calibre22">Location</tt> header containing the stored ID (which nonbrowser HTTP clients may find useful), and a textual <tt class="calibre22">:body</tt> that is suitable for human consumption.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">Remember from <a href="#filepos1898353"><span class="calibre5">Table 16-2</span></a> that Ring response bodies can be a number of different types, including a seq of strings.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">The only reason why we wouldn’t be able to store a URL with a short identifier is if the user requested an ID that was already taken. In this case, we return a response with a 409 <tt class="calibre22">:status</tt> (an HTTP response code indicating a “conflict” preventing the requested action from taking place).</blockquote><p class="calibre18"><tt class="calibre22">redirect</tt> will be the function that looks up a requested ID, responding with a browser redirect if the ID is known and corresponds to a URL:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(require 'ring.util.response)<br class="calibre33"/><br class="calibre33"/>(defn redirect<br class="calibre33"/>  [id]<br class="calibre33"/>  (if-let [url (url-for id)]<br class="calibre33"/>    (ring.util.response/redirect url)<br class="calibre33"/>    {:status 404 :body (str "No such short URL: " id)}))</tt></span></blockquote><p class="calibre23">If the given <tt class="calibre22">id</tt> is found in our <tt class="calibre22">mappings</tt>, then <tt class="calibre22">redirect</tt> uses a utility function in Ring’s <tt class="calibre22">ring.util.response</tt> namespace<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1930583"></a><a href="#filepos1953152"><span class="calibre32">406</span></a><span class="calibre32">]</span></small></sup> to send an appropriate redirect response (corresponding to an HTTP <tt class="calibre22">:status</tt> of 302).</p><p class="calibre18">Now, <tt class="calibre22">retain</tt><a id="filepos1930823"></a> and <tt class="calibre22">redirect</tt><a id="filepos1930852"></a> are technically <span class="italic">not</span> Ring handlers: while they return Ring responses and are therefore useful helpers, they do not accept request maps. This isn’t required, but we’ve constrained the scope of these functions to make them simpler, more concise, and easier to test.</p><p class="calibre18">Finally, we can define our Compojure routes, in the same order as they are depicted in <a href="#filepos1919953"><span class="calibre5">Figure 16-1</span></a>:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1931355"></a><a href="#filepos1953471"><span class="calibre32">407</span></a><span class="calibre32">]</span></small></sup></p><p id="filepos1931454" class="calibre23"></p><p class="calibre23"><span class="italic">Example 16-2. Compojure routes for a URL shortener service</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(use '[compojure.core :only (GET PUT POST defroutes)])<br class="calibre33"/>(require 'compojure.route)<br class="calibre33"/><br class="calibre33"/>(defroutes app*<br class="calibre33"/>  (GET "/" request "Welcome!")<br class="calibre33"/>  (PUT "/:id" [id url] (retain url id))<br class="calibre33"/>  (POST "/" [url] (retain url))<br class="calibre33"/>  (GET "/:id" [id] (redirect id))<br class="calibre33"/>  (GET "/list/" [] (interpose "\n" (keys @mappings)))<br class="calibre33"/>  (compojure.route/not-found "Sorry, there's nothing here."))</tt></span></p><p class="calibre13"><tt class="calibre22">defroutes</tt> defines a var (<tt class="calibre22">app*</tt> in this case) containing a single Ring handler that attempts to dispatch incoming requests to each of the Ring handlers provided in its body in order. The first handler that returns a non-<tt class="calibre22">nil</tt> value short circuits the dispatch process, and that returned value is used as the return value of the “top level” Ring handler defined by <tt class="calibre22">defroutes</tt>.</p><p class="calibre18">Routes in Compojure <a id="filepos1932608"></a>define both a Ring handler and the patterns used to match requests to that handler. Each route consists of:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">The HTTP method for which the handler should be invoked. These methods are macros provided by Compojure that correspond to common HTTP verbs like <tt class="calibre22">GET</tt> and <tt class="calibre22">POST</tt>.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1933054"></a><a href="#filepos1953983"><span class="calibre32">408</span></a><span class="calibre32">]</span></small></sup></blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">A URI pattern that describes the <tt class="calibre22">:uri</tt>s for which the handler should be invoked.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">A binding form for the request and/or parameters and matched portions of the URI; names in this form will become locals for the body of the handler.</blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17">The body of the handler, which can contain any Clojure code, and which should either return <tt class="calibre22">nil</tt> (indicating that the request was not handled and should continue to be dispatched to later routes), or some other value that can be used as the basis for a Ring response map.</blockquote></li></ul><p class="calibre18">Let’s look at one of our routes:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(PUT "/:id" [id url] (retain url id))</tt></span></blockquote><p class="calibre23">This route will only match requests with a <tt class="calibre22">:request-method</tt> of <tt class="calibre22">:put</tt> (which corresponds to <tt class="calibre22">PUT</tt> in the HTTP protocol), and requests for URIs with a single segment; for example, <tt class="calibre22">"/some-id"</tt> will match, but <tt class="calibre22">"/path/to/some-id"</tt> will not. The <tt class="calibre22">:id</tt> portion of the URI pattern string causes that part of the URI to be bound to the <tt class="calibre22">id</tt> local established by the <tt class="calibre22">[id url]</tt> binding vector. The <tt class="calibre22">url</tt> local isn’t mentioned in the pattern string; it is bound to the <tt class="calibre22">:url</tt> parameter (or <tt class="calibre22">nil</tt> if no such parameter is provided in the request). The behavior and return value is defined by the remaining Clojure code following the binding form.</p><p class="calibre18">Because Compojure routes evaluate to Ring handler functions, we can very easily get a feel for how they work at the REPL, and experiment with all of the options that Compojure routes offer.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1935159"></a><a href="#filepos1954668"><span class="calibre32">409</span></a><span class="calibre32">]</span></small></sup> For example, this is the same route we use in our URL shortener (although a different handler body is used here); we can see very clearly that parameters and named URI path segments are bound to symbols of the same name in the binding vector:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">((PUT "/:id"<br class="calibre33"/>      [id url]<br class="calibre33"/>      (list "You requested that " url " be assigned id " id))<br class="calibre33"/>  {:uri "/some-id" :params {:url "http://clojurebook.com"} :request-method :put})<br class="calibre33"/>;= {:status 200, :headers {"Content-Type" "text/html"},<br class="calibre33"/>;=  :body ("You requested that " "http://clojurebook.com" " be assigned id " <br class="calibre33"/>  "some-id")}</tt></span></blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">Note that the handlers produced by Compojure routes helpfully provide typical defaults for the </span><span class="calibre10"><tt class="calibre22">:status</tt></span><span class="calibre10"> and </span><span class="calibre10"><tt class="calibre22">:headers</tt></span><span class="calibre10"> slots of the response map. This allows you to simply return the body of the response if you know you’re producing an error-free HTML page.</span></blockquote><p class="calibre25">Path segments <a id="filepos1936603"></a>identified by a <tt class="calibre22">:keyword</tt> will match any character except for <tt class="calibre22">/</tt>, <tt class="calibre22">.</tt>, <tt class="calibre22">,</tt>, <tt class="calibre22">;</tt>, and <tt class="calibre22">?</tt>; an asterisk path segment will match everything up to the next forward slash. You can provide as many path segments as you like in your URI pattern, and bind any set of them as locals for the body of your handler.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1936991"></a><a href="#filepos1955244"><span class="calibre32">410</span></a><span class="calibre32">]</span></small></sup> If you have multiple path segments with the same name, a vector of each of the matching segments will be bound to the named locals:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">((PUT ["/*/*/:id/:id"]<br class="calibre33"/>      [* id]<br class="calibre33"/>      (str * id))<br class="calibre33"/>  {:uri "/abc/xyz/foo/bar" :request-method :put})<br class="calibre33"/>;= {:status 200, :headers {"Content-Type" "text/html"},<br class="calibre33"/>;=  :body "[\"abc\" \"xyz\"][\"foo\" \"bar\"]"}</tt></span></blockquote><p class="calibre23">One really useful feature is that regular expressions can be provided to define the nature and scope of path segments. This is very similar to the regular expression-based <tt class="calibre22">:constraints</tt> in Rails, and is done by wrapping the URI pattern in a vector, and providing key/value pairs of path segment names and regular expressions. For example, we can specify that the <tt class="calibre22">:id</tt> path segment only contain digits by using the <tt class="calibre22">#"\d+"</tt> regular expression:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">((PUT ["/:id" :id #"\d+"]<br class="calibre33"/>   [id url]<br class="calibre33"/>   (list "You requested that " url " be assigned id " id))<br class="calibre33"/> {:uri "/some-id" :params {:url "http://clojurebook.com"} :request-method :put})  </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= nil<br class="calibre33"/>((PUT ["/:id" :id #"\d+"]<br class="calibre33"/>   [id url]<br class="calibre33"/>   (list "You requested that " url " be assigned id " id))<br class="calibre33"/>  {:uri "/590" :params {:url "http://clojurebook.com"} :request-method :put})     </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= {:status 200, :headers {"Content-Type" "text/html"},<br class="calibre33"/>;=  :body "You requested that http://clojurebook.com be assigned id 590"}</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">The request doesn’t match the defined route because the <tt class="calibre22">:uri</tt> path segment <tt class="calibre22">some-id</tt> isn’t numeric, and so the route returns <tt class="calibre22">nil</tt> (thus signaling that request dispatching should continue on to the next route and handler).</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">A request with a numeric first <tt class="calibre22">:uri</tt> path segment does match, and so the handler body is invoked, producing a non-<tt class="calibre22">nil</tt> response.</blockquote><p class="calibre18">Finally, you can always provide a symbol or a map destructuring form as the binding form in a route; that will bind the entire request map for the handler’s body:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">((PUT "/:id" req (str "You requested: " (:uri req)))<br class="calibre33"/>  {:uri "/foo" :request-method :put})<br class="calibre33"/>;= {:status 200, :headers {"Content-Type" "text/html"}, :body "You requested: /foo"}<br class="calibre33"/>((PUT "/:id" {:keys [uri]} (str "You requested: " uri))<br class="calibre33"/>  {:uri "/foo" :request-method :put})<br class="calibre33"/>;= {:status 200, :headers {"Content-Type" "text/html"}, :body "You requested: /foo"}</tt></span></blockquote><p class="calibre23">The final route in <a href="#filepos1931454"><span class="calibre5">Example 16-2</span></a> is a catch-all that allows us to control what should happen if none of the routes we define in the <tt class="calibre22">defroutes</tt> form match the request and return a non-<tt class="calibre22">nil</tt> response. This will return an HTTP status of 404, with the body defined by the handler body we provide to the <tt class="calibre22">compojure.route/not-found</tt> helper; in our case, a simple string will do.</p><p class="calibre18">Our application is complete, except it’s not running yet! That’s just a matter of simple bookkeeping though. First, since we are depending on request parameters being parsed out and added to Ring requests, we need to add in some middleware. Compojure conveniently provides two helper functions for doing this in its <tt class="calibre22">compojure.handler</tt> namespace: <tt class="calibre22">api</tt> wraps a Ring handler with a couple of pieces of Ring-provided middleware that takes care of all of the parameter handling we might need, and is most suited for use with HTTP services; <tt class="calibre22">site</tt> provides the same, but adds other middleware to support functionality you’d expect in a user/browser-facing website, like handling for cookies, sessions, multipart form posts and uploads, and so on. We’ll opt for the former:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(require 'compojure.handler)<br class="calibre33"/><br class="calibre33"/>(def app (compojure.handler/api app*))</tt></span></blockquote><p class="calibre23">Now we just need to start up our application using the Jetty adapter:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(use '[ring.adapter.jetty :only (run-jetty)])<br class="calibre33"/>;= nil<br class="calibre33"/>(def server (run-jetty #'app {:port 8080 :join? false}))<br class="calibre33"/>;= #'user/server</tt></span></blockquote><p class="calibre23">All of this will be easily accessible from any web browser, but be well-formed enough that we can use the service programmatically with any HTTP library. In order to properly test our URL shortener service, we’ll need to send <tt class="calibre22">PUT</tt><a id="filepos1942527"></a> or <tt class="calibre22">POST</tt><a id="filepos1942551"></a> requests to the service with form parameters properly set. This can be a little tricky to do, since browsers need a form in order to send either type of request. However, <tt class="calibre22">curl</tt> is a commonly used and widely available command-line tool that makes it relatively easy to test our service end-to-end. <tt class="calibre22">curl</tt><a id="filepos1942877"></a> allows you to set the HTTP method with the <tt class="calibre22">-X</tt> argument, and will print out the full response from the server when executed with the <tt class="calibre22">-i</tt> argument.</p><p class="calibre18">Let’s establish a couple of short URL IDs using <tt class="calibre22">PUT</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">% curl -X PUT 'http://localhost:8080/sicp?url=http://mitpress.mit.edu/sicp/'<br class="calibre33"/>URL http://mitpress.mit.edu/sicp/ assigned the short identifier sicp<br class="calibre33"/><br class="calibre33"/>% curl -X PUT 'http://localhost:8080/clj?url=http://clojure.org'<br class="calibre33"/>URL http://clojure.org assigned the short identifier clj</tt></span></blockquote><p class="calibre23"><tt class="calibre22">curl</tt><a id="filepos1943588"></a> will output the headers it receives from our service if we include the <tt class="calibre22">-i</tt> option; if we do this while <tt class="calibre22">POST</tt>ing to the service to get an autogenerated ID, we can see the service properly returning the <tt class="calibre22">201 Created</tt> HTTP status code as well as the <tt class="calibre22">Location</tt> header:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">% curl -i -X POST 'http://localhost:8080/?url=http://clojurebook.com'<br class="calibre33"/>HTTP/1.1 201 Created<br class="calibre33"/>Date: Sun, 18 Dec 2011 20:58:09 GMT<br class="calibre33"/>Location: 1<br class="calibre33"/>Content-Length: 58<br class="calibre33"/>Server: Jetty(6.1.25)<br class="calibre33"/><br class="calibre33"/>URL http://clojurebook.com assigned the short identifier 1</tt></span></blockquote><p class="calibre23">Now, if we try to register a short URL ID that is already taken, the service will properly reply with a failure, the <tt class="calibre22">409 Conflict</tt><a id="filepos1944459"></a> HTTP status that a programmatic agent could use to provide a helpful message to a user:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">% curl -i -X PUT 'http://localhost:8080/1?url=http://apple.com'<br class="calibre33"/>HTTP/1.1 409 Conflict<br class="calibre33"/>Date: Sun, 18 Dec 2011 20:58:40 GMT<br class="calibre33"/>Content-Length: 28<br class="calibre33"/>Server: Jetty(6.1.25)<br class="calibre33"/><br class="calibre33"/>Short URL 1 is already taken</tt></span></blockquote><p class="calibre23">With some URLs now registered, we can use the <tt class="calibre22">/list/</tt> route to get a listing of the known short identifiers:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">% curl http://localhost:8080/list/<br class="calibre33"/>1<br class="calibre33"/>clj<br class="calibre33"/>sicp</tt></span></blockquote><p class="calibre23">Requesting any URI that has no corresponding route (or one that has a single segment but that does not correspond to any known short URL ID) properly yields a <tt class="calibre22">404 Not Found</tt><a id="filepos1945408"></a> response and message:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">% curl -i http://localhost:8080/foo<br class="calibre33"/>HTTP/1.1 404 Not Found<br class="calibre33"/>Date: Sun, 18 Dec 2011 21:21:39 GMT<br class="calibre33"/>Content-Length: 22<br class="calibre33"/>Server: Jetty(6.1.25)<br class="calibre33"/><br class="calibre33"/>No such short URL: foo</tt></span></blockquote><p class="calibre23">And requests for all other nonshort URL ID paths return the generalized <tt class="calibre22">404</tt> response:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">% curl -i http://localhost:8080/some/other/url<br class="calibre33"/>HTTP/1.1 404 Not Found<br class="calibre33"/>Date: Sun, 18 Dec 2011 21:21:53 GMT<br class="calibre33"/>Content-Length: 28<br class="calibre33"/>Server: Jetty(6.1.25)<br class="calibre33"/><br class="calibre33"/>Sorry, there's nothing here.</tt></span></blockquote><p class="calibre23">Finally, we can see that the redirection works properly by requesting a URI that <span class="italic">does</span> correspond to a short URL ID:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">% curl -i http://localhost:8080/sicp<br class="calibre33"/>HTTP/1.1 302 Found<br class="calibre33"/>Date: Sun, 18 Dec 2011 20:59:12 GMT<br class="calibre33"/>Location: http://mitpress.mit.edu/sicp/<br class="calibre33"/>Content-Length: 0<br class="calibre33"/>Server: Jetty(6.1.25)<br class="calibre33"/><br class="calibre33"/>% curl -L http://localhost:8080/sicp                           </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Welcome to the SICP Web Site&lt;/TITLE&gt;&lt;/HEAD&gt;<br class="calibre33"/>....</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">The <tt class="calibre22">-L</tt> option to <tt class="calibre22">curl</tt> instructs it to follow the HTTP redirect indicated by the <tt class="calibre22">302 Found</tt> status code and the <tt class="calibre22">Location</tt> header.</blockquote><p class="calibre18">The final code for our URL shortening service is reproduced here as it would appear in a source file.</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 16-3. A functional URL shortener</span><a id="filepos1947546"></a></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(ns com.clojurebook.url-shortener<br class="calibre33"/>  (:use [compojure.core :only (GET PUT POST defroutes)])<br class="calibre33"/>  (:require (compojure handler route)<br class="calibre33"/>            [ring.util.response :as response]))<br class="calibre33"/><br class="calibre33"/>(def ^:private counter (atom 0))<br class="calibre33"/><br class="calibre33"/>(def ^:private mappings (ref {}))<br class="calibre33"/><br class="calibre33"/>(defn url-for<br class="calibre33"/>  [id]<br class="calibre33"/>  (@mappings id))<br class="calibre33"/><br class="calibre33"/>(defn shorten!<br class="calibre33"/> "Stores the given URL under a new unique identifier, or the given identifier<br class="calibre33"/>  if provided.  Returns the identifier as a string.<br class="calibre33"/>  Modifies the global mapping accordingly." <br class="calibre33"/> ([url]<br class="calibre33"/>  (let [id (swap! counter inc)<br class="calibre33"/>        id (Long/toString id 36)]<br class="calibre33"/>    (or (shorten! url id)<br class="calibre33"/>        (recur url))))<br class="calibre33"/> ([url id]<br class="calibre33"/>   (dosync<br class="calibre33"/>     (when-not (@mappings id)<br class="calibre33"/>       (alter mappings assoc id url)<br class="calibre33"/>       id))))<br class="calibre33"/><br class="calibre33"/>(defn retain<br class="calibre33"/>  [&amp; [url id :as args]]<br class="calibre33"/>  (if-let [id (apply shorten! args)]<br class="calibre33"/>    {:status 201<br class="calibre33"/>     :headers {"Location" id}<br class="calibre33"/>     :body (list "URL " url " assigned the short identifier " id)}<br class="calibre33"/>    {:status 409 :body (format "Short URL %s is already taken" id)}))<br class="calibre33"/><br class="calibre33"/>(defn redirect<br class="calibre33"/>  [id]<br class="calibre33"/>  (if-let [url (url-for id)]<br class="calibre33"/>    (response/redirect url)<br class="calibre33"/>    {:status 404 :body (str "No such short URL: " id)}))<br class="calibre33"/><br class="calibre33"/>(defroutes app*<br class="calibre33"/>  (GET "/" request "Welcome!")<br class="calibre33"/>  (PUT "/:id" [id url] (retain url id))<br class="calibre33"/>  (POST "/" [url] (if (empty? url)<br class="calibre33"/>                    {:status 400 :body "No `url` parameter provided"}<br class="calibre33"/>                    (retain url)))<br class="calibre33"/>  (GET "/:id" [id] (redirect id))<br class="calibre33"/>  (GET "/list/" [] (interpose "\n" (keys @mappings)))<br class="calibre33"/>  (compojure.route/not-found "Sorry, there's nothing here."))<br class="calibre33"/><br class="calibre33"/>(def app (compojure.handler/api app*))<br class="calibre33"/><br class="calibre33"/>;; ; To run locally:<br class="calibre33"/>;; (use '[ring.adapter.jetty :only (run-jetty)])     <br class="calibre33"/>;; (def server (run-jetty #'app {:port 8080 :join? false}))</tt></span></p><p class="calibre13"><span class="bold">Composing routes</span>. Because <tt class="calibre22">defroutes</tt><a id="filepos1950133"></a> dispatches to any Ring handler function, and <tt class="calibre22">defroutes</tt> itself creates a handler function, you can compose hierarchies of routes with zero effort. If we wanted to add an admin console to our URL shortening service, we could mix in the existing <tt class="calibre22">app*</tt> routes trivially:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defroutes app+admin<br class="calibre33"/>  (GET "/admin/" request ...)<br class="calibre33"/>  (POST "/admin/some-admin-action" request ...)<br class="calibre33"/>  app*)</tt></span></blockquote><p class="calibre23">The only thing to keep in mind is that you’ll want to keep “catch-all” routes (e.g., like those produced by <tt class="calibre22">compojure.route/not-found</tt>) out of groups of routes that you would like to compose into higher-level groups; otherwise, routes appearing after <tt class="calibre22">app*</tt> above would never be dispatched to or their handlers invoked.<a id="filepos1951020"></a></p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1951124"></a><a href="#filepos1918915"><span class="calibre32">402</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Of course, if you are writing a very small, contained HTTP service, a single Ring handler running in Jetty may be perfect without any further adornment.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1951461"></a><a href="#filepos1921049"><span class="calibre32">403</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">You might call it a </span><span class="calibre10"><span class="italic">REST</span></span><span class="calibre10"> service, but the semantics of REST are tricky to get right, as Roy Fielding (the originator of the REST term) points out in, for example, </span><a href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven"><span class="calibre10"><span class="calibre5">http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven</span></span></a><span class="calibre10">. We’re happy enough to say that ours will be a well-behaved HTTP service.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1952162"></a><a href="#filepos1922280"><span class="calibre32">404</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">If we were going to properly build this service out for real usage, we could quite easily use one of the databases discussed in Chapters </span><a href="#filepos1757595"><span class="calibre10"><span class="calibre5">14</span></span></a><span class="calibre10"> or </span><a href="#filepos1819820"><span class="calibre10"><span class="calibre5">15</span></span></a><span class="calibre10"> in place of in-memory state.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1952719"></a><a href="#filepos1923503"><span class="calibre32">405</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Because modifications to the state of the ref’s mapping may end up retrying due to request contention, some automatically generated identifiers pulled from the counter will be dropped on the floor. This seems reasonable, but worth being aware of.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1953152"></a><a href="#filepos1930583"><span class="calibre32">406</span></a><span class="calibre32">] </span></small></sup><span class="calibre10"><tt class="calibre22">ring.util.response</tt></span><span class="calibre10"> contains a number of very useful utilities for creating and modifying response maps.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1953471"></a><a href="#filepos1931355"><span class="calibre32">407</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">As much of a non sequitur as it is, we would be remiss if we did not suggest that you internalize Tim Berners-Lee’s rant, “Cool URIs don’t change”: </span><a href="http://www.w3.org/Provider/Style/URI.html"><span class="calibre10"><span class="calibre5">http://www.w3.org/Provider/Style/URI.html</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1953983"></a><a href="#filepos1933054"><span class="calibre32">408</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Other request method macros Compojure provides out of the box include </span><span class="calibre10"><tt class="calibre22">PUT</tt></span><span class="calibre10">, </span><span class="calibre10"><tt class="calibre22">DELETE</tt></span><span class="calibre10">, </span><span class="calibre10"><tt class="calibre22">HEAD</tt></span><span class="calibre10">, and a special macro </span><span class="calibre10"><tt class="calibre22">ANY</tt></span><span class="calibre10">, which acts as a wildcard. If necessary, route macros can be defined as needed for “nonstandard” HTTP verbs like </span><span class="calibre10"><tt class="calibre22">COPY</tt></span><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1954668"></a><a href="#filepos1935159"><span class="calibre32">409</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Ring requests are generally quite easy to construct, and we do so directly here. If you find yourself “mocking” Ring requests regularly (for testing, experimentation, or other purposes), you may find ring-mock useful: </span><a href="https://github.com/weavejester/ring-mock"><span class="calibre10"><span class="calibre5">https://github.com/weavejester/ring-mock</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1955244"></a><a href="#filepos1936991"><span class="calibre32">410</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Alternatively, you can access path segments in a </span><span class="calibre10"><tt class="calibre22">:route-params</tt></span><span class="calibre10"> map that Compojure adds to the request.</span></p><div class="mbppagebreak"></div><p id="filepos1955537" class="calibre6"><span class="calibre4"><span class="bold">Templating</span></span></p><p id="filepos1955608" class="calibre18">Thus far, we have done just about everything a web framework can be expected to do, with the notable exception of actually producing complex HTML. While HTTP services and file servers are useful, most people think “HTML” when they hear “web application.” Most web frameworks use template systems where HTML is intermingled with executable code or unevaluated “directives” that refer to bound variables defined for the scope of page generation, resulting in a populated page of HTML.</p><p class="calibre18">A sample of this approach is Ruby’s ERB templating language<a id="filepos1956223"></a>:</p><p id="filepos1956235" class="calibre23"></p><p class="calibre23"><span class="italic">Example 16-4. Example of an ERB HTML template</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">&lt;h1&gt;Hello, &lt;%= @user.name %&gt;&lt;/h1&gt;<br class="calibre33"/><br class="calibre33"/>&lt;p&gt;These are your friends:&lt;/p&gt;<br class="calibre33"/>&lt;ul&gt;<br class="calibre33"/>&lt;% @user.friends.each do |friend| %&gt;<br class="calibre33"/>  &lt;li&gt;&lt;%= friend.name %&gt;&lt;/li&gt;<br class="calibre33"/>&lt;% end %&gt;<br class="calibre33"/>&lt;/ul&gt;</tt></span></p><p class="calibre13">Those unfamiliar with ERB syntax may be puzzled, but this is not so dissimilar to Django templates or JSPs or any of a hundred other templating systems you might be familiar with. All of these systems work primarily by string substitution; in ERB’s case, executing Ruby code found within <tt class="calibre22">&lt;%</tt> and <tt class="calibre22">%&gt;</tt> delimiters, and evaluating expressions within <tt class="calibre22">&lt;%=</tt> and <tt class="calibre22">%&gt;</tt> delimiters to obtain strings that should be included in the output. ERB templates run inside a context, so expressions like <tt class="calibre22">@user.name</tt> refer to a local inside the context, obtaining its <tt class="calibre22">name</tt> attribute.</p><p class="calibre18">This approach has been used by numerous languages and millions of programmers for years; this is even the primary mode of operation in the case of PHP. However, not all is well. The first obvious problem is that the HTML in these templates is tricky to debug and fine-tune; until we have a working web stack, we cannot make sure the template HTML works or make adjustments to its stylesheets. A similar problem exists with the code, in that it’s difficult to test in isolation without mocking out a nontrivial environment with appropriate domain objects and such. In more precise terms, the coupling between our model and our view is stronger than we’d like. Finally, the ideal developer of such templates is both an expert at HTML and an expert at Ruby (or Python, or PHP) and the software stack driving the templates.</p><p class="calibre18">Despite the templating approach’s popularity, people who are both expert web designers and expert software engineers are extremely rare. A designer is often commissioned to create HTML mockups and then developers modify the templates by hand, adding markup for their preferred templating languages. If there are design changes, they often come as updates to the original HTML documents, which the developers must revisit and carefully merge with their templated version. Obviously, this is not an optimal scenario. Can we do better?</p><p id="filepos1958790" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Enlive: Selector-Based HTML Transformation</span></span></span></p><p class="calibre18">Enlive (<a href="http://github.com/cgrand/enlive"><span class="calibre5">http://github.com/cgrand/enlive</span></a>)<a id="filepos1959065"></a> proposes a radical way to decouple code from templates: rather than defining a special local syntax for interpolating values into templates, Enlive templates are plain HTML files with no special tags, no special attributes, no special classes, and no special syntax. Instead, content is injected into templates by Clojure code that uses <span class="italic">selectors</span> (heavily inspired by CSS selectors) to specify what to modify, and Clojure functions that define what transformations to apply.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1959589"></a><a href="#filepos1986631"><span class="calibre32">411</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">This strict separation of concerns—design kept entirely isolated from code that transforms it—makes roundtrip collaboration between programmers and designers particularly easy. And, because the selectors that you might use to identify parts of a template to modify are likely the same as some of the CSS selectors used to style the produced content, changes in the template that might impact the code that transforms that design are easy for designers (or, programmers engaged in design!) to identify ahead of time.</p><p id="filepos1960239" class="calibre23"><span class="calibre53"><span class="bold">Testing the waters</span></span></p><p id="filepos1960318" class="calibre18">The first step in using Enlive is usually to write the HTML file—what is referred to as the template <span class="italic">source</span>—but let’s first get a sense of how Enlive works through some REPL tinkering. Add a dependency for it to your project:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">[enlive/enlive "1.0.0"]</tt></span></blockquote><p class="calibre23">…and start a REPL.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(require '[net.cgrand.enlive-html :as h])<br class="calibre33"/>;= nil<br class="calibre33"/>(h/sniptest "&lt;h1&gt;Lorem Ipsum&lt;/h1&gt;")<br class="calibre33"/>;= "&lt;h1&gt;Lorem Ipsum&lt;/h1&gt;"</tt></span></blockquote><p class="calibre23"><tt class="calibre22">sniptest</tt><a id="filepos1961037"></a> is a utility provided by Enlive that simplifies experimenting with and transforming snippets of HTML in the REPL. We’re not specifying a transformation here, so our input is being returned unchanged.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(h/sniptest "&lt;h1&gt;Lorem Ipsum&lt;/h1&gt;"<br class="calibre33"/>  [:h1] (h/content "Hello Reader!"))<br class="calibre33"/>;= "&lt;h1&gt;Hello Reader!&lt;/h1&gt;"</tt></span></blockquote><p class="calibre23"><tt class="calibre22">[:h1]</tt> is a selector—corresponding to the CSS selector <tt class="calibre22">h1</tt>—that matches all <tt class="calibre22">h1</tt> elements in the HTML being transformed. <tt class="calibre22">content</tt> is a HOF that returns a function that will set the body of matched elements to the value(s) provided to <tt class="calibre22">content</tt>. Enlive provides a large number of ready-made transformer HOFs that satisfy all of the common templating needs you might have in a typical web application, and its selectors provide a superset of CSS selectors for specifying where those transformations should be applied.</p><p class="calibre18">Let’s pull the covers back a bit so we can understand how more sophisticated transformations are possible. Enlive has a <tt class="calibre22">html-snippet</tt><a id="filepos1962239"></a> function that is used to parse any HTML content, returning a sequence of maps, each one representing an element with attributes and child content:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(h/html-snippet "&lt;p&gt;x, &lt;a id=\"home\" href=\"/\"&gt;y&lt;/a&gt;, &lt;a href=\"..\"&gt;z&lt;/a&gt;&lt;/p&gt;")<br class="calibre33"/>;= ({:tag :p,<br class="calibre33"/>;=   :attrs nil,<br class="calibre33"/>;=   :content<br class="calibre33"/>;=   ("x, "<br class="calibre33"/>;=    {:tag :a, :attrs {:href "/", :id "home"}, :content ("y")}<br class="calibre33"/>;=    ", "<br class="calibre33"/>;=    {:tag :a, :attrs {:href ".."}, :content ("z")})})</tt></span></blockquote><p class="calibre23">This representation of HTML/XML matches that produced and consumed by the functions in the <tt class="calibre22">clojure.xml</tt> namespace—another example where the selection of a common abstraction allows for simpler interchange of data and composition of functionality.</p><p class="calibre18">Knowing this, it’s not hard to imagine how Enlive implements transformations:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">Selectors traverse the tree that represents the HTML in question to find matching elements.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Those elements are passed to the transformation function paired with the each selector applied. The functions’ results replace the selected elements.</blockquote></li></ol><p class="calibre18">Because these operations are carried out over Clojure’s persistent data structures using pure functions, they can be chained, composed, and reused however your needs dictate:</p><p id="filepos1963968" class="calibre23"></p><p class="calibre23"><span class="italic">Example 16-5. A less trivial HTML transformation</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(h/sniptest "&lt;p&gt;x, &lt;a id=\"home\" href=\"/\"&gt;y&lt;/a&gt;, &lt;a href=\"..\"&gt;z&lt;/a&gt;&lt;/p&gt;"<br class="calibre33"/>  [:a#home] (h/set-attr :href "http://clojurebook.com")<br class="calibre33"/>  [[:a (h/attr= :href "..")]] (h/content "go up"))<br class="calibre33"/>;= "&lt;p&gt;x, &lt;a href=\"http://clojurebook.com\" id=\"home\"&gt;y&lt;/a&gt;, &lt;a href=\"..\"&gt;go up&lt;/a&gt;<br class="calibre33"/>  &lt;/p&gt;"</tt></span></p><p class="calibre13">Making the most of Enlive requires understanding how to construct appropriate selectors and transformer functions.</p><p id="filepos1964711" class="calibre23"><span class="calibre53"><span class="bold">Selectors</span></span></p><p id="filepos1964781" class="calibre18">Enlive selector syntax may seem daunting at first, but is in fact very easy to pick up if you know CSS much at all. Most of the time, adding colons in front of each step and wrapping everything into a vector suffices. For example, the CSS selector <tt class="calibre22">div span.phone</tt> becomes <tt class="calibre22">[:div :span.phone]</tt>, <tt class="calibre22">#summary .kw</tt> becomes <tt class="calibre22">[:#summary :.kw]</tt>, and so on.</p><p class="calibre18">Newcomers to Enlive often struggle with the meaning of nested vectors in selectors. The rule is easy, if not simple: <span class="italic">the outermost vector denotes chaining, all other vectors denote conjunction</span>. So, <tt class="calibre22">[:div [:span :.phone]]</tt> is equivalent to the above <tt class="calibre22">[:div :span.phone]</tt>. Conjunctive vectors can be nested <span class="italic">ad lib</span>: <tt class="calibre22">[:div [:span [:.phone :.mobile]]]</tt> is the same as <tt class="calibre22">[:div :span.phone.mobile]</tt>.</p><p class="calibre18">Note that the outermost vector is not optional, even if the selector has only one step: <tt class="calibre22">:h1</tt> is not a valid selector, <tt class="calibre22">[:h1]</tt> is.</p><p class="calibre18">Enlive also supports disjunctions.<a id="filepos1965894"></a> The equivalent of the CSS selector <tt class="calibre22">div#info span.phone, div#info span.email</tt> is the following: <tt class="calibre22">#{[:div#info :span.phone] [:div#info :span.email]}</tt>. However, unlike in CSS, disjunctions are not limited to the top level: <tt class="calibre22">[:div#info #{:span.phone :span.email}]</tt> or even <tt class="calibre22">[:div#info [:span #{:.phone :.email}]]</tt> are all different notations of the same selector.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">To summarize: sets denote disjunction, inner vectors denote conjunction, outermost vectors denote hierarchical chaining.</span></blockquote><p class="calibre25">All other tests are performed with predicates,<a id="filepos1966685"></a> and as such can be extended at will. This is the case of <tt class="calibre22">attr?</tt>: the CSS selector <tt class="calibre22">a[class]</tt> becomes <tt class="calibre22">[[:a (attr? :class)]]</tt>. Take note of the nested vectors: a single vector selector—that is, <tt class="calibre22">[:a (attr? :class)]</tt>—is equivalent to <tt class="calibre22">a *[class]</tt> in CSS. The difference is marked:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(h/sniptest "&lt;p class=\"\"&gt;&lt;a href=\"\" class=\"\"&gt;&lt;/a&gt;&lt;/p&gt;"<br class="calibre33"/>  [[:p (h/attr? :class)]] (h/content "XXX"))<br class="calibre33"/>;= "&lt;p class=\"\"&gt;XXX&lt;/p&gt;"<br class="calibre33"/><br class="calibre33"/>(h/sniptest "&lt;p class=\"\"&gt;&lt;a href=\"\" class=\"\"&gt;&lt;/a&gt;&lt;/p&gt;"<br class="calibre33"/>  [:p (h/attr? :class)] (h/content "XXX"))<br class="calibre33"/>;= "&lt;p class=\"\"&gt;&lt;a class=\"\" href=\"\"&gt;XXX&lt;/a&gt;&lt;/p&gt;"</tt></span></blockquote><p class="calibre23">Corollaries to most CSS selectors <a id="filepos1967608"></a>are provided in Enlive (including all the <tt class="calibre22">:nth-*</tt> pseudoclasses). Beyond that initial set, you can define your own selectors, which are themselves just functions. This can be accomplished using the <tt class="calibre22">pred</tt> or <tt class="calibre22">zip-pred</tt> HOFs that Enlive provides, which respectively take predicates on elements and predicates on zippers<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1967990"></a><a href="#filepos1987083"><span class="calibre32">412</span></a><span class="calibre32">]</span></small></sup> and yield a function that Enlive can use as a <span class="italic">selector step</span>.</p><p class="calibre18">In <tt class="calibre22">attr=</tt>, Enlive already provides a selector for matching elements that have a particular attribute whose value matches a given value.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1968363"></a><a href="#filepos1987435"><span class="calibre32">413</span></a><span class="calibre32">]</span></small></sup> Let’s define a new selector step function that matches elements that have <span class="italic">any</span> attribute whose value matches a given value:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn some-attr=<br class="calibre33"/> "Selector step, matches elements where at least one attribute<br class="calibre33"/>  has the specified value."<br class="calibre33"/> [value]<br class="calibre33"/> (h/pred (fn [node]<br class="calibre33"/>           (some #{value} (vals (:attrs node))))))</tt></span></blockquote><p class="calibre23">Let’s see how it works:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(h/sniptest "&lt;ul&gt;&lt;li id=\"foo\"&gt;A&lt;li&gt;B&lt;li name=\"foo\"&gt;C&lt;/li&gt;&lt;/ul&gt;"<br class="calibre33"/>  [(some-attr= "foo")] (h/set-attr :found "yes"))<br class="calibre33"/>;= "&lt;ul&gt;<br class="calibre33"/>;=    &lt;li found=\"yes\" id=\"foo\"&gt;A&lt;/li&gt;<br class="calibre33"/>;=    &lt;li&gt;B&lt;/li&gt;<br class="calibre33"/>;=    &lt;li found=\"yes\" name=\"foo\"&gt;C&lt;/li&gt;<br class="calibre33"/>;= &lt;/ul&gt;"</tt></span></blockquote><p class="calibre23">Enlive already gives us a lot of flexibility in controlling the effects of our transformations. As you can see, when that flexibility isn’t enough for what you want to do, you can define your own selectors, using whatever criteria you desire.</p><p id="filepos1969748" class="calibre23"><span class="calibre53"><span class="bold">Iterating and branching</span></span></p><p id="filepos1969832" class="calibre18">So far we have seen how to identify nodes and how to transform them (as with, e.g., <tt class="calibre22">content</tt> or <tt class="calibre22">set-attr</tt>) but we have not covered the two pillars of templating: condition and iteration.</p><p class="calibre18">The key to iterating and branching in Enlive is to understand that a transformation can be one of:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">A function of one element returning one element</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">A function of one element returning a collection of elements</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">nil</tt>, equivalent to <tt class="calibre22">(fn [_] nil)</tt></blockquote></li></ul><p class="calibre18">It follows that, for example, displaying an optional message is as simple as using <tt class="calibre22">when</tt>, which evaluates to <tt class="calibre22">nil</tt> when its condition is logically false:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn display<br class="calibre33"/>  [msg]<br class="calibre33"/>  (h/sniptest "&lt;div&gt;&lt;span class=\"msg\"&gt;&lt;/span&gt;&lt;/div&gt;"<br class="calibre33"/>    [:.msg] (when msg (h/content msg))))<br class="calibre33"/>;= #'user/display<br class="calibre33"/>(display "Welcome back!")<br class="calibre33"/>;= "&lt;div&gt;&lt;span class=\"msg\"&gt;Welcome back!&lt;/span&gt;&lt;/div&gt;"<br class="calibre33"/>(display nil)<br class="calibre33"/>;= "&lt;div&gt;&lt;/div&gt;"</tt></span></blockquote><p class="calibre23">When a message is present, the <tt class="calibre22">when</tt> form evaluates to the <tt class="calibre22">(h/content msg)</tt> transformation function, which sets the content of the matched <tt class="calibre22">span</tt> element to the provided message. On the other hand, when there’s no message to display, the <tt class="calibre22">when</tt> form evaluates to <tt class="calibre22">nil</tt>, and the message placeholder is removed.</p><p class="calibre18">Alternatively, you may need to retain the empty span because it is needed by client-side code; in that case, just use an <tt class="calibre22">if</tt> (or a <tt class="calibre22">cond</tt> or whatever other conditional you prefer) instead of the <tt class="calibre22">when</tt> form:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn display<br class="calibre33"/>  [msg]<br class="calibre33"/>  (h/sniptest "&lt;div&gt;&lt;span class=\"msg\"&gt;&lt;/span&gt;&lt;/div&gt;"<br class="calibre33"/>    [:.msg] (if msg<br class="calibre33"/>              (h/content msg)<br class="calibre33"/>              (h/add-class "hidden"))))<br class="calibre33"/>;= #'user/display<br class="calibre33"/>(display nil)<br class="calibre33"/>;= "&lt;div&gt;&lt;span class=\"msg hidden\"&gt;&lt;/span&gt;&lt;/div&gt;"</tt></span></blockquote><p class="calibre23">Iterating in Enlive is done with <tt class="calibre22">clone-for</tt><a id="filepos1972566"></a> which looks and behaves a lot like <tt class="calibre22">for</tt>:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn countdown<br class="calibre33"/>  [n]<br class="calibre33"/>  (h/sniptest "&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;"<br class="calibre33"/>    [:li] (h/clone-for [i (range n 0 -1)]<br class="calibre33"/>            (h/content (str i)))))<br class="calibre33"/>;= #'user/countdown<br class="calibre33"/>(countdown 0)<br class="calibre33"/>;= "&lt;ul&gt;&lt;/ul&gt;"<br class="calibre33"/>(countdown 3)<br class="calibre33"/>;= "&lt;ul&gt;&lt;li&gt;3&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;1&lt;/li&gt;&lt;/ul&gt;"</tt></span></blockquote><p class="calibre23">Under the covers, a <tt class="calibre22">for</tt> comprehension yields a sequence of transformation functions (in the example above, <tt class="calibre22">n</tt> instances of <tt class="calibre22">(h/content (str i))</tt>), each of which is used to produce element(s) based on the single node selected by the selector. The resulting elements replace the original node.</p><p class="calibre18">A common need when it comes to iteration is to remove some attributes that were used to select the node in the first place—for example, an ID. This is done with the <tt class="calibre22">do-&gt;</tt><a id="filepos1973697"></a> function, which composes transformations by applying them in sequence:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(defn countdown<br class="calibre33"/>  [n]<br class="calibre33"/>  (h/sniptest "&lt;ul&gt;&lt;li id=\"foo\"&gt;&lt;/li&gt;&lt;/ul&gt;"<br class="calibre33"/>    [:#foo] (h/do-&gt;<br class="calibre33"/>              (h/remove-attr :id)<br class="calibre33"/>              (h/clone-for [i (range n 0 -1)]<br class="calibre33"/>                (h/content (str i))))))<br class="calibre33"/>;= #'user/countdown<br class="calibre33"/>(countdown 3)<br class="calibre33"/>;= "&lt;ul&gt;&lt;li&gt;3&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;1&lt;/li&gt;&lt;/ul&gt;"</tt></span></blockquote><p class="calibre23">Of course, <tt class="calibre22">do-&gt;</tt> can be used anywhere a transformation is expected since it evaluates to one itself, so there is no limit to how you can compose transformation functions.</p><p id="filepos1974573" class="calibre23"><span class="calibre53"><span class="bold">Putting everything together</span></span></p><p class="calibre18"><tt class="calibre22">sniptest</tt><a id="filepos1974706"></a> is a great exploratory aid that has allowed us to demonstrate all the basics of Enlive, but it’s of little use in a real application. We need to load HTML from disk—or, more specifically, from our application’s classpath. This is the job of <tt class="calibre22">deftemplate</tt> and <tt class="calibre22">defsnippet</tt>.</p><p class="calibre18"><tt class="calibre22">defsnippet</tt><a id="filepos1975057"></a> defines a function that loads HTML from the file on our classpath that we can transform however we like as with <tt class="calibre22">sniptest</tt>. These functions are intended to be called from within other snippet or <tt class="calibre22">deftemplate</tt> functions as an easy way to compose discrete units of content. For example, assuming we have a file <span class="italic">footer.html</span> at the root of our classpath:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 16-6. footer.html</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">&lt;div class="footer"/&gt;</tt></span></p><p class="calibre13">we can define a reusable <tt class="calibre22">footer</tt> snippet:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(h/defsnippet footer "footer.html" [:.footer]  </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  [message]                                    </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  [:.footer] (h/content message))              </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37"><tt class="calibre22">footer</tt> is the name of the var and function we’re defining. <tt class="calibre22">"footer.html"</tt> is the path to the HTML file we’re loading content from, and can be a string or an instance of <tt class="calibre22">java.io.File</tt>, <tt class="calibre22">java.net.URL</tt>, or <tt class="calibre22">java.net.URI</tt>. The third argument to <tt class="calibre22">defsnippet</tt> is a selector that indicates the root element within the loaded HTML file to which transformations should be applied. <tt class="calibre22">[:.footer]</tt> here ensures that we discard the <tt class="calibre22">&lt;html&gt;</tt> and <tt class="calibre22">&lt;body&gt;</tt> elements that Enlive adds implicitly when loading snippets and templates. A single HTML file can contain several snippets, each <tt class="calibre22">defsnippet</tt> selecting only the relevant nodes—it’s handy to have many reusable components in the same file and to be able to preview them using just a web browser.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">An argument vector; this snippet function takes a single argument, <tt class="calibre22">message</tt>.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">The rest of the <tt class="calibre22">defsnippet</tt> form consists of pairs of selectors and transformers, as we’ve seen already.</blockquote><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">If you are using Leiningen, the best place to put HTML templates is inside the </span><a id="filepos1978038"></a><span class="calibre10"><span class="italic">resources</span></span><span class="calibre10"> directory (the default for the </span><span class="calibre10"><tt class="calibre22">:resources-path</tt></span><span class="calibre10"> option in </span><span class="calibre10"><span class="italic">project.clj</span></span><span class="calibre10">). With Maven, HTML templates are typically rooted within </span><span class="calibre10"><span class="italic">src/main/resources</span></span><span class="calibre10">.</span></blockquote><p class="calibre25">Unlike <tt class="calibre22">sniptest</tt>, calling a <tt class="calibre22">defsnippet</tt> function yields a sequence of maps representing HTML elements:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(footer "hello")<br class="calibre33"/>;= ({:tag :div, :attrs {:class "footer"}, :content ("hello")})</tt></span></blockquote><p class="calibre23"><tt class="calibre22">deftemplate</tt><a id="filepos1978793"></a> works in much the same way, but you cannot define a root for the transformations to apply to, and instead of a sequence of maps representing HTML, <tt class="calibre22">deftemplate</tt> functions return a lazy sequence of strings containing HTML fragments that can conveniently be used as the <tt class="calibre22">:body</tt> of a Ring response map.</p><p class="calibre18">Knowing all this, we can easily reproduce the results of the ERB template <a id="filepos1979220"></a>we initially considered in <a href="#filepos1956235"><span class="calibre5">Example 16-4</span></a>. First, we define our template file:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 16-7. friends.html</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">&lt;h1&gt;Hello, &lt;span class="username"/&gt;&lt;/h1&gt;<br class="calibre33"/>&lt;p&gt;These are your friends:&lt;/p&gt;<br class="calibre33"/>&lt;ul class="friends"&gt;&lt;li/&gt;&lt;/ul&gt;</tt></span></p><p class="calibre13">And then, either in our application or here in a REPL, we can define an Enlive template function and produce some complete HTML documents:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(h/deftemplate friends-list "friends.html"<br class="calibre33"/>  [username friends]<br class="calibre33"/>  [:.username] (h/content username)<br class="calibre33"/>  [:ul.friends :li] (h/clone-for [f friends]<br class="calibre33"/>                      (h/content f)))<br class="calibre33"/><br class="calibre33"/>(friends-list "Chas" ["Christophe" "Brian"])                   </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= ("&lt;html&gt;" "&lt;body&gt;" "&lt;h1&gt;" "Hello, " "&lt;span class=\"username\"&gt;"<br class="calibre33"/>;=  "Chas" "&lt;/span&gt;" "&lt;/h1&gt;" "\n" "&lt;p&gt;These are your friends:&lt;/p&gt;"<br class="calibre33"/>;=  "\n" "&lt;ul class=\"friends\"&gt;" "&lt;li&gt;" "Christophe" "&lt;/li&gt;" "&lt;li&gt;"<br class="calibre33"/>;=  "Brian" "&lt;/li&gt;" "&lt;/ul&gt;" "\n" "&lt;/body&gt;" "&lt;/html&gt;")</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Remember that <tt class="calibre22">deftemplate</tt> returns a sequence of strings. Although it’s unnecessary when returning content to a client via Ring, if you happen to need a concatenated string result of an Enlive operation, one is a quick <tt class="calibre22">(apply str (friends-list ...))</tt> call away.</blockquote><p class="calibre18">Now, we have reproduced the ERB template we initially considered, but it doesn’t seem like we’re very far ahead. The ERB template, while the source of a host of problems, has the apparent advantage of brevity. Even if we take into account that the ERB’s code is embedded into its HTML content, it still seems like our Enlive corollary demands more code. That might be an acceptable tradeoff, given how much we’ve gained in other areas. After all, no approach is perfect.</p><p class="calibre18">The real benefits of Enlive come as our templates and functional requirements expand beyond the trivial. Since Enlive operations are all implemented as functions operating over a standard set of data structures, we can easily compose them. This is in sharp contrast to most templating systems, which operate at the level of strings and string concatenation.</p><p class="calibre18">To demonstrate, let’s add a new class to each list item we produce in our example using <tt class="calibre22">do-&gt;</tt> to compose two transformers:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(h/deftemplate friends-list "friends.html"<br class="calibre33"/>  [username friends friend-class]<br class="calibre33"/>  [:.username] (h/content username)<br class="calibre33"/>  [:ul.friends :li] (h/clone-for [f friends]<br class="calibre33"/>                      (h/do-&gt; (h/content f)<br class="calibre33"/>                              (h/add-class friend-class))))<br class="calibre33"/><br class="calibre33"/>(friends-list "Chas" ["Christophe" "Brian"] "programmer")<br class="calibre33"/>;= ("&lt;html&gt;" "&lt;body&gt;" "&lt;h1&gt;" "Hello, " "&lt;span class=\"username\"&gt;" "Chas"<br class="calibre33"/>;=  "&lt;/span&gt;" "&lt;/h1&gt;" "\n" "&lt;p&gt;These are your friends:&lt;/p&gt;" "\n"<br class="calibre33"/>;=  "&lt;ul class=\"friends\"&gt;" "&lt;" "li" " " "class" "=\"" "programmer" "\""<br class="calibre33"/>;=  "&gt;" "Christophe" "&lt;/" "li" "&gt;" "&lt;" "li" " " "class" "=\"" "programmer"<br class="calibre33"/>;=  "\"" "&gt;" "Brian" "&lt;/" "li" "&gt;" "&lt;/ul&gt;" "\n" "&lt;/body&gt;" "&lt;/html&gt;")</tt></span></blockquote><p class="calibre23">We’ve hardly increased our code density at all, the change in question is distinct, and it is isolated within the code; meanwhile, our HTML template file hasn’t been touched. For comparison, the traditional ERB method starts to devolve into line noise:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">&lt;h1&gt;Hello, &lt;%= @user.name %&gt;&lt;/h1&gt;<br class="calibre33"/><br class="calibre33"/>&lt;p&gt;These are your friends:&lt;/p&gt;<br class="calibre33"/>&lt;ul&gt;<br class="calibre33"/>&lt;% @user.friends.each do |friend| %&gt;<br class="calibre33"/>  &lt;li class="&lt;%= @friendclass %&gt;"&gt;&lt;%= friend.name %&gt;&lt;/li&gt;<br class="calibre33"/>&lt;% end %&gt;<br class="calibre33"/>&lt;/ul&gt;</tt></span></blockquote><p class="calibre23">Finally, let’s add our footer into the page:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(h/deftemplate friends-list "friends.html"<br class="calibre33"/>  [username friends friend-class]<br class="calibre33"/>  [:.username] (h/content username)<br class="calibre33"/>  [:ul.friends :li] (h/clone-for [f friends]<br class="calibre33"/>                      (h/do-&gt; (h/content f)<br class="calibre33"/>                              (h/add-class friend-class)))<br class="calibre33"/>  [:body] (h/append (footer (str "Goodbye, " username))))  </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/><br class="calibre33"/>(friends-list "Chas" ["Christophe" "Brian"] "programmer")<br class="calibre33"/>;= ("&lt;html&gt;" "&lt;body&gt;" "&lt;h1&gt;" "Hello, " "&lt;span class=\"username\"&gt;" "Chas"<br class="calibre33"/>;= "&lt;/span&gt;" "&lt;/h1&gt;" "\n" "&lt;p&gt;These are your friends:&lt;/p&gt;" "\n"<br class="calibre33"/>;= "&lt;ul class=\"friends\"&gt;" "&lt;" "li" " " "class" "=\"" "programmer" "\""<br class="calibre33"/>;= "&gt;" "Christophe" "&lt;/" "li" "&gt;" "&lt;" "li" " " "class" "=\"" "programmer"<br class="calibre33"/>;= "\"" "&gt;" "Brian" "&lt;/" "li" "&gt;" "&lt;/ul&gt;" "\n" "&lt;div class=\"footer\"&gt;"<br class="calibre33"/>;= "Goodbye, Chas" "&lt;/div&gt;" "&lt;/body&gt;" "&lt;/html&gt;")</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">Where <tt class="calibre22">content</tt> replaces the child content of a selected element, <tt class="calibre22">append</tt> appends to it. If we had used <tt class="calibre22">content</tt> here, the footer would be the only content in the <tt class="calibre22">&lt;body&gt;</tt> of the generated HTML.</blockquote><p class="calibre18">You can call <tt class="calibre22">defsnippet</tt><a id="filepos1985957"></a> functions directly from your template functions as we do above; or, you can pass snippet functions or the results of calls to them into template functions as arguments; or, you can even do things like look up and call snippet functions based on class names present in the HTML of your template files. Because all of the entities involved in building up Enlive templates are generic—functions that consume and produce collections adhering to common abstractions—it’s entirely up to you as to how to combine templates and snippets to assemble complete pages.<a id="filepos1986527"></a></p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1986631"></a><a href="#filepos1959589"><span class="calibre32">411</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Templating is just a special case of transforming HTML or XML data: Enlive can also be used to scrape and extract content from HTML and XML documents using the same selectors it uses for templating. However, we’ll only discuss the use of Enlive for templating here.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1987083"></a><a href="#filepos1967990"><span class="calibre32">412</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Recall that we discussed zippers in </span><a href="#filepos569560"><span class="calibre10"><span class="calibre5">Navigation, Update, and Zippers</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1987435"></a><a href="#filepos1968363"><span class="calibre32">413</span></a><span class="calibre32">] </span></small></sup><span class="calibre10"><tt class="calibre22">attr=</tt></span><span class="calibre10"> is used in </span><a href="#filepos1963968"><span class="calibre10"><span class="calibre5">Example 16-5</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos1987734" class="calibre6"><span class="calibre4"><span class="bold">Final Thoughts</span></span></p><p class="calibre18">Throughout this chapter, we’ve seen how a functional approach to software design yields small but very powerful abstractions that let us quickly produce server-side applications. We’ve made an HTTP service in 26 short lines. We’ve shown how we can take a radically different approach to web content generation with Enlive, cutting our templates away from our server code along a novel axis. We’ve seen everything you need to make a middling-sized web framework. With proper persistent storage, there are few if any web properties that you couldn’t tackle with these components.</p><p class="calibre18">But even more interesting than what we’ve shown is what we haven’t shown: a big stack with frameworks and generators. This might be considered a complaint leveled at the state of Clojure’s web libraries. Those coming from Python or Ruby (or even Java) might be used to generators, fixtures, controllers, and views. Our examples have had none of these, and their absence may be jarring to an experienced web developer.</p><p class="calibre18">An experienced functional programmer might notice that this state of affairs is actually common for most functional languages. Because of the nature of functional programming, it’s very easy to knit together complex systems from very simple, basic functions. For example, adding authorization to our bookmarking example could be achieved with the addition of one small piece of middleware. The lightweight nature of the libraries and abstractions involved makes this possible and easy, in sharp contrast to the extremely heavyweight authorization hooks in a full web stack like Django or Spring-augmented Java.</p><p class="calibre18">In fact, this lightweight functional approach has made such an impression that it has started to press influence back to the traditional web communities. Small “ultra-lightweight” web frameworks are springing up in every language, concerned with only basic routing, rendering, and simple modeling.</p><p class="calibre18">This is not to say that Ring and Compojure and Enlive are the final word on Clojure web development. A variety of “batteries-included” frameworks have begun to appear,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1990094"></a><a href="#filepos1990619"><span class="calibre32">414</span></a><span class="calibre32">]</span></small></sup> as well as various larger-stack frameworks and app servers.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1990284"></a><a href="#filepos1991136"><span class="calibre32">415</span></a><span class="calibre32">]</span></small></sup> However, it is telling that most of these new developments have been happy to build upon the foundational pieces we’ve explored here.<a id="filepos1990515"></a></p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1990619"></a><a href="#filepos1990094"><span class="calibre32">414</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Such as Noir (</span><a href="http://www.webnoir.org"><span class="calibre10"><span class="calibre5">http://www.webnoir.org</span></span></a><span class="calibre10">) and Ringfinger (</span><a href="https://github.com/myfreeweb/ringfinger"><span class="calibre10"><span class="calibre5">https://github.com/myfreeweb/ringfinger</span></span></a><span class="calibre10">).</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1991136"></a><a href="#filepos1990284"><span class="calibre32">415</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">The most notable of which is Immutant, an application server for Clojure built on top of JBoss: </span><a href="http://immutant.org"><span class="calibre10"><span class="calibre5">http://immutant.org</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos1991497" class="calibre6"><span class="calibre2"><span class="bold">Chapter 17. Deploying Clojure Web Applications</span></span></p><p id="filepos1991606" class="calibre13">Once you’re past a certain point of competence with Clojure and are on your way toward having a working application completed, you’ll inevitably need to deliver its functionality to your users and customers. The modern era has tilted distribution norms toward server-side deployments (often “in the cloud”) that clients interact with via web services and interfaces. In this chapter, we’ll explore the various ways one can package and then deploy Clojure web applications, taking full advantage of the mature facilities that the JVM and Java ecosystem provide for doing so.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1992252"></a><a href="#filepos2018406"><span class="calibre32">416</span></a><span class="calibre32">]</span></small></sup></p><p id="filepos1992351" class="calibre6"><span class="calibre4"><span class="bold">Java and Clojure Web Architecture</span></span></p><p id="filepos1992445" class="calibre18">Almost without exception, Clojure web applications are packaged and deployed as <span class="italic">servlets</span><a id="filepos1992568"></a>, the same fundamental architecture used by web applications written in Java. Web servlets are simply Java classes that extend the <tt class="calibre22">javax.servlet.http.HttpServlet</tt> base class, which defines a programmatic interface for handling HTTP requests. There are methods for each HTTP request method (<tt class="calibre22">GET</tt>, <tt class="calibre22">POST</tt>, and so on), each of which accept request and response objects; each HTTP request method implementation examines the incoming request and coordinates the writing out of the response contents. Applications that follow the servlet specification (which boils down to implementing a single Java interface and following some packaging conventions) can be deployed as web applications to any of many dozens of app servers, many of which offer a variety of specialized capabilities on top of the baseline Java servlet support (like database connection pooling, message queue implementations, management and monitoring features, and so on).</p><p class="calibre18">With a few exceptions, app servers provide for <span class="italic">multitenancy</span><a id="filepos1993631"></a>, so you can deploy multiple applications, each potentially containing multiple servlets, to the same app server (<a href="#filepos1994188"><span class="calibre5">Figure 17-1</span></a>). Nearly all app servers are also web servers (often with very mature, performant HTTP/HTTPS implementations), but you can also opt to deploy to an app server proxied by a dedicated web server (such as Apache httpd, lighttpd, or IIS).<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1994089"></a><a href="#filepos2019067"><span class="calibre32">417</span></a><span class="calibre32">]</span></small></sup></p><blockquote id="filepos1994188" class="calibre47"></blockquote><blockquote class="calibre48"><img src="images/00066.jpg" class="calibre123"/></blockquote><blockquote class="calibre47"><span class="calibre10"><span class="italic"><span class="calibre7">Figure 17-1. Java web architecture</span></span></span><a id="filepos1994531"></a></blockquote><p class="calibre50">By piggybacking on this architecture and ecosystem, Clojure web applications enjoy the same diversity of deployment targets and operational capabilities as their Java web application cousins.</p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">NOTE</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">The Java server specification landscape is vast, of which servlets are one (admittedly foundational) part. Other specifications include standards for message queue support, directory access, and database persistence formalisms, defined by JMS, JNDI, and JPA, respectively. If your organization already has investments in these specifications, then you’ll be pleased to know that Clojure can participate in and use those facilities just as readily as it can take advantage of the servlet spec. On the other hand, if you’ve never heard of these JEE (</span><span class="calibre10"><span class="italic">Java Enterprise Edition</span></span><span class="calibre10">, née </span><span class="calibre10"><span class="italic">J2EE</span></span><span class="calibre10">) standards, you’ll be equally happy to know that you don’t need to know anything about them in order to build and deploy fully featured Clojure web applications.</span></blockquote><p class="calibre25">While you can implement servlets directly in Clojure (it’s just a matter of subclassing the <tt class="calibre22">HttpServlet</tt> base class, after all), it is vastly preferable to use a Clojure web framework (like Ring, examined in detail in <a href="#filepos1878886"><span class="calibre5">Chapter 16</span></a>) to abstract away from the programmatic (and decidedly imperative) nature of the servlet API. In Ring’s case, each handler is a function that accepts a Clojure map argument that is an idiomatic translation of the data in the servlet’s HTTP request object, returning a value that a Ring adapter writes out to the servlet’s HTTP response object. These handlers are then combined with routes—pairings of HTTP request methods (again, such as <tt class="calibre22">GET</tt>) and URL matchers—to yield a single function that encapsulates the unified functionality of your application across all types of supported HTTP verbs and URLs. Ring provides a couple of adapters that delegate a concrete servlet’s handler methods to that function.</p><p class="calibre18">If we “zoom” in on the Clojure web app in <a href="#filepos1994188"><span class="calibre5">Figure 17-1</span></a>, we can visualize the relationship between servlets and Ring:</p><blockquote class="calibre47"></blockquote><blockquote class="calibre48"><img src="images/00006.jpg" class="calibre124"/></blockquote><blockquote class="calibre47"><span class="calibre10"><span class="italic"><span class="calibre7">Figure 17-2. Clojure/Ring web app architecture</span></span></span><a id="filepos1997441"></a></blockquote><p class="calibre50">This bridging of the servlet architecture and Ring’s model can be done a couple of different ways depending on what your deployment strategy is:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">If you are going to use one of the embeddable app servers (Jetty and Glassfish being the most popular), you can produce a servlet wrapper at runtime and simply hand that to the app server running within the same JVM. With everything happening at runtime, and no special packaging or build process, this is perfect for development and local testing scenarios.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Deploying to a standalone app server<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1998279"></a><a href="#filepos2019770"><span class="calibre32">418</span></a><span class="calibre32">]</span></small></sup> generally requires that you package your web app into a <span class="italic">.war</span> file. This packaging step is a trivial addition to whatever build process you have in place already and will allow you to deploy your Clojure web application into any specification-compliant app server (including hosted platforms like Google App Engine<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1998730"></a><a href="#filepos2020128"><span class="calibre32">419</span></a><span class="calibre32">]</span></small></sup> and Amazon’s Elastic Beanstalk<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1998893"></a><a href="#filepos2020456"><span class="calibre32">420</span></a><span class="calibre32">]</span></small></sup>).<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos1999025"></a><a href="#filepos2020784"><span class="calibre32">421</span></a><span class="calibre32">]</span></small></sup></blockquote></li></ol><p class="calibre18">There are tradeoffs involved in both methods. Deploying to a standalone application server does involve some additional build and packaging configuration and process. On the other hand, going to production on top of an embedded app server (sometimes this is referred to as a <span class="italic">containerless</span> approach)<a id="filepos1999476"></a> forces you to create and maintain whatever bootstrap, deployment, and management processes you need, rather than simply reusing the (presumably better-tested) facilities provided by a standalone app server. We recommend that you do whatever you are most used to at first, and experiment with both options when possible so you can land on the best process for your project and team.</p><p class="calibre18">We already demonstrated how applications can be run from the REPL in the embedded Jetty runtime in <a href="#filepos1878886"><span class="calibre5">Chapter 16</span></a>; let’s now tackle <span class="italic">.war</span> packaging, which will allow us to flexibly deploy to production-ready app servers and hosted platforms.</p><p id="filepos2000202" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Web Application Packaging</span></span></span></p><p id="filepos2000317" class="calibre18">A Java web application is packaged into a <span class="italic">.war</span><a id="filepos2000398"></a> file, an extension of the <span class="italic">.jar</span> file packaging discussed in <a href="#filepos1208273"><span class="calibre5">Artifacts and coordinates</span></a>.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2000588"></a><a href="#filepos2021230"><span class="calibre32">422</span></a><span class="calibre32">]</span></small></sup> The typical <span class="italic">.war</span> file layout includes:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Resources like HTML files and images that are statically served out of the “top level” of the <span class="italic">.war</span> file</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">A variety of data rooted in a <span class="italic">WEB-INF</span> directory entry, under which you can find:</blockquote><ul class="calibre55"><li value="1" class="calibre16"><blockquote class="calibre17">A <span class="italic">web.xml</span> file that describes how the <span class="italic">.war</span> file should be deployed into a web application server.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">A <span class="italic">lib</span> directory entry, which can contain any number of nested <span class="italic">.jar</span> files. This is usually where all of the transitive dependencies of a web application are housed, and is what makes <span class="italic">.war</span> files self-contained deployable units (in contrast to other server application architectures that require extensive server configuration to ensure that the dependencies of deployed applications are available).</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">A <span class="italic">classes</span> directory entry, which contains Clojure source files, JVM class files (including class files resulting from AOT-compiling Clojure source), and other assets. This corresponds with the content of a typical <span class="italic">.jar</span> file, and is where the “top level” code for the web application is housed (in contrast to its dependencies).</blockquote></li></ul></li></ul><p class="calibre18">The linchpin of the <span class="italic">.war</span> packaging convention is the <span class="italic">web.xml</span> file. It is how one defines how an application should be deployed; in part, it can:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">“Mount” individual servlets on particular paths, allowing a single <span class="italic">.war</span> file to contain multiple independent applications rooted at different paths</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Specify which classes of static resources (such as CSS, JavaScript, and image files) should be served by the app server directly without being handled by mounted servlets</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Configure behavior of user sessions, including session timeouts as well as which storage mechanisms should be used to retain session data</blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17">Configure app-server-specific services and features</blockquote></li></ul><p class="calibre18">Here’s a very simple example <span class="italic">web.xml</span> file, which defines a single servlet (<tt class="calibre22">com.clojurebook.hello_world</tt>) that is mounted at the root (<tt class="calibre22">/</tt>) of the app server’s context, and requests that the “default” servlet (every app server has one for serving static resources) should be responsible for serving a variety of static files defined by their file extensions:</p><p id="filepos2003902" class="calibre23"></p><p class="calibre23"><span class="italic">Example 17-1. Simple web.xml file</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br class="calibre33"/>&lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee"<br class="calibre33"/>         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br class="calibre33"/>         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee <br class="calibre33"/>                             http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt;<br class="calibre33"/>    &lt;servlet&gt;<br class="calibre33"/>        &lt;servlet-name&gt;app&lt;/servlet-name&gt;<br class="calibre33"/>        &lt;servlet-class&gt;com.clojurebook.hello_world&lt;/servlet-class&gt;<br class="calibre33"/>    &lt;/servlet&gt;<br class="calibre33"/>    &lt;servlet-mapping&gt;<br class="calibre33"/>        &lt;servlet-name&gt;app&lt;/servlet-name&gt;<br class="calibre33"/>        &lt;url-pattern&gt;/&lt;/url-pattern&gt;<br class="calibre33"/>    &lt;/servlet-mapping&gt;<br class="calibre33"/>    &lt;servlet-mapping&gt;<br class="calibre33"/>        &lt;servlet-name&gt;default&lt;/servlet-name&gt;<br class="calibre33"/>        &lt;url-pattern&gt;*.css&lt;/url-pattern&gt;<br class="calibre33"/>        &lt;url-pattern&gt;*.js&lt;/url-pattern&gt;<br class="calibre33"/>        &lt;url-pattern&gt;*.png&lt;/url-pattern&gt;<br class="calibre33"/>        &lt;url-pattern&gt;*.jpg&lt;/url-pattern&gt;<br class="calibre33"/>        &lt;url-pattern&gt;*.gif&lt;/url-pattern&gt;<br class="calibre33"/>        &lt;url-pattern&gt;*.ico&lt;/url-pattern&gt;<br class="calibre33"/>        &lt;url-pattern&gt;*.swf&lt;/url-pattern&gt;<br class="calibre33"/>    &lt;/servlet-mapping&gt;<br class="calibre33"/>&lt;/web-app&gt;</tt></span></p><p class="calibre13">This is the <span class="italic">web.xml</span> file that we’ll use in our Maven-built Clojure web app; Leiningen takes a different approach where the <span class="italic">web.xml</span> file is generated from configuration housed in its <span class="italic">project.clj</span> file. As we’ll see throughout the rest of this chapter, your choice of build tool does influence minor details related to the packaging and organization of our web application.</p><p id="filepos2006010" class="calibre23"><span class="calibre53"><span class="bold">Building .war files with Maven</span></span></p><p id="filepos2006101" class="calibre18">As we saw in <a href="#filepos1230538"><span class="calibre5">Maven</span></a>, Maven projects produce <span class="italic">.jar</span> files by default, at least when your <span class="italic">pom.xml</span> defines a <tt class="calibre22">&lt;packaging&gt;</tt> of <tt class="calibre22">clojure</tt> (or <tt class="calibre22">jar</tt>, the default). Changing <tt class="calibre22">&lt;packaging&gt;</tt> to <tt class="calibre22">war</tt> will result in your project being packaged up as a <span class="italic">.war</span> file any time <tt class="calibre22">mvn package</tt> is invoked (or any phase that depends upon <tt class="calibre22">package</tt>, such as <tt class="calibre22">install</tt> or <tt class="calibre22">deploy</tt>). Since we’re not using the <tt class="calibre22">clojure</tt> packaging anymore, we also need to attach <tt class="calibre22">clojure-maven-plugin</tt>’s <tt class="calibre22">compile</tt> goal to Maven’s <tt class="calibre22">compile</tt> phase:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 17-2. pom.xml suitable for simple Clojure webapp projects</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" <br class="calibre33"/>         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br class="calibre33"/>    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 <br class="calibre33"/>                        http://maven.apache.org/maven-v4_0_0.xsd"&gt;<br class="calibre33"/>    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br class="calibre33"/>    <br class="calibre33"/>    &lt;groupId&gt;com.clojurebook&lt;/groupId&gt;<br class="calibre33"/>    &lt;artifactId&gt;sample-maven-web-project&lt;/artifactId&gt;<br class="calibre33"/>    &lt;version&gt;1.0.0&lt;/version&gt;<br class="calibre33"/>    &lt;packaging&gt;war&lt;/packaging&gt;<br class="calibre33"/><br class="calibre33"/>    &lt;dependencies&gt;<br class="calibre33"/>        &lt;dependency&gt;<br class="calibre33"/>            &lt;groupId&gt;org.clojure&lt;/groupId&gt;<br class="calibre33"/>            &lt;artifactId&gt;clojure&lt;/artifactId&gt;<br class="calibre33"/>            &lt;version&gt;1.3.0&lt;/version&gt;<br class="calibre33"/>        &lt;/dependency&gt;<br class="calibre33"/>        &lt;dependency&gt;<br class="calibre33"/>            &lt;groupId&gt;compojure&lt;/groupId&gt;<br class="calibre33"/>            &lt;artifactId&gt;compojure&lt;/artifactId&gt;<br class="calibre33"/>            &lt;version&gt;1.0.1&lt;/version&gt;<br class="calibre33"/>        &lt;/dependency&gt;<br class="calibre33"/>        &lt;dependency&gt;<br class="calibre33"/>            &lt;groupId&gt;ring&lt;/groupId&gt;<br class="calibre33"/>            &lt;artifactId&gt;ring-servlet&lt;/artifactId&gt;<br class="calibre33"/>            &lt;version&gt;1.0.1&lt;/version&gt;<br class="calibre33"/>        &lt;/dependency&gt;<br class="calibre33"/>    &lt;/dependencies&gt;<br class="calibre33"/><br class="calibre33"/>    &lt;build&gt;<br class="calibre33"/>        &lt;plugins&gt;<br class="calibre33"/>            &lt;plugin&gt;<br class="calibre33"/>                &lt;groupId&gt;com.theoryinpractise&lt;/groupId&gt;<br class="calibre33"/>                &lt;artifactId&gt;clojure-maven-plugin&lt;/artifactId&gt;<br class="calibre33"/>                &lt;version&gt;1.3.8&lt;/version&gt;<br class="calibre33"/>                &lt;extensions&gt;true&lt;/extensions&gt;<br class="calibre33"/>                &lt;configuration&gt;<br class="calibre33"/>                    &lt;warnOnReflection&gt;true&lt;/warnOnReflection&gt;<br class="calibre33"/>                    &lt;temporaryOutputDirectory&gt;false&lt;/temporaryOutputDirectory&gt;<br class="calibre33"/>                &lt;/configuration&gt;<br class="calibre33"/>                <br class="calibre33"/>                &lt;executions&gt;<br class="calibre33"/>                    &lt;execution&gt;<br class="calibre33"/>                        &lt;id&gt;compile-clojure&lt;/id&gt;<br class="calibre33"/>                        &lt;phase&gt;compile&lt;/phase&gt;<br class="calibre33"/>                        &lt;goals&gt;<br class="calibre33"/>                            &lt;goal&gt;compile&lt;/goal&gt;<br class="calibre33"/>                        &lt;/goals&gt;<br class="calibre33"/>                    &lt;/execution&gt;<br class="calibre33"/>                &lt;/executions&gt;<br class="calibre33"/>            &lt;/plugin&gt;<br class="calibre33"/>            &lt;plugin&gt;<br class="calibre33"/>                &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;<br class="calibre33"/>                &lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt;<br class="calibre33"/>                &lt;version&gt;6.1.15&lt;/version&gt;<br class="calibre33"/>                &lt;configuration&gt;<br class="calibre33"/>                    &lt;webAppConfig&gt;<br class="calibre33"/>                        &lt;extraClasspath&gt;<br class="calibre33"/>                          src/main/webapp,src/main/resources,src/main/clojure<br class="calibre33"/>                        &lt;/extraClasspath&gt;<br class="calibre33"/>                    &lt;/webAppConfig&gt;<br class="calibre33"/>                    &lt;reload&gt;manual&lt;/reload&gt;<br class="calibre33"/>                &lt;/configuration&gt;<br class="calibre33"/>            &lt;/plugin&gt;<br class="calibre33"/>        &lt;/plugins&gt;<br class="calibre33"/>    &lt;/build&gt;<br class="calibre33"/>&lt;/project&gt;</tt></span></p><p class="calibre13">This sample <span class="italic">pom.xml</span> also includes the baseline dependencies needed to use Compojure and Ring, and some configuration for the <tt class="calibre22">maven-jetty-plugin</tt>; the latter allows us to run our web application locally using the embedded Jetty app server, ideal for development and local testing.</p><p class="calibre18">Our simple webapp consists of a single handler; since we can include our own <span class="italic">web.xml</span> file when building it with Maven, we can rely on the app server to handle requests for static files, so no additional route is needed for images and such:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 17-3. com.clojurebook.hello-world</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(ns com.clojurebook.hello-world<br class="calibre33"/>  (:use<br class="calibre33"/>    [ring.util.servlet :only (defservice)]<br class="calibre33"/>    [compojure.core :only (GET)])<br class="calibre33"/>  (:gen-class<br class="calibre33"/>    :extends javax.servlet.http.HttpServlet))<br class="calibre33"/><br class="calibre33"/>(defservice<br class="calibre33"/>  (GET "*" {:keys [uri]}<br class="calibre33"/>       (format "&lt;html&gt;<br class="calibre33"/>                URL requested: %s<br class="calibre33"/>                &lt;p&gt;<br class="calibre33"/>                  &lt;a href=\"/wright_pond.jpg\"&gt;<br class="calibre33"/>                    Image served by app server via web.xml &lt;servlet-mapping&gt;<br class="calibre33"/>                  &lt;/a&gt;<br class="calibre33"/>                &lt;/p&gt;<br class="calibre33"/>                &lt;/html&gt;"<br class="calibre33"/>               uri)))</tt></span></p><p id="filepos2012970" class="calibre13"><span class="calibre53"><span class="bold">Building .war files with Leiningen</span></span></p><p class="calibre18"><tt class="calibre22">lein-ring<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2013141"></a><a href="#filepos2022092"><span class="calibre32">423</span></a><span class="calibre32">]</span></small></sup></tt><a id="filepos2013241"></a> is a Leiningen plug-in that provides a number of facilities useful for developing Ring web applications when using Leiningen. One of these is the production of <span class="italic">.war</span> files, with the <span class="italic">generation</span> of <span class="italic">web.xml</span> files based on configuration in your <span class="italic">project.clj</span> file. This approach is quite different (and <span class="italic">much</span> shorter and simpler!) than Maven’s, where you must author the <span class="italic">web.xml</span> file yourself.</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 17-4. project.clj suitable for simple Clojure webapp projects</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(defproject com.clojurebook/sample-lein-web-project "1.0.0"<br class="calibre33"/>  :dependencies [[org.clojure/clojure "1.4.0"]<br class="calibre33"/>                 [compojure/compojure "1.0.1"]<br class="calibre33"/>                 [ring/ring-servlet "1.0.1"]]<br class="calibre33"/>  plugins [[lein-ring "0.6.2"]]<br class="calibre33"/>  :ring {:handler com.clojurebook.hello-world/routes})</tt></span></p><p class="calibre13">The only configuration that <tt class="calibre22">lein-ring</tt><a id="filepos2014337"></a> requires is the <tt class="calibre22">:ring :handler</tt> slot, which is where you specify the namespace-qualified name of the var that holds your application’s top-level request handler. From that name, <tt class="calibre22">lein-ring</tt> will generate a servlet class (in this case, called <tt class="calibre22">com.clojurebook.servlet</tt>), which will delegate requests to our handler, and a <span class="italic">web.xml</span> file that defines that servlet and mounts it at the root URL path (<tt class="calibre22">/</tt>). This is the equivalent of our specifying our own <span class="italic">web.xml</span> and using <tt class="calibre22">gen-class</tt> and <tt class="calibre22">defservice</tt> to generate the servlet class and request delegation in the Maven project.</p><p class="calibre18">With this <span class="italic">project.clj</span> in place, running <tt class="calibre22">lein ring uberwar</tt> will produce a <span class="italic">.war</span> file that we can use to deploy to any app server.</p><p class="calibre18">Since <tt class="calibre22">lein-ring</tt> is generating our <span class="italic">web.xml</span> file without specifying that the app server’s default servlet should handle requests for static resources, we need to include a route in our main handler that will serve these assets from our classpath:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 17-5. com/clojurebook/hello_world.clj</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(ns com.clojurebook.hello-world<br class="calibre33"/>  (:use<br class="calibre33"/>    [compojure.core :only (GET defroutes)]<br class="calibre33"/>    [compojure.route :only (resources)]))<br class="calibre33"/><br class="calibre33"/>(defroutes routes<br class="calibre33"/>  (resources "/")<br class="calibre33"/>  (GET "*" {:keys [uri]}<br class="calibre33"/>       (format "&lt;html&gt;<br class="calibre33"/>                URL requested: %s<br class="calibre33"/>                &lt;p&gt;<br class="calibre33"/>                  &lt;a href=\"/wright_pond.jpg\"&gt;<br class="calibre33"/>                    Image served by compojure.route/resources<br class="calibre33"/>                  &lt;/a&gt;<br class="calibre33"/>                &lt;/p&gt;<br class="calibre33"/>                &lt;/html&gt;"<br class="calibre33"/>               uri)))</tt></span></p><blockquote class="calibre89"><span class="calibre21"><span class="bold"><span class="calibre7">WARNING</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10"><tt class="calibre22">lein-ring</tt></span><span class="calibre10"> only allows you to define a subset of the configuration options available in </span><span class="calibre10"><span class="italic">web.xml</span></span><span class="calibre10"> files, and it does not currently allow you to provide your own </span><span class="calibre10"><span class="italic">web.xml</span></span><span class="calibre10"> file. Thus, if you wish to use certain servlet specification features (such as servlet filters, context parameters, and default servlet mappings—which we use in the Maven example to let our app server handle requests for static resources), you will need to:</span></blockquote><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17"><span class="calibre10">Use the </span><span class="calibre10"><tt class="calibre22">leiningen-war</tt></span><span class="calibre10"> plug-in<sup class="calibre58"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2017445"></a><a href="#filepos2022485"><span class="calibre32">424</span></a><span class="calibre32">]</span></small></sup> (which only builds </span><span class="calibre10"><span class="italic">.war</span></span><span class="calibre10"> files; it does not provide the local Jetty deployment features of </span><span class="calibre10"><tt class="calibre22">lein-ring</tt></span><span class="calibre10">), or</span></blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17"><span class="calibre10">Add some additional scripting on top of your </span><span class="calibre10"><tt class="calibre22">lein-ring</tt></span><span class="calibre10"> usage to swap a customized </span><span class="calibre10"><span class="italic">web.xml</span></span><span class="calibre10"> file into the </span><span class="calibre10"><span class="italic">.war</span></span><span class="calibre10"> files it produces, or</span></blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17"><span class="calibre10">Use Maven.</span></blockquote></li><a id="filepos2018301"></a></ul><br class="calibre33"/><hr class="calibre34"/><p class="calibre25"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2018406"></a><a href="#filepos1992252"><span class="calibre32">416</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">There is no reason why the same practices and infrastructure that we describe here (tweaked in minor ways) cannot be effectively reused to deploy and manage server applications that do not expose web services. More broadly, client-side Clojure applications (for use in desktop or mobile environments) can follow the same general deployment path that Clojure web applications do: find how their Java cousins are deployed, and piggyback on the same infrastructure and processes.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2019067"></a><a href="#filepos1994089"><span class="calibre32">417</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Some app servers offer methods other than HTTP proxy for communication between an app server instance and a dedicated web server; for very high-load scenarios, these methods may be more efficient than HTTP proxying. For example, the Tomcat app server offers a set of Apache and ISAPI modules that implement a compact binary communications protocol: </span><a href="http://tomcat.apache.org/connectors-doc/"><span class="calibre10"><span class="calibre5">http://tomcat.apache.org/connectors-doc/</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2019770"></a><a href="#filepos1998279"><span class="calibre32">418</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">There are dozens of mature, well-supported app servers, each of which provides its own set of extra features on top of the foundational servlet and other JEE specifications.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2020128"></a><a href="#filepos1998730"><span class="calibre32">419</span></a><span class="calibre32">] </span></small></sup><a href="https://github.com/gcv/appengine-magic"><span class="calibre10"><span class="calibre5">https://github.com/gcv/appengine-magic</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2020456"></a><a href="#filepos1998893"><span class="calibre32">420</span></a><span class="calibre32">] </span></small></sup><a href="http://aws.amazon.com/elasticbeanstalk"><span class="calibre10"><span class="calibre5">http://aws.amazon.com/elasticbeanstalk</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2020784"></a><a href="#filepos1999025"><span class="calibre32">421</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Note that one of the most popular Clojure deployment targets of late, Heroku, has a significantly different take on application deployment; see </span><a href="#filepos2086843"><span class="calibre10"><span class="calibre5">Clojure on Heroku</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2021230"></a><a href="#filepos2000588"><span class="calibre32">422</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">We are merely scratching the surface here of what you can control about how your web applications are managed and deployed, especially through setting various parameters in the </span><span class="calibre10"><span class="italic">web.xml</span></span><span class="calibre10"> file you include in your </span><span class="calibre10"><span class="italic">.war</span></span><span class="calibre10">. You can read more about </span><span class="calibre10"><span class="italic">.war</span></span><span class="calibre10"> files and </span><span class="calibre10"><span class="italic">web.xml</span></span><span class="calibre10"> options at </span><a href="http://java.sun.com/j2ee/tutorial/1_3-fcs/doc/WCC3.html"><span class="calibre10"><span class="calibre5">http://java.sun.com/j2ee/tutorial/1_3-fcs/doc/WCC3.html</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2022092"></a><a href="#filepos2013141"><span class="calibre32">423</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="https://github.com/weavejester/lein-ring"><span class="calibre10"><span class="calibre5">https://github.com/weavejester/lein-ring</span></span></a><span class="calibre10"> for full documentation and details.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2022485"></a><a href="#filepos2017445"><span class="calibre32">424</span></a><span class="calibre32">] </span></small></sup><a href="https://github.com/alienscience/leiningen-war"><span class="calibre10"><span class="calibre5">https://github.com/alienscience/leiningen-war</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos2022780" class="calibre6"><span class="calibre4"><span class="bold">Running Web Apps Locally</span></span></p><p id="filepos2022865" class="calibre18">Whether you prefer Maven or Leiningen, Jetty is used to run web apps locally for development and testing. This allows you to rapidly prototype new features and bug fixes without going through a complete packaging and deployment cycle as required for “real” deployments to production or common remote testing environments.</p><p class="calibre18"><span class="bold">Maven</span>. <a id="filepos2023265"></a>As noted in <a href="#filepos2006010"><span class="calibre5">Building .war files with Maven</span></a>, our sample webapp-ready <span class="italic">pom.xml</span> includes a configuration for <tt class="calibre22">maven-jetty-plugin</tt>. Invoke <tt class="calibre22">mvn jetty:run</tt> within a project with such a configuration, and Jetty will be started on <tt class="calibre22">localhost</tt> port 8080, running the project’s web application. As you make changes to your Clojure code, static assets, or <span class="italic">web.xml</span> file, you will want those changes available to your application running in Jetty without stopping and restarting it fully. To do this, hit Return in the console where you started Maven; this will reload the Jetty webapp context that your application is running within, a far faster process than killing the Maven/Jetty process and starting it from scratch.</p><p class="calibre18"><span class="bold">Leiningen</span>. Leiningen’<a id="filepos2024136"></a>s support for running web apps locally is essentially the same as Maven’s. <tt class="calibre22">lein ring server</tt> will start a Jetty server with all requests routed to the root handler provided in your <span class="italic">project.clj</span> file’s <tt class="calibre22">:ring :handler</tt> slot. <tt class="calibre22">lein-ring</tt> takes a slightly different approach to loading changed files into your running webapp: rather than waiting until you request a reload of the application context, <tt class="calibre22">lein-ring</tt> reloads all of the Clojure source files in your project each time it receives a request using Clojure’s <tt class="calibre22">require</tt> function.</p><p class="calibre18"><span class="bold">Loading updated code via “remote” REPLs</span>. <a id="filepos2024809"></a>A more flexible code-loading solution than that offered by either <tt class="calibre22">maven-jetty-plugin</tt> or <tt class="calibre22">lein-ring</tt> is to bundle a REPL server with your web application, and configure it to start upon deployment. This will allow you to connect to the “remote” REPL server from your development environment (such as Eclipse + Counterclockwise or Emacs + SLIME), and load Clojure code when you want to, rather than having to rely upon a timeout, context-switch to the terminal from which Jetty was started, or potentially delay saving changes to disk until you’re ready to have those changes loaded into your running app.</p><p class="calibre18">This is a general-purpose approach that is not limited to web applications, and not limited to local deployments; see <a href="#filepos1437663"><span class="calibre5">Chapter 10</span></a> for details.</p><div class="mbppagebreak"></div><p id="filepos2025690" class="calibre6"><span class="calibre4"><span class="bold">Web Application Deployment</span></span></p><p id="filepos2025777" class="calibre18">Being able to package Clojure web applications into standard <span class="italic">.war</span> files gives us a lot of deployment flexibility: all of the deployment practices and facilities available for deploying Java web applications are therefore available for use with Clojure web apps. In general, the act of deployment requires the following:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">Setting up and configuring an app server</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Copying the <span class="italic">.war</span> file your build process is producing to your server</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Restarting the app server if necessary</blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17">If necessary, reverting your application’s <span class="italic">.war</span> file to a prior version (in case the last deployed version contained a regression, for example)</blockquote></li></ol><p class="calibre18">You can certainly do these things manually or in a custom way—programmers and system administrators have been doing “hands-on” application deployments for a <span class="italic">long</span> time. And, if your organization already deploys Java web applications, you can almost surely drop your shiny new Clojure web apps into that same process.</p><p class="calibre18">However, if you’re game, there are some specific Clojure-friendly toolchains that can make application deployment a lot simpler, easier, and more automated than most other options. We’ll take a look at one, Amazon’s Elastic Beanstalk service, that is broadly applicable to Clojure web applications, automating the provisioning and configuration of servers and deployment of applications to those servers.</p><p id="filepos2027663" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">Deploying Clojure Apps to Amazon’s Elastic Beanstalk</span></span></span></p><p id="filepos2027807" class="calibre18">Amazon’s Elastic Beanstalk (EB) is a <span class="italic">platform as a service</span> that provides a thin layer of automation and deployment management tools on top of Amazon Web Services’s (AWS) lower-level EC2 compute and load balancer services. EB allows you to programmatically provision and control <span class="italic">environments</span> (collections of one or more application servers fronted by a load balancer), to which you can deploy different versions of your application.</p><p class="calibre18">The load balancers used by EB are integrated with this provisioning mechanism, so that when your application experiences higher load (based on metrics you define, such as number of requests or aggregate bandwidth utilized per minute), the corresponding EB environment is expanded to contain more app servers to service that load. Especially if your application uses AWS’s database facilities<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2028744"></a><a href="#filepos2037869"><span class="calibre32">425</span></a><span class="calibre32">]</span></small></sup> or some other hosted database that can be co-located in AWS,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2028935"></a><a href="#filepos2038580"><span class="calibre32">426</span></a><span class="calibre32">]</span></small></sup> EB can be a very compelling deployment option that addresses the entire development, deployment, and maintenance life cycle of your application.</p><p class="calibre18">AWS provides a comprehensive Java API to their services, including EB, so interacting with it from Clojure is straightforward. Conveniently, there is a Leiningen plug-in for interacting with EB, lein-beanstalk.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2029452"></a><a href="#filepos2038940"><span class="calibre32">427</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18"><span class="bold">Basic setup and deployment</span>. A couple of changes need to be made to a Leiningen-ready web application project to make it ready for use with <tt class="calibre22">lein-beanstalk</tt>. First, add the <tt class="calibre22">lein-beanstalk</tt> plug-in to your <span class="italic">project.clj</span>’s <tt class="calibre22">plugins</tt> vector.</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">[lein-beanstalk "0.2.2"]</tt></span></blockquote><p class="calibre23">Second, we need to add a Compojure route to support Elastic Beanstalk’s “heartbeat.” At regular intervals, your deployed application will be polled with a <tt class="calibre22">HEAD</tt> request to its root (<tt class="calibre22">/</tt>) URI; if it doesn’t respond successfully, then Elastic Beanstalk will assume the entire application is down and attempt to redeploy and restart it. For this example, let’s reuse the URL shortener service we built in <a href="#filepos1918631"><span class="calibre5">Routing Requests with Compojure</span></a>; we’ll set up the Beanstalk heartbeat route in its own namespace, and—as further confirmation of the composability of Compojure routes and Ring handlers in general—just roll in the top-level route from the actual URL shortener service:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 17-6. com.clojurebook.url-shortener.beanstalk</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(ns com.clojurebook.url-shortener.beanstalk<br class="calibre33"/>  (:use [compojure.core :only (HEAD defroutes)])<br class="calibre33"/>  (:require [com.clojurebook.url-shortener :as shortener]<br class="calibre33"/>	        [compojure.core :as compojure]))<br class="calibre33"/><br class="calibre33"/>(compojure/defroutes app<br class="calibre33"/>  ; This HEAD route is here because Amazon's Elastic Beanstalk determines if<br class="calibre33"/>  ; your application is up by whether it responds successfully to a<br class="calibre33"/>  ; HEAD request at /<br class="calibre33"/>  (compojure/HEAD "/" [] "")<br class="calibre33"/>  shortener/app)</tt></span></p><p class="calibre13">The last modification we’ll need to make to the project is to add a suitable <tt class="calibre22">:ring :handler</tt> configuration, since <tt class="calibre22">lein-beanstalk</tt> reuses <tt class="calibre22">lein-ring</tt> to produce <span class="italic">.war</span> files for deployment. Here is what the URL shortener’s <span class="italic">project.clj</span> file looks like with the <tt class="calibre22">lein-beanstalk</tt> plug-in in place along with a suitable <tt class="calibre22">:ring :handler</tt> configuration:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 17-7. project.clj</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(defproject com.clojurebook/url-shortener "1.0.0"<br class="calibre33"/>  :description "A toy URL shortener HTTP service written using Ring and Compojure."<br class="calibre33"/>  :dependencies [[org.clojure/clojure "1.3.0"]<br class="calibre33"/>                 [compojure "1.0.1"]<br class="calibre33"/>                 [ring "1.0.1"]]<br class="calibre33"/>  plugins [[lein-beanstalk "0.2.2"]]<br class="calibre33"/>  :ring {:handler com.clojurebook.url-shortener.beanstalk/app})</tt></span></p><p class="calibre13">Finally, you need to put your AWS credentials into a definition in the file at <span class="italic">~/.lein/init.clj</span>;<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2032732"></a><a href="#filepos2039282"><span class="calibre32">428</span></a><span class="calibre32">]</span></small></sup> these will be used to authenticate all of your <tt class="calibre22">lein-beanstalk</tt> activity:</p><p class="calibre23"></p><p class="calibre23"><span class="italic">Example 17-8. ~/.lein/init.clj</span></p><p class="calibre9"><span class="calibre10"><tt class="calibre22">(def lein-beanstalk-credentials<br class="calibre33"/>  {:access-key "XXXXXXXXXXXXXX"<br class="calibre33"/>   :secret-key "YYYYYYYYYYYYYY"})</tt></span></p><p class="calibre13">Once these changes are in place, we can deploy our application via Elastic Beanstalk. One command-line invocation will do it:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">lein beanstalk deploy development</tt></span></blockquote><p class="calibre23">This command prompts <tt class="calibre22">lein-beanstalk</tt> to:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">Produce a <span class="italic">.war</span> file for your web application using <tt class="calibre22">lein-ring</tt>.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Copy that file to Amazon’s S3 service.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Create an Elastic Beanstalk application with the same name as your project’s name, if one does not exist yet.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2034120"></a><a href="#filepos2039871"><span class="calibre32">429</span></a><span class="calibre32">]</span></small></sup></blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17">Create an environment called <tt class="calibre22">development</tt> for the Elastic Beanstalk application.</blockquote></li><li value="5" class="calibre16"><blockquote class="calibre17">Request that the <span class="italic">.war</span> file copied to S3 be deployed to the <tt class="calibre22">development</tt> environment.</blockquote></li></ol><p class="calibre18">When the <tt class="calibre22">deploy</tt> command is finished (which can take a couple of minutes, especially the first time you perform a deployment for a particular application or environment), <tt class="calibre22">lein-beanstalk</tt> will indicate that your application is live and ready to be accessed.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2034948"></a><a href="#filepos2040570"><span class="calibre32">430</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18"><span class="bold">Application versioning</span>. <a id="filepos2035107"></a>Elastic Beanstalk retains all prior versions of your application in S3, so you can roll back a deployment at any time through the AWS console. <tt class="calibre22">lein-beanstalk</tt> uses the version number declared in your <span class="italic">project.clj</span> file to create those EB version numbers, so it is easy to understand what you have deployed, and how that relates to prior versions of your application. You can see the most recent versions uploaded to Elastic Beanstalk by running the <tt class="calibre22">lein beanstalk info</tt> command:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">% lein beanstalk info<br class="calibre33"/>Application Name: url-shortener<br class="calibre33"/>Last 5 Versions:  1.0.0-SNAPSHOT-20111219051007<br class="calibre33"/>                  1.0.0-SNAPSHOT-20111219045316<br class="calibre33"/>Created On:       Mon Dec 19 04:53:53 EST 2011<br class="calibre33"/>Updated On:       Mon Dec 19 04:53:53 EST 2011<br class="calibre33"/>Deployed Envs:    development (Ready)</tt></span></blockquote><p class="calibre23">When you are certain that what you have deployed is satisfactory, you can use <tt class="calibre22">lein beanstalk clean</tt> to remove any unused versions and their corresponding <span class="italic">.war</span> files from S3.</p><p class="calibre18"><span class="bold">Environments</span>. You can have as many environments <a id="filepos2036390"></a>as you need within a given Elastic Beanstalk application, with whatever names you like. <tt class="calibre22">lein-beanstalk</tt> defines three by default: <tt class="calibre22">development</tt>, <tt class="calibre22">staging</tt>, and <tt class="calibre22">production</tt>, the first of which we used in our example above. You can change or add to these defaults in your <span class="italic">project.clj</span>; consult the documentation for <tt class="calibre22">lein-beanstalk</tt> for details.</p><p class="calibre18">You can get various operational details about a particular environment by running the <tt class="calibre22">lein beanstalk info &lt;environment-name&gt;</tt> command:<a id="filepos2036963"></a></p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">% lein beanstalk info development<br class="calibre33"/>Environment ID:    e-cnjm4hrqki<br class="calibre33"/>Application Name:  url-shortener<br class="calibre33"/>Environment Name:  development<br class="calibre33"/>Description:<br class="calibre33"/>URL:               url-shortener-dev.elasticbeanstalk.com<br class="calibre33"/>Load Balancer URL: awseb-development-1574221210.us-east-1.elb.amazonaws.com<br class="calibre33"/>Status:            Ready<br class="calibre33"/>Health:            Green<br class="calibre33"/>Current Version:   1.0.0-SNAPSHOT-20111219051007<br class="calibre33"/>Solution Stack:    32bit Amazon Linux running Tomcat 6<br class="calibre33"/>Created On:        Mon Dec 19 05:10:44 EST 2011<br class="calibre33"/>Updated On:        Mon Dec 19 05:13:11 EST 2011</tt></span></blockquote><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2037869"></a><a href="#filepos2028744"><span class="calibre32">425</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">AWS provides three “managed” database services that pair well with the minimal operational overhead that Elastic Beanstalk enables: DynamoDB and SimpleDB, both nonrelational in nature (the latter being the precursor to the former), and AmazonRDS, which offers relational Oracle and MySQL environments. One of us maintains a Clojure API for SimpleDB, available at </span><a href="https://github.com/cemerick/rummage"><span class="calibre10"><span class="calibre5">https://github.com/cemerick/rummage</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2038580"></a><a href="#filepos2028935"><span class="calibre32">426</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Such as Cloudant for hosted CouchDB clusters: </span><a href="https://cloudant.com"><span class="calibre10"><span class="calibre5">https://cloudant.com</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2038940"></a><a href="#filepos2029452"><span class="calibre32">427</span></a><span class="calibre32">] </span></small></sup><a href="https://github.com/weavejester/lein-beanstalk"><span class="calibre10"><span class="calibre5">https://github.com/weavejester/lein-beanstalk</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2039282"></a><a href="#filepos2032732"><span class="calibre32">428</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Security credentials like this should never be put in your </span><span class="calibre10"><span class="italic">project.clj</span></span><span class="calibre10"> file, or any other file in your project that might be checked into source control. The prospect of that can be bad enough in an internal setting, but outright disastrous if you happen to push such commits to a publicly accessible repository-hosting service like GitHub or BitBucket.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2039871"></a><a href="#filepos2034120"><span class="calibre32">429</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">For example, if you are using our sample </span><span class="calibre10"><tt class="calibre22">lein-beanstalk</tt></span><span class="calibre10"> project—which has coordinates of </span><span class="calibre10"><tt class="calibre22">com.clojurebook/url-shortener</tt></span><span class="calibre10">, then the application name will be </span><span class="calibre10"><tt class="calibre22">url-shortener</tt></span><span class="calibre10">. Elastic Beanstalk application names must be globally unique, so if you are using (anyone’s) sample project, be sure you change the artifact ID to something you can be sure is unique.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2040570"></a><a href="#filepos2034948"><span class="calibre32">430</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">…at a URL of the form </span><span class="calibre10"><span class="italic">http://your-project-name.elasticbeanstalk.com</span></span><span class="calibre10">. You can use a </span><span class="calibre10"><tt class="calibre22">CNAME</tt></span><span class="calibre10"> record in your domain’s DNS configuration to point, e.g., </span><span class="calibre10"><span class="italic">www.yourdomain.com</span></span><span class="calibre10"> to this </span><span class="calibre10"><span class="italic">elasticbeanstalk.com</span></span><span class="calibre10"> domain, and transparently serve well-branded sites from Elastic Beanstalk.</span></p><div class="mbppagebreak"></div><p id="filepos2041187" class="calibre6"><span class="calibre4"><span class="bold">Going Beyond Simple Web Application Deployment</span></span></p><p id="filepos2041294" class="calibre18">Of course, depending on your requirements and environment, there can be much, much more to application deployment than what we’ve covered here. Many projects (even very large, heavily trafficked sites) can happily spend their entire existence on a service like Elastic Beanstalk; however, others will have a need to automate processes beyond simply getting a <span class="italic">.war</span> file up into a running container. Fine-grained control over provisioning and configuration of web frontends and load balancers, complete control over your database facilities, custom network routing and monitoring, perhaps in a heterogeneous mix of cloud services and in-house infrastructure…any of these issues can encroach on what might have otherwise been a straightforward use of a single easy-to-use cloud service and demand some tooling beyond what can handle the common case. Pallet <a id="filepos2042187"></a>is a Clojure toolchain for addressing challenges like these; see <a href="#filepos2083987"><span class="calibre5">Pallet</span></a>.</p><p class="calibre18">Whatever tool you use or requirements you have, never forget that solutions that apply to Java applications uniformly apply to Clojure applications. Similarly, you can always use non-Clojure tools (whether Chef, Puppet, or other) to deploy and manage Clojure applications, simply by using the techniques and idioms those tools provide for Java and JVM applications generally.<a id="filepos2042728"></a></p><div class="mbppagebreak"></div><p id="filepos2042755" class="calibre6"><span class="calibre4"><span class="bold">Part V. Miscellanea</span></span></p><div class="mbppagebreak"></div><p id="filepos2042853" class="calibre6"><span class="calibre2"><span class="bold">Chapter 18. Choosing Clojure Type Definition Forms Wisely</span></span></p><p id="filepos2042973" class="calibre13">Clojure provides a number of different forms useful for defining types:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">deftype</tt>, <tt class="calibre22">defrecord</tt>, and <tt class="calibre22">reify</tt>, Clojure’s primary datatype abstractions, explored in <a href="#filepos967758"><span class="calibre5">Defining Your Own Types</span></a></blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Maps of all sorts, particularly useful for the most flexible <span class="italic">de facto</span> types, discussed in <a href="#filepos335797"><span class="calibre5">Chapter 3</span></a></blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17"><tt class="calibre22">proxy</tt> and <tt class="calibre22">gen-class</tt>, which focus on providing comprehensive Java and JVM interoperability, covered in <a href="#filepos1343728"><span class="calibre5">Defining Classes and Implementing Interfaces</span></a></blockquote></li></ul><p class="calibre18">Each of these forms represents a different set of tradeoffs. Especially when you are new to Clojure, it may be difficult to determine when one type-definition form should be used over another. When should you use <tt class="calibre22">deftype</tt> instead of <tt class="calibre22">defrecord</tt>, <tt class="calibre22">gen-class</tt> instead of <tt class="calibre22">deftype</tt>, or <tt class="calibre22">proxy</tt> instead of <tt class="calibre22">reify</tt>?</p><p class="calibre18">We have attempted to explore all of the nuances of these forms in the sections referenced above. However, it is sometimes helpful to have a visual reference for such things, even if it is summary in nature. With that in mind, we hope you will find the flowchart in <a href="#filepos2045135"><span class="calibre5">Figure 18-1</span></a> useful. Starting with the premise that you would like to define a type in Clojure, it will guide you through the most significant points of distinction between the type definition forms in the language so that you can settle on the one that is right for your particular situation:<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2045036"></a><a href="#filepos2047461"><span class="calibre32">431</span></a><span class="calibre32">]</span></small></sup></p><blockquote id="filepos2045135" class="calibre47"></blockquote><blockquote class="calibre48"><img src="images/00005.jpg" class="calibre125"/></blockquote><blockquote class="calibre47"><span class="calibre10"><span class="italic"><span class="calibre7">Figure 18-1. Choosing Clojure type definition forms wisely</span></span></span></blockquote><p class="calibre50">“The <span class="italic">Interop Zone</span><a id="filepos2045570"></a>” demarcates use cases (e.g., needing to define multiple constructors) and forms (<tt class="calibre22">proxy</tt> and <tt class="calibre22">gen-class</tt>) that are exclusively the domain of Clojure’s JVM interoperability support. Using these forms is fine, but be aware that by doing so, you are stepping outside of Clojure’s “native” abstractions. Unless you are defining a type for the express purpose of meeting interoperability requirements, one of Clojure’s simpler type-definition forms may suit your needs better.</p><p class="calibre18">An example of “performance sensitive code” would be accessing slots in a hot loop. In such a situation:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">Regular maps will kill you.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">Using <tt class="calibre22">:keyword</tt> accessors with a record or <tt class="calibre22">deftype</tt> instance will deliver close-to-Java performance.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Using direct field access (i.e., <tt class="calibre22">(.field val)</tt>) with a record or <tt class="calibre22">deftype</tt> instance will be as fast as Java by definition.</blockquote></li></ul><p class="calibre18">This doesn’t mean that you should use field access all the time, or even most of the time. That’s an optimization and should only be taken on when absolutely necessary, especially given the costs associated with it: efficient field access ties code that uses it to a particular type, which often complicates the implementation of generic functionality and limits composability.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2047269"></a><a href="#filepos2048030"><span class="calibre32">432</span></a><span class="calibre32">]</span></small></sup></p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2047461"></a><a href="#filepos2045036"><span class="calibre32">431</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">The canonical and up-to-date version of this flowchart is maintained at </span><a href="https://github.com/cemerick/clojure-type-selection-flowchart"><span class="calibre10"><span class="calibre5">https://github.com/cemerick/clojure-type-selection-flowchart</span></span></a><span class="calibre10"> along with a number of translations, including Dutch, German, Japanese, Portuguese, and Spanish so far.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2048030"></a><a href="#filepos2047269"><span class="calibre32">432</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Recall that “premature optimization is the root of all evil.” Thank you, Professor Knuth.</span></p><div class="mbppagebreak"></div><p id="filepos2048261" class="calibre6"><span class="calibre2"><span class="bold">Chapter 19. Introducing Clojure into Your Workplace</span></span></p><blockquote class="calibre126"><span class="calibre10">(or, Sneaking Clojure Past the Boss<sup class="calibre58"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2048497"></a><a href="#filepos2054847"><span class="calibre32">433</span></a><span class="calibre32">]</span></small></sup>)</span></blockquote><p id="filepos2048613" class="calibre23">It is a sad fact that many programmers, if not the majority, use languages and tools every day that they begrudge. Either through historical accident, organizational inertia, or hard facts of the business, we often find ourselves stuck wishing we were using something, <span class="italic">anything</span> else to get our jobs done.</p><p class="calibre18">This <span class="italic">status quo</span> may be particularly frustrating if you’ve come far enough in your understanding and appreciation of Clojure that you’d like to be able to use it in your day job or on your next consulting engagement. What we’d like to do here is provide you with a brief guide, a cheat sheet, a set of talking points and strategies to help you successfully introduce Clojure into your workplace. In doing so, you’ll hopefully end up having more productive days, less frustrating nights, and a more profitable business.</p><p id="filepos2049520" class="calibre6"><span class="calibre4"><span class="bold">Just the Facts…</span></span></p><p class="calibre18"><span class="bold">Clojure is new and innovative</span>. <a id="filepos2049665"></a>In its relatively short history, Clojure has turned a lot of conventional programming language wisdom on its ear. It was unthinkable five years ago that a language would gain popularity that encourages functional programming, uses persistent immutable data structures by default, provides tractable concurrency and parallelism primitives, offers extensive metaprogramming <a id="filepos2050044"></a>facilities, and runs on the JVM with little to no performance differential compared to Java.</p><p class="calibre18">There’s a lot more to that story, and there’s no reason to believe that Clojure will not continue to push boundaries and cover new territory, even as what it offers already continues to mature and become more widely understood.</p><p class="calibre18"><span class="bold">Clojure has tried, tested, reliable foundations</span>. While Clojure itself is relatively new as programming languages go, it has deep roots. Rich Hickey (Clojure’s creator) created no fewer than three projects prior to Clojure that focused on interoperability between a Lisp environment and the JVM and/or .NET.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2050789"></a><a href="#filepos2055068"><span class="calibre32">434</span></a><span class="calibre32">]</span></small></sup> These early experiments paved the way for the creation of Clojure, which has attained and validated its particular approach to balancing its Lisp language fundamentals and its host VM environment.</p><p class="calibre18">Of course, Clojure is heavily inspired in ways large and small by prior Lisp languages and environments, just as most modern languages (including Java, Python, Ruby, JavaScript, to name a few) have been. Especially attractive parts of that lineage are Clojure’s wholehearted embrace of functional programming, and of macros, a metaprogramming approach that, while validated by decades of use prior to Clojure’s arrival, remains unparalleled outside of the Lisp family of languages.</p><p class="calibre18">In many ways, Clojure’s targeting of the JVM closes the loop started when the original creators of Java and the JVM borrowed so much of what made early Lisp systems such pleasant, productive programming environments.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2051883"></a><a href="#filepos2055823"><span class="calibre32">435</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18"><span class="bold">Clojure lets you take advantage of all the benefits of the JVM</span>. <a id="filepos2052082"></a>Many programmers, enticed by the expressiveness and relative flexibility of usually interpreted languages (such as Ruby and Python) have long pined for better runtimes. Especially for teams comfortable with the dynamic typing, Clojure provides the best of both worlds: top-notch expressivity stacked on top of the JVM, which in its nearly 20-year history has been crafted into an incredibly advanced, general-purpose computing platform.</p><p class="calibre18">Clojure being hosted on the JVM means that you benefit from all of the fruits of its widespread use: reliable operational and performance characteristics, a massive ecosystem of high-quality third-party libraries (both open source and commercial), mature server and tooling support, uncontroversial dependency management, and so on.</p><p class="calibre18"><span class="bold">Clojure lets you reuse your investment in Java</span>. If you use Java today, or otherwise have an existing investment in the JVM, Clojure helps you leverage that. Clojure web applications will run side by side with your other Java web applications without a hitch, you can call existing Java libraries from code you write in Clojure, and you can call Clojure functions and create instances of Clojure types from code you write in Java (or any other language that runs on the JVM, including JRuby, Jython, JavaScript [via Rhino], Scala, Groovy, and so on). Everything you’ve learned about builds, packaging, continuous integration, and JVM operations and tuning applies to the work you’ll do with Clojure.</p><p class="calibre18">Clojure is an incremental addition to your existing JVM investment, not a radical departure.</p><p id="filepos2053759" class="calibre18"><span class="bold">“Clojure is just another .jar file”</span>. <a id="filepos2053836"></a>A corollary of the fact that Clojure lets you reuse your investments in Java is that Clojure really is “just another <span class="italic">.jar</span> file.” This means that you can package it as one dependency among others within a delivered application that includes Clojure source (or class files obtained from AOT-compiling such source), and your customers and clients will be none the wiser.</p><p class="calibre18">We’re not suggesting that you subvert management or trick your customers. However, if you already legitimately have latitude and authority in choosing what you use to build software for clients and customers, then the use of Clojure as part of a complete solution is little different than choosing to build grammars using ANTLR, rightly abusing Lucene indexes as general-purpose datastores, or slipping into Visual Studio to build a sane launcher for your Java-based Windows desktop application.</p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2054847"></a><a href="#filepos2048497"><span class="calibre32">433</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">We’re kidding, of course…mostly.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2055068"></a><a href="#filepos2050789"><span class="calibre32">434</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">In chronological order: DotLisp, which worked with .NET (</span><a href="http://dotlisp.sourceforge.net"><span class="calibre10"><span class="calibre5">http://dotlisp.sourceforge.net</span></span></a><span class="calibre10">); jFli (</span><a href="http://jfli.sourceforge.net"><span class="calibre10"><span class="calibre5">http://jfli.sourceforge.net</span></span></a><span class="calibre10">), which targeted the JVM; and FOIL (</span><a href="http://foil.sourceforge.net"><span class="calibre10"><span class="calibre5">http://foil.sourceforge.net</span></span></a><span class="calibre10">), which could work with either VM.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2055823"></a><a href="#filepos2051883"><span class="calibre32">435</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Guy L. Steele, one of the creators of the original Scheme programming language and an author of both the </span><span class="calibre10"><span class="italic">Java Language Specification</span></span><span class="calibre10"> and </span><span class="calibre10"><span class="italic">Common Lisp, the Language</span></span><span class="calibre10"> (the basis of the ANSI Common Lisp standard) is widely quoted as having said, “We managed to drag a lot of [C++ programmers] about halfway to Lisp.”</span></p><div class="mbppagebreak"></div><p id="filepos2056378" class="calibre6"><span class="calibre4"><span class="bold">Emphasize Productivity</span></span></p><p class="calibre18"><span class="bold">Code less, do more</span>. <a id="filepos2056517"></a>Chances are very good that Clojure’s solution to a given problem will be less verbose, less complex, and more comprehensible than a solution to the same problem in another language. There’s <span class="italic">far</span> less mutable state to contend with. Concurrency and parallelism have consistent, simplified semantics, with locks and deadlocks eliminated. Classes and types are optional, and getters and setters are unnecessary. Syntactic patterns can be abstracted away with a judicious use of macros. The list goes on.</p><p class="calibre18">Taking advantage of Clojure will likely do for your personal level of productivity the same thing that Java did when you had been using C/C++, or the same thing Ruby or Python did when you had been using Java. Those benefits will scale up to your entire team as conceptual and design overhead imposed by the peculiarities of other languages is removed.</p><p class="calibre18">Programmers have been reaching for higher-level languages from the beginning; Clojure is just another step in that progression.</p><p class="calibre18"><span class="bold">Clojure enables innovative solutions to complex problems</span>. A lot of what we’ve been talking about here has to do with Clojure’s ability to fit in to existing investments, language preferences, and so on. But, some of the most tangible benefits of Clojure have to do with how it can help you stand out.</p><p class="calibre18">Most programming languages prescribe a particular architectural perspective, into which you must fit your domain. Clojure stands in stark contrast to this approach; it is structured to encourage the use of functional programming and modeling solutions in terms of purpose-built abstractions (enabled by things like protocols, records, and multimethods, for example). In doing so, Clojure forces you to “pay for” only those parts of the language that you use—where the currency involved isn’t cash, but rather, modeling complexity and mental overhead.</p><p class="calibre18">This all means that when you design an API, a library, or a whole system with Clojure, that design is not encumbered by decisions that Clojure makes for you. This can make solutions to small problems extraordinarily simple, and can enable tractable implementations of very complex problems.</p><p class="calibre18"><span class="bold">Clojure can give you an edge</span>. Would you use a tool that gave you or your organization an unfair advantage over your competition?<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2059035"></a><a href="#filepos2060399"><span class="calibre32">436</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">Thinking back some years, what if you could use Ruby and Rails for web development in 1999? Or, what if you could build large-scale systems in 1990 using circa-2000 Java? We suspect you’d jump at such an opportunity.</p><p class="calibre18">Right now, if we squint, the world runs on Java, PHP, C/C++, and a smattering of “fringe” languages like Ruby and Python and Scala. We can safely assume that Clojure will not become as widespread as Java or PHP or C++, but we can definitively say that some of its key distinctions—for example, its software transactional memory architecture and its persistent functional data structure implementations—are being adopted, adapted, and sometimes used directly by other very capable programming languages. However, just as Java was not a Lisp just because the JVM’s designers borrowed a raft of techniques and features from Lisp systems, languages that borrow capabilities and features from Clojure today are not equivalent to Clojure.</p><p class="calibre18">If you start using Clojure now, you may give yourself the opportunity to have an unfair advantage for years to come.</p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2060399"></a><a href="#filepos2059035"><span class="calibre32">436</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">We would be remiss at this point if we did not reference Paul Graham’s </span><span class="calibre10"><span class="italic">Beating the Averages</span></span><span class="calibre10"> essay, which is very relevant to this point: </span><a href="http://www.paulgraham.com/avg.html"><span class="calibre10"><span class="calibre5">http://www.paulgraham.com/avg.html</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos2060884" class="calibre6"><span class="calibre4"><span class="bold">Emphasize Community</span></span></p><p class="calibre18"><span class="bold">Clojure is open source and welcomes contributors</span>. <a id="filepos2061050"></a>Clojure is open source under a liberal-use license,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2061143"></a><a href="#filepos2065833"><span class="calibre32">437</span></a><span class="calibre32">]</span></small></sup> making it perfect for inclusion in commercial products and for use within commercial organizations (of course in addition to any noncommercial, charitable, or personal use).</p><p class="calibre18">While Clojure is itself the manifestation of one person’s vision,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2061546"></a><a href="#filepos2066274"><span class="calibre32">438</span></a><span class="calibre32">]</span></small></sup> the project effort that surrounds Clojure is very inclusive: hundreds of individuals (many of them representing companies) are registered contributors<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2061827"></a><a href="#filepos2066628"><span class="calibre32">439</span></a><span class="calibre32">]</span></small></sup> who have helped improve various aspects of the project. As of this writing, the Clojure language itself has a history of contributions from over 70 individuals.</p><p class="calibre18">The upshot is:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">You’ll never be restricted in your use of Clojure by legal externalities.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">If you ever find a bug in Clojure’s implementation, you can be confident that it will be fixed upstream—either by one of the existing contributors acting on a bug report, or by your own hand if you choose to become a contributor yourself.</blockquote></li></ol><p class="calibre18"><span class="bold">Clojure has a large, growing, friendly community</span>. The Clojure community is large, and growing at a furious pace:</p><div class="calibre14"> </div><ul class="calibre15"><li value="1" class="calibre16"><blockquote class="calibre17">The main mailing list (<a href="http://groups.google.com/group/clojure"><span class="calibre5">http://groups.google.com/group/clojure</span></a>) has over 6,000 subscribers and is constantly active.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">The main IRC channel<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2063297"></a><a href="#filepos2067006"><span class="calibre32">440</span></a><span class="calibre32">]</span></small></sup> regularly has over 400 people in it, and is constantly active.</blockquote></li><li value="3" class="calibre16"><blockquote class="calibre17">Major Clojure libraries and tools all have their own mailing lists (most of them hosted via Google Groups), monitored by the authors and lead developers.</blockquote></li><li value="4" class="calibre16"><blockquote class="calibre17">By the time you read this, at least six books on Clojure will have been published, all by major publishers.</blockquote></li></ul><p class="calibre18">Size isn’t everything, though. While some programming languages and frameworks have somehow managed to gather hostile, toxic, ego-driven communities, Clojure’s community is building a reputation as being notable in its friendliness and welcoming stance with regard to newcomers. In fact, when the 2011 State of Clojure survey<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2064318"></a><a href="#filepos2067454"><span class="calibre32">441</span></a><span class="calibre32">]</span></small></sup> asked what factors were most frustrating in their use of Clojure, just 2 percent of respondents (the smallest subpopulation for that question) reported that “unpleasant community interactions” were an issue.</p><p class="calibre18">All of this means that when you want to talk with experienced, knowledgeable Clojure programmers—whether to offer or ask for help—you’ll always have somewhere to go.</p><p class="calibre18"><span class="bold">Clojure is widely used</span>. The core Clojure team maintains a wiki page where organizations using Clojure can make themselves known:</p><blockquote class="calibre35"><a href="http://dev.clojure.org/display/community/Clojure+Success+Stories"><span class="calibre10"><span class="italic"><span class="calibre5">http://dev.clojure.org/display/community/Clojure+Success+Stories</span></span></span></a></blockquote><p class="calibre23">On that page, you’ll find that: global, established corporations like Citicorp and Akamai use Clojure; startups like Backtype (now with Twitter), The Climate Corporation (née Weatherbill), and Woven use Clojure; consulting shops like Relevance use Clojure; and hardcore research shops like the Max Planck Institute for Molecular Biomedicine use Clojure.</p><p class="calibre18">If your organization starts using Clojure, it will have good company.</p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2065833"></a><a href="#filepos2061143"><span class="calibre32">437</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">The Eclipse Public License, which allows for free commercial use and redistribution: </span><a href="http://www.eclipse.org/legal/epl-v10.html"><span class="calibre10"><span class="calibre5">http://www.eclipse.org/legal/epl-v10.html</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2066274"></a><a href="#filepos2061546"><span class="calibre32">438</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">In Clojure’s case, Rich Hickey, who has a role similar to Python’s Guido Van Rossum, Ruby’s Yukihiro Matsumoto, Perl’s Larry Wall, and C++’s Bjarne Stroustrup.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2066628"></a><a href="#filepos2061827"><span class="calibre32">439</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">All recognized contributors are listed at </span><a href="http://clojure.org/contributing"><span class="calibre10"><span class="calibre5">http://clojure.org/contributing</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2067006"></a><a href="#filepos2063297"><span class="calibre32">440</span></a><span class="calibre32">] </span></small></sup><span class="calibre10"><span class="italic">irc://irc.freenode.net/clojure</span></span><span class="calibre10"> or in your browser at </span><a href="http://webchat.freenode.net/?channels=#clojure"><span class="calibre10"><span class="calibre5">http://webchat.freenode.net/?channels=#clojure</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2067454"></a><a href="#filepos2064318"><span class="calibre32">441</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">One of us has run a community-wide survey for the past two years to gauge the origins, mood, and priorities of the Clojure community; full results of the last editing of that survey are available at </span><a href="http://cemerick.com/2011/07/11/results-of-the-2011-state-of-clojure-survey/"><span class="calibre10"><span class="calibre5">http://cemerick.com/2011/07/11/results-of-the-2011-state-of-clojure-survey/</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos2068030" class="calibre6"><span class="calibre4"><span class="bold">Be Prudent</span></span></p><p class="calibre18"><span class="bold">Don’t try to put a square peg into a round hole</span>. <a id="filepos2068188"></a>Like any tool, Clojure provides a number of affordances, and it shines the brightest when it is used in ways that allow those affordances to offer the most leverage. As much as you may like Clojure, and want to do work with it regularly, you should be sure that it is well-suited to your organization and its objectives before lobbying for its use.</p><p class="calibre18">Thus, if your company builds embedded systems using C++ (for example), it’s probably not realistic to attempt to convince your teammates to replace that codebase with Clojure.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2068787"></a><a href="#filepos2069514"><span class="calibre32">442</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18"><span class="bold">Start small, start slow</span>. Sometimes incremental measures are the best way to introduce something new into an existing system. With this in mind, perhaps it would be easy to start writing all of your projects’ tests in Clojure, or perhaps use Clojure to build secondary or internal tools. Building up a track record of success for Clojure among your colleagues will often be far more convincing of its capabilities and benefits than any well-delivered pitch or presentation ever would be.<a id="filepos2069410"></a></p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2069514"></a><a href="#filepos2068787"><span class="calibre32">442</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">At least not overnight, and at least not now. But, some </span><span class="calibre10"><span class="italic">are</span></span><span class="calibre10"> working on compiling Clojure down to lower-level languages suitable for delivering “native” applications. For an example, see </span><a href="http://nakkaya.com/2011/06/29/ferret-an-experimental-clojure-compiler/"><span class="calibre10"><span class="calibre5">http://nakkaya.com/2011/06/29/ferret-an-experimental-clojure-compiler/</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos2070122" class="calibre6"><span class="calibre2"><span class="bold">Chapter 20. What’s Next?</span></span></p><p id="filepos2070211" class="calibre13">If you’ve gotten all you can out of this book—or you want to look ahead to what’s waiting for you once you have a firm grasp on Clojure’s fundamentals—you might want to take a look at the projects and resources listed here. These are some of the coolest things we know of in the Clojure universe. Some of them will help you learn Clojure better, some of them might be useful to you in your “real” projects, and others are just too fun to not check out at least once.</p><p class="calibre18">Finally, because Clojure is a relatively new language with a community that is growing and building like mad, new awesome stuff pops up all the time. If you head over to <a href="http://clojurebook.com"><span class="calibre5">http://clojurebook.com</span></a>, we’ll do our best to keep up with it all and point you at the best of the best.</p><p id="filepos2071096" class="calibre6"><span class="calibre4"><span class="bold">(dissoc Clojure 'JVM)</span></span></p><p class="calibre18">There are two other well-supported implementations of Clojure that target other execution environments. If you like what you see here, but need to deploy outside of the JVM, then ClojureCLR or ClojureScript might be just what you need.</p><p id="filepos2071445" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">ClojureCLR</span></span></span></p><p class="calibre18">ClojureCLR<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2071618"></a><a href="#filepos2074907"><span class="calibre32">443</span></a><span class="calibre32">]</span></small></sup><a id="filepos2071713"></a> is a port of Clojure to the .NET CLR. It is not a naive cross-compilation; rather, it is maintained separately, and aims to provide the same degree of tight host interoperability for the CLR that Clojure does for the JVM. Given the differences between the JVM and the CLR, this means that ClojureCLR provides some facilities that Clojure does not.</p><p class="calibre18">While ClojureCLR has not seen as much use as Clojure proper, it is mature, well-tested, and represents a great option for anyone that needs to deploy applications on the CLR without leaving the comforts of Clojure.</p><p id="filepos2072318" class="calibre13"><span class="calibre19"><span class="bold"><span class="calibre5">ClojureScript</span></span></span></p><p id="filepos2072421" class="calibre18">ClojureScript (<a href="https://github.com/clojure/clojurescript"><span class="calibre5">https://github.com/clojure/clojurescript</span></a>) is a different animal entirely. It targets JavaScript (technically, ECMAScript 3), and therefore produces code that can be run in all modern browsers, as well as in other JavaScript execution environments such as Node.js, CouchDB,<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2072855"></a><a href="#filepos2075409"><span class="calibre32">444</span></a><span class="calibre32">]</span></small></sup> and others, much in the same vein as CoffeeScript or Dart. This means that you can write ClojureScript—using macros, types, protocols, multimethods, and so on—and deploy it to any JavaScript host.</p><p class="calibre18">There are two caveats we should mention:</p><div class="calibre14"> </div><ol class="calibre29"><li value="1" class="calibre16"><blockquote class="calibre17">ClojureScript is very new. The project was first made public in 2011, and significant changes continue to be made as of this book’s printing. That said, it is fundamentally quite stable; projects and sites using ClojureScript have been in production for many months.</blockquote></li><li value="2" class="calibre16"><blockquote class="calibre17">There are nontrivial differences between Clojure and ClojureScript. This is due in part to the vast differences between JavaScript hosts and the JVM, but also because ClojureScript is a source-to-source compiler: rather than generating bytecode that is loaded into the host, the ClojureScript compiler necessarily generates JavaScript source code. An overview of the differences between Clojure and ClojureScript is available at <a href="https://github.com/clojure/clojurescript/wiki/Differences-from-Clojure"><span class="calibre5">https://github.com/clojure/clojurescript/wiki/Differences-from-Clojure</span></a>.</blockquote></li></ol><p class="calibre18">ClojureScript was first introduced by Rich Hickey in summer of 2011 at a monthly meeting of ClojureNYC;<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2074508"></a><a href="#filepos2075992"><span class="calibre32">445</span></a><span class="calibre32">]</span></small></sup> video of that introduction is at <a href="http://blip.tv/clojure/rich-hickey-unveils-clojurescript-5399498"><span class="calibre5">http://blip.tv/clojure/rich-hickey-unveils-clojurescript-5399498</span></a>.</p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2074907"></a><a href="#filepos2071618"><span class="calibre32">443</span></a><span class="calibre32">] </span></small></sup><a href="https://github.com/clojure/clojure-clr"><span class="calibre10"><span class="calibre5">https://github.com/clojure/clojure-clr</span></span></a><span class="calibre10">; its maintainers blog at </span><a href="http://clojureclr.blogspot.com"><span class="calibre10"><span class="calibre5">http://clojureclr.blogspot.com</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2075409"></a><a href="#filepos2072855"><span class="calibre32">444</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">ClojureScript can be used with Clutch—used extensively in </span><a href="#filepos1819820"><span class="calibre10"><span class="calibre5">Chapter 15</span></span></a><span class="calibre10">—to define views in CouchDB: </span><a href="https://github.com/clojure-clutch/clutch-clojurescript"><span class="calibre10"><span class="calibre5">https://github.com/clojure-clutch/clutch-clojurescript</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2075992"></a><a href="#filepos2074508"><span class="calibre32">445</span></a><span class="calibre32">] </span></small></sup><a href="http://www.meetup.com/Clojure-NYC/"><span class="calibre10"><span class="calibre5">http://www.meetup.com/Clojure-NYC/</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos2076265" class="calibre6"><span class="calibre4"><span class="bold">4Clojure</span></span></p><p id="filepos2076334" class="calibre18">4Clojure (<a href="http://4clojure.com"><span class="calibre5">http://4clojure.com</span></a>) offers small interactive Clojure programming challenges, ranging from the most basic parts of Clojure to mind twisters. Once you complete a problem, you can take a peek at other players’ solutions. It has garnered quite a following, with thousands of people participating and hundreds of thousands of challenges solved.</p><p class="calibre18">While looking at others’ solutions, do keep in mind that code golfing (<a href="https://en.wikipedia.org/wiki/Code_golf"><span class="calibre5">https://en.wikipedia.org/wiki/Code_golf</span></a>) is a common practice on 4Clojure. Most of the tricks and ideas you’ll see there are valuable; just don’t take 4Clojure solutions as an authoritative style guide.</p><div class="mbppagebreak"></div><p id="filepos2077191" class="calibre6"><span class="calibre4"><span class="bold">Overtone</span></span></p><p id="filepos2077260" class="calibre18">Overtone<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2077331"></a><a href="#filepos2078753"><span class="calibre32">446</span></a><span class="calibre32">]</span></small></sup> is an open source audio environment written in Clojure that produces sounds and music via the SuperCollider<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2077569"></a><a href="#filepos2079057"><span class="calibre32">447</span></a><span class="calibre32">]</span></small></sup> synthesis server. This allows you to write instruments and synthesizers in Clojure using very high-level abstractions, and mix them together (optionally with loaded samples from around the Internet) into full compositions however you like. Beyond programmatically making sounds and music, Overtone provides support for things like TouchOSC, the Monome, and other hardware inputs so that the noise you make with code can be further controlled by your gestures and touch, just like any other instrument.</p><p class="calibre18">Clojure Conj 2011 (<a href="http://clojure-conj.org"><span class="calibre5">http://clojure-conj.org</span></a>) saw a presentation of Overtone by one of its project leads, which we highly recommend watching to get a feel for Overtone’s history and general objectives: <a href="http://blip.tv/clojure/sam-aaron-programming-music-with-overtone-5970273"><span class="calibre5">http://blip.tv/clojure/sam-aaron-programming-music-with-overtone-5970273</span></a>.</p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2078753"></a><a href="#filepos2077331"><span class="calibre32">446</span></a><span class="calibre32">] </span></small></sup><a href="http://overtone.github.com"><span class="calibre10"><span class="calibre5">http://overtone.github.com</span></span></a><span class="calibre10">.</span></p><p class="calibre18"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2079057"></a><a href="#filepos2077569"><span class="calibre32">447</span></a><span class="calibre32">] </span></small></sup><a href="http://supercollider.sourceforge.net"><span class="calibre10"><span class="calibre5">http://supercollider.sourceforge.net</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos2079334" class="calibre6"><span class="calibre4"><span class="bold">core.logic</span></span></p><p id="filepos2079405" class="calibre18">In <a href="#filepos518281"><span class="calibre5">Putting Clojure’s Collections to Work</span></a> we talked about <span class="italic">relational-oriented</span> programming. The <tt class="calibre22">core.logic</tt> (<a href="https://github.com/clojure/core.logic"><span class="calibre5">https://github.com/clojure/core.logic</span></a>) enables a form of logic programming known as <span class="italic">relational</span> programming, which, in terms of declarativeness, is the next step. Other examples of relational programming languages include SQL and Prolog. <tt class="calibre22">core.logic</tt> is oriented more toward the latter, in that it implements a form of miniKanren, a type of relational programming language that is well-suited for constraint logic programming.</p><p class="calibre18">With this extra declarativeness comes great features: a <tt class="calibre22">core.logic</tt>
<span class="italic">goal</span> (the relational corollary of a function) makes no distinction between parameters and return value, therefore making it possible to run them “backward,” so that you can obtain one (or several) possible arguments given a known “return” value.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2080535"></a><a href="#filepos2083671"><span class="calibre32">448</span></a><span class="calibre32">]</span></small></sup></p><p class="calibre18">The simplest example of this power is <tt class="calibre22">conso</tt>, the relational counterpart of <tt class="calibre22">cons</tt>. Since goals (“relational functions”) don’t discriminate between arguments and return value, <tt class="calibre22">conso</tt> takes its “return value” as an extra third and last argument. Let’s see it in action:</p><blockquote class="calibre35"><span class="calibre10"><tt class="calibre22">(use '[clojure.core.logic])<br class="calibre33"/><br class="calibre33"/>(run* [x] (conso 1 [2 3] x))        </tt></span><a></a><img src="images/00011.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= ((1 2 3))<br class="calibre33"/>(run* [x]<br class="calibre33"/>  (fresh [_]<br class="calibre33"/>    (conso x _ [1 2 3])))           </tt></span><a></a><img src="images/00007.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= (1)<br class="calibre33"/>(run* [x]<br class="calibre33"/>  (fresh [_]<br class="calibre33"/>    (conso _ 3 [1 2 3])))           </tt></span><a></a><img src="images/00003.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>;= ((2 3))<br class="calibre33"/>(run* [q]                           </tt></span><a></a><img src="images/00013.jpg" class="calibre36"/><span class="calibre10"><tt class="calibre22"><br class="calibre33"/>  (fresh [x y]<br class="calibre33"/>    (conso x y [1 2 3])<br class="calibre33"/>    (== q [x y])))<br class="calibre33"/>;= ((1 (2 3)))</tt></span></blockquote><p class="calibre6"><img src="images/00011.jpg" class="calibre36"/></p><blockquote class="calibre37">We first call it in the “obvious” way; the return value is a list of results, akin to a set of answers when solving an equation or the result set when executing a SQL query. The only solution to this program is <tt class="calibre22">(1 2 3)</tt>.</blockquote><p class="calibre23"><img src="images/00007.jpg" class="calibre36"/></p><blockquote class="calibre37">When called with the two first arguments unknown (<tt class="calibre22">x</tt> and <tt class="calibre22">_</tt>), and only asking for potential values for the first one, the only answer is <tt class="calibre22">1</tt>. In this way, <tt class="calibre22">conso</tt> can be used like <tt class="calibre22">first</tt>.</blockquote><p class="calibre23"><img src="images/00003.jpg" class="calibre36"/></p><blockquote class="calibre37">This time returning only the second argument, the only answer is <tt class="calibre22">(2 3)</tt>; so, <tt class="calibre22">conso</tt> can also be used like <tt class="calibre22">rest</tt>.</blockquote><p class="calibre23"><img src="images/00013.jpg" class="calibre36"/></p><blockquote class="calibre37">We can also return the first two arguments at once, a bit like destructuring the list, as in <tt class="calibre22">[x &amp; [y z]]</tt>.</blockquote><p class="calibre18">When even a simple function like <tt class="calibre22">cons</tt> (or rather <tt class="calibre22">conso</tt>) becomes more expressive and powerful, it opens new ways to express elegantly solutions to difficult problems.</p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2083671"></a><a href="#filepos2080535"><span class="calibre32">448</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">“Return” is so quoted to remind you that in relational programming, there’s no such thing as a return value as you are used to in object-oriented or functional programming.</span></p><div class="mbppagebreak"></div><p id="filepos2083987" class="calibre6"><span class="calibre4"><span class="bold">Pallet</span></span></p><p id="filepos2084054" class="calibre18">We walked through a basic deployment process for Clojure web applications in <a href="#filepos1991497"><span class="calibre5">Chapter 17</span></a>, but your needs may go beyond what we presented there. Pallet (<a href="https://github.com/pallet/pallet"><span class="calibre5">https://github.com/pallet/pallet</span></a>) is a Clojure toolchain for addressing many of the complex challenges involved in the deployment of applications and management of computing infrastructure in an automated way. While tools like Chef and Puppet are finding increasingly common usage to automate system configuration, Pallet aims to offer a superset of their functionality—including automating provisioning of instances across multiple cloud providers.<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2084851"></a><a href="#filepos2085410"><span class="calibre32">449</span></a><span class="calibre32">]</span></small></sup> Of course, being a Clojure tool, you configure, extend, and interact with Pallet (and therefore the hardware and servers and processes that make up your computing infrastructure), using Clojure code and through the REPL, so you can leverage all of the advantages of the language within the realms of provisioning, system administration, and configuration management.</p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2085410"></a><a href="#filepos2084851"><span class="calibre32">449</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">Thanks in large part to the jclouds library, which provides a uniform abstraction over dozens of different cloud services: </span><a href="http://code.google.com/p/jclouds"><span class="calibre10"><span class="calibre5">http://code.google.com/p/jclouds</span></span></a><span class="calibre10">.</span></p><div class="mbppagebreak"></div><p id="filepos2085824" class="calibre6"><span class="calibre4"><span class="bold">Avout</span></span></p><p id="filepos2085890" class="calibre18">All of the discussion of concurrency in <a href="#filepos593810"><span class="calibre5">Chapter 4</span></a> was focused on in-process concurrency, coordinating interleaving and parallelized processes within a single Clojure runtime. Avout (<a href="http://avout.io"><span class="calibre5">http://avout.io</span></a>) is a reimplementation of Clojure’s atoms and refs (and therefore the latter’s software transactional memory) for use in distributed, multiprocess applications. It is built on top of Apache Zookeeper (<a href="http://zookeeper.apache.org"><span class="calibre5">http://zookeeper.apache.org</span></a>) but is designed for extensibility so new backends can be added. If Clojure’s STM is attractive to you, but you need to have its transactional semantics apply across multiple applications (or instances of the same application running in different processes), Avout may be a natural fit.</p><div class="mbppagebreak"></div><p id="filepos2086843" class="calibre6"><span class="calibre4"><span class="bold">Clojure on Heroku</span></span></p><p id="filepos2086921" class="calibre18">While <a href="#filepos1991497"><span class="calibre5">Chapter 17</span></a> presented a very typical web application deployment approach using a container (such as Tomcat on Amazon’s Elastic Beanstalk), there are ways to run Clojure web apps <span class="italic">without</span> a container, and therefore without the packaging work that containers imply. While such <span class="italic">containerless</span> deployment options are a relatively new approach in the JVM space, they are becoming more and more common. One of the most popular to date is provided by Heroku (<a href="http://heroku.com"><span class="calibre5">http://heroku.com</span></a>)—a scalable application deployment platform that is itself hosted on Amazon Web Services—which now directly supports the deployment of Ring-based web applications using Leiningen<sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2087772"></a><a href="#filepos2088468"><span class="calibre32">450</span></a><span class="calibre32">]</span></small></sup> without requiring any separate compilation or packaging steps.</p><p class="calibre18">Heroku has the added benefit of offering application “add-ons”—managed database clusters, message queues, web services, and so on—that you can configure and use from within your Clojure project without having to set up and manage such things yourself. It is a proprietary platform, but it just might be paving the way for how all Clojure applications will be deployed in a containerless future.<a id="filepos2088364"></a></p><br class="calibre33"/><hr class="calibre34"/><p class="calibre46"><sup class="calibre30"><small class="calibre31"><span class="calibre32">[</span><a id="filepos2088468"></a><a href="#filepos2087772"><span class="calibre32">450</span></a><span class="calibre32">] </span></small></sup><span class="calibre10">See </span><a href="http://devcenter.heroku.com/articles/clojure"><span class="calibre10"><span class="calibre5">http://devcenter.heroku.com/articles/clojure</span></span></a><span class="calibre10"> for a full walk-through and documentation.</span></p><div class="mbppagebreak"></div><p id="filepos2088829" class="calibre6"><span class="calibre4"><span class="bold">Index</span></span></p><blockquote class="calibre20"><span class="calibre21"><span class="bold"><span class="calibre7">A NOTE ON THE DIGITAL INDEX</span></span></span></blockquote><blockquote class="calibre17"><span class="calibre10">A link in an index entry is displayed as the section title in which that entry appears. Because some sections have multiple index markers, it is not unusual for an entry to have several links to the same section. Clicking on any link will take you directly to the place in the text in which the marker appears.</span></blockquote><p class="calibre25"><span class="calibre53"><span class="bold">Symbols</span></span></p><p class="calibre46">! (exclamation mark), <a href="#filepos504376">Transients</a></p><p class="calibre23">&amp; (ampersand), <a href="#filepos147038">Sequential destructuring</a></p><p class="calibre23">&amp;env, <a href="#filepos906466">&amp;env</a>, <a href="#filepos913272">&amp;env</a></p><p class="calibre23">&amp;form, <a href="#filepos911201">&amp;env</a>, <a href="#filepos913558">&amp;form</a>, <a href="#filepos927698">Preserving user-provided type hints</a>, <a href="#filepos914441">Producing useful macro error messages</a>, <a href="#filepos921642">Preserving user-provided type hints</a>, <a href="#filepos927698">Preserving user-provided type hints</a></p><blockquote class="calibre35">arguments, <a href="#filepos911201">&amp;env</a></blockquote><blockquote class="calibre35">macro error messages, <a href="#filepos914441">Producing useful macro error messages</a></blockquote><blockquote class="calibre35">user-provided type hints, <a href="#filepos921642">Preserving user-provided type hints</a>, <a href="#filepos927698">Preserving user-provided type hints</a></blockquote><p class="calibre23">' (quote), <a href="#filepos102819">Collection Literals</a>, <a href="#filepos123985">Suppressing Evaluation: quote</a></p><p class="calibre23">* (asterisks), <a href="#filepos747535">Dynamic Scope</a></p><p class="calibre23">*math-context*, <a href="#filepos1572724">Scale and Rounding Modes for Arbitrary-Precision Decimals Ops</a></p><p class="calibre23">*unchecked-math*, <a href="#filepos1568743">Unchecked Ops</a></p><p class="calibre23">*warn-on-reflection*, <a href="#filepos1600853">Type errors and warnings</a>, <a href="#filepos1629674">Automating type hinting of multidimensional array operations</a></p><p class="calibre23">+ function, <a href="#filepos1137500">Defining and Using Namespaces</a></p><p class="calibre23">, (commas), <a href="#filepos100741">Whitespace and Commas</a></p><p class="calibre23">-&gt; and -&gt;&gt; in macros, <a href="#filepos291828">Composition of Function(ality)</a>, <a href="#filepos935842">In Detail: -&gt; and -&gt;&gt;</a>, <a href="#filepos944073">In Detail: -&gt; and -&gt;&gt;</a></p><p class="calibre23">. special form, <a href="#filepos190673">Java Interop: . and new</a></p><p class="calibre23">.jar file, <a href="#filepos1210963">Artifacts and coordinates</a>, <a href="#filepos2053836">Just the Facts…</a></p><p class="calibre23">.tar.gz file, <a href="#filepos1210174">Artifacts and coordinates</a></p><p class="calibre23">.war files, <a href="#filepos2000398">Web Application Packaging</a>, <a href="#filepos2006101">Building .war files with Maven</a>, <a href="#filepos2013241">Building .war files with Leiningen</a></p><blockquote class="calibre35">about, <a href="#filepos2000398">Web Application Packaging</a></blockquote><blockquote class="calibre35">Leiningen, <a href="#filepos2013241">Building .war files with Leiningen</a></blockquote><blockquote class="calibre35">Maven, <a href="#filepos2006101">Building .war files with Maven</a></blockquote><p class="calibre23">.zip, <a href="#filepos1210105">Artifacts and coordinates</a></p><p class="calibre23">::collection, <a href="#filepos1098282">Hierarchies</a></p><p class="calibre23">:as, <a href="#filepos153749">Map destructuring</a></p><p class="calibre23">:body, <a href="#filepos1896425">Requests and Responses</a>, <a href="#filepos1900592">Requests and Responses</a></p><p class="calibre23">:character-encoding, <a href="#filepos1895374">Requests and Responses</a></p><p class="calibre23">:content-length, <a href="#filepos1894827">Requests and Responses</a></p><p class="calibre23">:content-type, <a href="#filepos1894312">Requests and Responses</a></p><p class="calibre23">:error-handler, <a href="#filepos786463">Agent error handlers and modes</a></p><p class="calibre23">:headers, <a href="#filepos1893797">Requests and Responses</a>, <a href="#filepos1899938">Requests and Responses</a></p><p class="calibre23">:or, <a href="#filepos154272">Map destructuring</a></p><p class="calibre23">:query-string, <a href="#filepos1895866">Requests and Responses</a></p><p class="calibre23">:reload, <a href="#filepos1452145">The Persistent, Evolving Environment</a></p><p class="calibre23">:remote-addr, <a href="#filepos1891414">Requests and Responses</a></p><p class="calibre23">:request-method, <a href="#filepos1893291">Requests and Responses</a></p><p class="calibre23">:scheme, <a href="#filepos1892462">Requests and Responses</a></p><p class="calibre23">:server-name, <a href="#filepos1890920">Requests and Responses</a></p><p class="calibre23">:server-port, <a href="#filepos1890436">Requests and Responses</a></p><p class="calibre23">:status, <a href="#filepos1899266">Requests and Responses</a></p><p class="calibre23">:uri, <a href="#filepos1891881">Requests and Responses</a></p><p class="calibre23">= (equality), <a href="#filepos1578440">Reference Equality (=)</a></p><p class="calibre23">@ (at sign), <a href="#filepos598386">Delays</a></p><p class="calibre23">^:const, <a href="#filepos742122">Constants</a></p><p class="calibre23">_ (underscore), <a href="#filepos134226">Local Bindings: let</a>, <a href="#filepos1162109">Namespaces and files</a></p><p class="calibre23">_changes, CouchDB, <a href="#filepos1857966">_changes: Abusing CouchDB as a Message Queue</a></p><p class="calibre23">{…} (braces), <a href="#filepos49192">No, Parentheses Actually Won’t Make You Go Blind</a></p><p class="calibre23">~@, <a href="#filepos872008">unquote and unquote-splicing</a></p><p class="calibre23">404 Not Found, <a href="#filepos1945408">Routing Requests with Compojure</a></p><p class="calibre23">409 Conflict, <a href="#filepos1944459">Routing Requests with Compojure</a></p><p class="calibre23">4Clojure, <a href="#filepos2076334">4Clojure</a></p><div class="mbppagebreak"></div><p class="calibre23"><span class="calibre53"><span class="bold">A</span></span></p><p class="calibre46">abstract syntax tree, <a href="#filepos70572">Homoiconicity</a></p><p class="calibre23">abstractions, <a href="#filepos137786">Destructuring (let, Part 2)</a>, <a href="#filepos338606">Abstractions over Implementations</a>, <a href="#filepos446300">Collections and Keys and Higher-Order Functions</a>, <a href="#filepos347305">Collection</a>, <a href="#filepos354266">Sequences</a>, <a href="#filepos387930">Head retention</a>, <a href="#filepos361497">Sequences are not iterators</a>, <a href="#filepos363159">Sequences are not lists</a>, <a href="#filepos366106">Creating seqs</a>, <a href="#filepos368308">Lazy seqs</a>, <a href="#filepos385214">Lazy seqs</a>, <a href="#filepos385300">Head retention</a>, <a href="#filepos388042">Associative</a>, <a href="#filepos399463">Beware of nil values</a>, <a href="#filepos399580">Indexed</a>, <a href="#filepos403717">Stack</a>, <a href="#filepos405856">Set</a>, <a href="#filepos407171">Sorted</a>, <a href="#filepos426011">Comparators and predicates to define ordering</a>, <a href="#filepos1046890">Participating in Clojure’s Collection Abstractions</a></p><blockquote class="calibre35">associative, <a href="#filepos388042">Associative</a>, <a href="#filepos399463">Beware of nil values</a></blockquote><blockquote class="calibre35">collection abstractions, <a href="#filepos1046890">Participating in Clojure’s Collection Abstractions</a></blockquote><blockquote class="calibre35">collections, <a href="#filepos347305">Collection</a></blockquote><blockquote class="calibre35">indexed, <a href="#filepos399580">Indexed</a></blockquote><blockquote class="calibre35">sequences, <a href="#filepos354266">Sequences</a>, <a href="#filepos387930">Head retention</a>, <a href="#filepos361497">Sequences are not iterators</a>, <a href="#filepos363159">Sequences are not lists</a>, <a href="#filepos366106">Creating seqs</a>, <a href="#filepos368308">Lazy seqs</a>, <a href="#filepos385214">Lazy seqs</a>, <a href="#filepos385300">Head retention</a></blockquote><blockquote class="calibre35">creating seqs, <a href="#filepos366106">Creating seqs</a></blockquote><blockquote class="calibre35">head retention, <a href="#filepos385300">Head retention</a></blockquote><blockquote class="calibre35">lazy seqs, <a href="#filepos368308">Lazy seqs</a>, <a href="#filepos385214">Lazy seqs</a></blockquote><blockquote class="calibre35">versus iterators, <a href="#filepos361497">Sequences are not iterators</a></blockquote><blockquote class="calibre35">versus lists, <a href="#filepos363159">Sequences are not lists</a></blockquote><blockquote class="calibre35">sequential and map collections, <a href="#filepos137786">Destructuring (let, Part 2)</a></blockquote><blockquote class="calibre35">set abstractions, <a href="#filepos405856">Set</a></blockquote><blockquote class="calibre35">sorted, <a href="#filepos407171">Sorted</a>, <a href="#filepos426011">Comparators and predicates to define ordering</a></blockquote><blockquote class="calibre35">stacks, <a href="#filepos403717">Stack</a></blockquote><p class="calibre23">access, collections, <a href="#filepos438293">Concise Collection Access</a>, <a href="#filepos446300">Collections and Keys and Higher-Order Functions</a></p><p class="calibre23">adapters, Ring, <a href="#filepos1902480">Adapters</a></p><p class="calibre23">add-watch, <a href="#filepos659522">Watches</a></p><p class="calibre23">advice, <a href="#filepos1684494">Aspect-Oriented Programming</a></p><p class="calibre23">agents, <a href="#filepos768817">Agents</a>, <a href="#filepos820785">Using agents to parallelize workloads</a>, <a href="#filepos779236">Dealing with Errors in Agent Actions</a>, <a href="#filepos787482">I/O, Transactions, and Nested Sends</a>, <a href="#filepos820785">Using agents to parallelize workloads</a></p><blockquote class="calibre35">errors in agent actions, <a href="#filepos779236">Dealing with Errors in Agent Actions</a></blockquote><blockquote class="calibre35">I/O, transactions and nested sends, <a href="#filepos787482">I/O, Transactions, and Nested Sends</a>, <a href="#filepos820785">Using agents to parallelize workloads</a></blockquote><p class="calibre23">aget, <a href="#filepos1617816">The mechanics of primitive arrays</a>, <a href="#filepos1620940">The mechanics of primitive arrays</a></p><p class="calibre23">Aleph, <a href="#filepos1904295">Adapters</a></p><p class="calibre23">algorithms, defined, <a href="#filepos87188">Numbers</a></p><p class="calibre23">aliases, namespaces, <a href="#filepos116253">Namespaces</a></p><p class="calibre23">alter, <a href="#filepos681744">Understanding alter</a>, <a href="#filepos683645">Understanding alter</a></p><p class="calibre23">alter-var-root, <a href="#filepos762087">Vars Are Not Variables</a></p><p class="calibre23">amap, <a href="#filepos1619756">The mechanics of primitive arrays</a></p><p class="calibre23">Amazon, EB, <a href="#filepos2027807">Deploying Clojure Apps to Amazon’s Elastic Beanstalk</a>, <a href="#filepos2036963">Deploying Clojure Apps to Amazon’s Elastic Beanstalk</a></p><p class="calibre23">ampersand (&amp;), <a href="#filepos147038">Sequential destructuring</a></p><p class="calibre23">annotations, <a href="#filepos1389249">Annotations</a>, <a href="#filepos1402843">Implementing JAX-RS web service endpoints</a>, <a href="#filepos1391129">Producing annotated JUnit tests</a>, <a href="#filepos1396536">Implementing JAX-RS web service endpoints</a></p><blockquote class="calibre35">JAX-RS, <a href="#filepos1396536">Implementing JAX-RS web service endpoints</a></blockquote><blockquote class="calibre35">JUnit tests, <a href="#filepos1391129">Producing annotated JUnit tests</a></blockquote><p class="calibre23">anonymous classes, proxy, <a href="#filepos1352571">Instances of Anonymous Classes: proxy</a></p><p class="calibre23">anonymous functions versus function literals, <a href="#filepos265212">First-Class and Higher-Order Functions</a></p><p class="calibre23">anonymous types, reify, <a href="#filepos1019444">Defining anonymous types with reify</a></p><p class="calibre23">AOP (aspect-oriented programming), <a href="#filepos1682715">Aspect-Oriented Programming</a>, <a href="#filepos1694934">Aspect-Oriented Programming</a></p><p class="calibre23">AOT compilation, <a href="#filepos1199563">Ahead-of-Time Compilation</a>, <a href="#filepos1247197">AOT compilation configuration</a>, <a href="#filepos1428027">Using deftype and defrecord Classes</a></p><blockquote class="calibre35">about, <a href="#filepos1199563">Ahead-of-Time Compilation</a></blockquote><blockquote class="calibre35">configuration, <a href="#filepos1247197">AOT compilation configuration</a></blockquote><blockquote class="calibre35">need for, <a href="#filepos1428027">Using deftype and defrecord Classes</a></blockquote><p class="calibre23">APIs, <a href="#filepos341393">Abstractions over Implementations</a>, <a href="#filepos748835">Dynamic Scope</a>, <a href="#filepos840195">What Macros Are Not</a></p><blockquote class="calibre35">dynamic scope, <a href="#filepos748835">Dynamic Scope</a></blockquote><blockquote class="calibre35">manipulating code, <a href="#filepos840195">What Macros Are Not</a></blockquote><blockquote class="calibre35">size of, <a href="#filepos341393">Abstractions over Implementations</a></blockquote><p class="calibre23">appendTo, <a href="#filepos1317671">with-open, finally’s Lament</a></p><p class="calibre23">applications, versioning, <a href="#filepos2035107">Deploying Clojure Apps to Amazon’s Elastic Beanstalk</a></p><p class="calibre23">arbitrary implementation, <a href="#filepos1042799">Protocol Dispatch Edge Cases</a></p><p class="calibre23">arbitrary precision versus bounded, <a href="#filepos1557213">Bounded Versus Arbitrary Precision</a>, <a href="#filepos1564943">Bounded Versus Arbitrary Precision</a></p><p class="calibre23">arbitrary-precision decimals ops, scale and rounding modes, <a href="#filepos1570688">Scale and Rounding Modes for Arbitrary-Precision Decimals Ops</a></p><p class="calibre23">arbitrary-precision numbers, <a href="#filepos93981">Numbers</a></p><p class="calibre23">areduce, <a href="#filepos1620146">The mechanics of primitive arrays</a></p><p class="calibre23">argument vectors, <a href="#filepos1334794">Type Hinting for Performance</a></p><p class="calibre23">arguments, <a href="#filepos169123">Destructuring function arguments</a>, <a href="#filepos176625">Destructuring function arguments</a>, <a href="#filepos169902">Destructuring function arguments</a>, <a href="#filepos171023">Destructuring function arguments</a>, <a href="#filepos233404">Comparing Values to Mutable Objects</a>, <a href="#filepos911124">&amp;env</a>, <a href="#filepos1592576">Declare Functions to Take and Return Primitives</a>, <a href="#filepos1598648">Declare Functions to Take and Return Primitives</a></p><blockquote class="calibre35">&amp;form and &amp;env, <a href="#filepos911124">&amp;env</a></blockquote><blockquote class="calibre35">destructuring function arguments, <a href="#filepos169123">Destructuring function arguments</a>, <a href="#filepos176625">Destructuring function arguments</a></blockquote><blockquote class="calibre35">keywords, <a href="#filepos171023">Destructuring function arguments</a></blockquote><blockquote class="calibre35">mutable arguments and functions, <a href="#filepos233404">Comparing Values to Mutable Objects</a></blockquote><blockquote class="calibre35">performance, <a href="#filepos1592576">Declare Functions to Take and Return Primitives</a></blockquote><blockquote class="calibre35">primitive types, <a href="#filepos1598648">Declare Functions to Take and Return Primitives</a></blockquote><blockquote class="calibre35">rest arguments, <a href="#filepos169902">Destructuring function arguments</a></blockquote><p class="calibre23">arithmetic functions, <a href="#filepos321756">Pure Functions</a></p><p class="calibre23">arities, <a href="#filepos164260">Creating Functions: fn</a>, <a href="#filepos178935">Function literals</a>, <a href="#filepos274491">Applying Ourselves Partially</a>, <a href="#filepos1079015">Multimethods Basics</a></p><blockquote class="calibre35">functions, <a href="#filepos164260">Creating Functions: fn</a>, <a href="#filepos178935">Function literals</a></blockquote><blockquote class="calibre35">Multimethods, <a href="#filepos1079015">Multimethods Basics</a></blockquote><blockquote class="calibre35">performance, <a href="#filepos274491">Applying Ourselves Partially</a></blockquote><p class="calibre23">ArrayList, <a href="#filepos1302578">Handy Interop Utilities</a></p><p class="calibre23">arrays, <a href="#filepos1336385">Arrays</a>, <a href="#filepos1337208">Arrays</a>, <a href="#filepos1605278">Use Primitive Arrays Judiciously</a>, <a href="#filepos1629998">Automating type hinting of multidimensional array operations</a>, <a href="#filepos1610778">The mechanics of primitive arrays</a>, <a href="#filepos1613902">The mechanics of primitive arrays</a>, <a href="#filepos1616809">The mechanics of primitive arrays</a>, <a href="#filepos1623519">Automating type hinting of multidimensional array operations</a></p><blockquote class="calibre35">classes, <a href="#filepos1613902">The mechanics of primitive arrays</a></blockquote><blockquote class="calibre35">hints, <a href="#filepos1616809">The mechanics of primitive arrays</a></blockquote><blockquote class="calibre35">Java, <a href="#filepos1336385">Arrays</a></blockquote><blockquote class="calibre35">operations, <a href="#filepos1337208">Arrays</a></blockquote><blockquote class="calibre35">primitive arrays, <a href="#filepos1605278">Use Primitive Arrays Judiciously</a>, <a href="#filepos1629998">Automating type hinting of multidimensional array operations</a>, <a href="#filepos1610778">The mechanics of primitive arrays</a>, <a href="#filepos1623519">Automating type hinting of multidimensional array operations</a></blockquote><blockquote class="calibre35">about, <a href="#filepos1610778">The mechanics of primitive arrays</a></blockquote><blockquote class="calibre35">type hinting of multidimensional array operations, <a href="#filepos1623519">Automating type hinting of multidimensional array operations</a></blockquote><p class="calibre23">ArraySet, <a href="#filepos1059120">Participating in Clojure’s Collection Abstractions</a></p><p class="calibre23">artifactId, <a href="#filepos1212081">Artifacts and coordinates</a></p><p class="calibre23">artifacts, Maven dependency management model, <a href="#filepos1208359">Artifacts and coordinates</a></p><p class="calibre23">aset, <a href="#filepos1617841">The mechanics of primitive arrays</a>, <a href="#filepos1620915">The mechanics of primitive arrays</a></p><p class="calibre23">aspect-oriented programming (AOP), <a href="#filepos1682715">Aspect-Oriented Programming</a>, <a href="#filepos1694934">Aspect-Oriented Programming</a></p><p class="calibre23">AspectJ, <a href="#filepos1686062">Aspect-Oriented Programming</a></p><p class="calibre23">assertions, testing, <a href="#filepos1745138">Relying upon Assertions</a></p><p class="calibre23">assoc, <a href="#filepos389936">Associative</a>, <a href="#filepos485439">Visualizing persistence: maps (and vectors and sets)</a></p><p class="calibre23">associative abstraction, <a href="#filepos388042">Associative</a>, <a href="#filepos399463">Beware of nil values</a>, <a href="#filepos980863">Records</a></p><blockquote class="calibre35">data structures, <a href="#filepos388042">Associative</a>, <a href="#filepos399463">Beware of nil values</a></blockquote><blockquote class="calibre35">records, <a href="#filepos980863">Records</a></blockquote><p class="calibre23">asterisks (*), <a href="#filepos747535">Dynamic Scope</a></p><p class="calibre23">at sign (@), <a href="#filepos598386">Delays</a></p><p class="calibre23">atoms, <a href="#filepos646731">Atoms</a>, <a href="#filepos711862">Side-effecting functions strictly verboten</a></p><blockquote class="calibre35">concurrency and parallelism, <a href="#filepos646731">Atoms</a></blockquote><blockquote class="calibre35">operations on, <a href="#filepos711862">Side-effecting functions strictly verboten</a></blockquote><p class="calibre23">attrs, <a href="#filepos1736648">Growing an HTML DSL</a></p><p class="calibre23">auto-gensym, <a href="#filepos888772">Gensyms to the Rescue</a></p><p class="calibre23">autoboxing, <a href="#filepos1591040">Optimizing Numeric Performance</a>, <a href="#filepos1604153">Type errors and warnings</a></p><p class="calibre23">autopromoting operators, <a href="#filepos1562891">Bounded Versus Arbitrary Precision</a></p><p class="calibre23">auxiliary constructor, <a href="#filepos987493">Records</a></p><p class="calibre23">averaging numbers, <a href="#filepos42374">The Clojure REPL</a></p><p class="calibre23">Avout, <a href="#filepos2085890">Avout</a></p><p class="calibre23">await, <a href="#filepos776945">Agents</a></p><p class="calibre23">await-for, <a href="#filepos779048">Agents</a></p><div class="mbppagebreak"></div><p class="calibre23"><span class="calibre53"><span class="bold">B</span></span></p><p class="calibre46">back references, <a href="#filepos524173">Identifiers and Cycles</a></p><p class="calibre23">bare version numbers, <a href="#filepos1226712">Dependencies</a></p><p class="calibre23">barging, <a href="#filepos717358">Minimize the scope of each transaction</a></p><p class="calibre23">BigDecimal, <a href="#filepos1542549">Clojure Has a Mixed Numerics Model</a>, <a href="#filepos1570782">Scale and Rounding Modes for Arbitrary-Precision Decimals Ops</a></p><p class="calibre23">BigInt, <a href="#filepos1542689">Clojure Has a Mixed Numerics Model</a>, <a href="#filepos1559655">Bounded Versus Arbitrary Precision</a></p><p class="calibre23">BigInteger, <a href="#filepos1542594">Clojure Has a Mixed Numerics Model</a>, <a href="#filepos1558475">Bounded Versus Arbitrary Precision</a></p><p class="calibre23">binding, <a href="#filepos130567">Local Bindings: let</a>, <a href="#filepos155734">Map destructuring</a>, <a href="#filepos901692">Common Macro Idioms and Patterns</a>, <a href="#filepos1318707">with-open, finally’s Lament</a>, <a href="#filepos1700781">Mocking</a></p><blockquote class="calibre35">local bindings: let, <a href="#filepos130567">Local Bindings: let</a></blockquote><blockquote class="calibre35">multiple resources, <a href="#filepos1318707">with-open, finally’s Lament</a></blockquote><blockquote class="calibre35">value to their keys’ names, <a href="#filepos155734">Map destructuring</a></blockquote><blockquote class="calibre35">vectors, <a href="#filepos901692">Common Macro Idioms and Patterns</a></blockquote><blockquote class="calibre35">with-redefs, <a href="#filepos1700781">Mocking</a></blockquote><p class="calibre23">binding conveyance, <a href="#filepos757846">Dynamic Scope</a></p><p class="calibre23">blocks, Ruby, <a href="#filepos176888">Function literals</a></p><p class="calibre23">boilerplate, Hibernate, <a href="#filepos1811426">Removing Boilerplate</a></p><p class="calibre23">booleans, <a href="#filepos80691">Booleans</a></p><p class="calibre23">bounded versus arbitrary precision, <a href="#filepos1557213">Bounded Versus Arbitrary Precision</a>, <a href="#filepos1564943">Bounded Versus Arbitrary Precision</a></p><p class="calibre23">boxed decimals, <a href="#filepos1533418">Clojure Numerics</a></p><p class="calibre23">boxed integers, <a href="#filepos1532563">Clojure Numerics</a></p><p class="calibre23">braces {…}, <a href="#filepos49192">No, Parentheses Actually Won’t Make You Go Blind</a></p><p class="calibre23">branching, Enlive, <a href="#filepos1969832">Iterating and branching</a></p><p class="calibre23">browsing namespaces, <a href="#filepos1473664">Eclipse</a></p><p class="calibre23">build solutions, <a href="#filepos1192108">Build</a>, <a href="#filepos1261004">Building mixed-source projects</a>, <a href="#filepos1199563">Ahead-of-Time Compilation</a>, <a href="#filepos1205824">Dependency Management</a>, <a href="#filepos1228241">Dependencies</a>, <a href="#filepos1208359">Artifacts and coordinates</a>, <a href="#filepos1213484">Repositories</a>, <a href="#filepos1216111">Dependencies</a>, <a href="#filepos1228380">Build Tools and Configuration Patterns</a>, <a href="#filepos1261004">Building mixed-source projects</a>, <a href="#filepos1230604">Maven</a>, <a href="#filepos1238569">Leiningen</a>, <a href="#filepos1247197">AOT compilation configuration</a>, <a href="#filepos1252999">Building mixed-source projects</a></p><blockquote class="calibre35">compilation, <a href="#filepos1199563">Ahead-of-Time Compilation</a></blockquote><blockquote class="calibre35">dependency management, <a href="#filepos1205824">Dependency Management</a>, <a href="#filepos1228241">Dependencies</a>, <a href="#filepos1208359">Artifacts and coordinates</a>, <a href="#filepos1213484">Repositories</a>, <a href="#filepos1216111">Dependencies</a></blockquote><blockquote class="calibre35">artifacts and coordinates, <a href="#filepos1208359">Artifacts and coordinates</a></blockquote><blockquote class="calibre35">dependencies, <a href="#filepos1216111">Dependencies</a></blockquote><blockquote class="calibre35">repositories, <a href="#filepos1213484">Repositories</a></blockquote><blockquote class="calibre35">tools and configuration patterns, <a href="#filepos1228380">Build Tools and Configuration Patterns</a>, <a href="#filepos1261004">Building mixed-source projects</a>, <a href="#filepos1230604">Maven</a>, <a href="#filepos1238569">Leiningen</a>, <a href="#filepos1247197">AOT compilation configuration</a>, <a href="#filepos1252999">Building mixed-source projects</a></blockquote><blockquote class="calibre35">AOT compilation configuration, <a href="#filepos1247197">AOT compilation configuration</a></blockquote><blockquote class="calibre35">Leiningen, <a href="#filepos1238569">Leiningen</a></blockquote><blockquote class="calibre35">Maven, <a href="#filepos1230604">Maven</a></blockquote><blockquote class="calibre35">mixed source projects, <a href="#filepos1252999">Building mixed-source projects</a></blockquote><p class="calibre23">built-in operators, <a href="#filepos844947">What Can Macros Do that Functions Cannot?</a></p><div class="mbppagebreak"></div><p class="calibre23"><span class="calibre53"><span class="bold">C</span></span></p><p class="calibre46">catch, <a href="#filepos1309224">Exceptions and Error Handling</a></p><p class="calibre23">chain of responsibility, <a href="#filepos1675057">Chain of Responsibility</a>, <a href="#filepos1682600">Chain of Responsibility</a></p><p class="calibre23">character literals, <a href="#filepos81318">Characters</a></p><p class="calibre23">checked exceptions, <a href="#filepos1313513">Escaping Checked Exceptions</a></p><p class="calibre23">chunking, <a href="#filepos625701">Parallelism on the Cheap</a></p><p class="calibre23">class, <a href="#filepos1300959">Handy Interop Utilities</a></p><p class="calibre23">classes, <a href="#filepos1041445">Protocol Dispatch Edge Cases</a>, <a href="#filepos1123785">type Versus class; or, the Revenge of the Map</a>, <a href="#filepos1282546">Using Java Classes, Methods, and Fields</a>, <a href="#filepos1298190">Using Java Classes, Methods, and Fields</a>, <a href="#filepos1343833">Defining Classes and Implementing Interfaces</a>, <a href="#filepos1402843">Implementing JAX-RS web service endpoints</a>, <a href="#filepos1344522">Defining Classes and Implementing Interfaces</a>, <a href="#filepos1352571">Instances of Anonymous Classes: proxy</a>, <a href="#filepos1362584">Defining Named Classes</a>, <a href="#filepos1389137">gen-class</a>, <a href="#filepos1389249">Annotations</a>, <a href="#filepos1402843">Implementing JAX-RS web service endpoints</a>, <a href="#filepos1391129">Producing annotated JUnit tests</a>, <a href="#filepos1396536">Implementing JAX-RS web service endpoints</a>, <a href="#filepos1420153">Using deftype and defrecord Classes</a>, <a href="#filepos1429238">Using deftype and defrecord Classes</a>, <a href="#filepos1520764">Limitations to Redefining Constructs</a>, <a href="#filepos1613902">The mechanics of primitive arrays</a></p><blockquote class="calibre35">annotations, <a href="#filepos1389249">Annotations</a>, <a href="#filepos1402843">Implementing JAX-RS web service endpoints</a>, <a href="#filepos1391129">Producing annotated JUnit tests</a>, <a href="#filepos1396536">Implementing JAX-RS web service endpoints</a></blockquote><blockquote class="calibre35">JAX-RS, <a href="#filepos1396536">Implementing JAX-RS web service endpoints</a></blockquote><blockquote class="calibre35">JUnit tests, <a href="#filepos1391129">Producing annotated JUnit tests</a></blockquote><blockquote class="calibre35">arrays, <a href="#filepos1613902">The mechanics of primitive arrays</a></blockquote><blockquote class="calibre35">deftype and dfrecord classes, <a href="#filepos1420153">Using deftype and defrecord Classes</a>, <a href="#filepos1429238">Using deftype and defrecord Classes</a></blockquote><blockquote class="calibre35">hierarchies, <a href="#filepos1041445">Protocol Dispatch Edge Cases</a></blockquote><blockquote class="calibre35">inline and protocol implementations, <a href="#filepos1520764">Limitations to Redefining Constructs</a></blockquote><blockquote class="calibre35">Java, <a href="#filepos1282546">Using Java Classes, Methods, and Fields</a>, <a href="#filepos1298190">Using Java Classes, Methods, and Fields</a>, <a href="#filepos1344522">Defining Classes and Implementing Interfaces</a></blockquote><blockquote class="calibre35">multimethods, <a href="#filepos1123785">type Versus class; or, the Revenge of the Map</a></blockquote><blockquote class="calibre35">named classes, <a href="#filepos1362584">Defining Named Classes</a>, <a href="#filepos1389137">gen-class</a></blockquote><blockquote class="calibre35">proxy, <a href="#filepos1352571">Instances of Anonymous Classes: proxy</a></blockquote><p class="calibre23">classpath, <a href="#filepos41159">The Clojure REPL</a>, <a href="#filepos1168608">A classpath primer</a>, <a href="#filepos1519680">Limitations to Redefining Constructs</a></p><blockquote class="calibre35">JVM, <a href="#filepos41159">The Clojure REPL</a></blockquote><blockquote class="calibre35">limitations, <a href="#filepos1519680">Limitations to Redefining Constructs</a></blockquote><blockquote class="calibre35">namespaces, <a href="#filepos1168608">A classpath primer</a></blockquote><p class="calibre23">Clojars.org, <a href="#filepos1214803">Repositories</a></p><p class="calibre23">Clojure, <a href="#filepos28755">Down the Rabbit Hole</a>, <a href="#filepos215045">This Is Just the Beginning</a>, <a href="#filepos215769">Functional Programming</a>, <a href="#filepos335770">Functional Programming in the Real World</a>, <a href="#filepos335902">Collections and Data Structures</a>, <a href="#filepos593783">In Summary</a>, <a href="#filepos593911">Concurrency and Parallelism</a>, <a href="#filepos831370">Final Thoughts</a>, <a href="#filepos831586">Macros</a>, <a href="#filepos945416">Final Thoughts</a>, <a href="#filepos945540">Datatypes and Protocols</a>, <a href="#filepos1073462">Final Thoughts</a>, <a href="#filepos1073575">Multimethods</a>, <a href="#filepos1132069">Final Thoughts</a>, <a href="#filepos1132717">Organizing and Building Clojure Projects</a>, <a href="#filepos1274052">Final Thoughts</a>, <a href="#filepos1274182">Java and JVM Interoperability</a>, <a href="#filepos1437636">Collaborating Partners</a>, <a href="#filepos1437763">REPL-Oriented Programming</a>, <a href="#filepos1527318">In Summary</a>, <a href="#filepos1527542">Numerics and Mathematics</a>, <a href="#filepos1652902">Visualizing the Mandelbrot Set in Clojure</a>, <a href="#filepos1656409">Design Patterns</a>, <a href="#filepos1695922">Final Thoughts</a>, <a href="#filepos1696031">Testing</a>, <a href="#filepos1756471">Preconditions and Postconditions</a>, <a href="#filepos1757696">Using Relational Databases</a>, <a href="#filepos1819793">Final Thoughts</a>, <a href="#filepos1819924">Using Nonrelational Databases</a>, <a href="#filepos1878859">Final Thoughts</a>, <a href="#filepos1878980">Clojure and the Web</a>, <a href="#filepos1990515">Final Thoughts</a>, <a href="#filepos1991606">Deploying Clojure Web Applications</a>, <a href="#filepos2042728">Going Beyond Simple Web Application Deployment</a>, <a href="#filepos2042973">Choosing Clojure Type Definition Forms Wisely</a>, <a href="#filepos2048613">Introducing Clojure into Your Workplace</a>, <a href="#filepos2069410">Be Prudent</a>, <a href="#filepos2070211">What’s Next?</a>, <a href="#filepos2088364">Clojure on Heroku</a></p><blockquote class="calibre35">collections and data structures, <a href="#filepos335902">Collections and Data Structures</a>, <a href="#filepos593783">In Summary</a></blockquote><blockquote class="calibre35">concurrency and parallelism, <a href="#filepos593911">Concurrency and Parallelism</a>, <a href="#filepos831370">Final Thoughts</a></blockquote><blockquote class="calibre35">datatypes and protocols, <a href="#filepos945540">Datatypes and Protocols</a>, <a href="#filepos1073462">Final Thoughts</a></blockquote><blockquote class="calibre35">design patterns, <a href="#filepos1656409">Design Patterns</a>, <a href="#filepos1695922">Final Thoughts</a></blockquote><blockquote class="calibre35">FP, <a href="#filepos215769">Functional Programming</a>, <a href="#filepos335770">Functional Programming in the Real World</a></blockquote><blockquote class="calibre35">future, <a href="#filepos2070211">What’s Next?</a>, <a href="#filepos2088364">Clojure on Heroku</a></blockquote><blockquote class="calibre35">general information about, <a href="#filepos28755">Down the Rabbit Hole</a>, <a href="#filepos215045">This Is Just the Beginning</a></blockquote><blockquote class="calibre35">introducing to your workplace, <a href="#filepos2048613">Introducing Clojure into Your Workplace</a>, <a href="#filepos2069410">Be Prudent</a></blockquote><blockquote class="calibre35">Java, <a href="#filepos1274182">Java and JVM Interoperability</a>, <a href="#filepos1437636">Collaborating Partners</a></blockquote><blockquote class="calibre35">macros, <a href="#filepos831586">Macros</a>, <a href="#filepos945416">Final Thoughts</a></blockquote><blockquote class="calibre35">multimethods, <a href="#filepos1073575">Multimethods</a>, <a href="#filepos1132069">Final Thoughts</a></blockquote><blockquote class="calibre35">nonrelational databases, <a href="#filepos1819924">Using Nonrelational Databases</a>, <a href="#filepos1878859">Final Thoughts</a></blockquote><blockquote class="calibre35">numerics and mathematics, <a href="#filepos1527542">Numerics and Mathematics</a>, <a href="#filepos1652902">Visualizing the Mandelbrot Set in Clojure</a></blockquote><blockquote class="calibre35">projects, <a href="#filepos1132717">Organizing and Building Clojure Projects</a>, <a href="#filepos1274052">Final Thoughts</a></blockquote><blockquote class="calibre35">relational databases, <a href="#filepos1757696">Using Relational Databases</a>, <a href="#filepos1819793">Final Thoughts</a></blockquote><blockquote class="calibre35">REPL (Read, Evaluate, Print, Loop), <a href="#filepos1437763">REPL-Oriented Programming</a>, <a href="#filepos1527318">In Summary</a></blockquote><blockquote class="calibre35">testing, <a href="#filepos1696031">Testing</a>, <a href="#filepos1756471">Preconditions and Postconditions</a></blockquote><blockquote class="calibre35">type definition forms, <a href="#filepos2042973">Choosing Clojure Type Definition Forms Wisely</a></blockquote><blockquote class="calibre35">web applications, <a href="#filepos1991606">Deploying Clojure Web Applications</a>, <a href="#filepos2042728">Going Beyond Simple Web Application Deployment</a></blockquote><blockquote class="calibre35">web development, <a href="#filepos1878980">Clojure and the Web</a>, <a href="#filepos1990515">Final Thoughts</a></blockquote><p class="calibre23">clojure-maven-plugin, <a href="#filepos1237571">Maven</a>, <a href="#filepos1254554">Building mixed-source projects</a></p><p class="calibre23">clojure-mode, <a href="#filepos1479345">clojure-mode and paredit</a></p><p class="calibre23">clojure.core, <a href="#filepos1140478">Defining and Using Namespaces</a></p><p class="calibre23">clojure.java.jdbc, <a href="#filepos1758871">clojure.java.jdbc</a>, <a href="#filepos1780783">Connection Pooling</a>, <a href="#filepos1768147">with-query-results Explained</a>, <a href="#filepos1773214">Transactions</a>, <a href="#filepos1776470">Connection Pooling</a></p><blockquote class="calibre35">connection pooling, <a href="#filepos1776470">Connection Pooling</a></blockquote><blockquote class="calibre35">transactions, <a href="#filepos1773214">Transactions</a></blockquote><blockquote class="calibre35">with-query-results, <a href="#filepos1768147">with-query-results Explained</a></blockquote><p class="calibre23">clojure.lang.IEditableCollection, <a href="#filepos500880">Transients</a></p><p class="calibre23">clojure.repl, <a href="#filepos1462720">The Bare REPL</a></p><p class="calibre23">clojure.set, <a href="#filepos1144590">Defining and Using Namespaces</a></p><p class="calibre23">clojure.string, <a href="#filepos1144625">Defining and Using Namespaces</a></p><p class="calibre23">clojure.test, <a href="#filepos1704113">clojure.test</a>, <a href="#filepos1729957">Fixtures</a>, <a href="#filepos1708995">Defining Tests</a>, <a href="#filepos1714648">Defining Tests</a>, <a href="#filepos1715524">Test “Suites”</a>, <a href="#filepos1720614">Fixtures</a></p><blockquote class="calibre35">defining tests, <a href="#filepos1708995">Defining Tests</a>, <a href="#filepos1714648">Defining Tests</a></blockquote><blockquote class="calibre35">fixtures, <a href="#filepos1720614">Fixtures</a></blockquote><blockquote class="calibre35">test suites, <a href="#filepos1715524">Test “Suites”</a></blockquote><p class="calibre23">ClojureCLR, <a href="#filepos2071713">ClojureCLR</a></p><p class="calibre23">ClojureScript, <a href="#filepos2072421">ClojureScript</a></p><p class="calibre23">clone-for, <a href="#filepos1972566">Iterating and branching</a></p><p class="calibre23">Clutch, <a href="#filepos1822829">Getting Set Up with CouchDB and Clutch</a></p><p class="calibre23">code blocks: do, <a href="#filepos127037">Code Blocks: do</a></p><p class="calibre23">code generation versus macros, <a href="#filepos839556">What Macros Are Not</a></p><p class="calibre23">code-as-data, <a href="#filepos69773">Homoiconicity</a></p><p class="calibre23">codebases, functional organization of, <a href="#filepos1177983">The Functional Organization of Clojure Codebases</a></p><p class="calibre23">coercion functions, <a href="#filepos1603947">Type errors and warnings</a></p><p class="calibre23">collection abstractions, <a href="#filepos1046890">Participating in Clojure’s Collection Abstractions</a></p><p class="calibre23">collection literals, <a href="#filepos102366">Collection Literals</a></p><p class="calibre23">collection types, destructuring, <a href="#filepos137200">Local Bindings: let</a></p><p class="calibre23">collections and data structures, <a href="#filepos335902">Collections and Data Structures</a>, <a href="#filepos593783">In Summary</a>, <a href="#filepos338606">Abstractions over Implementations</a>, <a href="#filepos446300">Collections and Keys and Higher-Order Functions</a>, <a href="#filepos347305">Collection</a>, <a href="#filepos354266">Sequences</a>, <a href="#filepos387930">Head retention</a>, <a href="#filepos388042">Associative</a>, <a href="#filepos399463">Beware of nil values</a>, <a href="#filepos399580">Indexed</a>, <a href="#filepos403717">Stack</a>, <a href="#filepos405856">Set</a>, <a href="#filepos407171">Sorted</a>, <a href="#filepos426011">Comparators and predicates to define ordering</a>, <a href="#filepos438293">Concise Collection Access</a>, <a href="#filepos446300">Collections and Keys and Higher-Order Functions</a>, <a href="#filepos441319">Idiomatic Usage</a>, <a href="#filepos443341">Collections and Keys and Higher-Order Functions</a>, <a href="#filepos447326">Data Structure Types</a>, <a href="#filepos472646">Other usages of maps</a>, <a href="#filepos448004">Lists</a>, <a href="#filepos451006">Vectors</a>, <a href="#filepos455466">Sets</a>, <a href="#filepos457717">Maps</a>, <a href="#filepos474049">Immutability and Persistence</a>, <a href="#filepos508819">Transients</a>, <a href="#filepos477639">Persistence and Structural Sharing</a>, <a href="#filepos492450">Tangible benefits</a>, <a href="#filepos492605">Transients</a>, <a href="#filepos508819">Transients</a>, <a href="#filepos512882">Metadata</a>, <a href="#filepos520050">Identifiers and Cycles</a>, <a href="#filepos525895">Revisiting a classic: Conway’s Game of Life</a>, <a href="#filepos546783">Revisiting a classic: Conway’s Game of Life</a>, <a href="#filepos547102">Maze generation</a>, <a href="#filepos569549">Maze generation</a>, <a href="#filepos569681">Navigation, Update, and Zippers</a>, <a href="#filepos587550">Ariadne’s zipper</a>, <a href="#filepos849177">Macros Versus Ruby eval</a>, <a href="#filepos1590352">Optimizing Numeric Performance</a></p><blockquote class="calibre35">abstractions, <a href="#filepos338606">Abstractions over Implementations</a>, <a href="#filepos446300">Collections and Keys and Higher-Order Functions</a>, <a href="#filepos347305">Collection</a>, <a href="#filepos354266">Sequences</a>, <a href="#filepos387930">Head retention</a>, <a href="#filepos388042">Associative</a>, <a href="#filepos399463">Beware of nil values</a>, <a href="#filepos399580">Indexed</a>, <a href="#filepos403717">Stack</a>, <a href="#filepos405856">Set</a>, <a href="#filepos407171">Sorted</a>, <a href="#filepos426011">Comparators and predicates to define ordering</a></blockquote><blockquote class="calibre35">associative, <a href="#filepos388042">Associative</a>, <a href="#filepos399463">Beware of nil values</a></blockquote><blockquote class="calibre35">collections, <a href="#filepos347305">Collection</a></blockquote><blockquote class="calibre35">indexed, <a href="#filepos399580">Indexed</a></blockquote><blockquote class="calibre35">sequences, <a href="#filepos354266">Sequences</a>, <a href="#filepos387930">Head retention</a></blockquote><blockquote class="calibre35">set abstractions, <a href="#filepos405856">Set</a></blockquote><blockquote class="calibre35">sorted, <a href="#filepos407171">Sorted</a>, <a href="#filepos426011">Comparators and predicates to define ordering</a></blockquote><blockquote class="calibre35">stacks, <a href="#filepos403717">Stack</a></blockquote><blockquote class="calibre35">collection access, <a href="#filepos438293">Concise Collection Access</a>, <a href="#filepos446300">Collections and Keys and Higher-Order Functions</a>, <a href="#filepos441319">Idiomatic Usage</a>, <a href="#filepos443341">Collections and Keys and Higher-Order Functions</a></blockquote><blockquote class="calibre35">idiomatic usage, <a href="#filepos441319">Idiomatic Usage</a></blockquote><blockquote class="calibre35">keys and higher-order functions, <a href="#filepos443341">Collections and Keys and Higher-Order Functions</a></blockquote><blockquote class="calibre35">Conway’s Game of Life, <a href="#filepos525895">Revisiting a classic: Conway’s Game of Life</a>, <a href="#filepos546783">Revisiting a classic: Conway’s Game of Life</a></blockquote><blockquote class="calibre35">data structure types, <a href="#filepos447326">Data Structure Types</a>, <a href="#filepos472646">Other usages of maps</a>, <a href="#filepos448004">Lists</a>, <a href="#filepos451006">Vectors</a>, <a href="#filepos455466">Sets</a>, <a href="#filepos457717">Maps</a></blockquote><blockquote class="calibre35">lists, <a href="#filepos448004">Lists</a></blockquote><blockquote class="calibre35">maps, <a href="#filepos457717">Maps</a></blockquote><blockquote class="calibre35">sets, <a href="#filepos455466">Sets</a></blockquote><blockquote class="calibre35">vectors, <a href="#filepos451006">Vectors</a></blockquote><blockquote class="calibre35">identifiers and cycles, <a href="#filepos520050">Identifiers and Cycles</a></blockquote><blockquote class="calibre35">immutability and persistence, <a href="#filepos474049">Immutability and Persistence</a>, <a href="#filepos508819">Transients</a>, <a href="#filepos477639">Persistence and Structural Sharing</a>, <a href="#filepos492450">Tangible benefits</a>, <a href="#filepos492605">Transients</a>, <a href="#filepos508819">Transients</a></blockquote><blockquote class="calibre35">structural sharing, <a href="#filepos477639">Persistence and Structural Sharing</a>, <a href="#filepos492450">Tangible benefits</a></blockquote><blockquote class="calibre35">transients, <a href="#filepos492605">Transients</a>, <a href="#filepos508819">Transients</a></blockquote><blockquote class="calibre35">macros, <a href="#filepos849177">Macros Versus Ruby eval</a></blockquote><blockquote class="calibre35">maze generation, <a href="#filepos547102">Maze generation</a>, <a href="#filepos569549">Maze generation</a></blockquote><blockquote class="calibre35">metadata, <a href="#filepos512882">Metadata</a></blockquote><blockquote class="calibre35">navigation, update and zippers, <a href="#filepos569681">Navigation, Update, and Zippers</a>, <a href="#filepos587550">Ariadne’s zipper</a></blockquote><blockquote class="calibre35">performance, <a href="#filepos1590352">Optimizing Numeric Performance</a></blockquote><p class="calibre23">command-line utility, <a href="#filepos1368182">gen-class</a></p><p class="calibre23">commas (,), <a href="#filepos100741">Whitespace and Commas</a></p><p class="calibre23">comments, <a href="#filepos96957">Comments</a></p><p class="calibre23">community, <a href="#filepos2061050">Emphasize Community</a></p><p class="calibre23">commute, <a href="#filepos686722">Minimizing transaction conflict with commute</a>, <a href="#filepos699750">Minimizing transaction conflict with commute</a>, <a href="#filepos715721">Minimize the scope of each transaction</a></p><p class="calibre23">comp, <a href="#filepos286936">Composition of Function(ality)</a></p><p class="calibre23">comparators, ordering, <a href="#filepos412684">Comparators and predicates to define ordering</a>, <a href="#filepos426011">Comparators and predicates to define ordering</a></p><p class="calibre23">compare, <a href="#filepos412242">Sorted</a></p><p class="calibre23">compare-and-set, <a href="#filepos646892">Atoms</a></p><p class="calibre23">compilation, <a href="#filepos39080">The Clojure REPL</a>, <a href="#filepos835574">What Is a Macro?</a>, <a href="#filepos1199563">Ahead-of-Time Compilation</a>, <a href="#filepos1247197">AOT compilation configuration</a></p><blockquote class="calibre35">AOT, <a href="#filepos1199563">Ahead-of-Time Compilation</a>, <a href="#filepos1247197">AOT compilation configuration</a></blockquote><blockquote class="calibre35">macros, <a href="#filepos835574">What Is a Macro?</a></blockquote><blockquote class="calibre35">REPL, <a href="#filepos39080">The Clojure REPL</a></blockquote><p class="calibre23">Compojure, <a href="#filepos1921327">Routing Requests with Compojure</a>, <a href="#filepos1932608">Routing Requests with Compojure</a></p><blockquote class="calibre35">about, <a href="#filepos1921327">Routing Requests with Compojure</a></blockquote><blockquote class="calibre35">routes, <a href="#filepos1932608">Routing Requests with Compojure</a></blockquote><p class="calibre23">compositionality, <a href="#filepos284407">Composition of Function(ality)</a>, <a href="#filepos311125">Building a Primitive Logging System with Composable Higher-Order Functions</a>, <a href="#filepos294195">Writing Higher-Order Functions</a>, <a href="#filepos296247">Building a Primitive Logging System with Composable Higher-Order Functions</a>, <a href="#filepos311125">Building a Primitive Logging System with Composable Higher-Order Functions</a></p><blockquote class="calibre35">building a primitive logging system, <a href="#filepos296247">Building a Primitive Logging System with Composable Higher-Order Functions</a>, <a href="#filepos311125">Building a Primitive Logging System with Composable Higher-Order Functions</a></blockquote><blockquote class="calibre35">higher-order functions, <a href="#filepos294195">Writing Higher-Order Functions</a></blockquote><p class="calibre23">concat, <a href="#filepos871646">unquote and unquote-splicing</a></p><p class="calibre23">concurrency and parallelism, <a href="#filepos32725">Why Clojure?</a>, <a href="#filepos490043">Tangible benefits</a>, <a href="#filepos593911">Concurrency and Parallelism</a>, <a href="#filepos831370">Final Thoughts</a>, <a href="#filepos596974">Shifting Computation Through Time and Space</a>, <a href="#filepos603422">Futures</a>, <a href="#filepos608941">Promises</a>, <a href="#filepos618384">Parallelism on the Cheap</a>, <a href="#filepos619072">Parallelism on the Cheap</a>, <a href="#filepos628063">State and Identity</a>, <a href="#filepos636227">Clojure Reference Types</a>, <a href="#filepos640998">Classifying Concurrent Operations</a>, <a href="#filepos642242">Classifying Concurrent Operations</a>, <a href="#filepos646731">Atoms</a>, <a href="#filepos655293">Notifications and Constraints</a>, <a href="#filepos667730">Validators</a>, <a href="#filepos655948">Watches</a>, <a href="#filepos663904">Watches</a>, <a href="#filepos664015">Validators</a>, <a href="#filepos668381">Refs</a>, <a href="#filepos729589">Write skew</a>, <a href="#filepos669558">Software Transactional Memory</a>, <a href="#filepos672639">The Mechanics of Ref Change</a>, <a href="#filepos709570">Enforcing local consistency by using validators</a>, <a href="#filepos709851">The Sharp Corners of Software Transactional Memory</a>, <a href="#filepos729589">Write skew</a>, <a href="#filepos735068">Vars</a>, <a href="#filepos766262">Forward Declarations</a>, <a href="#filepos736765">Defining Vars</a>, <a href="#filepos744547">Constants</a>, <a href="#filepos744661">Dynamic Scope</a>, <a href="#filepos759026">Dynamic Scope</a>, <a href="#filepos759352">Vars Are Not Variables</a>, <a href="#filepos763173">Forward Declarations</a>, <a href="#filepos768817">Agents</a>, <a href="#filepos820785">Using agents to parallelize workloads</a>, <a href="#filepos779236">Dealing with Errors in Agent Actions</a>, <a href="#filepos787482">I/O, Transactions, and Nested Sends</a>, <a href="#filepos820785">Using agents to parallelize workloads</a>, <a href="#filepos799178">Using agents to parallelize workloads</a>, <a href="#filepos826459">Using Java’s Concurrency Primitives</a></p><blockquote class="calibre35">about, <a href="#filepos32725">Why Clojure?</a></blockquote><blockquote class="calibre35">agents, <a href="#filepos768817">Agents</a>, <a href="#filepos820785">Using agents to parallelize workloads</a>, <a href="#filepos779236">Dealing with Errors in Agent Actions</a>, <a href="#filepos787482">I/O, Transactions, and Nested Sends</a>, <a href="#filepos820785">Using agents to parallelize workloads</a></blockquote><blockquote class="calibre35">errors in agent actions, <a href="#filepos779236">Dealing with Errors in Agent Actions</a></blockquote><blockquote class="calibre35">I/O, transactions and nested sends, <a href="#filepos787482">I/O, Transactions, and Nested Sends</a>, <a href="#filepos820785">Using agents to parallelize workloads</a></blockquote><blockquote class="calibre35">agents and workloads, <a href="#filepos799178">Using agents to parallelize workloads</a></blockquote><blockquote class="calibre35">atoms, <a href="#filepos646731">Atoms</a></blockquote><blockquote class="calibre35">compared, <a href="#filepos619072">Parallelism on the Cheap</a></blockquote><blockquote class="calibre35">coordination, <a href="#filepos640998">Classifying Concurrent Operations</a></blockquote><blockquote class="calibre35">delays, <a href="#filepos596974">Shifting Computation Through Time and Space</a></blockquote><blockquote class="calibre35">futures, <a href="#filepos603422">Futures</a></blockquote><blockquote class="calibre35">Java’s concurrency primitives, <a href="#filepos826459">Using Java’s Concurrency Primitives</a></blockquote><blockquote class="calibre35">notifications and constraints, <a href="#filepos655293">Notifications and Constraints</a>, <a href="#filepos667730">Validators</a>, <a href="#filepos655948">Watches</a>, <a href="#filepos663904">Watches</a>, <a href="#filepos664015">Validators</a></blockquote><blockquote class="calibre35">validators, <a href="#filepos664015">Validators</a></blockquote><blockquote class="calibre35">watches, <a href="#filepos655948">Watches</a>, <a href="#filepos663904">Watches</a></blockquote><blockquote class="calibre35">parallelism on the cheap, <a href="#filepos618384">Parallelism on the Cheap</a></blockquote><blockquote class="calibre35">promises, <a href="#filepos608941">Promises</a></blockquote><blockquote class="calibre35">reference types, <a href="#filepos490043">Tangible benefits</a>, <a href="#filepos636227">Clojure Reference Types</a></blockquote><blockquote class="calibre35">refs, <a href="#filepos668381">Refs</a>, <a href="#filepos729589">Write skew</a>, <a href="#filepos669558">Software Transactional Memory</a>, <a href="#filepos672639">The Mechanics of Ref Change</a>, <a href="#filepos709570">Enforcing local consistency by using validators</a>, <a href="#filepos709851">The Sharp Corners of Software Transactional Memory</a>, <a href="#filepos729589">Write skew</a></blockquote><blockquote class="calibre35">mechanics of ref change, <a href="#filepos672639">The Mechanics of Ref Change</a>, <a href="#filepos709570">Enforcing local consistency by using validators</a></blockquote><blockquote class="calibre35">STM, <a href="#filepos669558">Software Transactional Memory</a></blockquote><blockquote class="calibre35">transactional memory, <a href="#filepos709851">The Sharp Corners of Software Transactional Memory</a>, <a href="#filepos729589">Write skew</a></blockquote><blockquote class="calibre35">state and identity, <a href="#filepos628063">State and Identity</a></blockquote><blockquote class="calibre35">synchronization, <a href="#filepos642242">Classifying Concurrent Operations</a></blockquote><blockquote class="calibre35">vars, <a href="#filepos735068">Vars</a>, <a href="#filepos766262">Forward Declarations</a>, <a href="#filepos736765">Defining Vars</a>, <a href="#filepos744547">Constants</a>, <a href="#filepos744661">Dynamic Scope</a>, <a href="#filepos759026">Dynamic Scope</a>, <a href="#filepos759352">Vars Are Not Variables</a>, <a href="#filepos763173">Forward Declarations</a></blockquote><blockquote class="calibre35">defining, <a href="#filepos736765">Defining Vars</a>, <a href="#filepos744547">Constants</a></blockquote><blockquote class="calibre35">dynamic scope, <a href="#filepos744661">Dynamic Scope</a>, <a href="#filepos759026">Dynamic Scope</a></blockquote><blockquote class="calibre35">forward declarations, <a href="#filepos763173">Forward Declarations</a></blockquote><blockquote class="calibre35">versus variables, <a href="#filepos759352">Vars Are Not Variables</a></blockquote><p class="calibre23">concurrency forms, dynamic scope, <a href="#filepos757451">Dynamic Scope</a></p><p class="calibre23">concurrency primitives, Java, <a href="#filepos826459">Using Java’s Concurrency Primitives</a></p><p class="calibre23">concurrency-ref-mechanics, <a href="#filepos790441">Persisting reference states with an agent-based write-behind log</a></p><p class="calibre23">cond, <a href="#filepos183355">Conditionals: if</a></p><p class="calibre23">conditionals: if, <a href="#filepos181506">Conditionals: if</a></p><p class="calibre23">configuration patterns, <a href="#filepos1228380">Build Tools and Configuration Patterns</a>, <a href="#filepos1261004">Building mixed-source projects</a></p><p class="calibre23">configuration, AOT compilation configuration, <a href="#filepos1247197">AOT compilation configuration</a></p><p class="calibre23">configure-view-server, <a href="#filepos1843947">Views in Clojure</a></p><p class="calibre23">conj, <a href="#filepos339572">Abstractions over Implementations</a>, <a href="#filepos349063">Collection</a>, <a href="#filepos404267">Stack</a>, <a href="#filepos448699">Lists</a>, <a href="#filepos480373">Visualizing persistence: lists</a></p><p class="calibre23">connection pooling, <a href="#filepos1776470">Connection Pooling</a></p><p class="calibre23">cons, <a href="#filepos366728">Creating seqs</a></p><p class="calibre23">constants, <a href="#filepos741958">Constants</a></p><p class="calibre23">constraints, <a href="#filepos25757">Safari® Books Online</a> (see notifications and constraints)</p><p class="calibre23">constructors, factory functions, <a href="#filepos988529">Constructors and factory functions</a></p><p class="calibre23">constructs, redefining, <a href="#filepos1519072">Limitations to Redefining Constructs</a></p><p class="calibre23">containerless approach, <a href="#filepos1999476">Java and Clojure Web Architecture</a></p><p class="calibre23">contains?, <a href="#filepos393891">Associative</a></p><p class="calibre23">continue, <a href="#filepos784418">Agent error handlers and modes</a></p><p class="calibre23">Conway’s Game of Life, <a href="#filepos525895">Revisiting a classic: Conway’s Game of Life</a>, <a href="#filepos546783">Revisiting a classic: Conway’s Game of Life</a></p><p class="calibre23">coordinates, Maven dependency management model, <a href="#filepos1208359">Artifacts and coordinates</a></p><p class="calibre23">coordination, concurrency and parallelism, <a href="#filepos640998">Classifying Concurrent Operations</a></p><p class="calibre23">core.logic, <a href="#filepos2079405">core.logic</a></p><p class="calibre23">core.memoize, <a href="#filepos330742">Why Are Pure Functions Interesting?</a></p><p class="calibre23">CouchDB, <a href="#filepos1819924">Using Nonrelational Databases</a>, <a href="#filepos1878859">Final Thoughts</a>, <a href="#filepos1822829">Getting Set Up with CouchDB and Clutch</a>, <a href="#filepos1825704">Basic CRUD Operations</a>, <a href="#filepos1832665">Views</a>, <a href="#filepos1855046">Views in Clojure</a>, <a href="#filepos1835255">A Simple (JavaScript) View</a>, <a href="#filepos1841465">A Simple (JavaScript) View</a>, <a href="#filepos1841591">Views in Clojure</a>, <a href="#filepos1855046">Views in Clojure</a>, <a href="#filepos1857966">_changes: Abusing CouchDB as a Message Queue</a>, <a href="#filepos1864812">À la Carte Message Queues</a>, <a href="#filepos1876087">À la Carte Message Queues</a></p><blockquote class="calibre35">about, <a href="#filepos1822829">Getting Set Up with CouchDB and Clutch</a></blockquote><blockquote class="calibre35">CRUD, <a href="#filepos1825704">Basic CRUD Operations</a></blockquote><blockquote class="calibre35">message queues, <a href="#filepos1864812">À la Carte Message Queues</a>, <a href="#filepos1876087">À la Carte Message Queues</a></blockquote><blockquote class="calibre35">views, <a href="#filepos1832665">Views</a>, <a href="#filepos1855046">Views in Clojure</a>, <a href="#filepos1835255">A Simple (JavaScript) View</a>, <a href="#filepos1841465">A Simple (JavaScript) View</a>, <a href="#filepos1841591">Views in Clojure</a>, <a href="#filepos1855046">Views in Clojure</a></blockquote><blockquote class="calibre35">Clojure, <a href="#filepos1841591">Views in Clojure</a>, <a href="#filepos1855046">Views in Clojure</a></blockquote><blockquote class="calibre35">JavaScript, <a href="#filepos1835255">A Simple (JavaScript) View</a>, <a href="#filepos1841465">A Simple (JavaScript) View</a></blockquote><blockquote class="calibre35">_changes, <a href="#filepos1857966">_changes: Abusing CouchDB as a Message Queue</a></blockquote><p class="calibre23">count, <a href="#filepos353353">Collection</a>, <a href="#filepos364358">Sequences are not lists</a></p><p class="calibre23">Counterclockwise, <a href="#filepos1470267">Eclipse</a></p><p class="calibre23">CRUD, nonrelational databases, <a href="#filepos1825704">Basic CRUD Operations</a></p><p class="calibre23">CSS selectors, <a href="#filepos1967608">Selectors</a></p><p class="calibre23">curl, <a href="#filepos1942877">Routing Requests with Compojure</a>, <a href="#filepos1943588">Routing Requests with Compojure</a></p><p class="calibre23">cycles, <a href="#filepos520050">Identifiers and Cycles</a>, <a href="#filepos524142">Identifiers and Cycles</a></p><blockquote class="calibre35">about, <a href="#filepos524142">Identifiers and Cycles</a></blockquote><blockquote class="calibre35">collections and data structures, <a href="#filepos520050">Identifiers and Cycles</a></blockquote><p class="calibre23">cyclic dependencies, <a href="#filepos612543">Promises</a></p><div class="mbppagebreak"></div><p class="calibre23"><span class="calibre53"><span class="bold">D</span></span></p><p class="calibre46">data, <a href="#filepos73961">Homoiconicity</a>, <a href="#filepos250697">First-Class and Higher-Order Functions</a>, <a href="#filepos1807587">Persisting Data</a></p><blockquote class="calibre35">Clojure programs represented as, <a href="#filepos73961">Homoiconicity</a></blockquote><blockquote class="calibre35">functions as, <a href="#filepos250697">First-Class and Higher-Order Functions</a></blockquote><blockquote class="calibre35">persisting data in Hibernate, <a href="#filepos1807587">Persisting Data</a></blockquote><p class="calibre23">data structures, <a href="#filepos25757">Safari® Books Online</a> (see collections and data structures)</p><p class="calibre23">databases, <a href="#filepos25757">Safari® Books Online</a> (see nonrelational databases; relational databases)</p><p class="calibre23">dataflow variables, <a href="#filepos610167">Promises</a></p><p class="calibre23">DataSource-based connection pooling, <a href="#filepos1776858">Connection Pooling</a></p><p class="calibre23">datatypes and protocols, <a href="#filepos945540">Datatypes and Protocols</a>, <a href="#filepos1073462">Final Thoughts</a>, <a href="#filepos948393">Protocols</a>, <a href="#filepos955640">Extending to Existing Types</a>, <a href="#filepos966265">Extending to Existing Types</a>, <a href="#filepos967842">Defining Your Own Types</a>, <a href="#filepos1002973">Types</a>, <a href="#filepos977716">Records</a>, <a href="#filepos995354">When to use maps or records</a>, <a href="#filepos995513">Types</a>, <a href="#filepos1002973">Types</a>, <a href="#filepos1008027">Implementing Protocols</a>, <a href="#filepos1034077">Reusing Implementations</a>, <a href="#filepos1011144">Inline Implementation</a>, <a href="#filepos1022991">Defining anonymous types with reify</a>, <a href="#filepos1023116">Reusing Implementations</a>, <a href="#filepos1034077">Reusing Implementations</a>, <a href="#filepos1036548">Protocol Introspection</a>, <a href="#filepos1039967">Protocol Dispatch Edge Cases</a>, <a href="#filepos1046890">Participating in Clojure’s Collection Abstractions</a>, <a href="#filepos1429380">Implementing Protocol Interfaces</a>, <a href="#filepos1520764">Limitations to Redefining Constructs</a></p><blockquote class="calibre35">about protocols, <a href="#filepos948393">Protocols</a></blockquote><blockquote class="calibre35">classes, <a href="#filepos1520764">Limitations to Redefining Constructs</a></blockquote><blockquote class="calibre35">collection abstractions, <a href="#filepos1046890">Participating in Clojure’s Collection Abstractions</a></blockquote><blockquote class="calibre35">defining your own types, <a href="#filepos967842">Defining Your Own Types</a>, <a href="#filepos1002973">Types</a>, <a href="#filepos977716">Records</a>, <a href="#filepos995354">When to use maps or records</a>, <a href="#filepos995513">Types</a>, <a href="#filepos1002973">Types</a></blockquote><blockquote class="calibre35">deftype, <a href="#filepos995513">Types</a>, <a href="#filepos1002973">Types</a></blockquote><blockquote class="calibre35">records, <a href="#filepos977716">Records</a>, <a href="#filepos995354">When to use maps or records</a></blockquote><blockquote class="calibre35">extending existing types, <a href="#filepos955640">Extending to Existing Types</a>, <a href="#filepos966265">Extending to Existing Types</a></blockquote><blockquote class="calibre35">implementing protocols, <a href="#filepos1008027">Implementing Protocols</a>, <a href="#filepos1034077">Reusing Implementations</a>, <a href="#filepos1011144">Inline Implementation</a>, <a href="#filepos1022991">Defining anonymous types with reify</a>, <a href="#filepos1023116">Reusing Implementations</a>, <a href="#filepos1034077">Reusing Implementations</a></blockquote><blockquote class="calibre35">inline, <a href="#filepos1011144">Inline Implementation</a>, <a href="#filepos1022991">Defining anonymous types with reify</a></blockquote><blockquote class="calibre35">reusing implementations, <a href="#filepos1023116">Reusing Implementations</a>, <a href="#filepos1034077">Reusing Implementations</a></blockquote><blockquote class="calibre35">protocol dispatch edge cases, <a href="#filepos1039967">Protocol Dispatch Edge Cases</a></blockquote><blockquote class="calibre35">protocol inspection, <a href="#filepos1036548">Protocol Introspection</a></blockquote><blockquote class="calibre35">using Clojure from Java, <a href="#filepos1429380">Implementing Protocol Interfaces</a></blockquote><p class="calibre23">debugging, <a href="#filepos857227">Debugging Macros</a>, <a href="#filepos1495518">SLIME</a>, <a href="#filepos1502842">Debugging, Monitoring, and Patching Production in the REPL</a>, <a href="#filepos1517456">Special Considerations for “Deployed” REPLs</a></p><blockquote class="calibre35">macros, <a href="#filepos857227">Debugging Macros</a></blockquote><blockquote class="calibre35">REPL, <a href="#filepos1502842">Debugging, Monitoring, and Patching Production in the REPL</a>, <a href="#filepos1517456">Special Considerations for “Deployed” REPLs</a></blockquote><blockquote class="calibre35">SLIME, <a href="#filepos1495518">SLIME</a></blockquote><p class="calibre23">dec, <a href="#filepos1545666">Clojure Has a Mixed Numerics Model</a></p><p class="calibre23">declarations, <a href="#filepos763173">Forward Declarations</a>, <a href="#filepos1327566">Type Hinting for Performance</a></p><blockquote class="calibre35">about, <a href="#filepos1327566">Type Hinting for Performance</a></blockquote><blockquote class="calibre35">forward declarations, <a href="#filepos763173">Forward Declarations</a></blockquote><p class="calibre23">declarative concurrency, <a href="#filepos610236">Promises</a></p><p class="calibre23">declare functions, <a href="#filepos1591947">Declare Functions to Take and Return Primitives</a>, <a href="#filepos1605145">Type errors and warnings</a></p><p class="calibre23">declare macro, <a href="#filepos764376">Forward Declarations</a></p><p class="calibre23">def, <a href="#filepos129097">Defining Vars: def</a>, <a href="#filepos1522796">Limitations to Redefining Constructs</a></p><p class="calibre23">defdb, <a href="#filepos1786693">Prelude</a></p><p class="calibre23">defining vars: def, <a href="#filepos129097">Defining Vars: def</a></p><p class="calibre23">defmethod, <a href="#filepos1075210">Multimethods Basics</a></p><p class="calibre23">defmulti, <a href="#filepos1079396">Multimethods Basics</a>, <a href="#filepos1522346">Limitations to Redefining Constructs</a></p><p class="calibre23">defn-, <a href="#filepos739570">Private vars</a></p><p class="calibre23">defonce, <a href="#filepos1448828">Interactive Development</a>, <a href="#filepos1522374">Limitations to Redefining Constructs</a>, <a href="#filepos1806975">Setup</a></p><p class="calibre23">defproject, <a href="#filepos1240730">Leiningen</a></p><p class="calibre23">defrecord, <a href="#filepos968325">Defining Your Own Types</a>, <a href="#filepos977813">Records</a>, <a href="#filepos1014403">Inline Implementation</a>, <a href="#filepos1363170">Defining Named Classes</a>, <a href="#filepos1520828">Limitations to Redefining Constructs</a></p><p class="calibre23">defroutes, <a href="#filepos1950133">Routing Requests with Compojure</a></p><p class="calibre23">defsnippet, <a href="#filepos1975057">Putting everything together</a>, <a href="#filepos1985957">Putting everything together</a></p><p class="calibre23">deftemplate, <a href="#filepos1978793">Putting everything together</a></p><p class="calibre23">deftype, <a href="#filepos968295">Defining Your Own Types</a>, <a href="#filepos995664">Types</a>, <a href="#filepos1014374">Inline Implementation</a>, <a href="#filepos1018566">Inline implementations of Java interfaces</a>, <a href="#filepos1346596">Defining Classes and Implementing Interfaces</a>, <a href="#filepos1363140">Defining Named Classes</a>, <a href="#filepos1520798">Limitations to Redefining Constructs</a></p><p class="calibre23">deftype class, <a href="#filepos1420153">Using deftype and defrecord Classes</a>, <a href="#filepos1429238">Using deftype and defrecord Classes</a></p><p class="calibre23">delays, <a href="#filepos596974">Shifting Computation Through Time and Space</a></p><p class="calibre23">dependencies, <a href="#filepos612543">Promises</a>, <a href="#filepos1164415">Namespaces and files</a>, <a href="#filepos1260691">Building mixed-source projects</a>, <a href="#filepos1759497">clojure.java.jdbc</a></p><blockquote class="calibre35">clojure.java.jdbc, <a href="#filepos1759497">clojure.java.jdbc</a></blockquote><blockquote class="calibre35">cyclic dependencies, <a href="#filepos612543">Promises</a></blockquote><blockquote class="calibre35">cyclic namespaces, <a href="#filepos1164415">Namespaces and files</a></blockquote><blockquote class="calibre35">interleaving source dependencies, <a href="#filepos1260691">Building mixed-source projects</a></blockquote><p class="calibre23">dependency injection, <a href="#filepos1662678">Dependency Injection</a>, <a href="#filepos1670481">Dependency Injection</a></p><p class="calibre23">dependency management, <a href="#filepos1205824">Dependency Management</a>, <a href="#filepos1228241">Dependencies</a>, <a href="#filepos1208359">Artifacts and coordinates</a>, <a href="#filepos1213484">Repositories</a>, <a href="#filepos1216111">Dependencies</a></p><blockquote class="calibre35">artifacts and coordinates, <a href="#filepos1208359">Artifacts and coordinates</a></blockquote><blockquote class="calibre35">dependencies, <a href="#filepos1216111">Dependencies</a></blockquote><blockquote class="calibre35">repositories, <a href="#filepos1213484">Repositories</a></blockquote><p class="calibre23">deployment, <a href="#filepos1213749">Repositories</a></p><p class="calibre23">deref, <a href="#filepos597559">Delays</a>, <a href="#filepos605116">Futures</a>, <a href="#filepos637839">Clojure Reference Types</a>, <a href="#filepos719008">Readers may retry</a></p><p class="calibre23">derive, <a href="#filepos1100202">Independent Hierarchies</a></p><p class="calibre23">deserialization, <a href="#filepos77787">The Reader</a></p><p class="calibre23">design patterns, <a href="#filepos1656409">Design Patterns</a>, <a href="#filepos1695922">Final Thoughts</a>, <a href="#filepos1662678">Dependency Injection</a>, <a href="#filepos1670481">Dependency Injection</a>, <a href="#filepos1672022">Strategy Pattern</a>, <a href="#filepos1675057">Chain of Responsibility</a>, <a href="#filepos1682600">Chain of Responsibility</a>, <a href="#filepos1682715">Aspect-Oriented Programming</a>, <a href="#filepos1694934">Aspect-Oriented Programming</a></p><blockquote class="calibre35">AOP, <a href="#filepos1682715">Aspect-Oriented Programming</a>, <a href="#filepos1694934">Aspect-Oriented Programming</a></blockquote><blockquote class="calibre35">chain of responsibility, <a href="#filepos1675057">Chain of Responsibility</a>, <a href="#filepos1682600">Chain of Responsibility</a></blockquote><blockquote class="calibre35">dependency injection, <a href="#filepos1662678">Dependency Injection</a>, <a href="#filepos1670481">Dependency Injection</a></blockquote><blockquote class="calibre35">strategy pattern, <a href="#filepos1672022">Strategy Pattern</a></blockquote><p class="calibre23">destructuring, <a href="#filepos137200">Local Bindings: let</a>, <a href="#filepos137360">Destructuring (let, Part 2)</a>, <a href="#filepos161384">Map destructuring</a>, <a href="#filepos141549">Sequential destructuring</a>, <a href="#filepos148722">Sequential destructuring</a>, <a href="#filepos149075">Map destructuring</a>, <a href="#filepos161384">Map destructuring</a>, <a href="#filepos169123">Destructuring function arguments</a>, <a href="#filepos176625">Destructuring function arguments</a></p><blockquote class="calibre35">collection types, <a href="#filepos137200">Local Bindings: let</a></blockquote><blockquote class="calibre35">function arguments, <a href="#filepos169123">Destructuring function arguments</a>, <a href="#filepos176625">Destructuring function arguments</a></blockquote><blockquote class="calibre35">map destructuring, <a href="#filepos149075">Map destructuring</a>, <a href="#filepos161384">Map destructuring</a></blockquote><blockquote class="calibre35">sequential, <a href="#filepos141549">Sequential destructuring</a>, <a href="#filepos148722">Sequential destructuring</a></blockquote><p class="calibre23">dfrecord classes, <a href="#filepos1420153">Using deftype and defrecord Classes</a>, <a href="#filepos1429238">Using deftype and defrecord Classes</a></p><p class="calibre23">Digital Subscriber Line (DSL) versus Korma, <a href="#filepos1791203">Why Bother with a DSL?</a></p><p class="calibre23">disjunctions, <a href="#filepos1965894">Selectors</a></p><p class="calibre23">dispatch function, <a href="#filepos1076856">Multimethods Basics</a>, <a href="#filepos1087845">Toward Hierarchies</a>, <a href="#filepos1112633">Making It Really Multiple!</a>, <a href="#filepos1127131">The Range of Dispatch Functions Is Unlimited</a></p><blockquote class="calibre35">about, <a href="#filepos1076856">Multimethods Basics</a></blockquote><blockquote class="calibre35">multimethods, <a href="#filepos1087845">Toward Hierarchies</a>, <a href="#filepos1127131">The Range of Dispatch Functions Is Unlimited</a></blockquote><blockquote class="calibre35">multiple, <a href="#filepos1112633">Making It Really Multiple!</a></blockquote><p class="calibre23">dissoc, <a href="#filepos389963">Associative</a>, <a href="#filepos984698">Records</a></p><p class="calibre23">do expressions, implicit, <a href="#filepos127844">Code Blocks: do</a></p><p class="calibre23">do forms, implicit, <a href="#filepos178170">Function literals</a></p><p class="calibre23">do-&gt;, <a href="#filepos1973697">Iterating and branching</a></p><p class="calibre23">do: code blocks, <a href="#filepos127037">Code Blocks: do</a></p><p class="calibre23">doall, <a href="#filepos380262">Lazy seqs</a>, <a href="#filepos626736">Parallelism on the Cheap</a>, <a href="#filepos1770420">with-query-results Explained</a></p><p class="calibre23">doc, <a href="#filepos1464185">The Bare REPL</a></p><p class="calibre23">docstrings, <a href="#filepos739786">Docstrings</a></p><p class="calibre23">dorun, <a href="#filepos380468">Lazy seqs</a>, <a href="#filepos622257">Parallelism on the Cheap</a></p><p class="calibre23">doseq, <a href="#filepos361809">Sequences are not iterators</a></p><p class="calibre23">dosync, <a href="#filepos676907">The Mechanics of Ref Change</a>, <a href="#filepos710604">Side-effecting functions strictly verboten</a></p><p class="calibre23">doto, <a href="#filepos1301451">Handy Interop Utilities</a>, <a href="#filepos1303266">Handy Interop Utilities</a></p><p class="calibre23">double, <a href="#filepos1553043">The Rules of Numeric Contagion</a></p><p class="calibre23">Double box class, <a href="#filepos1540802">Clojure Has a Mixed Numerics Model</a></p><p class="calibre23">double evaluation, macros, <a href="#filepos896618">Double Evaluation</a></p><p class="calibre23">downloading Clojure, <a href="#filepos34188">Obtaining Clojure</a></p><p class="calibre23">DSL (Digital Subscriber Line) versus Korma, <a href="#filepos1791203">Why Bother with a DSL?</a></p><p class="calibre23">dynamic expression problem, <a href="#filepos947522">Datatypes and Protocols</a></p><p class="calibre23">dynamic redefinition, <a href="#filepos1452745">The Persistent, Evolving Environment</a></p><p class="calibre23">dynamic scope, <a href="#filepos744661">Dynamic Scope</a>, <a href="#filepos759026">Dynamic Scope</a>, <a href="#filepos749235">Dynamic Scope</a>, <a href="#filepos757451">Dynamic Scope</a></p><blockquote class="calibre35">concurrency forms, <a href="#filepos757451">Dynamic Scope</a></blockquote><blockquote class="calibre35">visualizing, <a href="#filepos749235">Dynamic Scope</a></blockquote><div class="mbppagebreak"></div><p class="calibre23"><span class="calibre53"><span class="bold">E</span></span></p><p class="calibre46">each, <a href="#filepos1721865">Fixtures</a></p><p class="calibre23">earmuffs, <a href="#filepos747747">Dynamic Scope</a></p><p class="calibre23">EB (Elastic Beanstalk), <a href="#filepos2027807">Deploying Clojure Apps to Amazon’s Elastic Beanstalk</a>, <a href="#filepos2036963">Deploying Clojure Apps to Amazon’s Elastic Beanstalk</a></p><p class="calibre23">Eclipse, <a href="#filepos1470200">Eclipse</a>, <a href="#filepos1474291">Eclipse</a></p><p class="calibre23">editing, <a href="#filepos1468533">Introspecting namespaces</a>, <a href="#filepos1471104">Eclipse</a></p><blockquote class="calibre35">Clojure editing support, <a href="#filepos1471104">Eclipse</a></blockquote><blockquote class="calibre35">source code, <a href="#filepos1468533">Introspecting namespaces</a></blockquote><p class="calibre23">efficiency, <a href="#filepos25757">Safari® Books Online</a> (see performance)</p><p class="calibre23">Emacs, <a href="#filepos1474397">Emacs</a>, <a href="#filepos1497148">SLIME</a>, <a href="#filepos1479345">clojure-mode and paredit</a>, <a href="#filepos1480619">inferior-lisp</a>, <a href="#filepos1486481">SLIME</a></p><blockquote class="calibre35">clojure-mode and paredit, <a href="#filepos1479345">clojure-mode and paredit</a></blockquote><blockquote class="calibre35">inferior-lisp, <a href="#filepos1480619">inferior-lisp</a></blockquote><blockquote class="calibre35">SLIME, <a href="#filepos1486481">SLIME</a></blockquote><p class="calibre23">empty, <a href="#filepos350096">Collection</a></p><p class="calibre23">Enlive, <a href="#filepos1959065">Enlive: Selector-Based HTML Transformation</a>, <a href="#filepos1986527">Putting everything together</a>, <a href="#filepos1960318">Testing the waters</a>, <a href="#filepos1964781">Selectors</a>, <a href="#filepos1969832">Iterating and branching</a>, <a href="#filepos1974706">Putting everything together</a></p><blockquote class="calibre35">about, <a href="#filepos1960318">Testing the waters</a></blockquote><blockquote class="calibre35">iterating and branching, <a href="#filepos1969832">Iterating and branching</a></blockquote><blockquote class="calibre35">selectors, <a href="#filepos1964781">Selectors</a></blockquote><blockquote class="calibre35">using, <a href="#filepos1974706">Putting everything together</a></blockquote><p class="calibre23">ensure, <a href="#filepos729109">Write skew</a></p><p class="calibre23">environments, <a href="#filepos2036390">Deploying Clojure Apps to Amazon’s Elastic Beanstalk</a></p><p class="calibre23">equality and equivalence, <a href="#filepos1576052">Equality and Equivalence</a>, <a href="#filepos1586809">Equivalence can preserve your sanity</a>, <a href="#filepos1576325">Object Identity (identical?)</a>, <a href="#filepos1578440">Reference Equality (=)</a>, <a href="#filepos1581350">Numeric Equivalence (==)</a></p><blockquote class="calibre35">numeric equivalence, <a href="#filepos1581350">Numeric Equivalence (==)</a></blockquote><blockquote class="calibre35">object identity, <a href="#filepos1576325">Object Identity (identical?)</a></blockquote><blockquote class="calibre35">reference equality, <a href="#filepos1578440">Reference Equality (=)</a></blockquote><p class="calibre23">equals, <a href="#filepos1018158">Inline implementations of Java interfaces</a></p><p class="calibre23">ERB templates, <a href="#filepos1956223">Templating</a>, <a href="#filepos1979220">Putting everything together</a></p><blockquote class="calibre35">templating language, <a href="#filepos1956223">Templating</a></blockquote><blockquote class="calibre35">using, <a href="#filepos1979220">Putting everything together</a></blockquote><p class="calibre23">error handling, <a href="#filepos779236">Dealing with Errors in Agent Actions</a>, <a href="#filepos783650">Dealing with Errors in Agent Actions</a>, <a href="#filepos848091">Macros Versus Ruby eval</a>, <a href="#filepos914441">Producing useful macro error messages</a>, <a href="#filepos1306265">Exceptions and Error Handling</a>, <a href="#filepos1320088">with-open, finally’s Lament</a></p><blockquote class="calibre35">agents, <a href="#filepos779236">Dealing with Errors in Agent Actions</a>, <a href="#filepos783650">Dealing with Errors in Agent Actions</a></blockquote><blockquote class="calibre35">Java, <a href="#filepos1306265">Exceptions and Error Handling</a>, <a href="#filepos1320088">with-open, finally’s Lament</a></blockquote><blockquote class="calibre35">macros, <a href="#filepos848091">Macros Versus Ruby eval</a>, <a href="#filepos914441">Producing useful macro error messages</a></blockquote><p class="calibre23">escape hatch, <a href="#filepos1297231">Using Java Classes, Methods, and Fields</a></p><p class="calibre23">escaping checked exceptions, <a href="#filepos1313395">Escaping Checked Exceptions</a></p><p class="calibre23">eval, <a href="#filepos208670">eval</a>, <a href="#filepos846428">Macros Versus Ruby eval</a></p><blockquote class="calibre35">about, <a href="#filepos208670">eval</a></blockquote><blockquote class="calibre35">Ruby eval versus Clojure macros, <a href="#filepos846428">Macros Versus Ruby eval</a></blockquote><p class="calibre23">Evaluate, <a href="#filepos110360">Namespaces</a></p><p class="calibre23">evaluating, <a href="#filepos118585">Symbol Evaluation</a>, <a href="#filepos123985">Suppressing Evaluation: quote</a></p><blockquote class="calibre35">suppressing: quote, <a href="#filepos123985">Suppressing Evaluation: quote</a></blockquote><blockquote class="calibre35">symbols, <a href="#filepos118585">Symbol Evaluation</a></blockquote><p class="calibre23">event types, hierarchies, <a href="#filepos1847496">Views in Clojure</a></p><p class="calibre23">exceptions, <a href="#filepos196966">Exception Handling: try and throw</a>, <a href="#filepos779323">Dealing with Errors in Agent Actions</a>, <a href="#filepos1306265">Exceptions and Error Handling</a>, <a href="#filepos1320088">with-open, finally’s Lament</a>, <a href="#filepos1310727">Exceptions and Error Handling</a>, <a href="#filepos1311766">Exceptions and Error Handling</a>, <a href="#filepos1375287">gen-class</a></p><blockquote class="calibre35">agents, <a href="#filepos779323">Dealing with Errors in Agent Actions</a></blockquote><blockquote class="calibre35">Java, <a href="#filepos1306265">Exceptions and Error Handling</a>, <a href="#filepos1320088">with-open, finally’s Lament</a></blockquote><blockquote class="calibre35">throwing, <a href="#filepos1310727">Exceptions and Error Handling</a></blockquote><blockquote class="calibre35">try and throw, <a href="#filepos196966">Exception Handling: try and throw</a></blockquote><blockquote class="calibre35">types, <a href="#filepos1311766">Exceptions and Error Handling</a>, <a href="#filepos1375287">gen-class</a></blockquote><blockquote class="calibre35">custom, <a href="#filepos1375287">gen-class</a></blockquote><blockquote class="calibre35">reusing, <a href="#filepos1311766">Exceptions and Error Handling</a></blockquote><p class="calibre23">exclamation mark (!), <a href="#filepos504376">Transients</a></p><p class="calibre23">expanding macros, <a href="#filepos859097">Macroexpansion</a></p><p class="calibre23">expression problem, <a href="#filepos946641">Datatypes and Protocols</a></p><p class="calibre23">expressions, <a href="#filepos53434">Expressions, Operators, Syntax, and Precedence</a>, <a href="#filepos95003">Regular expressions</a>, <a href="#filepos127077">Code Blocks: do</a>, <a href="#filepos225354">About Values</a></p><blockquote class="calibre35">about, <a href="#filepos53434">Expressions, Operators, Syntax, and Precedence</a></blockquote><blockquote class="calibre35">code blocks, <a href="#filepos127077">Code Blocks: do</a></blockquote><blockquote class="calibre35">regular expressions, <a href="#filepos95003">Regular expressions</a></blockquote><blockquote class="calibre35">values, <a href="#filepos225354">About Values</a></blockquote><p class="calibre23">extend, <a href="#filepos1023954">Reusing Implementations</a></p><p class="calibre23">extend-protocol, <a href="#filepos956613">Extending to Existing Types</a></p><p class="calibre23">extend-type, <a href="#filepos958518">Extending to Existing Types</a>, <a href="#filepos1014015">Inline Implementation</a></p><p class="calibre23">extenders, <a href="#filepos1037019">Protocol Introspection</a></p><p class="calibre23">extends?, <a href="#filepos1037836">Protocol Introspection</a></p><p class="calibre23">extensibility, Emacs, <a href="#filepos1487190">SLIME</a></p><p class="calibre23">extra-positional sequential values, <a href="#filepos146974">Sequential destructuring</a></p><div class="mbppagebreak"></div><p class="calibre23"><span class="calibre53"><span class="bold">F</span></span></p><p class="calibre46">factory functions, <a href="#filepos960610">Extending to Existing Types</a>, <a href="#filepos988529">Constructors and factory functions</a></p><blockquote class="calibre35">constructors, <a href="#filepos988529">Constructors and factory functions</a></blockquote><blockquote class="calibre35">protocols and vectors, <a href="#filepos960610">Extending to Existing Types</a></blockquote><p class="calibre23">failed agents, <a href="#filepos780416">Dealing with Errors in Agent Actions</a></p><p class="calibre23">fallbacks, <a href="#filepos717125">Minimize the scope of each transaction</a></p><p class="calibre23">false, <a href="#filepos446184">Collections and Keys and Higher-Order Functions</a></p><p class="calibre23">false values, <a href="#filepos399336">Beware of nil values</a></p><p class="calibre23">false?, <a href="#filepos184032">Conditionals: if</a></p><p class="calibre23">fields, <a href="#filepos997157">Types</a>, <a href="#filepos998525">Types</a>, <a href="#filepos1282546">Using Java Classes, Methods, and Fields</a>, <a href="#filepos1298190">Using Java Classes, Methods, and Fields</a>, <a href="#filepos1296116">Using Java Classes, Methods, and Fields</a></p><blockquote class="calibre35">immutable fields, <a href="#filepos998525">Types</a></blockquote><blockquote class="calibre35">Java, <a href="#filepos1282546">Using Java Classes, Methods, and Fields</a>, <a href="#filepos1298190">Using Java Classes, Methods, and Fields</a></blockquote><blockquote class="calibre35">mutable fields, <a href="#filepos997157">Types</a></blockquote><blockquote class="calibre35">object fields, <a href="#filepos1296116">Using Java Classes, Methods, and Fields</a></blockquote><p class="calibre23">files, namespaces, <a href="#filepos1161037">Namespaces and files</a>, <a href="#filepos1168518">Namespaces and files</a></p><p class="calibre23">fill-dispatch, <a href="#filepos1099770">Independent Hierarchies</a></p><p class="calibre23">filter, <a href="#filepos444519">Collections and Keys and Higher-Order Functions</a></p><p class="calibre23">filter functions, <a href="#filepos1862153">_changes: Abusing CouchDB as a Message Queue</a></p><p class="calibre23">finally, <a href="#filepos1309780">Exceptions and Error Handling</a>, <a href="#filepos1315295">with-open, finally’s Lament</a></p><p class="calibre23">find, <a href="#filepos397957">Beware of nil values</a></p><p class="calibre23">find-doc, <a href="#filepos1463250">The Bare REPL</a></p><p class="calibre23">fire-and-forget persistence mechanism, <a href="#filepos798550">Persisting reference states with an agent-based write-behind log</a></p><p class="calibre23">first-class functions, <a href="#filepos250337">First-Class and Higher-Order Functions</a>, <a href="#filepos279583">Applying Ourselves Partially</a></p><p class="calibre23">fixnums, <a href="#filepos1577339">Object Identity (identical?)</a></p><p class="calibre23">fixtures, <a href="#filepos1720614">Fixtures</a></p><p class="calibre23">flow, <a href="#filepos1454349">The Persistent, Evolving Environment</a></p><p class="calibre23">fn, <a href="#filepos161507">Creating Functions: fn</a>, <a href="#filepos181349">Function literals</a>, <a href="#filepos1750770">Preconditions and Postconditions</a></p><p class="calibre23">for, <a href="#filepos352581">Collection</a></p><p class="calibre23">form-level comments, <a href="#filepos97663">Comments</a></p><p class="calibre23">forms, <a href="#filepos98802">Comments</a>, <a href="#filepos99707">Comments</a>, <a href="#filepos121582">Special Forms</a>, <a href="#filepos757451">Dynamic Scope</a>, <a href="#filepos863117">Macroexpansion</a>, <a href="#filepos2042973">Choosing Clojure Type Definition Forms Wisely</a></p><blockquote class="calibre35">(see also special forms)</blockquote><blockquote class="calibre35">comment forms, <a href="#filepos99707">Comments</a></blockquote><blockquote class="calibre35">concurrency forms, <a href="#filepos757451">Dynamic Scope</a></blockquote><blockquote class="calibre35">expanding nested forms, <a href="#filepos863117">Macroexpansion</a></blockquote><blockquote class="calibre35">println forms, <a href="#filepos98802">Comments</a></blockquote><blockquote class="calibre35">type definition forms, <a href="#filepos2042973">Choosing Clojure Type Definition Forms Wisely</a></blockquote><p class="calibre23">forward declarations, <a href="#filepos763173">Forward Declarations</a></p><p class="calibre23">FP (functional programming), <a href="#filepos215769">Functional Programming</a>, <a href="#filepos335770">Functional Programming in the Real World</a>, <a href="#filepos218479">What Does Functional Programming Mean?</a>, <a href="#filepos221936">On the Importance of Values</a>, <a href="#filepos245012">A Critical Choice</a>, <a href="#filepos224594">About Values</a>, <a href="#filepos226281">Comparing Values to Mutable Objects</a>, <a href="#filepos240312">Comparing Values to Mutable Objects</a>, <a href="#filepos240430">A Critical Choice</a>, <a href="#filepos250337">First-Class and Higher-Order Functions</a>, <a href="#filepos279583">Applying Ourselves Partially</a>, <a href="#filepos284407">Composition of Function(ality)</a>, <a href="#filepos311125">Building a Primitive Logging System with Composable Higher-Order Functions</a>, <a href="#filepos294195">Writing Higher-Order Functions</a>, <a href="#filepos296247">Building a Primitive Logging System with Composable Higher-Order Functions</a>, <a href="#filepos311125">Building a Primitive Logging System with Composable Higher-Order Functions</a>, <a href="#filepos316752">Pure Functions</a></p><blockquote class="calibre35">about, <a href="#filepos218479">What Does Functional Programming Mean?</a></blockquote><blockquote class="calibre35">compositionality, <a href="#filepos284407">Composition of Function(ality)</a>, <a href="#filepos311125">Building a Primitive Logging System with Composable Higher-Order Functions</a>, <a href="#filepos294195">Writing Higher-Order Functions</a>, <a href="#filepos296247">Building a Primitive Logging System with Composable Higher-Order Functions</a>, <a href="#filepos311125">Building a Primitive Logging System with Composable Higher-Order Functions</a></blockquote><blockquote class="calibre35">building a primitive logging system, <a href="#filepos296247">Building a Primitive Logging System with Composable Higher-Order Functions</a>, <a href="#filepos311125">Building a Primitive Logging System with Composable Higher-Order Functions</a></blockquote><blockquote class="calibre35">higher-order functions, <a href="#filepos294195">Writing Higher-Order Functions</a></blockquote><blockquote class="calibre35">first-class and higher-order functions, <a href="#filepos250337">First-Class and Higher-Order Functions</a>, <a href="#filepos279583">Applying Ourselves Partially</a></blockquote><blockquote class="calibre35">pure functions, <a href="#filepos316752">Pure Functions</a></blockquote><blockquote class="calibre35">values, <a href="#filepos221936">On the Importance of Values</a>, <a href="#filepos245012">A Critical Choice</a>, <a href="#filepos224594">About Values</a>, <a href="#filepos226281">Comparing Values to Mutable Objects</a>, <a href="#filepos240312">Comparing Values to Mutable Objects</a>, <a href="#filepos240430">A Critical Choice</a></blockquote><blockquote class="calibre35">about, <a href="#filepos224594">About Values</a></blockquote><blockquote class="calibre35">comparing to mutable objects, <a href="#filepos226281">Comparing Values to Mutable Objects</a>, <a href="#filepos240312">Comparing Values to Mutable Objects</a></blockquote><blockquote class="calibre35">unfettered object state, <a href="#filepos240430">A Critical Choice</a></blockquote><p class="calibre23">frequencies, <a href="#filepos1607079">Use Primitive Arrays Judiciously</a></p><p class="calibre23">function application, <a href="#filepos268181">Applying Ourselves Partially</a>, <a href="#filepos279583">Applying Ourselves Partially</a></p><p class="calibre23">function composition, <a href="#filepos285932">Composition of Function(ality)</a></p><p class="calibre23">function literals, <a href="#filepos265212">First-Class and Higher-Order Functions</a>, <a href="#filepos275425">Applying Ourselves Partially</a></p><blockquote class="calibre35">versus anonymous functions, <a href="#filepos265212">First-Class and Higher-Order Functions</a></blockquote><blockquote class="calibre35">versus partial literals, <a href="#filepos275425">Applying Ourselves Partially</a></blockquote><p class="calibre23">functions, <a href="#filepos121663">Special Forms</a>, <a href="#filepos139417">Destructuring (let, Part 2)</a>, <a href="#filepos147291">Sequential destructuring</a>, <a href="#filepos161507">Creating Functions: fn</a>, <a href="#filepos181349">Function literals</a>, <a href="#filepos163728">Creating Functions: fn</a>, <a href="#filepos164260">Creating Functions: fn</a>, <a href="#filepos165731">Creating Functions: fn</a>, <a href="#filepos168257">Creating Functions: fn</a>, <a href="#filepos169592">Destructuring function arguments</a>, <a href="#filepos178935">Function literals</a>, <a href="#filepos180580">Function literals</a>, <a href="#filepos215769">Functional Programming</a>, <a href="#filepos233404">Comparing Values to Mutable Objects</a>, <a href="#filepos250337">First-Class and Higher-Order Functions</a>, <a href="#filepos279583">Applying Ourselves Partially</a>, <a href="#filepos254608">First-Class and Higher-Order Functions</a>, <a href="#filepos265212">First-Class and Higher-Order Functions</a>, <a href="#filepos321373">Pure Functions</a>, <a href="#filepos321756">Pure Functions</a>, <a href="#filepos328183">Why Are Pure Functions Interesting?</a>, <a href="#filepos359583">Sequences</a>, <a href="#filepos438683">Concise Collection Access</a>, <a href="#filepos440352">Concise Collection Access</a>, <a href="#filepos443341">Collections and Keys and Higher-Order Functions</a>, <a href="#filepos527718">Revisiting a classic: Conway’s Game of Life</a>, <a href="#filepos751776">Dynamic Scope</a>, <a href="#filepos841003">What Can Macros Do that Functions Cannot?</a>, <a href="#filepos951095">Protocols</a>, <a href="#filepos960610">Extending to Existing Types</a>, <a href="#filepos988529">Constructors and factory functions</a>, <a href="#filepos994135">When to use maps or records</a>, <a href="#filepos1591947">Declare Functions to Take and Return Primitives</a>, <a href="#filepos1605145">Type errors and warnings</a>, <a href="#filepos1598648">Declare Functions to Take and Return Primitives</a>, <a href="#filepos1603947">Type errors and warnings</a>, <a href="#filepos1697043">Immutable Values and Pure Functions</a>, <a href="#filepos1862153">_changes: Abusing CouchDB as a Message Queue</a></p><blockquote class="calibre35">(see also FP)</blockquote><blockquote class="calibre35">anonymous functions versus function literals, <a href="#filepos265212">First-Class and Higher-Order Functions</a></blockquote><blockquote class="calibre35">arithmetic functions, <a href="#filepos321756">Pure Functions</a></blockquote><blockquote class="calibre35">arity, <a href="#filepos178935">Function literals</a></blockquote><blockquote class="calibre35">coercion functions, <a href="#filepos1603947">Type errors and warnings</a></blockquote><blockquote class="calibre35">collections and, <a href="#filepos438683">Concise Collection Access</a></blockquote><blockquote class="calibre35">collections keys, <a href="#filepos440352">Concise Collection Access</a></blockquote><blockquote class="calibre35">constructors and factory functions, <a href="#filepos988529">Constructors and factory functions</a></blockquote><blockquote class="calibre35">creating functions: fn, <a href="#filepos161507">Creating Functions: fn</a>, <a href="#filepos181349">Function literals</a></blockquote><blockquote class="calibre35">declare functions, <a href="#filepos1591947">Declare Functions to Take and Return Primitives</a>, <a href="#filepos1605145">Type errors and warnings</a></blockquote><blockquote class="calibre35">dynamic scope, <a href="#filepos751776">Dynamic Scope</a></blockquote><blockquote class="calibre35">factory functions, <a href="#filepos960610">Extending to Existing Types</a></blockquote><blockquote class="calibre35">filter functions, <a href="#filepos1862153">_changes: Abusing CouchDB as a Message Queue</a></blockquote><blockquote class="calibre35">first class and higher order functions, <a href="#filepos250337">First-Class and Higher-Order Functions</a>, <a href="#filepos279583">Applying Ourselves Partially</a></blockquote><blockquote class="calibre35">first class values, <a href="#filepos254608">First-Class and Higher-Order Functions</a></blockquote><blockquote class="calibre35">indexed-step functions, <a href="#filepos527718">Revisiting a classic: Conway’s Game of Life</a></blockquote><blockquote class="calibre35">keys and collections, <a href="#filepos443341">Collections and Keys and Higher-Order Functions</a></blockquote><blockquote class="calibre35">multiple arguments, <a href="#filepos163728">Creating Functions: fn</a></blockquote><blockquote class="calibre35">multiple arities, <a href="#filepos164260">Creating Functions: fn</a></blockquote><blockquote class="calibre35">mutable arguments, <a href="#filepos233404">Comparing Values to Mutable Objects</a></blockquote><blockquote class="calibre35">mutually recursive, <a href="#filepos165731">Creating Functions: fn</a></blockquote><blockquote class="calibre35">nesting literals, <a href="#filepos180580">Function literals</a></blockquote><blockquote class="calibre35">primitive types, <a href="#filepos1598648">Declare Functions to Take and Return Primitives</a></blockquote><blockquote class="calibre35">protocols, <a href="#filepos951095">Protocols</a></blockquote><blockquote class="calibre35">pure functions, <a href="#filepos321373">Pure Functions</a></blockquote><blockquote class="calibre35">rest arguments, <a href="#filepos147291">Sequential destructuring</a></blockquote><blockquote class="calibre35">sequential collections, <a href="#filepos139417">Destructuring (let, Part 2)</a></blockquote><blockquote class="calibre35">side-effecting functions, <a href="#filepos328183">Why Are Pure Functions Interesting?</a></blockquote><blockquote class="calibre35">single-arity functions, <a href="#filepos168257">Creating Functions: fn</a></blockquote><blockquote class="calibre35">symbols, <a href="#filepos121663">Special Forms</a></blockquote><blockquote class="calibre35">testing, <a href="#filepos1697043">Immutable Values and Pure Functions</a></blockquote><blockquote class="calibre35">variadic functions, <a href="#filepos169592">Destructuring function arguments</a>, <a href="#filepos359583">Sequences</a></blockquote><blockquote class="calibre35">versus macros, <a href="#filepos841003">What Can Macros Do that Functions Cannot?</a></blockquote><blockquote class="calibre35">versus records, <a href="#filepos994135">When to use maps or records</a></blockquote><p class="calibre23">Futon, <a href="#filepos1837156">A Simple (JavaScript) View</a></p><p class="calibre23">future, <a href="#filepos603422">Futures</a>, <a href="#filepos2070211">What’s Next?</a>, <a href="#filepos2088364">Clojure on Heroku</a>, <a href="#filepos2071713">ClojureCLR</a>, <a href="#filepos2072421">ClojureScript</a>, <a href="#filepos2076334">4Clojure</a>, <a href="#filepos2077260">Overtone</a>, <a href="#filepos2079405">core.logic</a>, <a href="#filepos2084054">Pallet</a>, <a href="#filepos2085890">Avout</a>, <a href="#filepos2086921">Clojure on Heroku</a></p><blockquote class="calibre35">4Clojure, <a href="#filepos2076334">4Clojure</a></blockquote><blockquote class="calibre35">about, <a href="#filepos603422">Futures</a></blockquote><blockquote class="calibre35">Avout, <a href="#filepos2085890">Avout</a></blockquote><blockquote class="calibre35">ClojureCLR, <a href="#filepos2071713">ClojureCLR</a></blockquote><blockquote class="calibre35">ClojureScript, <a href="#filepos2072421">ClojureScript</a></blockquote><blockquote class="calibre35">core.logic, <a href="#filepos2079405">core.logic</a></blockquote><blockquote class="calibre35">Heroku, <a href="#filepos2086921">Clojure on Heroku</a></blockquote><blockquote class="calibre35">Overtone, <a href="#filepos2077260">Overtone</a></blockquote><blockquote class="calibre35">Pallet, <a href="#filepos2084054">Pallet</a></blockquote><div class="mbppagebreak"></div><p class="calibre23"><span class="calibre53"><span class="bold">G</span></span></p><p class="calibre46">Game of Life, <a href="#filepos538102">Revisiting a classic: Conway’s Game of Life</a></p><p class="calibre23">games, <a href="#filepos673478">The Mechanics of Ref Change</a>, <a href="#filepos790335">Persisting reference states with an agent-based write-behind log</a></p><blockquote class="calibre35">concurrency-ref-mechanics, <a href="#filepos790335">Persisting reference states with an agent-based write-behind log</a></blockquote><blockquote class="calibre35">ref change, <a href="#filepos673478">The Mechanics of Ref Change</a></blockquote><p class="calibre23">gen-class, <a href="#filepos1346596">Defining Classes and Implementing Interfaces</a>, <a href="#filepos1364263">Defining Named Classes</a>, <a href="#filepos1364753">gen-class</a>, <a href="#filepos1389137">gen-class</a>, <a href="#filepos1520173">Limitations to Redefining Constructs</a></p><p class="calibre23">gensyms, macros, <a href="#filepos886008">Gensyms to the Rescue</a></p><p class="calibre23">get, <a href="#filepos392332">Associative</a>, <a href="#filepos396605">Beware of nil values</a>, <a href="#filepos400893">Indexed</a></p><p class="calibre23">GET, <a href="#filepos1920367">Routing Requests with Compojure</a></p><p class="calibre23">group-by, <a href="#filepos463182">Other usages of maps</a></p><p class="calibre23">groupId, <a href="#filepos1211562">Artifacts and coordinates</a></p><div class="mbppagebreak"></div><p class="calibre23"><span class="calibre53"><span class="bold">H</span></span></p><p class="calibre46">handlers, Ring, <a href="#filepos1905874">Handlers</a></p><p class="calibre23">handling exceptions: try and throw, <a href="#filepos196966">Exception Handling: try and throw</a></p><p class="calibre23">hash-map, <a href="#filepos458594">Maps</a></p><p class="calibre23">hash-set, <a href="#filepos456442">Sets</a></p><p class="calibre23">hashmaps, <a href="#filepos83197">Keywords</a></p><p class="calibre23">head retention, <a href="#filepos385300">Head retention</a></p><p class="calibre23">Heroku, <a href="#filepos2086921">Clojure on Heroku</a></p><p class="calibre23">heterogeneous arguments, <a href="#filepos1550401">The Rules of Numeric Contagion</a></p><p class="calibre23">hexadecimal notation, <a href="#filepos92825">Numbers</a></p><p class="calibre23">Hibernate, <a href="#filepos1798872">Hibernate</a>, <a href="#filepos1817703">Removing Boilerplate</a>, <a href="#filepos1799675">Setup</a>, <a href="#filepos1807471">Setup</a>, <a href="#filepos1807587">Persisting Data</a>, <a href="#filepos1809160">Running Queries</a>, <a href="#filepos1811426">Removing Boilerplate</a></p><blockquote class="calibre35">boilerplate, <a href="#filepos1811426">Removing Boilerplate</a></blockquote><blockquote class="calibre35">persisting data, <a href="#filepos1807587">Persisting Data</a></blockquote><blockquote class="calibre35">queries, <a href="#filepos1809160">Running Queries</a></blockquote><blockquote class="calibre35">setup, <a href="#filepos1799675">Setup</a>, <a href="#filepos1807471">Setup</a></blockquote><p class="calibre23">Hiccup, <a href="#filepos1733280">Growing an HTML DSL</a></p><p class="calibre23">hierarchies, <a href="#filepos1041445">Protocol Dispatch Edge Cases</a>, <a href="#filepos1084712">Toward Hierarchies</a>, <a href="#filepos1109941">Independent Hierarchies</a>, <a href="#filepos1847496">Views in Clojure</a></p><blockquote class="calibre35">classes, <a href="#filepos1041445">Protocol Dispatch Edge Cases</a></blockquote><blockquote class="calibre35">event types, <a href="#filepos1847496">Views in Clojure</a></blockquote><p class="calibre23">higher-order functions, <a href="#filepos250337">First-Class and Higher-Order Functions</a>, <a href="#filepos279583">Applying Ourselves Partially</a></p><p class="calibre23">hints, <a href="#filepos921642">Preserving user-provided type hints</a>, <a href="#filepos927698">Preserving user-provided type hints</a>, <a href="#filepos1616809">The mechanics of primitive arrays</a>, <a href="#filepos1623519">Automating type hinting of multidimensional array operations</a></p><blockquote class="calibre35">arrays, <a href="#filepos1616809">The mechanics of primitive arrays</a></blockquote><blockquote class="calibre35">type hints, <a href="#filepos921642">Preserving user-provided type hints</a>, <a href="#filepos927698">Preserving user-provided type hints</a>, <a href="#filepos1623519">Automating type hinting of multidimensional array operations</a></blockquote><blockquote class="calibre35">macros and &amp;form, <a href="#filepos921642">Preserving user-provided type hints</a>, <a href="#filepos927698">Preserving user-provided type hints</a></blockquote><blockquote class="calibre35">multidimensional array operations, <a href="#filepos1623519">Automating type hinting of multidimensional array operations</a></blockquote><p class="calibre23">history, <a href="#filepos719801">Readers may retry</a></p><p class="calibre23">homogeneously typed arguments, <a href="#filepos1551625">The Rules of Numeric Contagion</a></p><p class="calibre23">homoiconicity, <a href="#filepos51620">No, Parentheses Actually Won’t Make You Go Blind</a>, <a href="#filepos69549">Homoiconicity</a>, <a href="#filepos75439">Homoiconicity</a>, <a href="#filepos834605">What Is a Macro?</a></p><p class="calibre23">HTML DSL, <a href="#filepos1733087">Growing an HTML DSL</a>, <a href="#filepos1744640">Growing an HTML DSL</a></p><p class="calibre23">HTML templates, Leiningen, <a href="#filepos1978038">Putting everything together</a></p><p class="calibre23">html-snippet, <a href="#filepos1962239">Testing the waters</a></p><p class="calibre23">hygienic macros, <a href="#filepos882274">Hygiene</a></p><div class="mbppagebreak"></div><p class="calibre23"><span class="calibre53"><span class="bold">I</span></span></p><p class="calibre46">I/O, agents, <a href="#filepos787482">I/O, Transactions, and Nested Sends</a>, <a href="#filepos820785">Using agents to parallelize workloads</a></p><p class="calibre23">identifiers, collections and data structures, <a href="#filepos520050">Identifiers and Cycles</a></p><p class="calibre23">identities, <a href="#filepos524486">Identifiers and Cycles</a>, <a href="#filepos628063">State and Identity</a>, <a href="#filepos1576325">Object Identity (identical?)</a></p><blockquote class="calibre35">about, <a href="#filepos524486">Identifiers and Cycles</a></blockquote><blockquote class="calibre35">concurrency and parallelism, <a href="#filepos628063">State and Identity</a></blockquote><blockquote class="calibre35">object identity, <a href="#filepos1576325">Object Identity (identical?)</a></blockquote><p class="calibre23">identity, <a href="#filepos33034">Why Clojure?</a></p><p class="calibre23">IDEs (Integrated Development Environments), <a href="#filepos1458265">Tooling</a></p><p class="calibre23">if, <a href="#filepos181506">Conditionals: if</a></p><p class="calibre23">if-let, <a href="#filepos183709">Conditionals: if</a></p><p class="calibre23">IFn, <a href="#filepos1592135">Declare Functions to Take and Return Primitives</a></p><p class="calibre23">immutability, <a href="#filepos474049">Immutability and Persistence</a>, <a href="#filepos508819">Transients</a></p><p class="calibre23">immutable fields, <a href="#filepos998525">Types</a></p><p class="calibre23">immutable functions, testing, <a href="#filepos1697043">Immutable Values and Pure Functions</a></p><p class="calibre23">immutable objects, <a href="#filepos222755">On the Importance of Values</a></p><p class="calibre23">immutable values, <a href="#filepos219342">What Does Functional Programming Mean?</a></p><p class="calibre23">import, <a href="#filepos1151241">Defining and Using Namespaces</a></p><p class="calibre23">in-ns, <a href="#filepos1136284">Defining and Using Namespaces</a></p><p class="calibre23">indexed abstractions, <a href="#filepos399580">Indexed</a></p><p class="calibre23">indexed-step functions, <a href="#filepos527718">Revisiting a classic: Conway’s Game of Life</a></p><p class="calibre23">indices, <a href="#filepos139957">Destructuring (let, Part 2)</a>, <a href="#filepos151602">Map destructuring</a>, <a href="#filepos525409">Thinking Different: From Imperative to Functional</a></p><blockquote class="calibre35">destructuring, <a href="#filepos151602">Map destructuring</a></blockquote><blockquote class="calibre35">issues with, <a href="#filepos525409">Thinking Different: From Imperative to Functional</a></blockquote><blockquote class="calibre35">vectors, <a href="#filepos139957">Destructuring (let, Part 2)</a></blockquote><p class="calibre23">inferior-lisp, <a href="#filepos1480619">inferior-lisp</a></p><p class="calibre23">infix operators, <a href="#filepos67617">Expressions, Operators, Syntax, and Precedence</a></p><p class="calibre23">inheritance, <a href="#filepos1118614">Multiple Inheritance</a>, <a href="#filepos1660431">Design Patterns</a></p><blockquote class="calibre35">limitations, <a href="#filepos1660431">Design Patterns</a></blockquote><blockquote class="calibre35">multimethods, <a href="#filepos1118614">Multiple Inheritance</a></blockquote><p class="calibre23">inline implementation of protocols, <a href="#filepos1008947">Implementing Protocols</a>, <a href="#filepos1011144">Inline Implementation</a>, <a href="#filepos1022991">Defining anonymous types with reify</a>, <a href="#filepos1015494">Inline implementations of Java interfaces</a>, <a href="#filepos1019444">Defining anonymous types with reify</a></p><blockquote class="calibre35">example, <a href="#filepos1008947">Implementing Protocols</a></blockquote><blockquote class="calibre35">Java interfaces, <a href="#filepos1015494">Inline implementations of Java interfaces</a></blockquote><blockquote class="calibre35">reify, <a href="#filepos1019444">Defining anonymous types with reify</a></blockquote><p class="calibre23">inline interfaces, classes, <a href="#filepos1520764">Limitations to Redefining Constructs</a></p><p class="calibre23">inner classes, <a href="#filepos1156520">Defining and Using Namespaces</a></p><p class="calibre23">inner map destructuring, <a href="#filepos152775">Map destructuring</a></p><p class="calibre23">insert-records, <a href="#filepos1765323">clojure.java.jdbc</a></p><p class="calibre23">inspecting protocols, <a href="#filepos1036548">Protocol Introspection</a></p><p class="calibre23">inspector, <a href="#filepos1494635">SLIME</a></p><p class="calibre23">instance field access, <a href="#filepos196479">Java Interop: . and new</a></p><p class="calibre23">instance method, <a href="#filepos68556">Expressions, Operators, Syntax, and Precedence</a>, <a href="#filepos194680">Java Interop: . and new</a></p><blockquote class="calibre35">calls, <a href="#filepos68556">Expressions, Operators, Syntax, and Precedence</a></blockquote><blockquote class="calibre35">invocation, <a href="#filepos194680">Java Interop: . and new</a></blockquote><p class="calibre23">instance?, <a href="#filepos1301171">Handy Interop Utilities</a></p><p class="calibre23">integers, <a href="#filepos227168">Comparing Values to Mutable Objects</a></p><p class="calibre23">Integrated Development Environments (IDEs), <a href="#filepos1458265">Tooling</a></p><p class="calibre23">interaction styles, REPL, <a href="#filepos45527">The Clojure REPL</a></p><p class="calibre23">interactive development, <a href="#filepos1439560">Interactive Development</a>, <a href="#filepos1455833">The Persistent, Evolving Environment</a></p><p class="calibre23">interfaces, <a href="#filepos948684">Protocols</a>, <a href="#filepos1015630">Inline implementations of Java interfaces</a>, <a href="#filepos1343833">Defining Classes and Implementing Interfaces</a>, <a href="#filepos1402843">Implementing JAX-RS web service endpoints</a>, <a href="#filepos1429380">Implementing Protocol Interfaces</a></p><blockquote class="calibre35">inline implementation of Java interfaces, <a href="#filepos1015630">Inline implementations of Java interfaces</a></blockquote><blockquote class="calibre35">Java classes, <a href="#filepos1343833">Defining Classes and Implementing Interfaces</a>, <a href="#filepos1402843">Implementing JAX-RS web service endpoints</a></blockquote><blockquote class="calibre35">using Clojure from Java, <a href="#filepos1429380">Implementing Protocol Interfaces</a></blockquote><blockquote class="calibre35">versus protocols, <a href="#filepos948684">Protocols</a></blockquote><p class="calibre23">interleaving source dependencies, <a href="#filepos1260691">Building mixed-source projects</a></p><p class="calibre23">interop forms, <a href="#filepos1283114">Using Java Classes, Methods, and Fields</a></p><p class="calibre23">interop utilities, <a href="#filepos1300640">Handy Interop Utilities</a></p><blockquote class="calibre35">Java, <a href="#filepos1300640">Handy Interop Utilities</a></blockquote><p class="calibre23">Interop Zone, <a href="#filepos2045570">Choosing Clojure Type Definition Forms Wisely</a></p><p class="calibre23">interoperability, <a href="#filepos87996">Numbers</a>, <a href="#filepos190673">Java Interop: . and new</a>, <a href="#filepos1274182">Java and JVM Interoperability</a></p><blockquote class="calibre35">Java, <a href="#filepos190673">Java Interop: . and new</a></blockquote><blockquote class="calibre35">Java and JVM, <a href="#filepos1274182">Java and JVM Interoperability</a></blockquote><blockquote class="calibre35">numeric primitives, <a href="#filepos87996">Numbers</a></blockquote><p class="calibre23">into, <a href="#filepos496514">Transients</a></p><p class="calibre23">into-array, <a href="#filepos1611915">The mechanics of primitive arrays</a></p><p class="calibre23">introducing Clojure to your workplace, <a href="#filepos2048613">Introducing Clojure into Your Workplace</a>, <a href="#filepos2069410">Be Prudent</a>, <a href="#filepos2049665">Just the Facts…</a>, <a href="#filepos2056517">Emphasize Productivity</a>, <a href="#filepos2061050">Emphasize Community</a>, <a href="#filepos2068188">Be Prudent</a></p><blockquote class="calibre35">community, <a href="#filepos2061050">Emphasize Community</a></blockquote><blockquote class="calibre35">facts, <a href="#filepos2049665">Just the Facts…</a></blockquote><blockquote class="calibre35">productivity, <a href="#filepos2056517">Emphasize Productivity</a></blockquote><blockquote class="calibre35">prudence, <a href="#filepos2068188">Be Prudent</a></blockquote><p class="calibre23">introspecting, <a href="#filepos1121536">Introspecting Multimethods</a>, <a href="#filepos1465029">Introspecting namespaces</a></p><blockquote class="calibre35">multimethods, <a href="#filepos1121536">Introspecting Multimethods</a></blockquote><blockquote class="calibre35">namespaces, <a href="#filepos1465029">Introspecting namespaces</a></blockquote><p class="calibre23">invariants, <a href="#filepos243978">A Critical Choice</a></p><p class="calibre23">invoke, <a href="#filepos1592539">Declare Functions to Take and Return Primitives</a></p><p class="calibre23">invokePrim, <a href="#filepos1596231">Declare Functions to Take and Return Primitives</a></p><p class="calibre23">is, <a href="#filepos1704837">clojure.test</a></p><p class="calibre23">isa?, <a href="#filepos1095190">Hierarchies</a></p><p class="calibre23">isolated mutation of local arrays, <a href="#filepos1605650">Use Primitive Arrays Judiciously</a></p><p class="calibre23">isolation, <a href="#filepos671982">Software Transactional Memory</a></p><p class="calibre23">iterating, Enlive, <a href="#filepos1969832">Iterating and branching</a></p><p class="calibre23">iterators, <a href="#filepos361497">Sequences are not iterators</a>, <a href="#filepos1659229">Design Patterns</a></p><blockquote class="calibre35">about, <a href="#filepos1659229">Design Patterns</a></blockquote><blockquote class="calibre35">versus sequences, <a href="#filepos361497">Sequences are not iterators</a></blockquote><div class="mbppagebreak"></div><p class="calibre23"><span class="calibre53"><span class="bold">J</span></span></p><p class="calibre46">Java, <a href="#filepos190673">Java Interop: . and new</a>, <a href="#filepos342753">Abstractions over Implementations</a>, <a href="#filepos344228">Abstractions over Implementations</a>, <a href="#filepos826459">Using Java’s Concurrency Primitives</a>, <a href="#filepos1015494">Inline implementations of Java interfaces</a>, <a href="#filepos1015630">Inline implementations of Java interfaces</a>, <a href="#filepos1156132">Defining and Using Namespaces</a>, <a href="#filepos1274182">Java and JVM Interoperability</a>, <a href="#filepos1437636">Collaborating Partners</a>, <a href="#filepos1276981">The JVM Is Clojure’s Foundation</a>, <a href="#filepos1282546">Using Java Classes, Methods, and Fields</a>, <a href="#filepos1298190">Using Java Classes, Methods, and Fields</a>, <a href="#filepos1283114">Using Java Classes, Methods, and Fields</a>, <a href="#filepos1297231">Using Java Classes, Methods, and Fields</a>, <a href="#filepos1300640">Handy Interop Utilities</a>, <a href="#filepos1306265">Exceptions and Error Handling</a>, <a href="#filepos1320088">with-open, finally’s Lament</a>, <a href="#filepos1313395">Escaping Checked Exceptions</a>, <a href="#filepos1315295">with-open, finally’s Lament</a>, <a href="#filepos1324754">Type Hinting for Performance</a>, <a href="#filepos1335340">Type Hinting for Performance</a>, <a href="#filepos1336385">Arrays</a>, <a href="#filepos1343833">Defining Classes and Implementing Interfaces</a>, <a href="#filepos1402843">Implementing JAX-RS web service endpoints</a>, <a href="#filepos1352571">Instances of Anonymous Classes: proxy</a>, <a href="#filepos1362584">Defining Named Classes</a>, <a href="#filepos1389137">gen-class</a>, <a href="#filepos1389249">Annotations</a>, <a href="#filepos1402843">Implementing JAX-RS web service endpoints</a>, <a href="#filepos1408303">Using Clojure from Java</a>, <a href="#filepos1434493">Implementing Protocol Interfaces</a>, <a href="#filepos1420153">Using deftype and defrecord Classes</a>, <a href="#filepos1429238">Using deftype and defrecord Classes</a>, <a href="#filepos1429380">Implementing Protocol Interfaces</a>, <a href="#filepos1663117">Dependency Injection</a>, <a href="#filepos1915374">Middleware</a>, <a href="#filepos1992445">Java and Clojure Web Architecture</a>, <a href="#filepos2018301">Building .war files with Leiningen</a>, <a href="#filepos1994531">Java and Clojure Web Architecture</a>, <a href="#filepos2000317">Web Application Packaging</a>, <a href="#filepos2018301">Building .war files with Leiningen</a>, <a href="#filepos2006101">Building .war files with Maven</a>, <a href="#filepos2013241">Building .war files with Leiningen</a></p><blockquote class="calibre35">abstraction, <a href="#filepos344228">Abstractions over Implementations</a></blockquote><blockquote class="calibre35">arrays, <a href="#filepos1336385">Arrays</a></blockquote><blockquote class="calibre35">classes and interfaces, <a href="#filepos1343833">Defining Classes and Implementing Interfaces</a>, <a href="#filepos1402843">Implementing JAX-RS web service endpoints</a>, <a href="#filepos1352571">Instances of Anonymous Classes: proxy</a>, <a href="#filepos1362584">Defining Named Classes</a>, <a href="#filepos1389137">gen-class</a>, <a href="#filepos1389249">Annotations</a>, <a href="#filepos1402843">Implementing JAX-RS web service endpoints</a></blockquote><blockquote class="calibre35">annotations, <a href="#filepos1389249">Annotations</a>, <a href="#filepos1402843">Implementing JAX-RS web service endpoints</a></blockquote><blockquote class="calibre35">named classes, <a href="#filepos1362584">Defining Named Classes</a>, <a href="#filepos1389137">gen-class</a></blockquote><blockquote class="calibre35">proxy, <a href="#filepos1352571">Instances of Anonymous Classes: proxy</a></blockquote><blockquote class="calibre35">classes, methods and fields, <a href="#filepos1282546">Using Java Classes, Methods, and Fields</a>, <a href="#filepos1298190">Using Java Classes, Methods, and Fields</a></blockquote><blockquote class="calibre35">Clojure’s foundation, <a href="#filepos1276981">The JVM Is Clojure’s Foundation</a></blockquote><blockquote class="calibre35">concurrency primitives, <a href="#filepos826459">Using Java’s Concurrency Primitives</a></blockquote><blockquote class="calibre35">dependency injection, <a href="#filepos1663117">Dependency Injection</a></blockquote><blockquote class="calibre35">exceptions and error handling, <a href="#filepos1306265">Exceptions and Error Handling</a>, <a href="#filepos1320088">with-open, finally’s Lament</a>, <a href="#filepos1313395">Escaping Checked Exceptions</a>, <a href="#filepos1315295">with-open, finally’s Lament</a></blockquote><blockquote class="calibre35">escaping checked exceptions, <a href="#filepos1313395">Escaping Checked Exceptions</a></blockquote><blockquote class="calibre35">with-open and finally, <a href="#filepos1315295">with-open, finally’s Lament</a></blockquote><blockquote class="calibre35">inline implementation of protocols with Java interfaces, <a href="#filepos1015494">Inline implementations of Java interfaces</a></blockquote><blockquote class="calibre35">interfaces, <a href="#filepos1015630">Inline implementations of Java interfaces</a></blockquote><blockquote class="calibre35">interop forms equivalents, <a href="#filepos1283114">Using Java Classes, Methods, and Fields</a></blockquote><blockquote class="calibre35">interop utilities, <a href="#filepos1300640">Handy Interop Utilities</a></blockquote><blockquote class="calibre35">interoperability, <a href="#filepos190673">Java Interop: . and new</a></blockquote><blockquote class="calibre35">maps, <a href="#filepos342753">Abstractions over Implementations</a></blockquote><blockquote class="calibre35">mutability, <a href="#filepos1297231">Using Java Classes, Methods, and Fields</a></blockquote><blockquote class="calibre35">servlet filters, <a href="#filepos1915374">Middleware</a></blockquote><blockquote class="calibre35">type hinting, <a href="#filepos1324754">Type Hinting for Performance</a>, <a href="#filepos1335340">Type Hinting for Performance</a></blockquote><blockquote class="calibre35">using Clojure from Java, <a href="#filepos1408303">Using Clojure from Java</a>, <a href="#filepos1434493">Implementing Protocol Interfaces</a>, <a href="#filepos1420153">Using deftype and defrecord Classes</a>, <a href="#filepos1429238">Using deftype and defrecord Classes</a>, <a href="#filepos1429380">Implementing Protocol Interfaces</a></blockquote><blockquote class="calibre35">deftype and defrecord classes, <a href="#filepos1420153">Using deftype and defrecord Classes</a>, <a href="#filepos1429238">Using deftype and defrecord Classes</a></blockquote><blockquote class="calibre35">protocol interfaces, <a href="#filepos1429380">Implementing Protocol Interfaces</a></blockquote><blockquote class="calibre35">web application packaging, <a href="#filepos2000317">Web Application Packaging</a>, <a href="#filepos2018301">Building .war files with Leiningen</a>, <a href="#filepos2006101">Building .war files with Maven</a>, <a href="#filepos2013241">Building .war files with Leiningen</a></blockquote><blockquote class="calibre35">.war files with Leiningen, <a href="#filepos2013241">Building .war files with Leiningen</a></blockquote><blockquote class="calibre35">.war files with Maven, <a href="#filepos2006101">Building .war files with Maven</a></blockquote><blockquote class="calibre35">web architecture, <a href="#filepos1994531">Java and Clojure Web Architecture</a></blockquote><blockquote class="calibre35">wildcard import, <a href="#filepos1156132">Defining and Using Namespaces</a></blockquote><p class="calibre23">java.io.Serializable, <a href="#filepos1043196">Protocol Dispatch Edge Cases</a></p><p class="calibre23">java.lang, <a href="#filepos1154167">Defining and Using Namespaces</a></p><p class="calibre23">java.lang.Integer, <a href="#filepos228393">Comparing Values to Mutable Objects</a></p><p class="calibre23">java.lang.Runnable, <a href="#filepos827457">Using Java’s Concurrency Primitives</a></p><p class="calibre23">java.util.ArrayList, <a href="#filepos451218">Vectors</a></p><p class="calibre23">java.util.Collection, <a href="#filepos1041744">Protocol Dispatch Edge Cases</a></p><p class="calibre23">java.util.concurrent, <a href="#filepos826768">Using Java’s Concurrency Primitives</a>, <a href="#filepos827981">Using Java’s Concurrency Primitives</a></p><p class="calibre23">java.util.concurrent.Callable, <a href="#filepos827507">Using Java’s Concurrency Primitives</a></p><p class="calibre23">java.util.List, <a href="#filepos140236">Destructuring (let, Part 2)</a>, <a href="#filepos1041703">Protocol Dispatch Edge Cases</a></p><p class="calibre23">java.util.Map, <a href="#filepos1043155">Protocol Dispatch Edge Cases</a></p><p class="calibre23">JavaScript, views, <a href="#filepos1835255">A Simple (JavaScript) View</a>, <a href="#filepos1841465">A Simple (JavaScript) View</a></p><p class="calibre23">JAX-RS annotations, <a href="#filepos1397524">Implementing JAX-RS web service endpoints</a></p><p class="calibre23">JAX-RS web service endpoints, <a href="#filepos1396536">Implementing JAX-RS web service endpoints</a></p><p class="calibre23">JMX (Java Management Extensions), <a href="#filepos1514704">Special Considerations for “Deployed” REPLs</a></p><p class="calibre23">JSON, <a href="#filepos1830231">Basic CRUD Operations</a></p><p class="calibre23">JUnit tests, <a href="#filepos1391129">Producing annotated JUnit tests</a></p><p class="calibre23">JVM (Java Virtual Machine), <a href="#filepos30944">Why Clojure?</a>, <a href="#filepos2052082">Just the Facts…</a></p><blockquote class="calibre35">Clojure hosted on, <a href="#filepos30944">Why Clojure?</a></blockquote><blockquote class="calibre35">reusing investment in, <a href="#filepos2052082">Just the Facts…</a></blockquote><div class="mbppagebreak"></div><p class="calibre23"><span class="calibre53"><span class="bold">K</span></span></p><p class="calibre46">keys, <a href="#filepos151253">Map destructuring</a>, <a href="#filepos155734">Map destructuring</a>, <a href="#filepos440352">Concise Collection Access</a>, <a href="#filepos459209">Maps</a></p><blockquote class="calibre35">binding values, <a href="#filepos155734">Map destructuring</a></blockquote><blockquote class="calibre35">collections, <a href="#filepos440352">Concise Collection Access</a></blockquote><blockquote class="calibre35">destructuring, <a href="#filepos151253">Map destructuring</a></blockquote><p class="calibre23">keywords, <a href="#filepos82734">Keywords</a>, <a href="#filepos171023">Destructuring function arguments</a>, <a href="#filepos441774">Idiomatic Usage</a>, <a href="#filepos982338">Records</a>, <a href="#filepos1092952">Hierarchies</a></p><blockquote class="calibre35">arguments, <a href="#filepos171023">Destructuring function arguments</a></blockquote><blockquote class="calibre35">associative collections, <a href="#filepos982338">Records</a></blockquote><blockquote class="calibre35">as functions, <a href="#filepos441774">Idiomatic Usage</a></blockquote><blockquote class="calibre35">hierarchy, <a href="#filepos1092952">Hierarchies</a></blockquote><p class="calibre23">Korma, <a href="#filepos1782977">Korma</a>, <a href="#filepos1798131">Why Bother with a DSL?</a>, <a href="#filepos1783903">Prelude</a>, <a href="#filepos1788216">Queries</a>, <a href="#filepos1791203">Why Bother with a DSL?</a></p><blockquote class="calibre35">queries, <a href="#filepos1788216">Queries</a></blockquote><blockquote class="calibre35">using, <a href="#filepos1783903">Prelude</a></blockquote><blockquote class="calibre35">versus DSL, <a href="#filepos1791203">Why Bother with a DSL?</a></blockquote><div class="mbppagebreak"></div><p class="calibre23"><span class="calibre53"><span class="bold">L</span></span></p><p class="calibre46">lambdas, Python, <a href="#filepos176924">Function literals</a></p><p class="calibre23">lazy seqs, <a href="#filepos368308">Lazy seqs</a>, <a href="#filepos385214">Lazy seqs</a></p><p class="calibre23">lazy-seq, <a href="#filepos358579">Sequences</a>, <a href="#filepos368857">Lazy seqs</a></p><p class="calibre23">lein compile, <a href="#filepos1259955">Building mixed-source projects</a></p><p class="calibre23">lein-ring, <a href="#filepos2014337">Building .war files with Leiningen</a></p><p class="calibre23">Leiningen, <a href="#filepos1238569">Leiningen</a>, <a href="#filepos1247926">AOT compilation configuration</a>, <a href="#filepos1255593">Building mixed-source projects</a>, <a href="#filepos1978038">Putting everything together</a>, <a href="#filepos2013241">Building .war files with Leiningen</a>, <a href="#filepos2024136">Running Web Apps Locally</a></p><blockquote class="calibre35">AOT compilation, <a href="#filepos1247926">AOT compilation configuration</a></blockquote><blockquote class="calibre35">compilation, <a href="#filepos1255593">Building mixed-source projects</a></blockquote><blockquote class="calibre35">HTML templates, <a href="#filepos1978038">Putting everything together</a></blockquote><blockquote class="calibre35">.war files, <a href="#filepos2013241">Building .war files with Leiningen</a></blockquote><blockquote class="calibre35">web apps, <a href="#filepos2024136">Running Web Apps Locally</a></blockquote><p class="calibre23">let, <a href="#filepos130567">Local Bindings: let</a></p><p class="calibre23">letfn, <a href="#filepos165731">Creating Functions: fn</a>, <a href="#filepos167455">Creating Functions: fn</a></p><p class="calibre23">lexical scope, <a href="#filepos744736">Dynamic Scope</a></p><p class="calibre23">libraries, dynamic scope, <a href="#filepos748620">Dynamic Scope</a></p><p class="calibre23">Library Coding Standards style guide, <a href="#filepos465839">Other usages of maps</a></p><p class="calibre23">libspecs, <a href="#filepos1144107">Defining and Using Namespaces</a></p><p class="calibre23">LIFO (last-in, first-out), stacks, <a href="#filepos403790">Stack</a></p><p class="calibre23">LinkedHashMap, <a href="#filepos1354275">Instances of Anonymous Classes: proxy</a></p><p class="calibre23">Lisp, <a href="#filepos31490">Why Clojure?</a>, <a href="#filepos122386">Special Forms</a></p><blockquote class="calibre35">and Clojure, <a href="#filepos31490">Why Clojure?</a></blockquote><blockquote class="calibre35">special forms, <a href="#filepos122386">Special Forms</a></blockquote><p class="calibre23">list function, <a href="#filepos865221">Syntax</a>, <a href="#filepos870089">unquote and unquote-splicing</a></p><p class="calibre23">list*, <a href="#filepos367537">Creating seqs</a></p><p class="calibre23">lists, <a href="#filepos55088">Expressions, Operators, Syntax, and Precedence</a>, <a href="#filepos102819">Collection Literals</a>, <a href="#filepos125098">Suppressing Evaluation: quote</a>, <a href="#filepos363159">Sequences are not lists</a>, <a href="#filepos448004">Lists</a>, <a href="#filepos479865">Visualizing persistence: lists</a></p><blockquote class="calibre35">about, <a href="#filepos55088">Expressions, Operators, Syntax, and Precedence</a></blockquote><blockquote class="calibre35">data structure type, <a href="#filepos448004">Lists</a></blockquote><blockquote class="calibre35">quote ('), <a href="#filepos102819">Collection Literals</a></blockquote><blockquote class="calibre35">quoting, <a href="#filepos125098">Suppressing Evaluation: quote</a></blockquote><blockquote class="calibre35">structural sharing, <a href="#filepos479865">Visualizing persistence: lists</a></blockquote><blockquote class="calibre35">versus sequences, <a href="#filepos363159">Sequences are not lists</a></blockquote><p class="calibre23">literals, <a href="#filepos25757">Safari® Books Online</a> (see collection literals; scalar literals)</p><p class="calibre23">live lock, <a href="#filepos716741">Minimize the scope of each transaction</a></p><p class="calibre23">local arrays, isolated mutation of, <a href="#filepos1605650">Use Primitive Arrays Judiciously</a></p><p class="calibre23">local bindings, <a href="#filepos130567">Local Bindings: let</a>, <a href="#filepos147948">Sequential destructuring</a></p><blockquote class="calibre35">destructured value, <a href="#filepos147948">Sequential destructuring</a></blockquote><blockquote class="calibre35">let, <a href="#filepos130567">Local Bindings: let</a></blockquote><p class="calibre23">local consistency, validators, <a href="#filepos701110">Enforcing local consistency by using validators</a></p><p class="calibre23">locals, destructuring, <a href="#filepos143237">Sequential destructuring</a></p><p class="calibre23">locking, <a href="#filepos198647">Primitive Locking: monitor-enter and monitor-exit</a>, <a href="#filepos829265">Locking</a></p><blockquote class="calibre35">concurrency primitives, <a href="#filepos829265">Locking</a></blockquote><blockquote class="calibre35">primitives: monitor-enter and monitor-exit, <a href="#filepos198647">Primitive Locking: monitor-enter and monitor-exit</a></blockquote><p class="calibre23">logging, <a href="#filepos296247">Building a Primitive Logging System with Composable Higher-Order Functions</a>, <a href="#filepos311125">Building a Primitive Logging System with Composable Higher-Order Functions</a>, <a href="#filepos790298">Persisting reference states with an agent-based write-behind log</a>, <a href="#filepos799069">Persisting reference states with an agent-based write-behind log</a>, <a href="#filepos795425">Persisting reference states with an agent-based write-behind log</a>, <a href="#filepos1865041">À la Carte Message Queues</a></p><blockquote class="calibre35">building a primitive logging system, <a href="#filepos296247">Building a Primitive Logging System with Composable Higher-Order Functions</a>, <a href="#filepos311125">Building a Primitive Logging System with Composable Higher-Order Functions</a></blockquote><blockquote class="calibre35">databases, <a href="#filepos1865041">À la Carte Message Queues</a></blockquote><blockquote class="calibre35">states, <a href="#filepos795425">Persisting reference states with an agent-based write-behind log</a></blockquote><blockquote class="calibre35">write-behind log, <a href="#filepos790298">Persisting reference states with an agent-based write-behind log</a>, <a href="#filepos799069">Persisting reference states with an agent-based write-behind log</a></blockquote><p class="calibre23">Long box class, <a href="#filepos1540731">Clojure Has a Mixed Numerics Model</a></p><p class="calibre23">loop special form, <a href="#filepos136784">Local Bindings: let</a></p><p class="calibre23">loops, <a href="#filepos185067">Looping: loop and recur</a>, <a href="#filepos530441">Revisiting a classic: Conway’s Game of Life</a></p><blockquote class="calibre35">loop and recur, <a href="#filepos185067">Looping: loop and recur</a></blockquote><blockquote class="calibre35">replacing, <a href="#filepos530441">Revisiting a classic: Conway’s Game of Life</a></blockquote><p class="calibre23">LRU cache, <a href="#filepos1354275">Instances of Anonymous Classes: proxy</a></p><p class="calibre23">lucene-core, <a href="#filepos1212081">Artifacts and coordinates</a></p><p class="calibre23">lucene-queryparser, <a href="#filepos1212081">Artifacts and coordinates</a></p><div class="mbppagebreak"></div><p class="calibre23"><span class="calibre53"><span class="bold">M</span></span></p><p class="calibre46">macroexpand-1, <a href="#filepos856456">Writing Your First Macro</a>, <a href="#filepos859197">Macroexpansion</a></p><p class="calibre23">macroexpand-all, <a href="#filepos863945">Macroexpansion</a></p><p class="calibre23">macroexpansion, <a href="#filepos837955">What Is a Macro?</a></p><p class="calibre23">macros, <a href="#filepos99325">Comments</a>, <a href="#filepos831586">Macros</a>, <a href="#filepos945416">Final Thoughts</a>, <a href="#filepos833250">What Is a Macro?</a>, <a href="#filepos849987">Macros Versus Ruby eval</a>, <a href="#filepos838728">What Macros Are Not</a>, <a href="#filepos841003">What Can Macros Do that Functions Cannot?</a>, <a href="#filepos846428">Macros Versus Ruby eval</a>, <a href="#filepos852409">Writing Your First Macro</a>, <a href="#filepos857227">Debugging Macros</a>, <a href="#filepos864899">Syntax</a>, <a href="#filepos874628">unquote and unquote-splicing</a>, <a href="#filepos867361">quote Versus syntax-quote</a>, <a href="#filepos869832">unquote and unquote-splicing</a>, <a href="#filepos876254">When to Use Macros</a>, <a href="#filepos881503">Hygiene</a>, <a href="#filepos899774">Double Evaluation</a>, <a href="#filepos886008">Gensyms to the Rescue</a>, <a href="#filepos894874">Letting the User Pick Names</a>, <a href="#filepos896618">Double Evaluation</a>, <a href="#filepos901171">Common Macro Idioms and Patterns</a>, <a href="#filepos905996">The Implicit Arguments: &amp;env and &amp;form</a>, <a href="#filepos932834">Testing Contextual Macros</a>, <a href="#filepos906466">&amp;env</a>, <a href="#filepos913272">&amp;env</a>, <a href="#filepos913558">&amp;form</a>, <a href="#filepos927698">Preserving user-provided type hints</a>, <a href="#filepos927824">Testing Contextual Macros</a>, <a href="#filepos935842">In Detail: -&gt; and -&gt;&gt;</a>, <a href="#filepos944073">In Detail: -&gt; and -&gt;&gt;</a>, <a href="#filepos1521702">Limitations to Redefining Constructs</a></p><blockquote class="calibre35">-&gt; and -&gt;&gt;, <a href="#filepos935842">In Detail: -&gt; and -&gt;&gt;</a>, <a href="#filepos944073">In Detail: -&gt; and -&gt;&gt;</a></blockquote><blockquote class="calibre35">about, <a href="#filepos833250">What Is a Macro?</a>, <a href="#filepos849987">Macros Versus Ruby eval</a>, <a href="#filepos838728">What Macros Are Not</a>, <a href="#filepos841003">What Can Macros Do that Functions Cannot?</a>, <a href="#filepos846428">Macros Versus Ruby eval</a></blockquote><blockquote class="calibre35">versus functions, <a href="#filepos841003">What Can Macros Do that Functions Cannot?</a></blockquote><blockquote class="calibre35">versus Ruby eval, <a href="#filepos846428">Macros Versus Ruby eval</a></blockquote><blockquote class="calibre35">what macros are not, <a href="#filepos838728">What Macros Are Not</a></blockquote><blockquote class="calibre35">comment macros, <a href="#filepos99325">Comments</a></blockquote><blockquote class="calibre35">debugging, <a href="#filepos857227">Debugging Macros</a></blockquote><blockquote class="calibre35">getting started, <a href="#filepos852409">Writing Your First Macro</a></blockquote><blockquote class="calibre35">hygiene, <a href="#filepos881503">Hygiene</a>, <a href="#filepos899774">Double Evaluation</a>, <a href="#filepos886008">Gensyms to the Rescue</a>, <a href="#filepos894874">Letting the User Pick Names</a>, <a href="#filepos896618">Double Evaluation</a></blockquote><blockquote class="calibre35">double evaluation, <a href="#filepos896618">Double Evaluation</a></blockquote><blockquote class="calibre35">gensyms, <a href="#filepos886008">Gensyms to the Rescue</a></blockquote><blockquote class="calibre35">names, <a href="#filepos894874">Letting the User Pick Names</a></blockquote><blockquote class="calibre35">idiom and patterns, <a href="#filepos901171">Common Macro Idioms and Patterns</a></blockquote><blockquote class="calibre35">implicit arguments, <a href="#filepos905996">The Implicit Arguments: &amp;env and &amp;form</a>, <a href="#filepos932834">Testing Contextual Macros</a>, <a href="#filepos906466">&amp;env</a>, <a href="#filepos913272">&amp;env</a>, <a href="#filepos913558">&amp;form</a>, <a href="#filepos927698">Preserving user-provided type hints</a>, <a href="#filepos927824">Testing Contextual Macros</a></blockquote><blockquote class="calibre35">&amp;env, <a href="#filepos906466">&amp;env</a>, <a href="#filepos913272">&amp;env</a></blockquote><blockquote class="calibre35">&amp;form, <a href="#filepos913558">&amp;form</a>, <a href="#filepos927698">Preserving user-provided type hints</a></blockquote><blockquote class="calibre35">testing contextual macros, <a href="#filepos927824">Testing Contextual Macros</a></blockquote><blockquote class="calibre35">redefining, <a href="#filepos1521702">Limitations to Redefining Constructs</a></blockquote><blockquote class="calibre35">syntax, <a href="#filepos864899">Syntax</a>, <a href="#filepos874628">unquote and unquote-splicing</a>, <a href="#filepos867361">quote Versus syntax-quote</a>, <a href="#filepos869832">unquote and unquote-splicing</a></blockquote><blockquote class="calibre35">quote versus syntax-quote, <a href="#filepos867361">quote Versus syntax-quote</a></blockquote><blockquote class="calibre35">unquote and unquote-splicing, <a href="#filepos869832">unquote and unquote-splicing</a></blockquote><blockquote class="calibre35">when to use, <a href="#filepos876254">When to Use Macros</a></blockquote><p class="calibre23">make-array, <a href="#filepos1613300">The mechanics of primitive arrays</a></p><p class="calibre23">make-hierarchy, <a href="#filepos1099018">Hierarchies</a></p><p class="calibre23">Mandelbrot Set, <a href="#filepos1634282">Visualizing the Mandelbrot Set in Clojure</a>, <a href="#filepos1652902">Visualizing the Mandelbrot Set in Clojure</a></p><p class="calibre23">many-to-one relationships, <a href="#filepos1786423">Prelude</a></p><p class="calibre23">map function, <a href="#filepos256481">First-Class and Higher-Order Functions</a>, <a href="#filepos1618605">The mechanics of primitive arrays</a></p><p class="calibre23">maps, <a href="#filepos137547">Destructuring (let, Part 2)</a>, <a href="#filepos149075">Map destructuring</a>, <a href="#filepos161384">Map destructuring</a>, <a href="#filepos342753">Abstractions over Implementations</a>, <a href="#filepos457717">Maps</a>, <a href="#filepos469838">Other usages of maps</a>, <a href="#filepos483235">Visualizing persistence: maps (and vectors and sets)</a>, <a href="#filepos500412">Transients</a>, <a href="#filepos738381">Private vars</a>, <a href="#filepos993131">When to use maps or records</a></p><blockquote class="calibre35">collections, <a href="#filepos137547">Destructuring (let, Part 2)</a></blockquote><blockquote class="calibre35">data structure type, <a href="#filepos457717">Maps</a></blockquote><blockquote class="calibre35">destructuring, <a href="#filepos149075">Map destructuring</a>, <a href="#filepos161384">Map destructuring</a></blockquote><blockquote class="calibre35">Java, <a href="#filepos342753">Abstractions over Implementations</a></blockquote><blockquote class="calibre35">metadata maps and vars, <a href="#filepos738381">Private vars</a></blockquote><blockquote class="calibre35">nested maps, <a href="#filepos469838">Other usages of maps</a></blockquote><blockquote class="calibre35">structural sharing, <a href="#filepos483235">Visualizing persistence: maps (and vectors and sets)</a></blockquote><blockquote class="calibre35">transient variants, <a href="#filepos500412">Transients</a></blockquote><blockquote class="calibre35">when to use, <a href="#filepos993131">When to use maps or records</a></blockquote><p class="calibre23">*math-context*, <a href="#filepos1572724">Scale and Rounding Modes for Arbitrary-Precision Decimals Ops</a></p><p class="calibre23">mathematics, <a href="#filepos25757">Safari® Books Online</a> (see numerics and mathematics)</p><p class="calibre23">matrices, map destructuring, <a href="#filepos151893">Map destructuring</a></p><p class="calibre23">Maven, <a href="#filepos1174187">Location, Location, Location</a>, <a href="#filepos1214127">Repositories</a>, <a href="#filepos1221947">Dependencies</a>, <a href="#filepos1237516">Maven</a>, <a href="#filepos1248767">AOT compilation configuration</a>, <a href="#filepos1254554">Building mixed-source projects</a>, <a href="#filepos2006101">Building .war files with Maven</a>, <a href="#filepos2023265">Running Web Apps Locally</a></p><blockquote class="calibre35">AOT compilation, <a href="#filepos1248767">AOT compilation configuration</a></blockquote><blockquote class="calibre35">clojure-maven-plugin, <a href="#filepos1237516">Maven</a>, <a href="#filepos1254554">Building mixed-source projects</a></blockquote><blockquote class="calibre35">layout conventions, <a href="#filepos1174187">Location, Location, Location</a></blockquote><blockquote class="calibre35">repositories, <a href="#filepos1214127">Repositories</a></blockquote><blockquote class="calibre35">version range formats, <a href="#filepos1221947">Dependencies</a></blockquote><blockquote class="calibre35">.war files, <a href="#filepos2006101">Building .war files with Maven</a></blockquote><blockquote class="calibre35">web apps, <a href="#filepos2023265">Running Web Apps Locally</a></blockquote><p class="calibre23">Maven dependency management model, <a href="#filepos1207324">The Maven Dependency Management Model</a>, <a href="#filepos1228241">Dependencies</a>, <a href="#filepos1208359">Artifacts and coordinates</a>, <a href="#filepos1213484">Repositories</a>, <a href="#filepos1216111">Dependencies</a>, <a href="#filepos1230604">Maven</a></p><blockquote class="calibre35">about, <a href="#filepos1230604">Maven</a></blockquote><blockquote class="calibre35">artifacts and coordinates, <a href="#filepos1208359">Artifacts and coordinates</a></blockquote><blockquote class="calibre35">dependencies, <a href="#filepos1216111">Dependencies</a></blockquote><blockquote class="calibre35">repositories, <a href="#filepos1213484">Repositories</a></blockquote><p class="calibre23">maze generation, <a href="#filepos547102">Maze generation</a>, <a href="#filepos569549">Maze generation</a></p><p class="calibre23">memoization, <a href="#filepos325326">Why Are Pure Functions Interesting?</a></p><p class="calibre23">memory, <a href="#filepos25757">Safari® Books Online</a> (see STM: transactional memory)</p><p class="calibre23">message queues, <a href="#filepos1864812">À la Carte Message Queues</a>, <a href="#filepos1876087">À la Carte Message Queues</a></p><p class="calibre23">metadata, <a href="#filepos105987">Miscellaneous Reader Sugar</a>, <a href="#filepos512882">Metadata</a>, <a href="#filepos601955">Delays</a>, <a href="#filepos738381">Private vars</a>, <a href="#filepos740747">Docstrings</a>, <a href="#filepos742139">Constants</a>, <a href="#filepos813254">Using agents to parallelize workloads</a>, <a href="#filepos913995">&amp;form</a>, <a href="#filepos921703">Preserving user-provided type hints</a>, <a href="#filepos985747">Records</a>, <a href="#filepos997285">Types</a>, <a href="#filepos1124347">type Versus class; or, the Revenge of the Map</a>, <a href="#filepos1335277">Type Hinting for Performance</a>, <a href="#filepos1389416">Annotations</a></p><blockquote class="calibre35">&amp;form, <a href="#filepos913995">&amp;form</a></blockquote><blockquote class="calibre35">about, <a href="#filepos105987">Miscellaneous Reader Sugar</a></blockquote><blockquote class="calibre35">agents, <a href="#filepos813254">Using agents to parallelize workloads</a></blockquote><blockquote class="calibre35">annotations, <a href="#filepos1389416">Annotations</a></blockquote><blockquote class="calibre35">associative collections, <a href="#filepos985747">Records</a></blockquote><blockquote class="calibre35">collections and data structures, <a href="#filepos512882">Metadata</a></blockquote><blockquote class="calibre35">constants, <a href="#filepos742139">Constants</a></blockquote><blockquote class="calibre35">docstrings, <a href="#filepos740747">Docstrings</a></blockquote><blockquote class="calibre35">macros, <a href="#filepos921703">Preserving user-provided type hints</a></blockquote><blockquote class="calibre35">maps, <a href="#filepos738381">Private vars</a></blockquote><blockquote class="calibre35">multimethods, <a href="#filepos1124347">type Versus class; or, the Revenge of the Map</a></blockquote><blockquote class="calibre35">realized?, <a href="#filepos601955">Delays</a></blockquote><blockquote class="calibre35">types, <a href="#filepos997285">Types</a></blockquote><blockquote class="calibre35">var names, <a href="#filepos1335277">Type Hinting for Performance</a></blockquote><p class="calibre23">metaprogramming, <a href="#filepos2050044">Just the Facts…</a></p><p class="calibre23">methodName, <a href="#filepos952784">Protocols</a></p><p class="calibre23">methods, <a href="#filepos951095">Protocols</a>, <a href="#filepos957458">Extending to Existing Types</a>, <a href="#filepos1282546">Using Java Classes, Methods, and Fields</a>, <a href="#filepos1298190">Using Java Classes, Methods, and Fields</a></p><blockquote class="calibre35">functions, <a href="#filepos951095">Protocols</a></blockquote><blockquote class="calibre35">Java, <a href="#filepos1282546">Using Java Classes, Methods, and Fields</a>, <a href="#filepos1298190">Using Java Classes, Methods, and Fields</a></blockquote><blockquote class="calibre35">protocols, <a href="#filepos957458">Extending to Existing Types</a></blockquote><p class="calibre23">middleware, <a href="#filepos1679921">Chain of Responsibility</a>, <a href="#filepos1910280">Middleware</a></p><blockquote class="calibre35">Ring, <a href="#filepos1910280">Middleware</a></blockquote><blockquote class="calibre35">using, <a href="#filepos1679921">Chain of Responsibility</a></blockquote><p class="calibre23">Midje, <a href="#filepos1704583">clojure.test</a></p><p class="calibre23">mixins, <a href="#filepos1027971">Reusing Implementations</a></p><p class="calibre23">mocking objects, <a href="#filepos1698276">Mocking</a></p><p class="calibre23">modes, <a href="#filepos784157">Agent error handlers and modes</a>, <a href="#filepos1570688">Scale and Rounding Modes for Arbitrary-Precision Decimals Ops</a></p><blockquote class="calibre35">agent error handlers, <a href="#filepos784157">Agent error handlers and modes</a></blockquote><blockquote class="calibre35">scale and rounding modes for arbitrary-precision decimals ops, <a href="#filepos1570688">Scale and Rounding Modes for Arbitrary-Precision Decimals Ops</a></blockquote><p class="calibre23">monitor-enter, <a href="#filepos198647">Primitive Locking: monitor-enter and monitor-exit</a></p><p class="calibre23">monitor-exit, <a href="#filepos198647">Primitive Locking: monitor-enter and monitor-exit</a></p><p class="calibre23">monitoring REPL, <a href="#filepos1502842">Debugging, Monitoring, and Patching Production in the REPL</a>, <a href="#filepos1517456">Special Considerations for “Deployed” REPLs</a></p><p class="calibre23">monkey-patching, <a href="#filepos946178">Datatypes and Protocols</a></p><p class="calibre23">multidimensional arrays, <a href="#filepos1620889">The mechanics of primitive arrays</a>, <a href="#filepos1623519">Automating type hinting of multidimensional array operations</a></p><blockquote class="calibre35">performance, <a href="#filepos1620889">The mechanics of primitive arrays</a></blockquote><blockquote class="calibre35">type hinting, <a href="#filepos1623519">Automating type hinting of multidimensional array operations</a></blockquote><p class="calibre23">multimethods, <a href="#filepos1045490">Protocol Dispatch Edge Cases</a>, <a href="#filepos1073575">Multimethods</a>, <a href="#filepos1132069">Final Thoughts</a>, <a href="#filepos1075054">Multimethods Basics</a>, <a href="#filepos1083202">Multimethods Basics</a>, <a href="#filepos1084712">Toward Hierarchies</a>, <a href="#filepos1109941">Independent Hierarchies</a>, <a href="#filepos1112127">Making It Really Multiple!</a>, <a href="#filepos1118614">Multiple Inheritance</a>, <a href="#filepos1121536">Introspecting Multimethods</a>, <a href="#filepos1123785">type Versus class; or, the Revenge of the Map</a>, <a href="#filepos1127131">The Range of Dispatch Functions Is Unlimited</a>, <a href="#filepos1522160">Limitations to Redefining Constructs</a></p><blockquote class="calibre35">about, <a href="#filepos1075054">Multimethods Basics</a>, <a href="#filepos1083202">Multimethods Basics</a></blockquote><blockquote class="calibre35">hierarchies, <a href="#filepos1084712">Toward Hierarchies</a>, <a href="#filepos1109941">Independent Hierarchies</a></blockquote><blockquote class="calibre35">inheritance, <a href="#filepos1118614">Multiple Inheritance</a></blockquote><blockquote class="calibre35">introspecting, <a href="#filepos1121536">Introspecting Multimethods</a></blockquote><blockquote class="calibre35">multiple dispatch, <a href="#filepos1112127">Making It Really Multiple!</a></blockquote><blockquote class="calibre35">range of dispatch functions, <a href="#filepos1127131">The Range of Dispatch Functions Is Unlimited</a></blockquote><blockquote class="calibre35">redefining, <a href="#filepos1522160">Limitations to Redefining Constructs</a></blockquote><blockquote class="calibre35">type versus class, <a href="#filepos1123785">type Versus class; or, the Revenge of the Map</a></blockquote><p class="calibre23">multiplayer games, <a href="#filepos673478">The Mechanics of Ref Change</a></p><p class="calibre23">multiple arities, <a href="#filepos164260">Creating Functions: fn</a></p><p class="calibre23">multitenancy, <a href="#filepos1993631">Java and Clojure Web Architecture</a></p><p class="calibre23">mutable fields, <a href="#filepos997157">Types</a></p><p class="calibre23">mutable objects, <a href="#filepos226281">Comparing Values to Mutable Objects</a>, <a href="#filepos240312">Comparing Values to Mutable Objects</a>, <a href="#filepos240515">A Critical Choice</a></p><blockquote class="calibre35">comparing to values, <a href="#filepos226281">Comparing Values to Mutable Objects</a>, <a href="#filepos240312">Comparing Values to Mutable Objects</a></blockquote><blockquote class="calibre35">unfettered object state, <a href="#filepos240515">A Critical Choice</a></blockquote><p class="calibre23">mutable state, <a href="#filepos222614">On the Importance of Values</a></p><p class="calibre23">mutations, <a href="#filepos136784">Local Bindings: let</a>, <a href="#filepos1617883">The mechanics of primitive arrays</a></p><blockquote class="calibre35">primitive arrays, <a href="#filepos1617883">The mechanics of primitive arrays</a></blockquote><blockquote class="calibre35">reference types, <a href="#filepos136784">Local Bindings: let</a></blockquote><p class="calibre23">mutually recursive functions, <a href="#filepos165731">Creating Functions: fn</a></p><div class="mbppagebreak"></div><p class="calibre23"><span class="calibre53"><span class="bold">N</span></span></p><p class="calibre46">named classes, <a href="#filepos1362584">Defining Named Classes</a>, <a href="#filepos1389137">gen-class</a></p><p class="calibre23">names, macros, <a href="#filepos894874">Letting the User Pick Names</a></p><p class="calibre23">namespace-global identity, <a href="#filepos735313">Vars</a></p><p class="calibre23">namespaced keywords, <a href="#filepos83623">Keywords</a></p><p class="calibre23">namespaced symbols, <a href="#filepos86422">Symbols</a></p><p class="calibre23">namespaces, <a href="#filepos109413">Namespaces</a>, <a href="#filepos737053">Defining Vars</a>, <a href="#filepos920034">Producing useful macro error messages</a>, <a href="#filepos953246">Protocols</a>, <a href="#filepos962047">Extending to Existing Types</a>, <a href="#filepos973122">Defining Your Own Types</a>, <a href="#filepos1092590">Hierarchies</a>, <a href="#filepos1134653">Defining and Using Namespaces</a>, <a href="#filepos1160945">Defining and Using Namespaces</a>, <a href="#filepos1134653">Defining and Using Namespaces</a>, <a href="#filepos1173529">A classpath primer</a>, <a href="#filepos1161037">Namespaces and files</a>, <a href="#filepos1168518">Namespaces and files</a>, <a href="#filepos1178139">The Functional Organization of Clojure Codebases</a>, <a href="#filepos1465029">Introspecting namespaces</a>, <a href="#filepos1473664">Eclipse</a></p><blockquote class="calibre35">about, <a href="#filepos109413">Namespaces</a></blockquote><blockquote class="calibre35">browsing, <a href="#filepos1473664">Eclipse</a></blockquote><blockquote class="calibre35">codebases, <a href="#filepos1178139">The Functional Organization of Clojure Codebases</a></blockquote><blockquote class="calibre35">files, <a href="#filepos1161037">Namespaces and files</a>, <a href="#filepos1168518">Namespaces and files</a></blockquote><blockquote class="calibre35">hierarchies and multimethods, <a href="#filepos1092590">Hierarchies</a></blockquote><blockquote class="calibre35">introspecting, <a href="#filepos1465029">Introspecting namespaces</a></blockquote><blockquote class="calibre35">macros, <a href="#filepos920034">Producing useful macro error messages</a></blockquote><blockquote class="calibre35">projects, <a href="#filepos1134653">Defining and Using Namespaces</a>, <a href="#filepos1160945">Defining and Using Namespaces</a></blockquote><blockquote class="calibre35">protocols, <a href="#filepos953246">Protocols</a>, <a href="#filepos962047">Extending to Existing Types</a></blockquote><blockquote class="calibre35">types, <a href="#filepos973122">Defining Your Own Types</a></blockquote><blockquote class="calibre35">vars, <a href="#filepos737053">Defining Vars</a></blockquote><p class="calibre23">natural keys versus synthetic keys, <a href="#filepos521013">Identifiers and Cycles</a></p><p class="calibre23">nested collections, accessing values in, <a href="#filepos140764">Destructuring (let, Part 2)</a></p><p class="calibre23">nested forms, expanding, <a href="#filepos863117">Macroexpansion</a></p><p class="calibre23">nested maps, reduce-by, <a href="#filepos469838">Other usages of maps</a></p><p class="calibre23">nested send, <a href="#filepos789644">I/O, Transactions, and Nested Sends</a></p><p class="calibre23">nested vectors, destructuring, <a href="#filepos146756">Sequential destructuring</a></p><p class="calibre23">nesting, function literals, <a href="#filepos180580">Function literals</a></p><p class="calibre23">networks, security, <a href="#filepos1516306">Special Considerations for “Deployed” REPLs</a></p><p class="calibre23">new special form, <a href="#filepos190673">Java Interop: . and new</a></p><p class="calibre23">next, <a href="#filepos359911">Sequences</a></p><p class="calibre23">nil, <a href="#filepos80998">nil</a>, <a href="#filepos396605">Beware of nil values</a>, <a href="#filepos446115">Collections and Keys and Higher-Order Functions</a></p><p class="calibre23">nonrelational databases, <a href="#filepos1819924">Using Nonrelational Databases</a>, <a href="#filepos1878859">Final Thoughts</a>, <a href="#filepos1822829">Getting Set Up with CouchDB and Clutch</a>, <a href="#filepos1825704">Basic CRUD Operations</a>, <a href="#filepos1832665">Views</a>, <a href="#filepos1855046">Views in Clojure</a>, <a href="#filepos1835255">A Simple (JavaScript) View</a>, <a href="#filepos1841465">A Simple (JavaScript) View</a>, <a href="#filepos1841591">Views in Clojure</a>, <a href="#filepos1855046">Views in Clojure</a>, <a href="#filepos1857966">_changes: Abusing CouchDB as a Message Queue</a>, <a href="#filepos1864812">À la Carte Message Queues</a>, <a href="#filepos1876087">À la Carte Message Queues</a></p><blockquote class="calibre35">CouchDB and Clutch, <a href="#filepos1822829">Getting Set Up with CouchDB and Clutch</a></blockquote><blockquote class="calibre35">CRUD, <a href="#filepos1825704">Basic CRUD Operations</a></blockquote><blockquote class="calibre35">message queues, <a href="#filepos1864812">À la Carte Message Queues</a>, <a href="#filepos1876087">À la Carte Message Queues</a></blockquote><blockquote class="calibre35">views, <a href="#filepos1832665">Views</a>, <a href="#filepos1855046">Views in Clojure</a>, <a href="#filepos1835255">A Simple (JavaScript) View</a>, <a href="#filepos1841465">A Simple (JavaScript) View</a>, <a href="#filepos1841591">Views in Clojure</a>, <a href="#filepos1855046">Views in Clojure</a></blockquote><blockquote class="calibre35">Clojure, <a href="#filepos1841591">Views in Clojure</a>, <a href="#filepos1855046">Views in Clojure</a></blockquote><blockquote class="calibre35">JavaScript, <a href="#filepos1835255">A Simple (JavaScript) View</a>, <a href="#filepos1841465">A Simple (JavaScript) View</a></blockquote><blockquote class="calibre35">_changes, <a href="#filepos1857966">_changes: Abusing CouchDB as a Message Queue</a></blockquote><p class="calibre23">notifications and constraints, <a href="#filepos655293">Notifications and Constraints</a>, <a href="#filepos667730">Validators</a>, <a href="#filepos655948">Watches</a>, <a href="#filepos663904">Watches</a>, <a href="#filepos664015">Validators</a></p><blockquote class="calibre35">validators, <a href="#filepos664015">Validators</a></blockquote><blockquote class="calibre35">watches, <a href="#filepos655948">Watches</a>, <a href="#filepos663904">Watches</a></blockquote><p class="calibre23">nREPL, <a href="#filepos1472557">Eclipse</a></p><p class="calibre23">ns, <a href="#filepos1157109">Defining and Using Namespaces</a></p><p class="calibre23">ns-aliases, <a href="#filepos1466050">Introspecting namespaces</a></p><p class="calibre23">ns-imports, <a href="#filepos1466050">Introspecting namespaces</a></p><p class="calibre23">ns-interns, <a href="#filepos1466050">Introspecting namespaces</a></p><p class="calibre23">ns-map, <a href="#filepos1466050">Introspecting namespaces</a></p><p class="calibre23">ns-publics, <a href="#filepos1466050">Introspecting namespaces</a></p><p class="calibre23">ns-refers, <a href="#filepos1466050">Introspecting namespaces</a></p><p class="calibre23">ns-unalias, <a href="#filepos1466867">Introspecting namespaces</a></p><p class="calibre23">ns-unmap, <a href="#filepos1466867">Introspecting namespaces</a>, <a href="#filepos1713904">Defining Tests</a></p><p class="calibre23">nth, <a href="#filepos401818">Indexed</a>, <a href="#filepos448966">Lists</a></p><p class="calibre23">number literals, <a href="#filepos86839">Numbers</a></p><p class="calibre23">numbering states, <a href="#filepos522113">Identifiers and Cycles</a></p><p class="calibre23">numeric literals, <a href="#filepos89586">Numbers</a></p><p class="calibre23">numeric primitives, interoperability, <a href="#filepos87996">Numbers</a></p><p class="calibre23">numerics and mathematics, <a href="#filepos1527542">Numerics and Mathematics</a>, <a href="#filepos1652902">Visualizing the Mandelbrot Set in Clojure</a>, <a href="#filepos1529018">Clojure Numerics</a>, <a href="#filepos1554351">The Rules of Numeric Contagion</a>, <a href="#filepos1537940">Clojure Prefers 64-bit (or Larger) Representations</a>, <a href="#filepos1538935">Clojure Has a Mixed Numerics Model</a>, <a href="#filepos1546838">Rationals</a>, <a href="#filepos1549346">The Rules of Numeric Contagion</a>, <a href="#filepos1556554">Clojure Mathematics</a>, <a href="#filepos1572793">Scale and Rounding Modes for Arbitrary-Precision Decimals Ops</a>, <a href="#filepos1557213">Bounded Versus Arbitrary Precision</a>, <a href="#filepos1564943">Bounded Versus Arbitrary Precision</a>, <a href="#filepos1565100">Unchecked Ops</a>, <a href="#filepos1570688">Scale and Rounding Modes for Arbitrary-Precision Decimals Ops</a>, <a href="#filepos1576052">Equality and Equivalence</a>, <a href="#filepos1586809">Equivalence can preserve your sanity</a>, <a href="#filepos1576325">Object Identity (identical?)</a>, <a href="#filepos1578440">Reference Equality (=)</a>, <a href="#filepos1581350">Numeric Equivalence (==)</a>, <a href="#filepos1588489">Optimizing Numeric Performance</a>, <a href="#filepos1629998">Automating type hinting of multidimensional array operations</a>, <a href="#filepos1591947">Declare Functions to Take and Return Primitives</a>, <a href="#filepos1605145">Type errors and warnings</a>, <a href="#filepos1605278">Use Primitive Arrays Judiciously</a>, <a href="#filepos1629998">Automating type hinting of multidimensional array operations</a>, <a href="#filepos1634282">Visualizing the Mandelbrot Set in Clojure</a>, <a href="#filepos1652902">Visualizing the Mandelbrot Set in Clojure</a></p><blockquote class="calibre35">equality and equivalence, <a href="#filepos1576052">Equality and Equivalence</a>, <a href="#filepos1586809">Equivalence can preserve your sanity</a>, <a href="#filepos1576325">Object Identity (identical?)</a>, <a href="#filepos1578440">Reference Equality (=)</a>, <a href="#filepos1581350">Numeric Equivalence (==)</a></blockquote><blockquote class="calibre35">numeric equivalence, <a href="#filepos1581350">Numeric Equivalence (==)</a></blockquote><blockquote class="calibre35">object identity, <a href="#filepos1576325">Object Identity (identical?)</a></blockquote><blockquote class="calibre35">reference equality, <a href="#filepos1578440">Reference Equality (=)</a></blockquote><blockquote class="calibre35">Mandelbrot Set, <a href="#filepos1634282">Visualizing the Mandelbrot Set in Clojure</a>, <a href="#filepos1652902">Visualizing the Mandelbrot Set in Clojure</a></blockquote><blockquote class="calibre35">mathematics, <a href="#filepos1556554">Clojure Mathematics</a>, <a href="#filepos1572793">Scale and Rounding Modes for Arbitrary-Precision Decimals Ops</a>, <a href="#filepos1557213">Bounded Versus Arbitrary Precision</a>, <a href="#filepos1564943">Bounded Versus Arbitrary Precision</a>, <a href="#filepos1565100">Unchecked Ops</a>, <a href="#filepos1570688">Scale and Rounding Modes for Arbitrary-Precision Decimals Ops</a></blockquote><blockquote class="calibre35">bounded versus arbitrary precision, <a href="#filepos1557213">Bounded Versus Arbitrary Precision</a>, <a href="#filepos1564943">Bounded Versus Arbitrary Precision</a></blockquote><blockquote class="calibre35">scale and rounding modes, <a href="#filepos1570688">Scale and Rounding Modes for Arbitrary-Precision Decimals Ops</a></blockquote><blockquote class="calibre35">unchecked ops, <a href="#filepos1565100">Unchecked Ops</a></blockquote><blockquote class="calibre35">numerics, <a href="#filepos1529018">Clojure Numerics</a>, <a href="#filepos1554351">The Rules of Numeric Contagion</a>, <a href="#filepos1537940">Clojure Prefers 64-bit (or Larger) Representations</a>, <a href="#filepos1538935">Clojure Has a Mixed Numerics Model</a>, <a href="#filepos1546838">Rationals</a>, <a href="#filepos1549346">The Rules of Numeric Contagion</a></blockquote><blockquote class="calibre35">mixed numerics model, <a href="#filepos1538935">Clojure Has a Mixed Numerics Model</a></blockquote><blockquote class="calibre35">numeric contagion, <a href="#filepos1549346">The Rules of Numeric Contagion</a></blockquote><blockquote class="calibre35">rationals, <a href="#filepos1546838">Rationals</a></blockquote><blockquote class="calibre35">representations, <a href="#filepos1537940">Clojure Prefers 64-bit (or Larger) Representations</a></blockquote><blockquote class="calibre35">optimizing numeric performance, <a href="#filepos1588489">Optimizing Numeric Performance</a>, <a href="#filepos1629998">Automating type hinting of multidimensional array operations</a>, <a href="#filepos1591947">Declare Functions to Take and Return Primitives</a>, <a href="#filepos1605145">Type errors and warnings</a>, <a href="#filepos1605278">Use Primitive Arrays Judiciously</a>, <a href="#filepos1629998">Automating type hinting of multidimensional array operations</a></blockquote><blockquote class="calibre35">declare functions, <a href="#filepos1591947">Declare Functions to Take and Return Primitives</a>, <a href="#filepos1605145">Type errors and warnings</a></blockquote><blockquote class="calibre35">primitive arrays, <a href="#filepos1605278">Use Primitive Arrays Judiciously</a>, <a href="#filepos1629998">Automating type hinting of multidimensional array operations</a></blockquote><div class="mbppagebreak"></div><p class="calibre23"><span class="calibre53"><span class="bold">O</span></span></p><p class="calibre46">objects, <a href="#filepos192877">Java Interop: . and new</a>, <a href="#filepos226281">Comparing Values to Mutable Objects</a>, <a href="#filepos240312">Comparing Values to Mutable Objects</a>, <a href="#filepos240430">A Critical Choice</a>, <a href="#filepos240515">A Critical Choice</a>, <a href="#filepos1296116">Using Java Classes, Methods, and Fields</a>, <a href="#filepos1545396">Clojure Has a Mixed Numerics Model</a>, <a href="#filepos1576325">Object Identity (identical?)</a>, <a href="#filepos1698433">Mocking</a></p><blockquote class="calibre35">fields, <a href="#filepos1296116">Using Java Classes, Methods, and Fields</a></blockquote><blockquote class="calibre35">identity, <a href="#filepos1576325">Object Identity (identical?)</a></blockquote><blockquote class="calibre35">instantiation, <a href="#filepos192877">Java Interop: . and new</a></blockquote><blockquote class="calibre35">mocking, <a href="#filepos1698433">Mocking</a></blockquote><blockquote class="calibre35">mutable objects, <a href="#filepos226281">Comparing Values to Mutable Objects</a>, <a href="#filepos240312">Comparing Values to Mutable Objects</a>, <a href="#filepos240515">A Critical Choice</a></blockquote><blockquote class="calibre35">comparing to values, <a href="#filepos226281">Comparing Values to Mutable Objects</a>, <a href="#filepos240312">Comparing Values to Mutable Objects</a></blockquote><blockquote class="calibre35">unfettered object state, <a href="#filepos240515">A Critical Choice</a></blockquote><blockquote class="calibre35">types, <a href="#filepos1545396">Clojure Has a Mixed Numerics Model</a></blockquote><blockquote class="calibre35">unfettered object state, <a href="#filepos240430">A Critical Choice</a></blockquote><p class="calibre23">octal notation, <a href="#filepos93086">Numbers</a></p><p class="calibre23">once, <a href="#filepos1722284">Fixtures</a></p><p class="calibre23">operations, arrays, <a href="#filepos1337208">Arrays</a></p><p class="calibre23">operators, <a href="#filepos53434">Expressions, Operators, Syntax, and Precedence</a></p><p class="calibre23">opt-in computation, <a href="#filepos600324">Delays</a></p><p class="calibre23">or, <a href="#filepos921939">Preserving user-provided type hints</a></p><p class="calibre23">ordering, comparators and predicates, <a href="#filepos412684">Comparators and predicates to define ordering</a>, <a href="#filepos426011">Comparators and predicates to define ordering</a></p><p class="calibre23">outer map destructuring, <a href="#filepos152612">Map destructuring</a></p><p class="calibre23">OutputStream, <a href="#filepos788191">I/O, Transactions, and Nested Sends</a></p><p class="calibre23">overloading, <a href="#filepos1074587">Multimethods</a></p><p class="calibre23">overriding local binding, <a href="#filepos136784">Local Bindings: let</a></p><p class="calibre23">Overtone, <a href="#filepos2077260">Overtone</a></p><div class="mbppagebreak"></div><p class="calibre23"><span class="calibre53"><span class="bold">P</span></span></p><p class="calibre46">packaging, <a href="#filepos1212411">Artifacts and coordinates</a></p><p class="calibre23">Pallet, <a href="#filepos2042187">Going Beyond Simple Web Application Deployment</a>, <a href="#filepos2084054">Pallet</a></p><p class="calibre23">parallelism, <a href="#filepos25757">Safari® Books Online</a> (see concurrency and parallelism)</p><p class="calibre23">parameterized queries, <a href="#filepos1768576">with-query-results Explained</a></p><p class="calibre23">paredit, <a href="#filepos1468827">Introspecting namespaces</a>, <a href="#filepos1471328">Eclipse</a>, <a href="#filepos1479345">clojure-mode and paredit</a></p><p class="calibre23">parentheses, <a href="#filepos49192">No, Parentheses Actually Won’t Make You Go Blind</a></p><p class="calibre23">partial literals versus function literals, <a href="#filepos275425">Applying Ourselves Partially</a></p><p class="calibre23">partition, <a href="#filepos532963">Revisiting a classic: Conway’s Game of Life</a></p><p class="calibre23">patching, <a href="#filepos1512602">Debugging, Monitoring, and Patching Production in the REPL</a></p><p class="calibre23">path segments, <a href="#filepos1936603">Routing Requests with Compojure</a></p><p class="calibre23">peek, <a href="#filepos404595">Stack</a></p><p class="calibre23">performance, <a href="#filepos274065">Applying Ourselves Partially</a>, <a href="#filepos477720">Persistence and Structural Sharing</a>, <a href="#filepos495393">Transients</a>, <a href="#filepos624031">Parallelism on the Cheap</a>, <a href="#filepos1324754">Type Hinting for Performance</a>, <a href="#filepos1335340">Type Hinting for Performance</a>, <a href="#filepos1588489">Optimizing Numeric Performance</a>, <a href="#filepos1629998">Automating type hinting of multidimensional array operations</a>, <a href="#filepos1591947">Declare Functions to Take and Return Primitives</a>, <a href="#filepos1605145">Type errors and warnings</a>, <a href="#filepos1605278">Use Primitive Arrays Judiciously</a>, <a href="#filepos1629998">Automating type hinting of multidimensional array operations</a>, <a href="#filepos1610778">The mechanics of primitive arrays</a>, <a href="#filepos1623519">Automating type hinting of multidimensional array operations</a></p><blockquote class="calibre35">declare functions, <a href="#filepos1591947">Declare Functions to Take and Return Primitives</a>, <a href="#filepos1605145">Type errors and warnings</a></blockquote><blockquote class="calibre35">higher order functions and arities, <a href="#filepos274065">Applying Ourselves Partially</a></blockquote><blockquote class="calibre35">immutable data structures, <a href="#filepos477720">Persistence and Structural Sharing</a></blockquote><blockquote class="calibre35">persistent data structures, <a href="#filepos495393">Transients</a></blockquote><blockquote class="calibre35">pmap, <a href="#filepos624031">Parallelism on the Cheap</a></blockquote><blockquote class="calibre35">primitive arrays, <a href="#filepos1605278">Use Primitive Arrays Judiciously</a>, <a href="#filepos1629998">Automating type hinting of multidimensional array operations</a>, <a href="#filepos1610778">The mechanics of primitive arrays</a>, <a href="#filepos1623519">Automating type hinting of multidimensional array operations</a></blockquote><blockquote class="calibre35">about, <a href="#filepos1610778">The mechanics of primitive arrays</a></blockquote><blockquote class="calibre35">type hinting of multidimensional array operations, <a href="#filepos1623519">Automating type hinting of multidimensional array operations</a></blockquote><blockquote class="calibre35">type hinting, <a href="#filepos1324754">Type Hinting for Performance</a>, <a href="#filepos1335340">Type Hinting for Performance</a></blockquote><p class="calibre23">persistence, <a href="#filepos474049">Immutability and Persistence</a>, <a href="#filepos508819">Transients</a>, <a href="#filepos477639">Persistence and Structural Sharing</a>, <a href="#filepos492450">Tangible benefits</a>, <a href="#filepos479865">Visualizing persistence: lists</a>, <a href="#filepos483235">Visualizing persistence: maps (and vectors and sets)</a>, <a href="#filepos489321">Tangible benefits</a>, <a href="#filepos492605">Transients</a>, <a href="#filepos508819">Transients</a>, <a href="#filepos790298">Persisting reference states with an agent-based write-behind log</a>, <a href="#filepos799069">Persisting reference states with an agent-based write-behind log</a>, <a href="#filepos1807587">Persisting Data</a></p><blockquote class="calibre35">data in Hibernate, <a href="#filepos1807587">Persisting Data</a></blockquote><blockquote class="calibre35">reference states, <a href="#filepos790298">Persisting reference states with an agent-based write-behind log</a>, <a href="#filepos799069">Persisting reference states with an agent-based write-behind log</a></blockquote><blockquote class="calibre35">structural sharing, <a href="#filepos477639">Persistence and Structural Sharing</a>, <a href="#filepos492450">Tangible benefits</a>, <a href="#filepos479865">Visualizing persistence: lists</a>, <a href="#filepos483235">Visualizing persistence: maps (and vectors and sets)</a>, <a href="#filepos489321">Tangible benefits</a></blockquote><blockquote class="calibre35">benefits, <a href="#filepos489321">Tangible benefits</a></blockquote><blockquote class="calibre35">lists, <a href="#filepos479865">Visualizing persistence: lists</a></blockquote><blockquote class="calibre35">maps, vectors and sets, <a href="#filepos483235">Visualizing persistence: maps (and vectors and sets)</a></blockquote><blockquote class="calibre35">transients, <a href="#filepos492605">Transients</a>, <a href="#filepos508819">Transients</a></blockquote><p class="calibre23">plug-ins, <a href="#filepos35751">Obtaining Clojure</a>, <a href="#filepos1238142">Maven</a>, <a href="#filepos1240048">Leiningen</a></p><blockquote class="calibre35">about, <a href="#filepos35751">Obtaining Clojure</a></blockquote><blockquote class="calibre35">Leiningen, <a href="#filepos1240048">Leiningen</a></blockquote><blockquote class="calibre35">Maven, <a href="#filepos1238142">Maven</a></blockquote><p class="calibre23">pmap, <a href="#filepos622604">Parallelism on the Cheap</a>, <a href="#filepos757950">Dynamic Scope</a></p><p class="calibre23">pointcuts, <a href="#filepos1686025">Aspect-Oriented Programming</a></p><p class="calibre23">polymorphism, <a href="#filepos338869">Abstractions over Implementations</a>, <a href="#filepos993774">When to use maps or records</a></p><p class="calibre23">pop, <a href="#filepos404432">Stack</a>, <a href="#filepos448751">Lists</a></p><p class="calibre23">POST, <a href="#filepos1942551">Routing Requests with Compojure</a></p><p class="calibre23">postconditions, assertions, <a href="#filepos1750475">Preconditions and Postconditions</a></p><p class="calibre23">postwalk, <a href="#filepos853535">Writing Your First Macro</a></p><p class="calibre23">pre- and postconditions, <a href="#filepos176353">Destructuring function arguments</a></p><p class="calibre23">precedence, <a href="#filepos53434">Expressions, Operators, Syntax, and Precedence</a></p><p class="calibre23">preconditions, assertions, <a href="#filepos1750475">Preconditions and Postconditions</a></p><p class="calibre23">predicates, <a href="#filepos412684">Comparators and predicates to define ordering</a>, <a href="#filepos426011">Comparators and predicates to define ordering</a>, <a href="#filepos414324">Comparators and predicates to define ordering</a>, <a href="#filepos1966685">Selectors</a></p><blockquote class="calibre35">ordering, <a href="#filepos412684">Comparators and predicates to define ordering</a>, <a href="#filepos426011">Comparators and predicates to define ordering</a></blockquote><blockquote class="calibre35">testing, <a href="#filepos1966685">Selectors</a></blockquote><blockquote class="calibre35">turning into comparators, <a href="#filepos414324">Comparators and predicates to define ordering</a></blockquote><p class="calibre23">prefer-method, <a href="#filepos1120279">Multiple Inheritance</a></p><p class="calibre23">preferences, multiple inheritance, <a href="#filepos1120224">Multiple Inheritance</a></p><p class="calibre23">prime operators, <a href="#filepos1564668">Bounded Versus Arbitrary Precision</a></p><p class="calibre23">primitives, <a href="#filepos87996">Numbers</a>, <a href="#filepos198647">Primitive Locking: monitor-enter and monitor-exit</a>, <a href="#filepos826459">Using Java’s Concurrency Primitives</a>, <a href="#filepos1531000">Clojure Numerics</a>, <a href="#filepos1539065">Clojure Has a Mixed Numerics Model</a>, <a href="#filepos1544566">Clojure Has a Mixed Numerics Model</a>, <a href="#filepos1589651">Optimizing Numeric Performance</a>, <a href="#filepos1591947">Declare Functions to Take and Return Primitives</a>, <a href="#filepos1605145">Type errors and warnings</a>, <a href="#filepos1605278">Use Primitive Arrays Judiciously</a>, <a href="#filepos1629998">Automating type hinting of multidimensional array operations</a>, <a href="#filepos1610778">The mechanics of primitive arrays</a>, <a href="#filepos1623519">Automating type hinting of multidimensional array operations</a></p><blockquote class="calibre35">64-bit integers, <a href="#filepos1531000">Clojure Numerics</a></blockquote><blockquote class="calibre35">arrays, <a href="#filepos1605278">Use Primitive Arrays Judiciously</a>, <a href="#filepos1629998">Automating type hinting of multidimensional array operations</a>, <a href="#filepos1610778">The mechanics of primitive arrays</a>, <a href="#filepos1623519">Automating type hinting of multidimensional array operations</a></blockquote><blockquote class="calibre35">about, <a href="#filepos1610778">The mechanics of primitive arrays</a></blockquote><blockquote class="calibre35">type hinting of multidimensional array operations, <a href="#filepos1623519">Automating type hinting of multidimensional array operations</a></blockquote><blockquote class="calibre35">concurrency primitives, <a href="#filepos826459">Using Java’s Concurrency Primitives</a></blockquote><blockquote class="calibre35">declare functions, <a href="#filepos1591947">Declare Functions to Take and Return Primitives</a>, <a href="#filepos1605145">Type errors and warnings</a></blockquote><blockquote class="calibre35">locking: monitor-enter and monitor-exit, <a href="#filepos198647">Primitive Locking: monitor-enter and monitor-exit</a></blockquote><blockquote class="calibre35">numeric primitives interoperability, <a href="#filepos87996">Numbers</a></blockquote><blockquote class="calibre35">numerics, <a href="#filepos1539065">Clojure Has a Mixed Numerics Model</a></blockquote><blockquote class="calibre35">performance, <a href="#filepos1589651">Optimizing Numeric Performance</a></blockquote><blockquote class="calibre35">types, <a href="#filepos1544566">Clojure Has a Mixed Numerics Model</a></blockquote><p class="calibre23">println forms, <a href="#filepos98802">Comments</a></p><p class="calibre23">private vars, <a href="#filepos737669">Private vars</a></p><p class="calibre23">productivity, <a href="#filepos2056517">Emphasize Productivity</a></p><p class="calibre23">program state, <a href="#filepos221998">On the Importance of Values</a></p><p class="calibre23">project.clj, <a href="#filepos1242366">Leiningen</a></p><p class="calibre23">projects, <a href="#filepos1132717">Organizing and Building Clojure Projects</a>, <a href="#filepos1274052">Final Thoughts</a>, <a href="#filepos1134653">Defining and Using Namespaces</a>, <a href="#filepos1173529">A classpath primer</a>, <a href="#filepos1161037">Namespaces and files</a>, <a href="#filepos1168518">Namespaces and files</a>, <a href="#filepos1168608">A classpath primer</a>, <a href="#filepos1173797">Location, Location, Location</a>, <a href="#filepos1177983">The Functional Organization of Clojure Codebases</a>, <a href="#filepos1192108">Build</a>, <a href="#filepos1261004">Building mixed-source projects</a>, <a href="#filepos1199563">Ahead-of-Time Compilation</a>, <a href="#filepos1205824">Dependency Management</a>, <a href="#filepos1228241">Dependencies</a>, <a href="#filepos1228380">Build Tools and Configuration Patterns</a>, <a href="#filepos1261004">Building mixed-source projects</a></p><blockquote class="calibre35">build solutions, <a href="#filepos1192108">Build</a>, <a href="#filepos1261004">Building mixed-source projects</a>, <a href="#filepos1199563">Ahead-of-Time Compilation</a>, <a href="#filepos1205824">Dependency Management</a>, <a href="#filepos1228241">Dependencies</a>, <a href="#filepos1228380">Build Tools and Configuration Patterns</a>, <a href="#filepos1261004">Building mixed-source projects</a></blockquote><blockquote class="calibre35">compilation, <a href="#filepos1199563">Ahead-of-Time Compilation</a></blockquote><blockquote class="calibre35">dependency management, <a href="#filepos1205824">Dependency Management</a>, <a href="#filepos1228241">Dependencies</a></blockquote><blockquote class="calibre35">tools and configuration patterns, <a href="#filepos1228380">Build Tools and Configuration Patterns</a>, <a href="#filepos1261004">Building mixed-source projects</a></blockquote><blockquote class="calibre35">codebases, <a href="#filepos1177983">The Functional Organization of Clojure Codebases</a></blockquote><blockquote class="calibre35">layout conventions, <a href="#filepos1173797">Location, Location, Location</a></blockquote><blockquote class="calibre35">namespaces, <a href="#filepos1134653">Defining and Using Namespaces</a>, <a href="#filepos1173529">A classpath primer</a>, <a href="#filepos1161037">Namespaces and files</a>, <a href="#filepos1168518">Namespaces and files</a>, <a href="#filepos1168608">A classpath primer</a></blockquote><blockquote class="calibre35">classpath, <a href="#filepos1168608">A classpath primer</a></blockquote><blockquote class="calibre35">files, <a href="#filepos1161037">Namespaces and files</a>, <a href="#filepos1168518">Namespaces and files</a></blockquote><p class="calibre23">promises, <a href="#filepos608941">Promises</a></p><p class="calibre23">protocols, <a href="#filepos25757">Safari® Books Online</a> (see datatypes and protocols)</p><p class="calibre23">proxy, <a href="#filepos1346596">Defining Classes and Implementing Interfaces</a></p><p class="calibre23">pure functions, <a href="#filepos316752">Pure Functions</a></p><p class="calibre23">PUT, <a href="#filepos1920522">Routing Requests with Compojure</a>, <a href="#filepos1942527">Routing Requests with Compojure</a></p><p class="calibre23">Python, <a href="#filepos143746">Sequential destructuring</a>, <a href="#filepos176924">Function literals</a>, <a href="#filepos1529763">Clojure Numerics</a></p><blockquote class="calibre35">destructuring and unpacking, <a href="#filepos143746">Sequential destructuring</a></blockquote><blockquote class="calibre35">lambdas, <a href="#filepos176924">Function literals</a></blockquote><blockquote class="calibre35">numeric types, <a href="#filepos1529763">Clojure Numerics</a></blockquote><p class="calibre23">PYTHONPATH, <a href="#filepos1169645">A classpath primer</a></p><div class="mbppagebreak"></div><p class="calibre23"><span class="calibre53"><span class="bold">Q</span></span></p><p class="calibre46">queries, <a href="#filepos1788216">Queries</a>, <a href="#filepos1809160">Running Queries</a></p><blockquote class="calibre35">Hibernate, <a href="#filepos1809160">Running Queries</a></blockquote><blockquote class="calibre35">Korma, <a href="#filepos1788216">Queries</a></blockquote><p class="calibre23">queues, message queues, <a href="#filepos1864812">À la Carte Message Queues</a>, <a href="#filepos1876087">À la Carte Message Queues</a></p><p class="calibre23">quote ('), <a href="#filepos102819">Collection Literals</a>, <a href="#filepos123985">Suppressing Evaluation: quote</a></p><p class="calibre23">quote versus syntax-quote, <a href="#filepos867361">quote Versus syntax-quote</a></p><div class="mbppagebreak"></div><p class="calibre23"><span class="calibre53"><span class="bold">R</span></span></p><p class="calibre46">random numbers, <a href="#filepos318583">Pure Functions</a></p><p class="calibre23">ranges of versions, <a href="#filepos1221247">Dependencies</a></p><p class="calibre23">rasterization, <a href="#filepos1648789">Visualizing the Mandelbrot Set in Clojure</a></p><p class="calibre23">rational numbers, <a href="#filepos94415">Numbers</a></p><p class="calibre23">rationals, <a href="#filepos1536230">Clojure Numerics</a>, <a href="#filepos1546838">Rationals</a></p><p class="calibre23">Read, <a href="#filepos109916">Namespaces</a></p><p class="calibre23">reader, <a href="#filepos76439">The Reader</a>, <a href="#filepos105987">Miscellaneous Reader Sugar</a>, <a href="#filepos80031">Strings</a>, <a href="#filepos80691">Booleans</a>, <a href="#filepos80998">nil</a>, <a href="#filepos81318">Characters</a>, <a href="#filepos82734">Keywords</a>, <a href="#filepos85474">Symbols</a>, <a href="#filepos86839">Numbers</a>, <a href="#filepos95003">Regular expressions</a>, <a href="#filepos96957">Comments</a>, <a href="#filepos100741">Whitespace and Commas</a>, <a href="#filepos102366">Collection Literals</a>, <a href="#filepos103251">Miscellaneous Reader Sugar</a>, <a href="#filepos103251">Miscellaneous Reader Sugar</a>, <a href="#filepos718852">Readers may retry</a></p><blockquote class="calibre35">collection literals, <a href="#filepos102366">Collection Literals</a></blockquote><blockquote class="calibre35">comments, <a href="#filepos96957">Comments</a></blockquote><blockquote class="calibre35">scalar literals, <a href="#filepos80031">Strings</a>, <a href="#filepos80691">Booleans</a>, <a href="#filepos80998">nil</a>, <a href="#filepos81318">Characters</a>, <a href="#filepos82734">Keywords</a>, <a href="#filepos85474">Symbols</a>, <a href="#filepos86839">Numbers</a>, <a href="#filepos95003">Regular expressions</a></blockquote><blockquote class="calibre35">booleans, <a href="#filepos80691">Booleans</a></blockquote><blockquote class="calibre35">characters, <a href="#filepos81318">Characters</a></blockquote><blockquote class="calibre35">keywords, <a href="#filepos82734">Keywords</a></blockquote><blockquote class="calibre35">nil, <a href="#filepos80998">nil</a></blockquote><blockquote class="calibre35">numbers, <a href="#filepos86839">Numbers</a></blockquote><blockquote class="calibre35">regular expressions, <a href="#filepos95003">Regular expressions</a></blockquote><blockquote class="calibre35">strings, <a href="#filepos80031">Strings</a></blockquote><blockquote class="calibre35">symbols, <a href="#filepos85474">Symbols</a></blockquote><blockquote class="calibre35">syntax, <a href="#filepos103251">Miscellaneous Reader Sugar</a>, <a href="#filepos103251">Miscellaneous Reader Sugar</a></blockquote><blockquote class="calibre35">transactional memory, <a href="#filepos718852">Readers may retry</a></blockquote><blockquote class="calibre35">whitespace and commas, <a href="#filepos100741">Whitespace and Commas</a></blockquote><p class="calibre23">realized?, <a href="#filepos602313">Delays</a></p><p class="calibre23">records, <a href="#filepos977716">Records</a>, <a href="#filepos995354">When to use maps or records</a>, <a href="#filepos988529">Constructors and factory functions</a>, <a href="#filepos993131">When to use maps or records</a>, <a href="#filepos995513">Types</a>, <a href="#filepos1002973">Types</a></p><blockquote class="calibre35">constructors and factory functions, <a href="#filepos988529">Constructors and factory functions</a></blockquote><blockquote class="calibre35">when to use, <a href="#filepos993131">When to use maps or records</a></blockquote><p class="calibre23">recur special form, <a href="#filepos136784">Local Bindings: let</a>, <a href="#filepos185067">Looping: loop and recur</a></p><p class="calibre23">recursive functions, letfn, <a href="#filepos165731">Creating Functions: fn</a></p><p class="calibre23">redefining, <a href="#filepos1519072">Limitations to Redefining Constructs</a>, <a href="#filepos1521702">Limitations to Redefining Constructs</a>, <a href="#filepos1522160">Limitations to Redefining Constructs</a></p><blockquote class="calibre35">constructs, <a href="#filepos1519072">Limitations to Redefining Constructs</a></blockquote><blockquote class="calibre35">macros, <a href="#filepos1521702">Limitations to Redefining Constructs</a></blockquote><blockquote class="calibre35">multimethods, <a href="#filepos1522160">Limitations to Redefining Constructs</a></blockquote><p class="calibre23">redirect, <a href="#filepos1930852">Routing Requests with Compojure</a></p><p class="calibre23">reduce, <a href="#filepos260553">First-Class and Higher-Order Functions</a>, <a href="#filepos530481">Revisiting a classic: Conway’s Game of Life</a>, <a href="#filepos1618632">The mechanics of primitive arrays</a>, <a href="#filepos1835864">A Simple (JavaScript) View</a></p><blockquote class="calibre35">about, <a href="#filepos260553">First-Class and Higher-Order Functions</a></blockquote><blockquote class="calibre35">Conway’s Game of Life, <a href="#filepos530481">Revisiting a classic: Conway’s Game of Life</a></blockquote><blockquote class="calibre35">CouchDB, <a href="#filepos1835864">A Simple (JavaScript) View</a></blockquote><blockquote class="calibre35">over arrays, <a href="#filepos1618632">The mechanics of primitive arrays</a></blockquote><p class="calibre23">reduce-by, <a href="#filepos469808">Other usages of maps</a></p><p class="calibre23">ref-history-count, <a href="#filepos719902">Readers may retry</a></p><p class="calibre23">ref-max-history, <a href="#filepos719935">Readers may retry</a></p><p class="calibre23">ref-min-history, <a href="#filepos719972">Readers may retry</a></p><p class="calibre23">ref-set, <a href="#filepos699908">Clobbering ref state with ref-set</a>, <a href="#filepos700353">Clobbering ref state with ref-set</a></p><p class="calibre23">refactoring, <a href="#filepos992518">Constructors and factory functions</a>, <a href="#filepos1164313">Namespaces and files</a></p><p class="calibre23">refer, <a href="#filepos1138359">Defining and Using Namespaces</a></p><p class="calibre23">reference equality, <a href="#filepos1578440">Reference Equality (=)</a></p><p class="calibre23">reference states, <a href="#filepos790298">Persisting reference states with an agent-based write-behind log</a>, <a href="#filepos799069">Persisting reference states with an agent-based write-behind log</a></p><p class="calibre23">reference types, <a href="#filepos32957">Why Clojure?</a>, <a href="#filepos136784">Local Bindings: let</a>, <a href="#filepos633601">State and Identity</a>, <a href="#filepos636227">Clojure Reference Types</a>, <a href="#filepos644078">Classifying Concurrent Operations</a>, <a href="#filepos1922429">Routing Requests with Compojure</a></p><blockquote class="calibre35">about, <a href="#filepos32957">Why Clojure?</a>, <a href="#filepos633601">State and Identity</a>, <a href="#filepos636227">Clojure Reference Types</a></blockquote><blockquote class="calibre35">coordinated and asynchronous semantics, <a href="#filepos644078">Classifying Concurrent Operations</a></blockquote><blockquote class="calibre35">mutation semantics, <a href="#filepos136784">Local Bindings: let</a></blockquote><blockquote class="calibre35">using, <a href="#filepos1922429">Routing Requests with Compojure</a></blockquote><p class="calibre23">referential transparency, <a href="#filepos324491">Why Are Pure Functions Interesting?</a></p><p class="calibre23">refs, <a href="#filepos668381">Refs</a>, <a href="#filepos729589">Write skew</a>, <a href="#filepos669558">Software Transactional Memory</a>, <a href="#filepos672639">The Mechanics of Ref Change</a>, <a href="#filepos709570">Enforcing local consistency by using validators</a>, <a href="#filepos681744">Understanding alter</a>, <a href="#filepos686722">Minimizing transaction conflict with commute</a>, <a href="#filepos699750">Minimizing transaction conflict with commute</a>, <a href="#filepos699908">Clobbering ref state with ref-set</a>, <a href="#filepos701110">Enforcing local consistency by using validators</a>, <a href="#filepos709851">The Sharp Corners of Software Transactional Memory</a>, <a href="#filepos729589">Write skew</a>, <a href="#filepos710339">Side-effecting functions strictly verboten</a>, <a href="#filepos714025">Minimize the scope of each transaction</a>, <a href="#filepos718852">Readers may retry</a>, <a href="#filepos723647">Write skew</a></p><blockquote class="calibre35">mechanics of ref change, <a href="#filepos672639">The Mechanics of Ref Change</a>, <a href="#filepos709570">Enforcing local consistency by using validators</a>, <a href="#filepos681744">Understanding alter</a>, <a href="#filepos686722">Minimizing transaction conflict with commute</a>, <a href="#filepos699750">Minimizing transaction conflict with commute</a>, <a href="#filepos699908">Clobbering ref state with ref-set</a>, <a href="#filepos701110">Enforcing local consistency by using validators</a></blockquote><blockquote class="calibre35">alter, <a href="#filepos681744">Understanding alter</a></blockquote><blockquote class="calibre35">commute, <a href="#filepos686722">Minimizing transaction conflict with commute</a>, <a href="#filepos699750">Minimizing transaction conflict with commute</a></blockquote><blockquote class="calibre35">ref-set, <a href="#filepos699908">Clobbering ref state with ref-set</a></blockquote><blockquote class="calibre35">validators, <a href="#filepos701110">Enforcing local consistency by using validators</a></blockquote><blockquote class="calibre35">STM, <a href="#filepos669558">Software Transactional Memory</a></blockquote><blockquote class="calibre35">transactional memory, <a href="#filepos709851">The Sharp Corners of Software Transactional Memory</a>, <a href="#filepos729589">Write skew</a>, <a href="#filepos710339">Side-effecting functions strictly verboten</a>, <a href="#filepos714025">Minimize the scope of each transaction</a>, <a href="#filepos718852">Readers may retry</a>, <a href="#filepos723647">Write skew</a></blockquote><blockquote class="calibre35">readers may retry, <a href="#filepos718852">Readers may retry</a></blockquote><blockquote class="calibre35">side-effecting functions, <a href="#filepos710339">Side-effecting functions strictly verboten</a></blockquote><blockquote class="calibre35">transaction scope, <a href="#filepos714025">Minimize the scope of each transaction</a></blockquote><blockquote class="calibre35">write skew, <a href="#filepos723647">Write skew</a></blockquote><p class="calibre23">regular expressions, <a href="#filepos95003">Regular expressions</a></p><p class="calibre23">reify, <a href="#filepos1019444">Defining anonymous types with reify</a>, <a href="#filepos1346596">Defining Classes and Implementing Interfaces</a></p><blockquote class="calibre35">anonymous types, <a href="#filepos1019444">Defining anonymous types with reify</a></blockquote><blockquote class="calibre35">Java classes, <a href="#filepos1346596">Defining Classes and Implementing Interfaces</a></blockquote><p class="calibre23">relational databases, <a href="#filepos1757696">Using Relational Databases</a>, <a href="#filepos1819793">Final Thoughts</a>, <a href="#filepos1758871">clojure.java.jdbc</a>, <a href="#filepos1780783">Connection Pooling</a>, <a href="#filepos1768147">with-query-results Explained</a>, <a href="#filepos1773214">Transactions</a>, <a href="#filepos1776470">Connection Pooling</a>, <a href="#filepos1782977">Korma</a>, <a href="#filepos1798131">Why Bother with a DSL?</a>, <a href="#filepos1783903">Prelude</a>, <a href="#filepos1788216">Queries</a>, <a href="#filepos1791203">Why Bother with a DSL?</a>, <a href="#filepos1798872">Hibernate</a>, <a href="#filepos1817703">Removing Boilerplate</a>, <a href="#filepos1799675">Setup</a>, <a href="#filepos1807471">Setup</a>, <a href="#filepos1807587">Persisting Data</a>, <a href="#filepos1809160">Running Queries</a>, <a href="#filepos1811426">Removing Boilerplate</a></p><blockquote class="calibre35">clojure.java.jdbc, <a href="#filepos1758871">clojure.java.jdbc</a>, <a href="#filepos1780783">Connection Pooling</a>, <a href="#filepos1768147">with-query-results Explained</a>, <a href="#filepos1773214">Transactions</a>, <a href="#filepos1776470">Connection Pooling</a></blockquote><blockquote class="calibre35">connection pooling, <a href="#filepos1776470">Connection Pooling</a></blockquote><blockquote class="calibre35">transactions, <a href="#filepos1773214">Transactions</a></blockquote><blockquote class="calibre35">with-query-results, <a href="#filepos1768147">with-query-results Explained</a></blockquote><blockquote class="calibre35">Hibernate, <a href="#filepos1798872">Hibernate</a>, <a href="#filepos1817703">Removing Boilerplate</a>, <a href="#filepos1799675">Setup</a>, <a href="#filepos1807471">Setup</a>, <a href="#filepos1807587">Persisting Data</a>, <a href="#filepos1809160">Running Queries</a>, <a href="#filepos1811426">Removing Boilerplate</a></blockquote><blockquote class="calibre35">boilerplate, <a href="#filepos1811426">Removing Boilerplate</a></blockquote><blockquote class="calibre35">persisting data, <a href="#filepos1807587">Persisting Data</a></blockquote><blockquote class="calibre35">queries, <a href="#filepos1809160">Running Queries</a></blockquote><blockquote class="calibre35">setup, <a href="#filepos1799675">Setup</a>, <a href="#filepos1807471">Setup</a></blockquote><blockquote class="calibre35">Korma, <a href="#filepos1782977">Korma</a>, <a href="#filepos1798131">Why Bother with a DSL?</a>, <a href="#filepos1783903">Prelude</a>, <a href="#filepos1788216">Queries</a>, <a href="#filepos1791203">Why Bother with a DSL?</a></blockquote><blockquote class="calibre35">queries, <a href="#filepos1788216">Queries</a></blockquote><blockquote class="calibre35">using, <a href="#filepos1783903">Prelude</a></blockquote><blockquote class="calibre35">versus DSL, <a href="#filepos1791203">Why Bother with a DSL?</a></blockquote><p class="calibre23">releases, <a href="#filepos1219308">Dependencies</a></p><p class="calibre23">remove, <a href="#filepos445515">Collections and Keys and Higher-Order Functions</a></p><p class="calibre23">remove-ns, <a href="#filepos1467304">Introspecting namespaces</a></p><p class="calibre23">render-image, <a href="#filepos1648745">Visualizing the Mandelbrot Set in Clojure</a></p><p class="calibre23">render-text, <a href="#filepos1641569">Visualizing the Mandelbrot Set in Clojure</a></p><p class="calibre23">REPL (Read, Evaluate, Print, Loop), <a href="#filepos37526">The Clojure REPL</a>, <a href="#filepos47226">The Clojure REPL</a>, <a href="#filepos718069">Minimize the scope of each transaction</a>, <a href="#filepos776120">Agents</a>, <a href="#filepos1095398">Hierarchies</a>, <a href="#filepos1135604">Defining and Using Namespaces</a>, <a href="#filepos1172794">A classpath primer</a>, <a href="#filepos1437763">REPL-Oriented Programming</a>, <a href="#filepos1527318">In Summary</a>, <a href="#filepos1439560">Interactive Development</a>, <a href="#filepos1455833">The Persistent, Evolving Environment</a>, <a href="#filepos1458133">Tooling</a>, <a href="#filepos1497148">SLIME</a>, <a href="#filepos1460389">The Bare REPL</a>, <a href="#filepos1470083">Introspecting namespaces</a>, <a href="#filepos1470200">Eclipse</a>, <a href="#filepos1474291">Eclipse</a>, <a href="#filepos1474397">Emacs</a>, <a href="#filepos1497148">SLIME</a>, <a href="#filepos1502842">Debugging, Monitoring, and Patching Production in the REPL</a>, <a href="#filepos1517456">Special Considerations for “Deployed” REPLs</a>, <a href="#filepos1506391">Debugging, Monitoring, and Patching Production in the REPL</a>, <a href="#filepos1519072">Limitations to Redefining Constructs</a>, <a href="#filepos1906557">Handlers</a>, <a href="#filepos2024809">Running Web Apps Locally</a></p><blockquote class="calibre35">agents, <a href="#filepos776120">Agents</a></blockquote><blockquote class="calibre35">classpath, <a href="#filepos1172794">A classpath primer</a></blockquote><blockquote class="calibre35">debugging, monitoring, and patching production, <a href="#filepos1502842">Debugging, Monitoring, and Patching Production in the REPL</a>, <a href="#filepos1517456">Special Considerations for “Deployed” REPLs</a></blockquote><blockquote class="calibre35">interactive development, <a href="#filepos1439560">Interactive Development</a>, <a href="#filepos1455833">The Persistent, Evolving Environment</a></blockquote><blockquote class="calibre35">monitoring, <a href="#filepos1506391">Debugging, Monitoring, and Patching Production in the REPL</a></blockquote><blockquote class="calibre35">multimethods, <a href="#filepos1095398">Hierarchies</a></blockquote><blockquote class="calibre35">namespaces, <a href="#filepos1135604">Defining and Using Namespaces</a></blockquote><blockquote class="calibre35">redefining constructs, <a href="#filepos1519072">Limitations to Redefining Constructs</a></blockquote><blockquote class="calibre35">tooling, <a href="#filepos1458133">Tooling</a>, <a href="#filepos1497148">SLIME</a>, <a href="#filepos1460389">The Bare REPL</a>, <a href="#filepos1470083">Introspecting namespaces</a>, <a href="#filepos1470200">Eclipse</a>, <a href="#filepos1474291">Eclipse</a>, <a href="#filepos1474397">Emacs</a>, <a href="#filepos1497148">SLIME</a></blockquote><blockquote class="calibre35">bare REPL, <a href="#filepos1460389">The Bare REPL</a>, <a href="#filepos1470083">Introspecting namespaces</a></blockquote><blockquote class="calibre35">Eclipse, <a href="#filepos1470200">Eclipse</a>, <a href="#filepos1474291">Eclipse</a></blockquote><blockquote class="calibre35">Emacs, <a href="#filepos1474397">Emacs</a>, <a href="#filepos1497148">SLIME</a></blockquote><blockquote class="calibre35">transactions, <a href="#filepos718069">Minimize the scope of each transaction</a></blockquote><blockquote class="calibre35">uploading via remote REPLs, <a href="#filepos2024809">Running Web Apps Locally</a></blockquote><blockquote class="calibre35">web applications, <a href="#filepos1906557">Handlers</a></blockquote><p class="calibre23">REPL-bound vars, <a href="#filepos1460904">The Bare REPL</a></p><p class="calibre23">repositories, Maven dependency management model, <a href="#filepos1213484">Repositories</a></p><p class="calibre23">representations, numerics, <a href="#filepos1537940">Clojure Prefers 64-bit (or Larger) Representations</a></p><p class="calibre23">require, <a href="#filepos1141533">Defining and Using Namespaces</a></p><p class="calibre23">requirements, <a href="#filepos34188">Obtaining Clojure</a></p><p class="calibre23">responsibility, chain of responsibility, <a href="#filepos1675057">Chain of Responsibility</a>, <a href="#filepos1682600">Chain of Responsibility</a></p><p class="calibre23">rest, <a href="#filepos147262">Sequential destructuring</a>, <a href="#filepos158548">Map destructuring</a>, <a href="#filepos169902">Destructuring function arguments</a>, <a href="#filepos359886">Sequences</a>, <a href="#filepos448797">Lists</a>, <a href="#filepos482644">Visualizing persistence: lists</a></p><p class="calibre23">restarting agents, <a href="#filepos782645">Dealing with Errors in Agent Actions</a></p><p class="calibre23">result set, <a href="#filepos1770492">with-query-results Explained</a></p><p class="calibre23">retain, <a href="#filepos1930823">Routing Requests with Compojure</a></p><p class="calibre23">return values, performance, <a href="#filepos1592601">Declare Functions to Take and Return Primitives</a></p><p class="calibre23">reusing exception types, <a href="#filepos1311766">Exceptions and Error Handling</a></p><p class="calibre23">Ring, <a href="#filepos1887327">The Foundation: Ring</a>, <a href="#filepos1916018">Middleware</a>, <a href="#filepos1888867">Requests and Responses</a>, <a href="#filepos1902480">Adapters</a>, <a href="#filepos1905874">Handlers</a>, <a href="#filepos1910280">Middleware</a>, <a href="#filepos1997441">Java and Clojure Web Architecture</a></p><blockquote class="calibre35">adapters, <a href="#filepos1902480">Adapters</a></blockquote><blockquote class="calibre35">handlers, <a href="#filepos1905874">Handlers</a></blockquote><blockquote class="calibre35">middleware, <a href="#filepos1910280">Middleware</a></blockquote><blockquote class="calibre35">requests and responses, <a href="#filepos1888867">Requests and Responses</a></blockquote><blockquote class="calibre35">web app architecture, <a href="#filepos1997441">Java and Clojure Web Architecture</a></blockquote><p class="calibre23">ring-httpcore-adapter, <a href="#filepos1903974">Adapters</a></p><p class="calibre23">ring-jetty-adapter, <a href="#filepos1903570">Adapters</a></p><p class="calibre23">Robert Hooke library, <a href="#filepos1689982">Aspect-Oriented Programming</a></p><p class="calibre23">root bindings, <a href="#filepos746359">Dynamic Scope</a>, <a href="#filepos761802">Vars Are Not Variables</a></p><p class="calibre23">rounding modes, arbitrary-precision decimals ops, <a href="#filepos1570688">Scale and Rounding Modes for Arbitrary-Precision Decimals Ops</a></p><p class="calibre23">routing requests, <a href="#filepos1918723">Routing Requests with Compojure</a>, <a href="#filepos1951020">Routing Requests with Compojure</a></p><p class="calibre23">rseq, <a href="#filepos407854">Sorted</a></p><p class="calibre23">rsubseq, <a href="#filepos408241">Sorted</a>, <a href="#filepos421830">Comparators and predicates to define ordering</a></p><p class="calibre23">Ruby, <a href="#filepos176888">Function literals</a>, <a href="#filepos234371">Comparing Values to Mutable Objects</a>, <a href="#filepos342935">Abstractions over Implementations</a>, <a href="#filepos846428">Macros Versus Ruby eval</a>, <a href="#filepos1529763">Clojure Numerics</a>, <a href="#filepos1956223">Templating</a></p><blockquote class="calibre35">blocks, <a href="#filepos176888">Function literals</a></blockquote><blockquote class="calibre35">ERB templating language, <a href="#filepos1956223">Templating</a></blockquote><blockquote class="calibre35">eval versus Clojure macros, <a href="#filepos846428">Macros Versus Ruby eval</a></blockquote><blockquote class="calibre35">lists and hashes, <a href="#filepos342935">Abstractions over Implementations</a></blockquote><blockquote class="calibre35">numeric types, <a href="#filepos1529763">Clojure Numerics</a></blockquote><blockquote class="calibre35">strings, <a href="#filepos234371">Comparing Values to Mutable Objects</a></blockquote><p class="calibre23">runtime, <a href="#filepos1200340">Ahead-of-Time Compilation</a>, <a href="#filepos1452745">The Persistent, Evolving Environment</a>, <a href="#filepos1506391">Debugging, Monitoring, and Patching Production in the REPL</a></p><blockquote class="calibre35">analysis, <a href="#filepos1506391">Debugging, Monitoring, and Patching Production in the REPL</a></blockquote><blockquote class="calibre35">compilation, <a href="#filepos1200340">Ahead-of-Time Compilation</a></blockquote><blockquote class="calibre35">dynamic redefinition, <a href="#filepos1452745">The Persistent, Evolving Environment</a></blockquote><div class="mbppagebreak"></div><p class="calibre23"><span class="calibre53"><span class="bold">S</span></span></p><p class="calibre46">satisfies?, <a href="#filepos1038125">Protocol Introspection</a></p><p class="calibre23">scalar literals, <a href="#filepos79660">Scalar Literals</a>, <a href="#filepos96848">Regular expressions</a>, <a href="#filepos80031">Strings</a>, <a href="#filepos80691">Booleans</a>, <a href="#filepos80998">nil</a>, <a href="#filepos81318">Characters</a>, <a href="#filepos82734">Keywords</a>, <a href="#filepos85474">Symbols</a>, <a href="#filepos86839">Numbers</a>, <a href="#filepos95003">Regular expressions</a></p><blockquote class="calibre35">booleans, <a href="#filepos80691">Booleans</a></blockquote><blockquote class="calibre35">characters, <a href="#filepos81318">Characters</a></blockquote><blockquote class="calibre35">keywords, <a href="#filepos82734">Keywords</a></blockquote><blockquote class="calibre35">nil, <a href="#filepos80998">nil</a></blockquote><blockquote class="calibre35">numbers, <a href="#filepos86839">Numbers</a></blockquote><blockquote class="calibre35">regular expressions, <a href="#filepos95003">Regular expressions</a></blockquote><blockquote class="calibre35">strings, <a href="#filepos80031">Strings</a></blockquote><blockquote class="calibre35">symbols, <a href="#filepos85474">Symbols</a></blockquote><p class="calibre23">scale, arbitrary-precision decimals ops, <a href="#filepos1570688">Scale and Rounding Modes for Arbitrary-Precision Decimals Ops</a></p><p class="calibre23">scope, <a href="#filepos714025">Minimize the scope of each transaction</a>, <a href="#filepos744661">Dynamic Scope</a>, <a href="#filepos759026">Dynamic Scope</a>, <a href="#filepos749235">Dynamic Scope</a>, <a href="#filepos757451">Dynamic Scope</a></p><blockquote class="calibre35">dynamic scope, <a href="#filepos744661">Dynamic Scope</a>, <a href="#filepos759026">Dynamic Scope</a>, <a href="#filepos749235">Dynamic Scope</a>, <a href="#filepos757451">Dynamic Scope</a></blockquote><blockquote class="calibre35">concurrency forms, <a href="#filepos757451">Dynamic Scope</a></blockquote><blockquote class="calibre35">visualizing, <a href="#filepos749235">Dynamic Scope</a></blockquote><blockquote class="calibre35">transactions, <a href="#filepos714025">Minimize the scope of each transaction</a></blockquote><p class="calibre23">security, networks, <a href="#filepos1516306">Special Considerations for “Deployed” REPLs</a></p><p class="calibre23">select, <a href="#filepos1788671">Queries</a></p><p class="calibre23">selectors, Enlive, <a href="#filepos1964781">Selectors</a></p><p class="calibre23">semantics, <a href="#filepos136784">Local Bindings: let</a>, <a href="#filepos644078">Classifying Concurrent Operations</a>, <a href="#filepos979962">Records</a></p><blockquote class="calibre35">reference types, <a href="#filepos644078">Classifying Concurrent Operations</a></blockquote><blockquote class="calibre35">reference types and mutation semantics, <a href="#filepos136784">Local Bindings: let</a></blockquote><blockquote class="calibre35">value semantics, <a href="#filepos979962">Records</a></blockquote><p class="calibre23">send, <a href="#filepos769687">Agents</a></p><p class="calibre23">send-off, <a href="#filepos769716">Agents</a></p><p class="calibre23">sends, agents and nested sends, <a href="#filepos787482">I/O, Transactions, and Nested Sends</a>, <a href="#filepos820785">Using agents to parallelize workloads</a></p><p class="calibre23">sequences, <a href="#filepos339559">Abstractions over Implementations</a>, <a href="#filepos354266">Sequences</a>, <a href="#filepos387930">Head retention</a>, <a href="#filepos361497">Sequences are not iterators</a>, <a href="#filepos363159">Sequences are not lists</a>, <a href="#filepos366106">Creating seqs</a>, <a href="#filepos368308">Lazy seqs</a>, <a href="#filepos385214">Lazy seqs</a>, <a href="#filepos385300">Head retention</a>, <a href="#filepos449327">Lists</a>, <a href="#filepos503732">Transients</a>, <a href="#filepos1590352">Optimizing Numeric Performance</a></p><blockquote class="calibre35">creating seqs, <a href="#filepos366106">Creating seqs</a></blockquote><blockquote class="calibre35">head retention, <a href="#filepos385300">Head retention</a></blockquote><blockquote class="calibre35">lazy seqs, <a href="#filepos368308">Lazy seqs</a>, <a href="#filepos385214">Lazy seqs</a></blockquote><blockquote class="calibre35">lists, <a href="#filepos449327">Lists</a></blockquote><blockquote class="calibre35">performance, <a href="#filepos1590352">Optimizing Numeric Performance</a></blockquote><blockquote class="calibre35">seq, <a href="#filepos339559">Abstractions over Implementations</a></blockquote><blockquote class="calibre35">transients, <a href="#filepos503732">Transients</a></blockquote><blockquote class="calibre35">versus iterators, <a href="#filepos361497">Sequences are not iterators</a></blockquote><blockquote class="calibre35">versus lists, <a href="#filepos363159">Sequences are not lists</a></blockquote><p class="calibre23">sequential collections, <a href="#filepos137512">Destructuring (let, Part 2)</a></p><p class="calibre23">sequential destructuring, <a href="#filepos141549">Sequential destructuring</a>, <a href="#filepos148722">Sequential destructuring</a>, <a href="#filepos379588">Lazy seqs</a></p><p class="calibre23">serializable snapshot isolation, <a href="#filepos685958">Understanding alter</a></p><p class="calibre23">serialization, <a href="#filepos79300">The Reader</a></p><p class="calibre23">servlets, <a href="#filepos1903233">Adapters</a>, <a href="#filepos1915374">Middleware</a>, <a href="#filepos1992568">Java and Clojure Web Architecture</a></p><blockquote class="calibre35">about, <a href="#filepos1992568">Java and Clojure Web Architecture</a></blockquote><blockquote class="calibre35">filters, <a href="#filepos1915374">Middleware</a></blockquote><blockquote class="calibre35">Ring, <a href="#filepos1903233">Adapters</a></blockquote><p class="calibre23">session factories, <a href="#filepos1805054">Setup</a></p><p class="calibre23">set abstractions, <a href="#filepos405856">Set</a></p><p class="calibre23">set function, <a href="#filepos456783">Sets</a></p><p class="calibre23">set!, <a href="#filepos197719">Specialized Mutation: set!</a>, <a href="#filepos756706">Dynamic Scope</a>, <a href="#filepos1296928">Using Java Classes, Methods, and Fields</a></p><p class="calibre23">sets, <a href="#filepos455466">Sets</a>, <a href="#filepos483235">Visualizing persistence: maps (and vectors and sets)</a></p><blockquote class="calibre35">data structure type, <a href="#filepos455466">Sets</a></blockquote><blockquote class="calibre35">structural sharing, <a href="#filepos483235">Visualizing persistence: maps (and vectors and sets)</a></blockquote><p class="calibre23">sharing, <a href="#filepos25757">Safari® Books Online</a> (see structural sharing)</p><p class="calibre23">shorten!, <a href="#filepos1927495">Routing Requests with Compojure</a></p><p class="calibre23">side effects, <a href="#filepos317051">Pure Functions</a>, <a href="#filepos382542">Lazy seqs</a></p><blockquote class="calibre35">defined, <a href="#filepos317051">Pure Functions</a></blockquote><blockquote class="calibre35">lazy sequences, <a href="#filepos382542">Lazy seqs</a></blockquote><p class="calibre23">side-effecting functions, <a href="#filepos328183">Why Are Pure Functions Interesting?</a>, <a href="#filepos710339">Side-effecting functions strictly verboten</a></p><p class="calibre23">single-arity functions, <a href="#filepos168257">Creating Functions: fn</a></p><p class="calibre23">single-segment namespaces, <a href="#filepos1166855">Namespaces and files</a></p><p class="calibre23">SLIME, <a href="#filepos1481047">inferior-lisp</a>, <a href="#filepos1495518">SLIME</a></p><p class="calibre23">slots, <a href="#filepos460146">Maps as ad-hoc structs</a></p><p class="calibre23">snapshots, <a href="#filepos1219282">Dependencies</a></p><p class="calibre23">sniptest, <a href="#filepos1961037">Testing the waters</a>, <a href="#filepos1974706">Putting everything together</a></p><p class="calibre23">software transactional memory, <a href="#filepos25757">Safari® Books Online</a> (see STM)</p><p class="calibre23">sorted abstractions, <a href="#filepos407171">Sorted</a>, <a href="#filepos426011">Comparators and predicates to define ordering</a></p><p class="calibre23">sorted-map, <a href="#filepos416218">Comparators and predicates to define ordering</a></p><p class="calibre23">sorted-map-by, <a href="#filepos416371">Comparators and predicates to define ordering</a></p><p class="calibre23">sorted-set, <a href="#filepos416249">Comparators and predicates to define ordering</a></p><p class="calibre23">sorted-set-by, <a href="#filepos416405">Comparators and predicates to define ordering</a></p><p class="calibre23">source code, <a href="#filepos1463444">The Bare REPL</a>, <a href="#filepos1468533">Introspecting namespaces</a></p><blockquote class="calibre35">printing, <a href="#filepos1463444">The Bare REPL</a></blockquote><blockquote class="calibre35">structural editing, <a href="#filepos1468533">Introspecting namespaces</a></blockquote><p class="calibre23">SPEC, <a href="#filepos1887857">The Foundation: Ring</a></p><p class="calibre23">special forms, <a href="#filepos121582">Special Forms</a>, <a href="#filepos199024">Primitive Locking: monitor-enter and monitor-exit</a>, <a href="#filepos123985">Suppressing Evaluation: quote</a>, <a href="#filepos127037">Code Blocks: do</a>, <a href="#filepos129097">Defining Vars: def</a>, <a href="#filepos130567">Local Bindings: let</a>, <a href="#filepos137360">Destructuring (let, Part 2)</a>, <a href="#filepos161384">Map destructuring</a>, <a href="#filepos141549">Sequential destructuring</a>, <a href="#filepos148722">Sequential destructuring</a>, <a href="#filepos149075">Map destructuring</a>, <a href="#filepos161384">Map destructuring</a>, <a href="#filepos161507">Creating Functions: fn</a>, <a href="#filepos181349">Function literals</a>, <a href="#filepos169123">Destructuring function arguments</a>, <a href="#filepos176625">Destructuring function arguments</a>, <a href="#filepos181506">Conditionals: if</a>, <a href="#filepos185067">Looping: loop and recur</a>, <a href="#filepos189601">Referring to Vars: var</a>, <a href="#filepos190673">Java Interop: . and new</a>, <a href="#filepos196966">Exception Handling: try and throw</a>, <a href="#filepos198647">Primitive Locking: monitor-enter and monitor-exit</a>, <a href="#filepos844981">What Can Macros Do that Functions Cannot?</a></p><blockquote class="calibre35">code blocks: do, <a href="#filepos127037">Code Blocks: do</a></blockquote><blockquote class="calibre35">conditionals: if, <a href="#filepos181506">Conditionals: if</a></blockquote><blockquote class="calibre35">creating functions: fn, <a href="#filepos161507">Creating Functions: fn</a>, <a href="#filepos181349">Function literals</a>, <a href="#filepos169123">Destructuring function arguments</a>, <a href="#filepos176625">Destructuring function arguments</a></blockquote><blockquote class="calibre35">destructuring function arguments, <a href="#filepos169123">Destructuring function arguments</a>, <a href="#filepos176625">Destructuring function arguments</a></blockquote><blockquote class="calibre35">defining vars: def, <a href="#filepos129097">Defining Vars: def</a></blockquote><blockquote class="calibre35">destructuring, <a href="#filepos137360">Destructuring (let, Part 2)</a>, <a href="#filepos161384">Map destructuring</a>, <a href="#filepos141549">Sequential destructuring</a>, <a href="#filepos148722">Sequential destructuring</a>, <a href="#filepos149075">Map destructuring</a>, <a href="#filepos161384">Map destructuring</a></blockquote><blockquote class="calibre35">map destructuring, <a href="#filepos149075">Map destructuring</a>, <a href="#filepos161384">Map destructuring</a></blockquote><blockquote class="calibre35">sequential, <a href="#filepos141549">Sequential destructuring</a>, <a href="#filepos148722">Sequential destructuring</a></blockquote><blockquote class="calibre35">exception handling: try and throw, <a href="#filepos196966">Exception Handling: try and throw</a></blockquote><blockquote class="calibre35">Java interoperability: . and new special forms, <a href="#filepos190673">Java Interop: . and new</a></blockquote><blockquote class="calibre35">local bindings: let, <a href="#filepos130567">Local Bindings: let</a></blockquote><blockquote class="calibre35">looping: loop and recur, <a href="#filepos185067">Looping: loop and recur</a></blockquote><blockquote class="calibre35">primitive locking: monitor-enter and monitor-exit, <a href="#filepos198647">Primitive Locking: monitor-enter and monitor-exit</a></blockquote><blockquote class="calibre35">referring to vars: var, <a href="#filepos189601">Referring to Vars: var</a></blockquote><blockquote class="calibre35">suppressing evaluation: quote, <a href="#filepos123985">Suppressing Evaluation: quote</a></blockquote><blockquote class="calibre35">versus macros, <a href="#filepos844981">What Can Macros Do that Functions Cannot?</a></blockquote><p class="calibre23">splicing, unquote and unquote-splicing, <a href="#filepos869832">unquote and unquote-splicing</a></p><p class="calibre23">split-with, <a href="#filepos386032">Head retention</a></p><p class="calibre23">SQLite, <a href="#filepos1760183">clojure.java.jdbc</a></p><p class="calibre23">stacks, <a href="#filepos188516">Looping: loop and recur</a>, <a href="#filepos403717">Stack</a>, <a href="#filepos1879938">The “Clojure Stack”</a></p><blockquote class="calibre35">abstractions, <a href="#filepos403717">Stack</a></blockquote><blockquote class="calibre35">Clojure stack, <a href="#filepos1879938">The “Clojure Stack”</a></blockquote><blockquote class="calibre35">space, <a href="#filepos188516">Looping: loop and recur</a></blockquote><p class="calibre23">states, <a href="#filepos33007">Why Clojure?</a>, <a href="#filepos522113">Identifiers and Cycles</a>, <a href="#filepos628063">State and Identity</a>, <a href="#filepos735232">Vars</a>, <a href="#filepos790298">Persisting reference states with an agent-based write-behind log</a>, <a href="#filepos799069">Persisting reference states with an agent-based write-behind log</a>, <a href="#filepos795425">Persisting reference states with an agent-based write-behind log</a></p><blockquote class="calibre35">concurrency and parallelism, <a href="#filepos33007">Why Clojure?</a>, <a href="#filepos628063">State and Identity</a></blockquote><blockquote class="calibre35">logging, <a href="#filepos795425">Persisting reference states with an agent-based write-behind log</a></blockquote><blockquote class="calibre35">numbering, <a href="#filepos522113">Identifiers and Cycles</a></blockquote><blockquote class="calibre35">reference states, <a href="#filepos790298">Persisting reference states with an agent-based write-behind log</a>, <a href="#filepos799069">Persisting reference states with an agent-based write-behind log</a></blockquote><blockquote class="calibre35">vars, <a href="#filepos735232">Vars</a></blockquote><p class="calibre23">static field access, <a href="#filepos195569">Java Interop: . and new</a></p><p class="calibre23">static methods, <a href="#filepos68056">Expressions, Operators, Syntax, and Precedence</a>, <a href="#filepos193763">Java Interop: . and new</a>, <a href="#filepos1368182">gen-class</a></p><blockquote class="calibre35">calls, <a href="#filepos68056">Expressions, Operators, Syntax, and Precedence</a></blockquote><blockquote class="calibre35">gen-class, <a href="#filepos1368182">gen-class</a></blockquote><blockquote class="calibre35">invocation, <a href="#filepos193763">Java Interop: . and new</a></blockquote><p class="calibre23">stepper, <a href="#filepos545424">Revisiting a classic: Conway’s Game of Life</a></p><p class="calibre23">STM (software transactional memory), <a href="#filepos669558">Software Transactional Memory</a>, <a href="#filepos788711">I/O, Transactions, and Nested Sends</a></p><blockquote class="calibre35">about, <a href="#filepos669558">Software Transactional Memory</a></blockquote><blockquote class="calibre35">agents, <a href="#filepos788711">I/O, Transactions, and Nested Sends</a></blockquote><p class="calibre23">strategy pattern, <a href="#filepos1672022">Strategy Pattern</a></p><p class="calibre23">strings, <a href="#filepos80031">Strings</a>, <a href="#filepos234371">Comparing Values to Mutable Objects</a></p><blockquote class="calibre35">about, <a href="#filepos80031">Strings</a></blockquote><blockquote class="calibre35">Ruby, <a href="#filepos234371">Comparing Values to Mutable Objects</a></blockquote><p class="calibre23">struct map, <a href="#filepos978983">Records</a></p><p class="calibre23">structs, maps as ad-hoc structs, <a href="#filepos459946">Maps as ad-hoc structs</a></p><p class="calibre23">structural editing, source code, <a href="#filepos1468533">Introspecting namespaces</a></p><p class="calibre23">structural sharing, <a href="#filepos477639">Persistence and Structural Sharing</a>, <a href="#filepos492450">Tangible benefits</a>, <a href="#filepos479865">Visualizing persistence: lists</a>, <a href="#filepos483235">Visualizing persistence: maps (and vectors and sets)</a>, <a href="#filepos489321">Tangible benefits</a></p><blockquote class="calibre35">benefits, <a href="#filepos489321">Tangible benefits</a></blockquote><blockquote class="calibre35">lists, <a href="#filepos479865">Visualizing persistence: lists</a></blockquote><blockquote class="calibre35">maps, vectors and sets, <a href="#filepos483235">Visualizing persistence: maps (and vectors and sets)</a></blockquote><p class="calibre23">subseq, <a href="#filepos408061">Sorted</a>, <a href="#filepos421802">Comparators and predicates to define ordering</a></p><p class="calibre23">suppressing, evaluations: quote, <a href="#filepos123985">Suppressing Evaluation: quote</a></p><p class="calibre23">swap!, <a href="#filepos647200">Atoms</a></p><p class="calibre23">symbols, <a href="#filepos55529">Expressions, Operators, Syntax, and Precedence</a>, <a href="#filepos85474">Symbols</a>, <a href="#filepos118585">Symbol Evaluation</a>, <a href="#filepos121663">Special Forms</a>, <a href="#filepos441791">Idiomatic Usage</a>, <a href="#filepos895854">Letting the User Pick Names</a>, <a href="#filepos1092952">Hierarchies</a></p><blockquote class="calibre35">about, <a href="#filepos85474">Symbols</a></blockquote><blockquote class="calibre35">evaluation of, <a href="#filepos55529">Expressions, Operators, Syntax, and Precedence</a>, <a href="#filepos118585">Symbol Evaluation</a></blockquote><blockquote class="calibre35">functions, <a href="#filepos121663">Special Forms</a>, <a href="#filepos441791">Idiomatic Usage</a></blockquote><blockquote class="calibre35">hierarchy, <a href="#filepos1092952">Hierarchies</a></blockquote><blockquote class="calibre35">macros, <a href="#filepos895854">Letting the User Pick Names</a></blockquote><p class="calibre23">synchronization, <a href="#filepos642242">Classifying Concurrent Operations</a>, <a href="#filepos788039">I/O, Transactions, and Nested Sends</a></p><blockquote class="calibre35">agents, <a href="#filepos788039">I/O, Transactions, and Nested Sends</a></blockquote><blockquote class="calibre35">concurrency and parallelism, <a href="#filepos642242">Classifying Concurrent Operations</a></blockquote><p class="calibre23">syntax, <a href="#filepos53434">Expressions, Operators, Syntax, and Precedence</a>, <a href="#filepos103251">Miscellaneous Reader Sugar</a>, <a href="#filepos140956">Destructuring (let, Part 2)</a>, <a href="#filepos864899">Syntax</a>, <a href="#filepos874628">unquote and unquote-splicing</a></p><blockquote class="calibre35">about, <a href="#filepos53434">Expressions, Operators, Syntax, and Precedence</a></blockquote><blockquote class="calibre35">for destructuring, <a href="#filepos140956">Destructuring (let, Part 2)</a></blockquote><blockquote class="calibre35">macros, <a href="#filepos864899">Syntax</a>, <a href="#filepos874628">unquote and unquote-splicing</a></blockquote><blockquote class="calibre35">reader, <a href="#filepos103251">Miscellaneous Reader Sugar</a></blockquote><p class="calibre23">syntax-quote versus quote, <a href="#filepos867361">quote Versus syntax-quote</a></p><p class="calibre23">syntax-quoted lists, <a href="#filepos872445">unquote and unquote-splicing</a></p><p class="calibre23">syntax-quoting, <a href="#filepos867755">quote Versus syntax-quote</a></p><p class="calibre23">synthetic keys versus natural keys, <a href="#filepos521013">Identifiers and Cycles</a></p><div class="mbppagebreak"></div><p class="calibre23"><span class="calibre53"><span class="bold">T</span></span></p><p class="calibre46">templating, <a href="#filepos1955608">Templating</a>, <a href="#filepos1986527">Putting everything together</a>, <a href="#filepos1959065">Enlive: Selector-Based HTML Transformation</a>, <a href="#filepos1986527">Putting everything together</a>, <a href="#filepos1960318">Testing the waters</a>, <a href="#filepos1964781">Selectors</a>, <a href="#filepos1969832">Iterating and branching</a>, <a href="#filepos1974706">Putting everything together</a></p><blockquote class="calibre35">Enlive, <a href="#filepos1959065">Enlive: Selector-Based HTML Transformation</a>, <a href="#filepos1986527">Putting everything together</a>, <a href="#filepos1960318">Testing the waters</a>, <a href="#filepos1964781">Selectors</a>, <a href="#filepos1969832">Iterating and branching</a>, <a href="#filepos1974706">Putting everything together</a></blockquote><blockquote class="calibre35">about, <a href="#filepos1960318">Testing the waters</a></blockquote><blockquote class="calibre35">iterating and branching, <a href="#filepos1969832">Iterating and branching</a></blockquote><blockquote class="calibre35">selectors, <a href="#filepos1964781">Selectors</a></blockquote><blockquote class="calibre35">using, <a href="#filepos1974706">Putting everything together</a></blockquote><p class="calibre23">temporaryOutputDirectory, <a href="#filepos1250533">AOT compilation configuration</a></p><p class="calibre23">testing, <a href="#filepos323222">Why Are Pure Functions Interesting?</a>, <a href="#filepos910645">&amp;env</a>, <a href="#filepos927824">Testing Contextual Macros</a>, <a href="#filepos1391129">Producing annotated JUnit tests</a>, <a href="#filepos1584936">Equivalence can preserve your sanity</a>, <a href="#filepos1696031">Testing</a>, <a href="#filepos1756471">Preconditions and Postconditions</a>, <a href="#filepos1697043">Immutable Values and Pure Functions</a>, <a href="#filepos1704113">clojure.test</a>, <a href="#filepos1729957">Fixtures</a>, <a href="#filepos1708995">Defining Tests</a>, <a href="#filepos1714648">Defining Tests</a>, <a href="#filepos1715524">Test “Suites”</a>, <a href="#filepos1720614">Fixtures</a>, <a href="#filepos1733087">Growing an HTML DSL</a>, <a href="#filepos1744640">Growing an HTML DSL</a>, <a href="#filepos1745138">Relying upon Assertions</a></p><blockquote class="calibre35">&amp;env, <a href="#filepos910645">&amp;env</a></blockquote><blockquote class="calibre35">assertions, <a href="#filepos1745138">Relying upon Assertions</a></blockquote><blockquote class="calibre35">clojure.test, <a href="#filepos1704113">clojure.test</a>, <a href="#filepos1729957">Fixtures</a>, <a href="#filepos1708995">Defining Tests</a>, <a href="#filepos1714648">Defining Tests</a>, <a href="#filepos1715524">Test “Suites”</a>, <a href="#filepos1720614">Fixtures</a></blockquote><blockquote class="calibre35">defining tests, <a href="#filepos1708995">Defining Tests</a>, <a href="#filepos1714648">Defining Tests</a></blockquote><blockquote class="calibre35">fixtures, <a href="#filepos1720614">Fixtures</a></blockquote><blockquote class="calibre35">test suites, <a href="#filepos1715524">Test “Suites”</a></blockquote><blockquote class="calibre35">contextual macros, <a href="#filepos927824">Testing Contextual Macros</a></blockquote><blockquote class="calibre35">HTML DSL, <a href="#filepos1733087">Growing an HTML DSL</a>, <a href="#filepos1744640">Growing an HTML DSL</a></blockquote><blockquote class="calibre35">immutable values and pure functions, <a href="#filepos1697043">Immutable Values and Pure Functions</a></blockquote><blockquote class="calibre35">JUnit tests, <a href="#filepos1391129">Producing annotated JUnit tests</a></blockquote><blockquote class="calibre35">mixed floating point equality tests, <a href="#filepos1584936">Equivalence can preserve your sanity</a></blockquote><blockquote class="calibre35">pure functions, <a href="#filepos323222">Why Are Pure Functions Interesting?</a></blockquote><p class="calibre23">thread pools, <a href="#filepos772608">Agents</a>, <a href="#filepos828505">Using Java’s Concurrency Primitives</a></p><blockquote class="calibre35">agents, <a href="#filepos772608">Agents</a></blockquote><blockquote class="calibre35">defined, <a href="#filepos828505">Using Java’s Concurrency Primitives</a></blockquote><p class="calibre23">threading macros, <a href="#filepos936113">In Detail: -&gt; and -&gt;&gt;</a></p><p class="calibre23">threads, <a href="#filepos757797">Dynamic Scope</a>, <a href="#filepos773046">Agents</a></p><blockquote class="calibre35">agents, <a href="#filepos773046">Agents</a></blockquote><blockquote class="calibre35">dynamic scope, <a href="#filepos757797">Dynamic Scope</a></blockquote><p class="calibre23">throw, <a href="#filepos196966">Exception Handling: try and throw</a></p><p class="calibre23">throwing exceptions, <a href="#filepos1310727">Exceptions and Error Handling</a></p><p class="calibre23">time-it, <a href="#filepos1690691">Aspect-Oriented Programming</a></p><p class="calibre23">transactional memory, <a href="#filepos709851">The Sharp Corners of Software Transactional Memory</a>, <a href="#filepos729589">Write skew</a>, <a href="#filepos710339">Side-effecting functions strictly verboten</a>, <a href="#filepos714025">Minimize the scope of each transaction</a>, <a href="#filepos718852">Readers may retry</a>, <a href="#filepos723647">Write skew</a></p><blockquote class="calibre35">readers may retry, <a href="#filepos718852">Readers may retry</a></blockquote><blockquote class="calibre35">side-effecting functions, <a href="#filepos710339">Side-effecting functions strictly verboten</a></blockquote><blockquote class="calibre35">transaction scope, <a href="#filepos714025">Minimize the scope of each transaction</a></blockquote><blockquote class="calibre35">write skew, <a href="#filepos723647">Write skew</a></blockquote><p class="calibre23">transactions, <a href="#filepos677149">The Mechanics of Ref Change</a>, <a href="#filepos686366">Understanding alter</a>, <a href="#filepos686722">Minimizing transaction conflict with commute</a>, <a href="#filepos699750">Minimizing transaction conflict with commute</a>, <a href="#filepos714025">Minimize the scope of each transaction</a>, <a href="#filepos787482">I/O, Transactions, and Nested Sends</a>, <a href="#filepos820785">Using agents to parallelize workloads</a>, <a href="#filepos1773214">Transactions</a></p><blockquote class="calibre35">agents, <a href="#filepos787482">I/O, Transactions, and Nested Sends</a>, <a href="#filepos820785">Using agents to parallelize workloads</a></blockquote><blockquote class="calibre35">clojure.java.jdbc, <a href="#filepos1773214">Transactions</a></blockquote><blockquote class="calibre35">commute, <a href="#filepos686722">Minimizing transaction conflict with commute</a>, <a href="#filepos699750">Minimizing transaction conflict with commute</a></blockquote><blockquote class="calibre35">conflicts, <a href="#filepos686366">Understanding alter</a></blockquote><blockquote class="calibre35">modifications, <a href="#filepos677149">The Mechanics of Ref Change</a></blockquote><blockquote class="calibre35">scope, <a href="#filepos714025">Minimize the scope of each transaction</a></blockquote><p class="calibre23">TRANSACTION_SERIALIZABLE, <a href="#filepos1775580">Transactions</a></p><p class="calibre23">transients, immutability and persistence, <a href="#filepos492605">Transients</a>, <a href="#filepos508819">Transients</a></p><p class="calibre23">transitive dependencies, <a href="#filepos1216925">Dependencies</a></p><p class="calibre23">trap door, <a href="#filepos1297231">Using Java Classes, Methods, and Fields</a></p><p class="calibre23">trees, data structures and persistent semantics, <a href="#filepos486787">Visualizing persistence: maps (and vectors and sets)</a></p><p class="calibre23">true?, <a href="#filepos183961">Conditionals: if</a></p><p class="calibre23">try, <a href="#filepos196966">Exception Handling: try and throw</a>, <a href="#filepos1308606">Exceptions and Error Handling</a></p><p class="calibre23">try-with-resources, <a href="#filepos1316572">with-open, finally’s Lament</a></p><p class="calibre23">tuples, as vectors, <a href="#filepos452324">Vectors as tuples</a></p><p class="calibre23">type definition forms, <a href="#filepos2042973">Choosing Clojure Type Definition Forms Wisely</a></p><p class="calibre23">type hints, <a href="#filepos921642">Preserving user-provided type hints</a>, <a href="#filepos927698">Preserving user-provided type hints</a>, <a href="#filepos1324754">Type Hinting for Performance</a>, <a href="#filepos1335340">Type Hinting for Performance</a>, <a href="#filepos1623519">Automating type hinting of multidimensional array operations</a></p><blockquote class="calibre35">macros and &amp;form, <a href="#filepos921642">Preserving user-provided type hints</a>, <a href="#filepos927698">Preserving user-provided type hints</a></blockquote><blockquote class="calibre35">multidimensional array operations, <a href="#filepos1623519">Automating type hinting of multidimensional array operations</a></blockquote><blockquote class="calibre35">performance, <a href="#filepos1324754">Type Hinting for Performance</a>, <a href="#filepos1335340">Type Hinting for Performance</a></blockquote><p class="calibre23">types, <a href="#filepos33276">Why Clojure?</a>, <a href="#filepos945540">Datatypes and Protocols</a>, <a href="#filepos1123785">type Versus class; or, the Revenge of the Map</a>, <a href="#filepos1529763">Clojure Numerics</a>, <a href="#filepos1600014">Type errors and warnings</a></p><blockquote class="calibre35">(see also datatypes and protocols; reference types)</blockquote><blockquote class="calibre35">about, <a href="#filepos33276">Why Clojure?</a></blockquote><blockquote class="calibre35">errors, <a href="#filepos1600014">Type errors and warnings</a></blockquote><blockquote class="calibre35">multimethods, <a href="#filepos1123785">type Versus class; or, the Revenge of the Map</a></blockquote><blockquote class="calibre35">numerics, <a href="#filepos1529763">Clojure Numerics</a></blockquote><div class="mbppagebreak"></div><p class="calibre23"><span class="calibre53"><span class="bold">U</span></span></p><p class="calibre46">unary operators, <a href="#filepos67873">Expressions, Operators, Syntax, and Precedence</a></p><p class="calibre23">unchecked ops, <a href="#filepos1565100">Unchecked Ops</a></p><p class="calibre23">unchecked-*, <a href="#filepos1567503">Unchecked Ops</a></p><p class="calibre23">*unchecked-math*, <a href="#filepos1568743">Unchecked Ops</a></p><p class="calibre23">uncoordinated operations, <a href="#filepos641907">Classifying Concurrent Operations</a></p><p class="calibre23">underscore (_), <a href="#filepos134226">Local Bindings: let</a>, <a href="#filepos1162109">Namespaces and files</a></p><p class="calibre23">unfettered object state, <a href="#filepos240430">A Critical Choice</a></p><p class="calibre23">Unix, classpath, <a href="#filepos1172208">A classpath primer</a></p><p class="calibre23">unpacking, <a href="#filepos143791">Sequential destructuring</a></p><p class="calibre23">unquote and unquote-splicing, <a href="#filepos869832">unquote and unquote-splicing</a></p><p class="calibre23">unquote-splicing operator, <a href="#filepos871990">unquote and unquote-splicing</a></p><p class="calibre23">uploading via remote REPLs, <a href="#filepos2024809">Running Web Apps Locally</a></p><p class="calibre23">URL shortener, <a href="#filepos1947546">Routing Requests with Compojure</a></p><p class="calibre23">use, <a href="#filepos1141557">Defining and Using Namespaces</a></p><div class="mbppagebreak"></div><p class="calibre23"><span class="calibre53"><span class="bold">V</span></span></p><p class="calibre46">validators, <a href="#filepos664015">Validators</a>, <a href="#filepos701110">Enforcing local consistency by using validators</a></p><blockquote class="calibre35">enforcing local consistency, <a href="#filepos701110">Enforcing local consistency by using validators</a></blockquote><blockquote class="calibre35">notifications and constraints, <a href="#filepos664015">Validators</a></blockquote><p class="calibre23">vals, <a href="#filepos459209">Maps</a></p><p class="calibre23">value semantics, <a href="#filepos979962">Records</a></p><p class="calibre23">values, <a href="#filepos221936">On the Importance of Values</a>, <a href="#filepos245012">A Critical Choice</a>, <a href="#filepos222790">On the Importance of Values</a>, <a href="#filepos224594">About Values</a>, <a href="#filepos226281">Comparing Values to Mutable Objects</a>, <a href="#filepos240312">Comparing Values to Mutable Objects</a>, <a href="#filepos240430">A Critical Choice</a>, <a href="#filepos523278">Identifiers and Cycles</a>, <a href="#filepos1522763">Limitations to Redefining Constructs</a></p><blockquote class="calibre35">about, <a href="#filepos224594">About Values</a>, <a href="#filepos523278">Identifiers and Cycles</a></blockquote><blockquote class="calibre35">comparing to mutable objects, <a href="#filepos226281">Comparing Values to Mutable Objects</a>, <a href="#filepos240312">Comparing Values to Mutable Objects</a></blockquote><blockquote class="calibre35">program state, <a href="#filepos222790">On the Importance of Values</a></blockquote><blockquote class="calibre35">unfettered object state, <a href="#filepos240430">A Critical Choice</a></blockquote><blockquote class="calibre35">versus vars, <a href="#filepos1522763">Limitations to Redefining Constructs</a></blockquote><p class="calibre23">variables, <a href="#filepos112803">Namespaces</a>, <a href="#filepos610167">Promises</a>, <a href="#filepos759352">Vars Are Not Variables</a></p><blockquote class="calibre35">dataflow variables, <a href="#filepos610167">Promises</a></blockquote><blockquote class="calibre35">versus vars, <a href="#filepos112803">Namespaces</a>, <a href="#filepos759352">Vars Are Not Variables</a></blockquote><p class="calibre23">variadic functions, <a href="#filepos169592">Destructuring function arguments</a>, <a href="#filepos359583">Sequences</a></p><p class="calibre23">vars, <a href="#filepos104285">Miscellaneous Reader Sugar</a>, <a href="#filepos111338">Namespaces</a>, <a href="#filepos129097">Defining Vars: def</a>, <a href="#filepos189601">Referring to Vars: var</a>, <a href="#filepos735068">Vars</a>, <a href="#filepos766262">Forward Declarations</a>, <a href="#filepos736765">Defining Vars</a>, <a href="#filepos744547">Constants</a>, <a href="#filepos737669">Private vars</a>, <a href="#filepos739786">Docstrings</a>, <a href="#filepos741958">Constants</a>, <a href="#filepos744661">Dynamic Scope</a>, <a href="#filepos759026">Dynamic Scope</a>, <a href="#filepos749235">Dynamic Scope</a>, <a href="#filepos757451">Dynamic Scope</a>, <a href="#filepos759352">Vars Are Not Variables</a>, <a href="#filepos763173">Forward Declarations</a>, <a href="#filepos902956">Common Macro Idioms and Patterns</a>, <a href="#filepos1448828">Interactive Development</a>, <a href="#filepos1460904">The Bare REPL</a>, <a href="#filepos1522763">Limitations to Redefining Constructs</a></p><blockquote class="calibre35">defined, <a href="#filepos111338">Namespaces</a></blockquote><blockquote class="calibre35">defining, <a href="#filepos129097">Defining Vars: def</a>, <a href="#filepos736765">Defining Vars</a>, <a href="#filepos744547">Constants</a>, <a href="#filepos737669">Private vars</a>, <a href="#filepos739786">Docstrings</a>, <a href="#filepos741958">Constants</a>, <a href="#filepos902956">Common Macro Idioms and Patterns</a></blockquote><blockquote class="calibre35">constants, <a href="#filepos741958">Constants</a></blockquote><blockquote class="calibre35">docstrings, <a href="#filepos739786">Docstrings</a></blockquote><blockquote class="calibre35">private vars, <a href="#filepos737669">Private vars</a></blockquote><blockquote class="calibre35">defonce, <a href="#filepos1448828">Interactive Development</a></blockquote><blockquote class="calibre35">dynamic scope, <a href="#filepos744661">Dynamic Scope</a>, <a href="#filepos759026">Dynamic Scope</a>, <a href="#filepos749235">Dynamic Scope</a>, <a href="#filepos757451">Dynamic Scope</a></blockquote><blockquote class="calibre35">concurrency forms, <a href="#filepos757451">Dynamic Scope</a></blockquote><blockquote class="calibre35">visualizing, <a href="#filepos749235">Dynamic Scope</a></blockquote><blockquote class="calibre35">forward declarations, <a href="#filepos763173">Forward Declarations</a></blockquote><blockquote class="calibre35">REPL-bound vars, <a href="#filepos1460904">The Bare REPL</a></blockquote><blockquote class="calibre35">symbols, <a href="#filepos104285">Miscellaneous Reader Sugar</a>, <a href="#filepos189601">Referring to Vars: var</a></blockquote><blockquote class="calibre35">versus values, <a href="#filepos1522763">Limitations to Redefining Constructs</a></blockquote><blockquote class="calibre35">versus variables, <a href="#filepos759352">Vars Are Not Variables</a></blockquote><p class="calibre23">vary-meta, <a href="#filepos514914">Metadata</a></p><p class="calibre23">vector?, <a href="#filepos452144">Vectors</a></p><p class="calibre23">vectors, <a href="#filepos139957">Destructuring (let, Part 2)</a>, <a href="#filepos146756">Sequential destructuring</a>, <a href="#filepos390405">Associative</a>, <a href="#filepos403149">Indexed</a>, <a href="#filepos451006">Vectors</a>, <a href="#filepos451745">Vectors</a>, <a href="#filepos483235">Visualizing persistence: maps (and vectors and sets)</a>, <a href="#filepos500412">Transients</a>, <a href="#filepos901692">Common Macro Idioms and Patterns</a>, <a href="#filepos1334794">Type Hinting for Performance</a>, <a href="#filepos1734386">Growing an HTML DSL</a></p><blockquote class="calibre35">argument vectors, <a href="#filepos1334794">Type Hinting for Performance</a></blockquote><blockquote class="calibre35">bindings, <a href="#filepos901692">Common Macro Idioms and Patterns</a></blockquote><blockquote class="calibre35">data structure type, <a href="#filepos451006">Vectors</a></blockquote><blockquote class="calibre35">defined, <a href="#filepos451745">Vectors</a></blockquote><blockquote class="calibre35">HTML example, <a href="#filepos1734386">Growing an HTML DSL</a></blockquote><blockquote class="calibre35">indices, <a href="#filepos139957">Destructuring (let, Part 2)</a>, <a href="#filepos390405">Associative</a></blockquote><blockquote class="calibre35">nested, <a href="#filepos146756">Sequential destructuring</a></blockquote><blockquote class="calibre35">nth, <a href="#filepos403149">Indexed</a></blockquote><blockquote class="calibre35">structural sharing, <a href="#filepos483235">Visualizing persistence: maps (and vectors and sets)</a></blockquote><blockquote class="calibre35">transient variants, <a href="#filepos500412">Transients</a></blockquote><p class="calibre23">versioning, <a href="#filepos490742">Tangible benefits</a>, <a href="#filepos1212737">Artifacts and coordinates</a>, <a href="#filepos1219190">Dependencies</a>, <a href="#filepos2035107">Deploying Clojure Apps to Amazon’s Elastic Beanstalk</a></p><blockquote class="calibre35">about, <a href="#filepos490742">Tangible benefits</a></blockquote><blockquote class="calibre35">applications, <a href="#filepos2035107">Deploying Clojure Apps to Amazon’s Elastic Beanstalk</a></blockquote><blockquote class="calibre35">snapshots and release versions, <a href="#filepos1219190">Dependencies</a></blockquote><blockquote class="calibre35">version string, <a href="#filepos1212737">Artifacts and coordinates</a></blockquote><p class="calibre23">views, <a href="#filepos1832665">Views</a>, <a href="#filepos1855046">Views in Clojure</a>, <a href="#filepos1835255">A Simple (JavaScript) View</a>, <a href="#filepos1841465">A Simple (JavaScript) View</a>, <a href="#filepos1841591">Views in Clojure</a>, <a href="#filepos1855046">Views in Clojure</a></p><blockquote class="calibre35">Clojure, <a href="#filepos1841591">Views in Clojure</a>, <a href="#filepos1855046">Views in Clojure</a></blockquote><blockquote class="calibre35">JavaScript, <a href="#filepos1835255">A Simple (JavaScript) View</a>, <a href="#filepos1841465">A Simple (JavaScript) View</a></blockquote><div class="mbppagebreak"></div><p class="calibre23"><span class="calibre53"><span class="bold">W</span></span></p><p class="calibre46">*warn-on-reflection*, <a href="#filepos1600853">Type errors and warnings</a>, <a href="#filepos1629674">Automating type hinting of multidimensional array operations</a></p><p class="calibre23">warnings, primitives, <a href="#filepos1600014">Type errors and warnings</a></p><p class="calibre23">warnOnReflection, <a href="#filepos1250488">AOT compilation configuration</a></p><p class="calibre23">watches, notifications and constraints, <a href="#filepos655948">Watches</a>, <a href="#filepos663904">Watches</a></p><p class="calibre23">web, <a href="#filepos1878980">Clojure and the Web</a>, <a href="#filepos1990515">Final Thoughts</a>, <a href="#filepos1879938">The “Clojure Stack”</a>, <a href="#filepos1887327">The Foundation: Ring</a>, <a href="#filepos1916018">Middleware</a>, <a href="#filepos1888867">Requests and Responses</a>, <a href="#filepos1902480">Adapters</a>, <a href="#filepos1905874">Handlers</a>, <a href="#filepos1910280">Middleware</a>, <a href="#filepos1918723">Routing Requests with Compojure</a>, <a href="#filepos1951020">Routing Requests with Compojure</a>, <a href="#filepos1955608">Templating</a>, <a href="#filepos1986527">Putting everything together</a>, <a href="#filepos1959065">Enlive: Selector-Based HTML Transformation</a>, <a href="#filepos1986527">Putting everything together</a>, <a href="#filepos1991606">Deploying Clojure Web Applications</a>, <a href="#filepos2042728">Going Beyond Simple Web Application Deployment</a>, <a href="#filepos1992445">Java and Clojure Web Architecture</a>, <a href="#filepos2018301">Building .war files with Leiningen</a>, <a href="#filepos2000317">Web Application Packaging</a>, <a href="#filepos2018301">Building .war files with Leiningen</a>, <a href="#filepos2022865">Running Web Apps Locally</a>, <a href="#filepos2025777">Web Application Deployment</a>, <a href="#filepos2036963">Deploying Clojure Apps to Amazon’s Elastic Beanstalk</a>, <a href="#filepos2027807">Deploying Clojure Apps to Amazon’s Elastic Beanstalk</a>, <a href="#filepos2036963">Deploying Clojure Apps to Amazon’s Elastic Beanstalk</a>, <a href="#filepos2041294">Going Beyond Simple Web Application Deployment</a></p><blockquote class="calibre35">beyond simple web application deployment, <a href="#filepos2041294">Going Beyond Simple Web Application Deployment</a></blockquote><blockquote class="calibre35">Clojure stack, <a href="#filepos1879938">The “Clojure Stack”</a></blockquote><blockquote class="calibre35">Java, <a href="#filepos1992445">Java and Clojure Web Architecture</a>, <a href="#filepos2018301">Building .war files with Leiningen</a>, <a href="#filepos2000317">Web Application Packaging</a>, <a href="#filepos2018301">Building .war files with Leiningen</a></blockquote><blockquote class="calibre35">web application packaging, <a href="#filepos2000317">Web Application Packaging</a>, <a href="#filepos2018301">Building .war files with Leiningen</a></blockquote><blockquote class="calibre35">Ring, <a href="#filepos1887327">The Foundation: Ring</a>, <a href="#filepos1916018">Middleware</a>, <a href="#filepos1888867">Requests and Responses</a>, <a href="#filepos1902480">Adapters</a>, <a href="#filepos1905874">Handlers</a>, <a href="#filepos1910280">Middleware</a></blockquote><blockquote class="calibre35">adapters, <a href="#filepos1902480">Adapters</a></blockquote><blockquote class="calibre35">handlers, <a href="#filepos1905874">Handlers</a></blockquote><blockquote class="calibre35">middleware, <a href="#filepos1910280">Middleware</a></blockquote><blockquote class="calibre35">requests and responses, <a href="#filepos1888867">Requests and Responses</a></blockquote><blockquote class="calibre35">routing requests, <a href="#filepos1918723">Routing Requests with Compojure</a>, <a href="#filepos1951020">Routing Requests with Compojure</a></blockquote><blockquote class="calibre35">templating, <a href="#filepos1955608">Templating</a>, <a href="#filepos1986527">Putting everything together</a>, <a href="#filepos1959065">Enlive: Selector-Based HTML Transformation</a>, <a href="#filepos1986527">Putting everything together</a></blockquote><blockquote class="calibre35">Enlive, <a href="#filepos1959065">Enlive: Selector-Based HTML Transformation</a>, <a href="#filepos1986527">Putting everything together</a></blockquote><blockquote class="calibre35">web application deployment, <a href="#filepos2025777">Web Application Deployment</a>, <a href="#filepos2036963">Deploying Clojure Apps to Amazon’s Elastic Beanstalk</a>, <a href="#filepos2027807">Deploying Clojure Apps to Amazon’s Elastic Beanstalk</a>, <a href="#filepos2036963">Deploying Clojure Apps to Amazon’s Elastic Beanstalk</a></blockquote><blockquote class="calibre35">EB, <a href="#filepos2027807">Deploying Clojure Apps to Amazon’s Elastic Beanstalk</a>, <a href="#filepos2036963">Deploying Clojure Apps to Amazon’s Elastic Beanstalk</a></blockquote><blockquote class="calibre35">web apps, <a href="#filepos2022865">Running Web Apps Locally</a></blockquote><p class="calibre23">web app, <a href="#filepos1997441">Java and Clojure Web Architecture</a></p><p class="calibre23">web crawlers, <a href="#filepos800010">Using agents to parallelize workloads</a></p><p class="calibre23">when-let, <a href="#filepos183709">Conditionals: if</a></p><p class="calibre23">where, <a href="#filepos1789667">Queries</a></p><p class="calibre23">white space, <a href="#filepos100741">Whitespace and Commas</a></p><p class="calibre23">why Clojure, <a href="#filepos29976">Why Clojure?</a></p><p class="calibre23">wildcard import, <a href="#filepos1156132">Defining and Using Namespaces</a></p><p class="calibre23">Wilson’s algorithm, <a href="#filepos560334">Maze generation</a></p><p class="calibre23">with, <a href="#filepos1788832">Queries</a></p><p class="calibre23">with-connection, <a href="#filepos1776470">Connection Pooling</a></p><p class="calibre23">with-meta, <a href="#filepos514884">Metadata</a></p><p class="calibre23">with-open, <a href="#filepos1315295">with-open, finally’s Lament</a>, <a href="#filepos1811877">Removing Boilerplate</a></p><p class="calibre23">with-precision, <a href="#filepos1571870">Scale and Rounding Modes for Arbitrary-Precision Decimals Ops</a></p><p class="calibre23">with-query-results, <a href="#filepos1766043">clojure.java.jdbc</a>, <a href="#filepos1768147">with-query-results Explained</a></p><p class="calibre23">with-redefs, <a href="#filepos762780">Vars Are Not Variables</a>, <a href="#filepos1700266">Mocking</a></p><p class="calibre23">workflow, Emacs, <a href="#filepos1482261">inferior-lisp</a></p><p class="calibre23">workloads, agents, <a href="#filepos799178">Using agents to parallelize workloads</a>, <a href="#filepos820785">Using agents to parallelize workloads</a></p><p class="calibre23">write skew, <a href="#filepos723647">Write skew</a></p><p class="calibre23">write-behind log, <a href="#filepos790298">Persisting reference states with an agent-based write-behind log</a>, <a href="#filepos799069">Persisting reference states with an agent-based write-behind log</a></p><div class="mbppagebreak"></div><p class="calibre23"><span class="calibre53"><span class="bold">Z</span></span></p><p class="calibre46">zero-arg arity, <a href="#filepos170546">Destructuring function arguments</a></p><p class="calibre23">zippers, <a href="#filepos569681">Navigation, Update, and Zippers</a>, <a href="#filepos587550">Ariadne’s zipper</a>, <a href="#filepos570901">Manipulating zippers</a>, <a href="#filepos575517">Custom zippers</a>, <a href="#filepos578674">Ariadne’s zipper</a></p><blockquote class="calibre35">Ariadne’s, <a href="#filepos578674">Ariadne’s zipper</a></blockquote><blockquote class="calibre35">custom, <a href="#filepos575517">Custom zippers</a></blockquote><blockquote class="calibre35">manipulating, <a href="#filepos570901">Manipulating zippers</a></blockquote><div class="mbppagebreak"></div><p id="filepos2350943" class="calibre6"><span class="calibre4"><span class="bold">About the Authors</span></span></p><p class="calibre18">Chas Emerick is the founder of Snowtide Informatics, a small software company in Western Massachusetts. Since 2008, he has helped to develop the core Clojure language and many Clojure open source projects. Chas writes about Clojure, software development practices, entrepreneurship, and other passions at cemerick.com.</p><p class="calibre18">Brian Carper is a professional programmer in the field of psychological research. He uses Clojure for data analysis and web development. He's the author of a Clojure-to-CSS compiler and relational database library, and writes about Clojure and other topics at <a href="http://briancarper.net">http://briancarper.net</a>.</p><p class="calibre18">Christophe Grand is an independent consultant, based near Lyon, France. He tutors, trains and codes primarily in Clojure. A participant in developing the core Clojure language, he also authored the Enlive and Moustache libaries and is a contributor to Counterclockwise, the Clojure IDE for Eclipse. Christophe writes on Clojure at clj-me.cgrand.net.</p><div class="mbppagebreak"></div><p id="filepos2352120" class="calibre6"><span class="calibre4"><span class="bold">Colophon</span></span></p><p class="calibre18">The animal on the cover of <span class="italic">Clojure Programming</span> is a painted snipe. The painted snipes (family Rostratulidae) comprise three species: the Greater Painted Snipe, the Australian Painted Snipe, and the South American Painted Snipe.</p><p class="calibre18">These shorebirds are distinct from the true snipes, and, as their name implies, also much more colorful. They may be more closely related to jacanas or sandpipers. Painted snipe live in marshes, swamps, and other wetlands, and they eat a varied diet of seeds, rice, millet, insects, snails, and crustaceans. They are solitary and “skulking,” except during breeding season, so they are difficult to spot.</p><p class="calibre18">The Greater Painted Snipe (<span class="italic">Rostratula benghalensis</span>) lives in Africa, India, and Southeast Asia. The Australian Painted Snipe (<span class="italic">R. australis</span>), long considered a subspecies, is found only in Australia and is classified as endangered. These two species of painted snipe exhibit an unusual sexual dimorphism, with the females larger and more brightly colored than the males. They are polyandrous, with the female courting several males, and the males take responsibility for incubating the eggs and raising the chicks.</p><p class="calibre18">The South American Painted Snipe (<span class="italic">Nycticryptes semicollaris</span>) is found in the southern parts of that continent. It can be distinguished from the other painted snipes by its webbed toes. The South American Painted Snipe mates monogamously and doesn’t display the same degree of sexual dimorphism as the Greater and Australian species. It is hunted for food in Chile and Argentina.</p><p class="calibre18">The cover image is from <span class="italic">Riverside Natural History</span>. The cover font is Adobe ITC Garamond. The text font is Linotype Birka; the heading font is Adobe Myriad Condensed; and the code font is LucasFont’s TheSansMonoCondensed.</p><div class="mbppagebreak"></div><p id="filepos2354149" class="calibre54"><span class="calibre2"><span class="bold">Table of Contents</span></span></p><p class="calibre127"><a href="#filepos109">Clojure Programming</a></p><p class="calibre128"><a href="#filepos2808">Preface</a></p><blockquote class="calibre37"><a href="#filepos4892">Who Is This Book For?</a></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos5859">Engaged Java Developers</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos7027">Ruby, Python, and Other Developers</a></blockquote></blockquote></blockquote><blockquote class="calibre37"><a href="#filepos8871">How to Read This Book</a></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos10236">Start with Practical Applications of Clojure</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos11120">Start from the Ground Up with Clojure’s Foundational Concepts</a></blockquote></blockquote></blockquote><blockquote class="calibre37"><a href="#filepos12050">Who’s “We”?</a></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos12443">Chas Emerick</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos13573">Brian Carper</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos14402">Christophe Grand</a></blockquote></blockquote></blockquote><blockquote class="calibre37"><a href="#filepos15480">Acknowledgments</a></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos17518">And Last, but Certainly Far from Least</a></blockquote></blockquote></blockquote><blockquote class="calibre37"><a href="#filepos21058">Conventions Used in This Book</a></blockquote><blockquote class="calibre37"><a href="#filepos23066">Using Code Examples</a></blockquote><blockquote class="calibre37"><a href="#filepos24450">Safari® Books Online</a></blockquote><blockquote class="calibre37"><a href="#filepos25784">How to Contact Us</a></blockquote><p class="calibre128"><a href="#filepos28661">1. Down the Rabbit Hole</a></p><blockquote class="calibre37"><a href="#filepos29903">Why Clojure?</a></blockquote><blockquote class="calibre37"><a href="#filepos34110">Obtaining Clojure</a></blockquote><blockquote class="calibre37"><a href="#filepos37449">The Clojure REPL</a></blockquote><blockquote class="calibre37"><a href="#filepos49081">No, Parentheses Actually Won’t Make You Go Blind</a></blockquote><blockquote class="calibre37"><a href="#filepos53327">Expressions, Operators, Syntax, and Precedence</a></blockquote><blockquote class="calibre37"><a href="#filepos69475">Homoiconicity</a></blockquote><blockquote class="calibre37"><a href="#filepos76368">The Reader</a></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos79505">Scalar Literals</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos79919">Strings</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos80622">Booleans</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos80894">nil</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos81200">Characters</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos82628">Keywords</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos85406">Symbols</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos86771">Numbers</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos94923">Regular expressions</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos96859">Comments</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos100630">Whitespace and Commas</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos102257">Collection Literals</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos103135">Miscellaneous Reader Sugar</a></blockquote></blockquote></blockquote><blockquote class="calibre37"><a href="#filepos109342">Namespaces</a></blockquote><blockquote class="calibre37"><a href="#filepos118507">Symbol Evaluation</a></blockquote><blockquote class="calibre37"><a href="#filepos121508">Special Forms</a></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos123823">Suppressing Evaluation: quote</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos126892">Code Blocks: do</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos128989">Defining Vars: def</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos130417">Local Bindings: let</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos137243">Destructuring (let, Part 2)</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos141464">Sequential destructuring</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos148997">Map destructuring</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos161395">Creating Functions: fn</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos168988">Destructuring function arguments</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos176636">Function literals</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos181360">Conditionals: if</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos184954">Looping: loop and recur</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos189489">Referring to Vars: var</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos190560">Java Interop: . and new</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos196843">Exception Handling: try and throw</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos197231">Specialized Mutation: set!</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos198508">Primitive Locking: monitor-enter and monitor-exit</a></blockquote></blockquote></blockquote><blockquote class="calibre37"><a href="#filepos206399">Putting It All Together</a></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos208576">eval</a></blockquote></blockquote></blockquote><blockquote class="calibre37"><a href="#filepos212898">This Is Just the Beginning</a></blockquote><p class="calibre128"><a href="#filepos215548">I. Functional Programming and Concurrency</a></p><blockquote class="calibre37"><a href="#filepos215673">2. Functional Programming</a></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos218380">What Does Functional Programming Mean?</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos221848">On the Importance of Values</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos224492">About Values</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos226156">Comparing Values to Mutable Objects</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos240323">A Critical Choice</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos250238">First-Class and Higher-Order Functions</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos268007">Applying Ourselves Partially</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos284265">Composition of Function(ality)</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos294075">Writing Higher-Order Functions</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos296083">Building a Primitive Logging System with Composable Higher-Order Functions</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos316677">Pure Functions</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos322001">Why Are Pure Functions Interesting?</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos332912">Functional Programming in the Real World</a></blockquote></blockquote></blockquote><blockquote class="calibre37"><a href="#filepos335797">3. Collections and Data Structures</a></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos337805">Abstractions over Implementations</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos347205">Collection</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos354167">Sequences</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos361409">Sequences are not iterators</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos363075">Sequences are not lists</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos366032">Creating seqs</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos368238">Lazy seqs</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos385225">Head retention</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos387941">Associative</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos396484">Beware of nil values</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos399483">Indexed</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos403580">Stack</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos405763">Set</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos407075">Sorted</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos412578">Comparators and predicates to define ordering</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos438207">Concise Collection Access</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos441214">Idiomatic Usage</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos443204">Collections and Keys and Higher-Order Functions</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos447245">Data Structure Types</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos447909">Lists</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos450909">Vectors</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos452246">Vectors as tuples</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos455372">Sets</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos457623">Maps</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos459863">Maps as ad-hoc structs</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos462899">Other usages of maps</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos473960">Immutability and Persistence</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos477515">Persistence and Structural Sharing</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos479774">Visualizing persistence: lists</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos483122">Visualizing persistence: maps (and vectors and sets)</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos489242">Tangible benefits</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos492461">Transients</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos512813">Metadata</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos518281">Putting Clojure’s Collections to Work</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos519938">Identifiers and Cycles</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos525195">Thinking Different: From Imperative to Functional</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos525789">Revisiting a classic: Conway’s Game of Life</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos547026">Maze generation</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos569560">Navigation, Update, and Zippers</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos570771">Manipulating zippers</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos575442">Custom zippers</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos578595">Ariadne’s zipper</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos593244">In Summary</a></blockquote></blockquote></blockquote><blockquote class="calibre37"><a href="#filepos593810">4. Concurrency and Parallelism</a></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos596870">Shifting Computation Through Time and Space</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos597315">Delays</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos603325">Futures</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos608843">Promises</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos618299">Parallelism on the Cheap</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos627984">State and Identity</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos636143">Clojure Reference Types</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos640580">Classifying Concurrent Operations</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos646665">Atoms</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos655203">Notifications and Constraints</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos655851">Watches</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos663915">Validators</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos668316">Refs</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos669439">Software Transactional Memory</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos672522">The Mechanics of Ref Change</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos681623">Understanding alter</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos686617">Minimizing transaction conflict with commute</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos699770">Clobbering ref state with ref-set</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos701002">Enforcing local consistency by using validators</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos709711">The Sharp Corners of Software Transactional Memory</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos710236">Side-effecting functions strictly verboten</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos713926">Minimize the scope of each transaction</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos718774">Readers may retry</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos723576">Write skew</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos735003">Vars</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos736662">Defining Vars</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos737596">Private vars</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos739715">Docstrings</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos741888">Constants</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos744558">Dynamic Scope</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos759240">Vars Are Not Variables</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos763063">Forward Declarations</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos768750">Agents</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos779110">Dealing with Errors in Agent Actions</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos784066">Agent error handlers and modes</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos787357">I/O, Transactions, and Nested Sends</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos790173">Persisting reference states with an agent-based write-behind log</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos799080">Using agents to parallelize workloads</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos826361">Using Java’s Concurrency Primitives</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos829168">Locking</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos830923">Final Thoughts</a></blockquote></blockquote></blockquote><p class="calibre128"><a href="#filepos831397">II. Building Abstractions</a></p><blockquote class="calibre37"><a href="#filepos831506">5. Macros</a></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos833173">What Is a Macro?</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos838619">What Macros Are Not</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos840872">What Can Macros Do that Functions Cannot?</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos846315">Macros Versus Ruby eval</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos852324">Writing Your First Macro</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos857150">Debugging Macros</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos858993">Macroexpansion</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos864832">Syntax</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos867246">quote Versus syntax-quote</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos869714">unquote and unquote-splicing</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos876175">When to Use Macros</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos881435">Hygiene</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos885897">Gensyms to the Rescue</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos894757">Letting the User Pick Names</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos896511">Double Evaluation</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos901078">Common Macro Idioms and Patterns</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos905889">The Implicit Arguments: &amp;env and &amp;form</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos906323">&amp;env</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos913413">&amp;form</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos914343">Producing useful macro error messages</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos921546">Preserving user-provided type hints</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos927709">Testing Contextual Macros</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos935751">In Detail: -&gt; and -&gt;&gt;</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos944637">Final Thoughts</a></blockquote></blockquote></blockquote><blockquote class="calibre37"><a href="#filepos945443">6. Datatypes and Protocols</a></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos948323">Protocols</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos955552">Extending to Existing Types</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos967758">Defining Your Own Types</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos977618">Records</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos988434">Constructors and factory functions</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos993043">When to use maps or records</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos995374">Types</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1007944">Implementing Protocols</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1011033">Inline Implementation</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1015392">Inline implementations of Java interfaces</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1019348">Defining anonymous types with reify</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1023003">Reusing Implementations</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1036465">Protocol Introspection</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1039878">Protocol Dispatch Edge Cases</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1046777">Participating in Clojure’s Collection Abstractions</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1072817">Final Thoughts</a></blockquote></blockquote></blockquote><blockquote class="calibre37"><a href="#filepos1073489">7. Multimethods</a></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1074974">Multimethods Basics</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1084633">Toward Hierarchies</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1091657">Hierarchies</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1099597">Independent Hierarchies</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1112040">Making It Really Multiple!</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1118426">A Few More Things</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1118504">Multiple Inheritance</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1121420">Introspecting Multimethods</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1123608">type Versus class; or, the Revenge of the Map</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1126997">The Range of Dispatch Functions Is Unlimited</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1131345">Final Thoughts</a></blockquote></blockquote></blockquote><p class="calibre128"><a href="#filepos1132485">III. Tools, Platform, and Projects</a></p><blockquote class="calibre37"><a href="#filepos1132603">8. Organizing and Building Clojure Projects</a></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1134167">Project Geography</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1134534">Defining and Using Namespaces</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1160956">Namespaces and files</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1168529">A classpath primer</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1173679">Location, Location, Location</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1177845">The Functional Organization of Clojure Codebases</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1180795">Basic project organization principles</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1192042">Build</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1199448">Ahead-of-Time Compilation</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1205713">Dependency Management</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1207197">The Maven Dependency Management Model</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1208273">Artifacts and coordinates</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1213411">Repositories</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1216038">Dependencies</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1228252">Build Tools and Configuration Patterns</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1230538">Maven</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1238499">Leiningen</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1247107">AOT compilation configuration</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1252908">Building mixed-source projects</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1273658">Final Thoughts</a></blockquote></blockquote></blockquote><blockquote class="calibre37"><a href="#filepos1274079">9. Java and JVM Interoperability</a></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1276887">The JVM Is Clojure’s Foundation</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1282446">Using Java Classes, Methods, and Fields</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1300556">Handy Interop Utilities</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1306175">Exceptions and Error Handling</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1313278">Escaping Checked Exceptions</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1315176">with-open, finally’s Lament</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1324665">Type Hinting for Performance</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1336318">Arrays</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1343728">Defining Classes and Implementing Interfaces</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1352402">Instances of Anonymous Classes: proxy</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1362472">Defining Named Classes</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1364637">gen-class</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1389148">Annotations</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1391036">Producing annotated JUnit tests</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1396434">Implementing JAX-RS web service endpoints</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1408219">Using Clojure from Java</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1420028">Using deftype and defrecord Classes</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1429258">Implementing Protocol Interfaces</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1437114">Collaborating Partners</a></blockquote></blockquote></blockquote><blockquote class="calibre37"><a href="#filepos1437663">10. REPL-Oriented Programming</a></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1439418">Interactive Development</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1451167">The Persistent, Evolving Environment</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1458065">Tooling</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1460286">The Bare REPL</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1464944">Introspecting namespaces</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1470103">Eclipse</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1474302">Emacs</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1479259">clojure-mode and paredit</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1480365">inferior-lisp</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1486252">SLIME</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1502723">Debugging, Monitoring, and Patching Production in the REPL</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1514374">Special Considerations for “Deployed” REPLs</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1518975">Limitations to Redefining Constructs</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1526786">In Summary</a></blockquote></blockquote></blockquote><p class="calibre128"><a href="#filepos1527345">IV. Practicums</a></p><blockquote class="calibre37"><a href="#filepos1527443">11. Numerics and Mathematics</a></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1528941">Clojure Numerics</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1537800">Clojure Prefers 64-bit (or Larger) Representations</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1538811">Clojure Has a Mixed Numerics Model</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1546739">Rationals</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1549226">The Rules of Numeric Contagion</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1556474">Clojure Mathematics</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1557089">Bounded Versus Arbitrary Precision</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1564954">Unchecked Ops</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1570537">Scale and Rounding Modes for Arbitrary-Precision Decimals Ops</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1575967">Equality and Equivalence</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1576207">Object Identity (identical?)</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1578328">Reference Equality (=)</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1581236">Numeric Equivalence (==)</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1583249">Equivalence can preserve your sanity</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1588398">Optimizing Numeric Performance</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1591810">Declare Functions to Take and Return Primitives</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1599929">Type errors and warnings</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1605156">Use Primitive Arrays Judiciously</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1610684">The mechanics of primitive arrays</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1623398">Automating type hinting of multidimensional array operations</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1634180">Visualizing the Mandelbrot Set in Clojure</a></blockquote></blockquote></blockquote><blockquote class="calibre37"><a href="#filepos1656269">12. Design Patterns</a></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1662597">Dependency Injection</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1671945">Strategy Pattern</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1674973">Chain of Responsibility</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1682627">Aspect-Oriented Programming</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1695309">Final Thoughts</a></blockquote></blockquote></blockquote><blockquote class="calibre37"><a href="#filepos1695949">13. Testing</a></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1696947">Immutable Values and Pure Functions</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1698179">Mocking</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1703991">clojure.test</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1708891">Defining Tests</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1715417">Test “Suites”</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1720516">Fixtures</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1733007">Growing an HTML DSL</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1745054">Relying upon Assertions</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1750353">Preconditions and Postconditions</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre37"><a href="#filepos1757595">14. Using Relational Databases</a></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1758793">clojure.java.jdbc</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1767974">with-query-results Explained</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1773112">Transactions</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1776310">Connection Pooling</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1782878">Korma</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1783806">Prelude</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1788119">Queries</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1791091">Why Bother with a DSL?</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1798802">Hibernate</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1799580">Setup</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1807482">Persisting Data</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1809055">Running Queries</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1811316">Removing Boilerplate</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1819329">Final Thoughts</a></blockquote></blockquote></blockquote><blockquote class="calibre37"><a href="#filepos1819820">15. Using Nonrelational Databases</a></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1822730">Getting Set Up with CouchDB and Clutch</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1825622">Basic CRUD Operations</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1832599">Views</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1835139">A Simple (JavaScript) View</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1841485">Views in Clojure</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1857861">_changes: Abusing CouchDB as a Message Queue</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1864725">À la Carte Message Queues</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1878169">Final Thoughts</a></blockquote></blockquote></blockquote><blockquote class="calibre37"><a href="#filepos1878886">16. Clojure and the Web</a></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1879854">The “Clojure Stack”</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1887246">The Foundation: Ring</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1888755">Requests and Responses</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1902382">Adapters</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1905776">Handlers</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1910180">Middleware</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1918631">Routing Requests with Compojure</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1955537">Templating</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1958790">Enlive: Selector-Based HTML Transformation</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1960239">Testing the waters</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1964711">Selectors</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1969748">Iterating and branching</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1974573">Putting everything together</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1987734">Final Thoughts</a></blockquote></blockquote></blockquote><blockquote class="calibre37"><a href="#filepos1991497">17. Deploying Clojure Web Applications</a></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos1992351">Java and Clojure Web Architecture</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos2000202">Web Application Packaging</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos2006010">Building .war files with Maven</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos2012970">Building .war files with Leiningen</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos2022780">Running Web Apps Locally</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos2025690">Web Application Deployment</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos2027663">Deploying Clojure Apps to Amazon’s Elastic Beanstalk</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos2041187">Going Beyond Simple Web Application Deployment</a></blockquote></blockquote></blockquote><p class="calibre128"><a href="#filepos2042755">V. Miscellanea</a></p><blockquote class="calibre37"><a href="#filepos2042853">18. Choosing Clojure Type Definition Forms Wisely</a></blockquote><blockquote class="calibre37"><a href="#filepos2048261">19. Introducing Clojure into Your Workplace</a></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos2049520">Just the Facts…</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos2056378">Emphasize Productivity</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos2060884">Emphasize Community</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos2068030">Be Prudent</a></blockquote></blockquote></blockquote><blockquote class="calibre37"><a href="#filepos2070122">20. What’s Next?</a></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos2071096">(dissoc Clojure 'JVM)</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos2071445">ClojureCLR</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos2072318">ClojureScript</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos2076265">4Clojure</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos2077191">Overtone</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos2079334">core.logic</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos2083987">Pallet</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos2085824">Avout</a></blockquote></blockquote></blockquote><blockquote class="calibre100"><blockquote class="calibre100"><blockquote class="calibre37"><a href="#filepos2086843">Clojure on Heroku</a></blockquote></blockquote></blockquote><p class="calibre128"><a href="#filepos2088829">Index</a></p><p class="calibre128"><a href="#filepos2350943">About the Authors</a></p><p class="calibre128"><a href="#filepos2352120">Colophon</a></p><div class="mbppagebreak"></div><a></a>
<a></a>
<a></a></div>

{% endraw %}

