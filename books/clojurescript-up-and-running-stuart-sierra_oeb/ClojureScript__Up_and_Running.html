---
layout: page
title: "ClojureScript: Up and Running"
prev: None
next: None
book_path: books/clojurescript-up-and-running-stuart-sierra_oeb/
---
{% include JB/setup %}
{% raw %}
<div>
<p id="filepos109" class="calibre1"><span class="calibre2"><span class="bold">ClojureScript: Up and Running</span></span></p><p class="calibre1"><span class="calibre2"><span class="bold"><span class="calibre3">Stuart Sierra</span></span></span></p><p class="calibre1"><span class="calibre2"><span class="bold"><span class="calibre3">Luke VanderHart</span></span></span></p><p class="calibre4"><span class="calibre5">Published by O’Reilly Media</span><br class="calibre6"/></p><p class="calibre7"><img src="images/00001.jpg" class="calibre8"/></p><p class="calibre9"><span class="calibre10">Beijing ⋅ Cambridge ⋅ Farnham ⋅ Köln ⋅ Sebastopol ⋅ Tokyo</span></p><div class="mbppagebreak"></div><p id="filepos829" class="calibre11"><span class="calibre2"><span class="bold">Preface</span></span></p><p id="filepos897" class="calibre11"><span class="calibre12"><span class="bold">Who Should Read This Book</span></span></p><p class="calibre13">This book is for software developers who want to learn how to get started using ClojureScript to build web browser applications. This book will not assume any prior knowledge of ClojureScript. We do assume that you have at least a basic working knowledge of the core JavaScript language. For the sections of this book that deal with ClojureScript in a web browser, we assume you are familiar with HTML, CSS, the DOM, and how they are manipulated in JavaScript.</p><p class="calibre13">While this book will not assume any prior knowledge of Clojure, it is not designed to be a comprehensive reference to the Clojure programming language. We will explain Clojure language concepts in ClojureScript as they become important, but we also recommend picking up a book on Clojure for a more thorough guide to the language. The authors of this book wrote <span class="italic">Practical Clojure</span> (Apress, 2010) and O’Reilly has released <a href="http://oreil.ly/Clojure_Programming"><span class="italic"><span class="calibre3">Clojure Programming</span></span></a> by our friends Chas Emerick, Brian Carper, and Christophe Grand.</p><p id="filepos2107" class="calibre11"><span class="calibre12"><span class="bold">How to Use This Book</span></span></p><p class="calibre13">This book is both a how-to guide for using ClojureScript and a tutorial on the language itself. We have arranged the chapters in what we felt was the best order for someone who is completely new to the language but wants to get started quickly. If you already know Clojure or ClojureScript and just want advice on development tools and workflow, focus on Chapters 2, 3, 7, 9, and 10. If you want to dive into the language right away, start with Chapters 4 through 6 before reading about the development process.</p><p class="calibre14"><a href="#filepos14967"><span class="calibre3">Chapter 1, Introduction: Why ClojureScript?</span></a></p><blockquote class="calibre15">In this chapter, we lay out the motivation for ClojureScript: why it exists and what role it is designed to fill.</blockquote><p class="calibre14"><a href="#filepos23106"><span class="calibre3">Chapter 2, Hello World</span></a></p><blockquote class="calibre15">In this chapter, we work through a complete, albeit trivial, ClojureScript application. We introduce Leiningen, the lein-cljsbuild plug-in, and how to use ClojureScript in an HTML page. We save explanation for later chapters, but this chapter should be enough to get your first ClojureScript code “up and running.”</blockquote><p class="calibre14"><a href="#filepos45583"><span class="calibre3">Chapter 3, The Compilation Process</span></a></p><blockquote class="calibre15">This chapter goes into the ClojureScript compiler in detail, explaining how it works, most of the configuration options it supports, and how it integrates with the Google Closure Compiler.</blockquote><p class="calibre13">Chapters 4 through 6 cover the basics of the ClojureScript language itself. Although not a complete guide to every corner of the language, they cover most of the features that are required for everyday programming. Because ClojureScript and Clojure are so similar, we recommend books about Clojure to learn more about the language.</p><p class="calibre14"><a href="#filepos83077"><span class="calibre3">Chapter 4, ClojureScript Basics</span></a></p><blockquote class="calibre15">This chapter introduces the essential syntax and control structures of the ClojureScript language including functions, bindings, scope, and interoperation with JavaScript.</blockquote><p class="calibre14"><a href="#filepos127395"><span class="calibre3">Chapter 5, Data and State</span></a></p><blockquote class="calibre15">This chapter covers the primitive and composite data structures of ClojureScript, and shows how to work with them in programs. In particular, it explains ClojureScript’s approach to immutability and state management.</blockquote><p class="calibre14"><a href="#filepos164179"><span class="calibre3">Chapter 6, Sequences</span></a></p><blockquote class="calibre15">This chapter introduces Lazy Sequences, an important data structure in ClojureScript that makes up a substantial portion of the standard library.</blockquote><p class="calibre14"><a href="#filepos179627"><span class="calibre3">Chapter 7, Namespaces, Libraries, and Google Closure</span></a></p><blockquote class="calibre15">This chapter covers namespaces as a feature of the ClojureScript language and also explains how files are organized in ClojureScript projects. We go into detail about how the Google Closure Compiler affects the use of libraries in ClojureScript projects, and provide a detailed flowchart for determining how best to use any particular library.</blockquote><p class="calibre14"><a href="#filepos215466"><span class="calibre3">Chapter 8, Macros</span></a></p><blockquote class="calibre15">This chapter introduces macros, an advanced language feature provided by ClojureScript.</blockquote><p class="calibre14"><a href="#filepos228815"><span class="calibre3">Chapter 9, Development Process and Workflow</span></a></p><blockquote class="calibre15">This chapter covers a variety of alternative methods for working with ClojureScript code apart from the workflow we have used elsewhere in the book. We demonstrate some tools packaged with ClojureScript itself, including command-line compilation scripts and the ClojureScript Browser REPL (bREPL).</blockquote><p class="calibre14"><a href="#filepos264235"><span class="calibre3">Chapter 10, Integration with Clojure</span></a></p><blockquote class="calibre15">This chapter briefly demonstrates what can be achieved by combining Clojure and ClojureScript in the same application.</blockquote><p id="filepos6795" class="calibre11"><span class="calibre12"><span class="bold">Conventions Used in This Book</span></span></p><p class="calibre13">The following typographical conventions are used in this book:</p><p class="calibre14"><span class="italic">Italic</span></p><blockquote class="calibre15">Indicates new terms, URLs, email addresses, filenames, and file extensions.</blockquote><p class="calibre14"><tt class="calibre16">Constant width</tt></p><blockquote class="calibre15">Used for program listings, as well as within paragraphs to refer to program elements such as variable or function names, databases, data types, environment variables, statements, and keywords.</blockquote><p class="calibre14"><tt class="calibre16"><span class="bold">Constant width bold</span></tt></p><blockquote class="calibre15">Shows commands or other text that should be typed literally by the user.</blockquote><p class="calibre14"><tt class="calibre16"><span class="italic">Constant width italic</span></tt></p><blockquote class="calibre15">Shows text that should be replaced with user-supplied values or by values determined by context.</blockquote><blockquote class="calibre17"><span class="calibre10"><span class="bold"><span class="calibre18">TIP</span></span></span></blockquote><blockquote class="calibre15"><span class="calibre19">This icon signifies a tip, suggestion, or general note.</span></blockquote><blockquote class="calibre20"><span class="calibre10"><span class="bold"><span class="calibre18">CAUTION</span></span></span></blockquote><blockquote class="calibre15"><span class="calibre19">This icon indicates a warning or caution.</span></blockquote><p id="filepos8341" class="calibre21"><span class="calibre12"><span class="bold">Using Code Examples</span></span></p><p class="calibre13">This book is here to help you get your job done. In general, you may use the code in this book in your programs and documentation. You do not need to contact us for permission unless you’re reproducing a significant portion of the code. For example, writing a program that uses several chunks of code from this book does not require permission. Selling or distributing a CD-ROM of examples from O’Reilly books does require permission. Answering a question by citing this book and quoting example code does not require permission. Incorporating a significant amount of example code from this book into your product’s documentation does require permission.</p><p class="calibre13">We appreciate, but do not require, attribution. An attribution usually includes the title, author, publisher, and ISBN. For example: “<span class="italic">ClojureScript: Up and Running</span> by Stuart Sierra and Luke VanderHart (O’Reilly). Copyright 2013 Stuart Sierra and Luke VanderHart, 978-1-449-32743-9.”</p><p class="calibre13">If you feel your use of code examples falls outside fair use or the permission given above, feel free to contact us at <a href="mailto:permissions@oreilly.com"><span class="calibre3">permissions@oreilly.com</span></a>.</p><p id="filepos9689" class="calibre11"><span class="calibre12"><span class="bold">Safari® Books Online</span></span></p><blockquote class="calibre17"><span class="calibre10"><span class="bold"><span class="calibre18">NOTE</span></span></span></blockquote><blockquote class="calibre15"><span class="calibre19">Safari Books Online (</span><a href="http://my.safaribooksonline.com/?portal=oreilly"><span class="calibre19"><span class="calibre3">www.safaribooksonline.com</span></span></a><span class="calibre19">) is an on-demand digital library that delivers expert </span><a href="http://www.safaribooksonline.com/content"><span class="calibre19"><span class="calibre3">content</span></span></a><span class="calibre19"> in both book and video form from the world’s leading authors in technology and business.</span></blockquote><p class="calibre21">Technology professionals, software developers, web designers, and business and creative professionals use Safari Books Online as their primary resource for research, problem solving, learning, and certification training.</p><p class="calibre13">Safari Books Online offers a range of <a href="http://www.safaribooksonline.com/subscriptions"><span class="calibre3">product mixes</span></a> and pricing programs for <a href="http://www.safaribooksonline.com/organizations-teams"><span class="calibre3">organizations</span></a>, <a href="http://www.safaribooksonline.com/government"><span class="calibre3">government agencies</span></a>, and <a href="http://www.safaribooksonline.com/individuals"><span class="calibre3">individuals</span></a>. Subscribers have access to thousands of books, training videos, and prepublication manuscripts in one fully searchable database from publishers like O’Reilly Media, Prentice Hall Professional, Addison-Wesley Professional, Microsoft Press, Sams, Que, Peachpit Press, Focal Press, Cisco Press, John Wiley &amp; Sons, Syngress, Morgan Kaufmann, IBM Redbooks, Packt, Adobe Press, FT Press, Apress, Manning, New Riders, McGraw-Hill, Jones &amp; Bartlett, Course Technology, and dozens <a href="http://www.safaribooksonline.com/publishers"><span class="calibre3">more</span></a>. For more information about Safari Books Online, please visit us <a href="http://www.safaribooksonline.com/"><span class="calibre3">online</span></a>.</p><p id="filepos11928" class="calibre11"><span class="calibre12"><span class="bold">How to Contact Us</span></span></p><p class="calibre13">Please address comments and questions concerning this book to the publisher:</p><table border="1" valign="top" class="calibre22"><tr border="1" valign="top" class="calibre23"><td border="1" valign="top" class="calibre24"><span class="calibre19"> O’Reilly Media, Inc. </span></td></tr><tr border="1" valign="top" class="calibre23"><td border="1" valign="top" class="calibre24"><span class="calibre19"> 1005 Gravenstein Highway North </span></td></tr><tr border="1" valign="top" class="calibre23"><td border="1" valign="top" class="calibre24"><span class="calibre19"> Sebastopol, CA 95472 </span></td></tr><tr border="1" valign="top" class="calibre23"><td border="1" valign="top" class="calibre24"><span class="calibre19"> 800-998-9938 (in the United States or Canada) </span></td></tr><tr border="1" valign="top" class="calibre23"><td border="1" valign="top" class="calibre24"><span class="calibre19"> 707-829-0515 (international or local) </span></td></tr><tr border="1" valign="top" class="calibre23"><td border="1" valign="top" class="calibre24"><span class="calibre19"> 707-829-0104 (fax) </span></td></tr></table><p class="calibre14">We have a web page for this book, where we list errata, examples, and any additional information. You can access this page at <a href="http://oreil.ly/ClojureScript"><span class="calibre3">http://oreil.ly/ClojureScript</span></a>.</p><p class="calibre13">To comment or ask technical questions about this book, send email to <a href="mailto:bookquestions@oreilly.com"><span class="calibre3">bookquestions@oreilly.com</span></a>.</p><p class="calibre13">For more information about our books, courses, conferences, and news, see our website at <a href="http://www.oreilly.com"><span class="calibre3">http://www.oreilly.com</span></a>.</p><p class="calibre13">Find us on Facebook: <a href="http://facebook.com/oreilly"><span class="calibre3">http://facebook.com/oreilly</span></a></p><p class="calibre13">Follow us on Twitter: <a href="http://twitter.com/oreillymedia"><span class="calibre3">http://twitter.com/oreillymedia</span></a></p><p class="calibre13">Watch us on YouTube: <a href="http://www.youtube.com/oreillymedia"><span class="calibre3">http://www.youtube.com/oreillymedia</span></a></p><p id="filepos14315" class="calibre11"><span class="calibre12"><span class="bold">Acknowledgments</span></span></p><p class="calibre13">We would like to thank everyone involved in the development of ClojureScript as an open-source project, especially its creator, Rich Hickey. Thanks also to our technical reviewers Brenton Ashworth, Michael Fogus, and David Nolen, and to all our readers who sent in notes and corrections on early drafts. Finally, a big thank you to Justin Gehtland and Stuart Halloway, founders of Relevance, Inc., for creating a unique workplace that gives us the freedom to explore new technologies and contribute to the open-source community.</p><div class="mbppagebreak"></div><p id="filepos14967" class="calibre11"><span class="calibre2"><span class="bold">Chapter 1. Introduction: Why ClojureScript?</span></span></p><p class="calibre25">This book aims to get you up and running with <span class="italic">ClojureScript</span>, a dialect of the Clojure programming language that compiles to JavaScript. To begin, this chapter will provide some motivation for why ClojureScript exists.</p><p id="filepos15329" class="calibre11"><span class="calibre12"><span class="bold">The Rise of Browser Applications</span></span></p><p class="calibre13">Web applications have come a long way from simple CGI scripts, but they have always been constrained by the stateless request-response model of HTTP. As the “pages” in a web application become more elaborate, the cost in time and bandwidth of reloading an entire page just to update a single piece of information becomes prohibitively high.</p><p class="calibre13">One of the first major uses of JavaScript on the web was to ameliorate the cost of small updates, but “web applications” remained primarily <span class="italic">server applications</span> for a long time, and for good reason. Deploying an application to a web server is much easier than distributing it to diverse client machines: the server is a controlled environment, with many more options for programming languages and frameworks. But by treating web browsers like dumb terminals, applications were severely limited by how quickly they could push updates to a client.</p><p class="calibre13">Recent years have witnessed the rise of what one might call <span class="italic">browser applications</span>. These applications typically still have server-side components, but a significant part of their logic runs client-side, in a web browser. The web browser acts like a virtual machine, executing JavaScript code to communicate with a server, render a graphical user interface, and make all the local decisions that do not require a server. The result is a more responsive, more fluid style of interaction for client applications. While the original World Wide Web of hyperlinked documents will likely remain for many years to come, it seems probable that web <span class="italic">server</span> applications will be largely supplanted by web browser applications.</p><p id="filepos17144" class="calibre11"><span class="calibre12"><span class="bold">The Rise of JavaScript</span></span></p><p class="calibre13">Browser applications were made possible by dramatic improvements in the JavaScript execution environments packaged with web browsers. High-performance JavaScript engines such as WebKit’s SquirrelFish, Mozilla’s TraceMonkey, and Google’s V8 proved that JavaScript could be fast and launched the browser performance wars. JavaScript began to succeed as a general-purpose application platform where other in-browser execution environments had failed. It was a historical accident that no one could have predicted, least of all the early developers of JavaScript.</p><p class="calibre13">Although JavaScript has many flaws, it has a few strengths that allowed it to succeed:</p><div class="calibre26"> </div><ol class="calibre27"><li value="1" class="calibre28"><blockquote class="calibre15">It is a small language. Core JavaScript has a limited number of keywords, concepts, and built-in features. This makes it easy to embed in different environments.</blockquote></li><li value="2" class="calibre28"><blockquote class="calibre15">It is flexible. Features missing from core JavaScript, such as namespaces or classes, can be added using the language itself.</blockquote></li><li value="3" class="calibre28"><blockquote class="calibre15">JavaScript functions are first-class. Although JavaScript is not a “functional” programming language in the usual sense, the ability to create and compose functions as values grants it immense power.</blockquote></li><li value="4" class="calibre28"><blockquote class="calibre15"><span class="italic">It’s there.</span> Every web browser has had JavaScript built-in since the mid-1990s. Beyond that, the ease of embedding JavaScript in other applications has led to its inclusion in products as diverse as databases and television set-top boxes.</blockquote></li></ol><p id="filepos19098" class="calibre11"><span class="calibre12"><span class="bold">The Need for a Better Language</span></span></p><p class="calibre13">Despite JavaScript’s overwhelming success, it still has many flaws (see Douglas Crockford’s excellent book, <a href="http://shop.oreilly.com/product/9780596517748.do"><span class="italic"><span class="calibre3">JavaScript: The Good Parts</span></span></a> (O’Reilly)). It was a product of unpredictable evolution, not a carefully thought-out design process. And the vast reach and diversity of JavaScript runtimes is both a blessing and a curse: it will be difficult to create a new and improved version of the language that can replace all of the “legacy” versions deployed around the world.</p><p class="calibre13">So JavaScript is here to stay, probably in its current form, for some time. Some have gone so far as to say that “JavaScript is the assembly language of the web” (see Scott Hanselman’s article, <a href="http://bit.ly/OtWURd"><span class="calibre3">“JavaScript is Assembly Language for the Web”</span></a>). So now we are beginning to see the rise of tools and languages that treat JavaScript as a compilation target, much like bytecode on a virtual machine or object code in a traditional compiler. For example, the <a href="http://bit.ly/W0zaqU"><span class="calibre3">Google Web Toolkit</span></a> compiles a subset of the Java language to JavaScript. We even have entirely new languages, such as <a href="http://coffeescript.org/"><span class="calibre3">CoffeeScript</span></a> and <a href="http://www.dartlang.org/"><span class="calibre3">Dart</span></a>, designed to target JavaScript compilation directly.</p><p class="calibre13">Any cross-language compiler has to make decisions about where to draw boundaries between the source language and the target language. CoffeeScript, for example, is deliberately designed to have semantics very close to those of JavaScript, adding only a cleaner syntax and protection from some of JavaScript’s more egregious flaws. Google Web Toolkit, on the other hand, is designed to hide JavaScript from developers who want to work exclusively with the Java language.</p><p id="filepos21253" class="calibre11"><span class="calibre12"><span class="bold">Introducing ClojureScript</span></span></p><p class="calibre13">ClojureScript is a version of the Clojure programming language, which compiles to JavaScript. Its primary target is web browser applications, but it is also applicable to any environment where JavaScript is the only programmable technology available.</p><p class="calibre13">Clojure is a powerful, expressive, Lisp-like language developed for the Java Virtual Machine (there is also a community-maintained port of Clojure to the .NET Common Language Runtime (CLR)). ClojureScript is more than Clojure syntax layered on top of JavaScript: it supports the full semantics of the Clojure language, including immutable data structures, lazy sequences, first-class functions, and macros. Explaining how to use these features in ClojureScript will be the subject of this book.</p><p class="calibre13">Clojure was designed to have a symbiotic relationship with the JVM: it does not try to hide all the details of its host platform. In the same vein, ClojureScript does not try to hide all the details of JavaScript or the browser execution environment. ClojureScript uses the same native types as JavaScript, such as strings and numbers, and can call JavaScript functions directly without any special “wrapper” or “foreign-function” code. ClojureScript is also designed to work closely with best-of-breed JavaScript optimization tools such as the Google Closure Compiler. These relationships will be explored in <a href="#filepos45583"><span class="calibre3">Chapter 3</span></a>.</p><p class="calibre13">In summary, ClojureScript provides developers with a language that is more powerful than JavaScript, which can reach all the same places JavaScript can, with fewer of JavaScript’s shortcomings.</p><div class="mbppagebreak"></div><p id="filepos23106" class="calibre11"><span class="calibre2"><span class="bold">Chapter 2. Hello World</span></span></p><p class="calibre25">The next chapter will explain in detail how the ClojureScript compiler works, and its various options and their applications. But for now, you probably want to jump right in and get started.</p><p class="calibre13">Due to the relative youth of ClojureScript as a technology, there aren’t any highly standardized ways of working or best practices yet. What conventions there are tend to change frequently, and the built-in tools that ClojureScript ships with are somewhat low-level and labor-intensive to use.</p><p class="calibre13">Therefore, in the spirit of the <span class="italic">Up and Running</span> title of this book, we will recommend <span class="italic">Leiningen</span> and <span class="italic">lein-cljsbuild</span> as tools for getting started, and these will be introduced in this chapter and used throughout the rest of the book. They are more mature than other tools currently available, are relatively easy to use, work on all three major platforms (Windows, Linux, and OS X), and are likely to be around for some time.</p><p class="calibre13">Instructions for installing ClojureScript from source and running its lower-level, more primitive tools will also be included in <a href="#filepos228815"><span class="calibre3">Chapter 9</span></a>. However, for most users, Leiningen should prove more than sufficient for both learning and real-world production use.</p><blockquote class="calibre29"></blockquote><blockquote class="calibre30"><span class="calibre19"><span class="bold">JAVA DEVELOPMENT KIT</span></span></blockquote><blockquote class="calibre15"><span class="calibre19">Clojure, ClojureScript, and Leiningen all run on top of the Java Virtual Machine (JVM), which is provided by a Java Development Kit (JDK). Many operating systems come prepackaged with a JDK. For those that don’t, you can download one for free </span><a href="http://bit.ly/TEA7iC"><span class="calibre19"><span class="calibre3">here</span></span></a><span class="calibre19">. Get the latest version of the Java Standard Edition (SE) JDK available for your operating system. Clojure requires at least version 5.</span></blockquote><blockquote class="calibre15"><span class="calibre19">There are other JDKs available but these are not as thoroughly tested with Clojure and ClojureScript, so we recommend the Oracle JDK as the easiest way to get started.</span></blockquote><p id="filepos25528" class="calibre21"><span class="calibre12"><span class="bold">Leiningen</span></span></p><p class="calibre13">Leiningen is a build system for Clojure, named to highlight its opposition to the venerable but labor-intensive <span class="italic">Ant</span> build system for Java (see the short story <span class="italic">Leiningen Versus the Ants</span> by Carl Stephenson). It is the <span class="italic">de facto</span> standard for building Clojure projects in the Clojure community, and has a wide array of useful features.</p><p class="calibre13">It utilizes <a href="http://maven.apache.org/"><span class="calibre3">Maven</span></a> for dependency resolution, and can seamlessly connect to any Maven repository to acquire dependencies. However, it features an original build system optimized for Clojure workflows, and can also compile Java source code. In addition, it exposes integration points for third-party plug-ins, enabling its use with a wide variety of other programming languages, including ClojureScript via the <span class="italic">lein-cljsbuild</span> plug-in discussed below.</p><p class="calibre13">This book describes Leiningen version 2, which is much more featureful than previous versions and is recommended for new projects at the time of writing. If you do need to use ClojureScript with existing versions of Leiningen, don’t worry: <span class="italic">lein-cljsbuild</span> is fully compatible with Leiningen 1.7.0 and up. However, you’ll need to read the legacy Leiningen documentation, as the examples included here use new configuration properties introduced in 2.0.0.</p><p class="calibre13">Don’t worry if some things described in this chapter don’t make sense, or if you don’t understand some of the syntax or terms used. Everything covered here will be elaborated in much greater detail throughout the rest of the book.</p><p id="filepos27299" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Installing Leiningen on OS X and Linux</span></span></span></p><div class="calibre26"> </div><ol class="calibre27"><li value="1" class="calibre28"><blockquote class="calibre15">Download the latest version of the <tt class="calibre16">lein</tt> script from the <a href="https://github.com/technomancy/leiningen"><span class="calibre3">Leiningen GitHub page</span></a>, and save it to a location on your system’s PATH (typically <tt class="calibre16">~/bin</tt> or <tt class="calibre16">/usr/local/bin</tt>).</blockquote></li><li value="2" class="calibre28"><blockquote class="calibre15">Set the script to be executable (e.g., <tt class="calibre16">chmod +x ./lein</tt>).</blockquote></li><li value="3" class="calibre28"><blockquote class="calibre15">Run the script (e.g., <tt class="calibre16">./lein</tt>). Leiningen will automatically download everything it needs to function properly.</blockquote></li></ol><p class="calibre13">That’s it! You’re now ready to use Leiningen.</p><blockquote class="calibre29"></blockquote><blockquote class="calibre30"><span class="calibre19"><span class="bold">GIT AND GITHUB</span></span></blockquote><blockquote class="calibre15"><span class="calibre19"><span class="italic">Git</span></span><span class="calibre19"> is a powerful source code management system that is extremely popular among open source developers and is used for most open source projects. If you’re not already using it, you can install it and learn about how it works from its </span><a href="http://git-scm.com/"><span class="calibre19"><span class="calibre3">website</span></span></a><span class="calibre19">.</span></blockquote><blockquote class="calibre15"><span class="calibre19">You will probably also see frequent references to </span><span class="calibre19"><span class="italic">GitHub</span></span><span class="calibre19">, a featureful and easy-to-use Git hosting service that is free for open source projects. ClojureScript itself is hosted on GitHub, as are practically all ClojureScript tools and libraries.</span></blockquote><p id="filepos29274" class="calibre32"><span class="calibre31"><span class="bold"><span class="calibre3">Installing Leiningen on Windows</span></span></span></p><div class="calibre26"> </div><ol class="calibre27"><li value="1" class="calibre28"><blockquote class="calibre15">Download the <tt class="calibre16">lein.bat</tt> file from the <a href="https://github.com/technomancy/leiningen"><span class="calibre3">Leiningen GitHub page</span></a>, and save it to your hard drive.</blockquote></li><li value="2" class="calibre28"><blockquote class="calibre15">Install either <a href="http://gnuwin32.sourceforge.net/packages/wget.htm"><tt class="calibre16"><span class="calibre3">wget</span></tt></a> or <a href="http://curl.haxx.se/"><tt class="calibre16"><span class="calibre3">curl</span></tt></a>. These are programs that the Leiningen batch script can use to automatically download the rest of its dependencies.</blockquote></li><li value="3" class="calibre28"><blockquote class="calibre15">Run <tt class="calibre16">lein.bat</tt>, passing it the <tt class="calibre16">self-install</tt> argument (<tt class="calibre16">.\lein.bat self-install</tt>). Leiningen will download the rest of its dependencies and finish installing itself.</blockquote></li></ol><p class="calibre13">That’s all! Leiningen is now installed on your Windows system.</p><p id="filepos30507" class="calibre11"><span class="calibre12"><span class="bold">Using lein-cljsbuild</span></span></p><p class="calibre13">Leiningen does not yet support building ClojureScript code on its own. Fortunately, thanks to its plug-in system, using the <span class="italic">lein-cljsbuild</span> plug-in for ClojureScript development is easy: just reference it in the <tt class="calibre16">:plugins</tt> key of your <tt class="calibre16">project.clj</tt> build configuration (demonstrated below).</p><p class="calibre13">Before you can use <span class="italic">lein-cljsbuild</span>, you’ll need to create a Leiningen project (if you don’t have one already). In your command console, switch to a directory of your choice, then type:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">lein new hello-world</tt></span></blockquote><p class="calibre14">This will generate a new directory prepopulated with some default files. It should contain a <tt class="calibre16">project.clj</tt> file, which initially will look something like this:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(defproject hello-world "0.1.0-SNAPSHOT"<br class="calibre6"/>  :description "FIXME: write description"<br class="calibre6"/>  :url "http://example.com/FIXME"<br class="calibre6"/>  :license {:name "Eclipse Public License"<br class="calibre6"/>            :url "http://www.eclipse.org/legal/epl-v10.html"}<br class="calibre6"/>  :dependencies [[org.clojure/clojure "1.4.0"]])</tt></span></blockquote><p class="calibre14">To enable <span class="italic">lein-cljsbuild</span>, you’ll need to add two lines: a <tt class="calibre16">:plugins</tt> key adding <span class="italic">lein-cljsbuild</span> to the project, and a <tt class="calibre16">:cljsbuild</tt> key containing build configurations (which will start out empty). Once you’ve added them, your <tt class="calibre16">project.clj</tt> should look something like the following:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(defproject hello-world "0.1.0-SNAPSHOT"<br class="calibre6"/>  :description "FIXME: write description"<br class="calibre6"/>  :url "http://example.com/FIXME"<br class="calibre6"/>  :license {:name "Eclipse Public License"<br class="calibre6"/>            :url "http://www.eclipse.org/legal/epl-v10.html"}<br class="calibre6"/>  :dependencies [[org.clojure/clojure "1.4.0"]<br class="calibre6"/>                 [org.clojure/clojurescript "0.0-1450"]]<br class="calibre6"/>  :plugins [[lein-cljsbuild "0.2.7"]]<br class="calibre6"/>  :cljsbuild {:builds []})</tt></span></blockquote><p class="calibre14">Note that on a new project, you should specify whichever versions of Clojure, ClojureScript, and <span class="italic">lein-cljsbuild</span> are most recent (at the time of writing, this is 1.4.0, 0.0-1450, and 0.2.7, respectively, as shown in the example <tt class="calibre16">project.clj</tt>).</p><p id="filepos33210" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Getting Started with the REPL</span></span></span></p><p class="calibre13">The fastest way to start writing ClojureScript code is to fire up the REPL. For those not already familiar with the concept of a REPL from Clojure or another Lisp, REPL stands for Read Eval Print Loop, and is similar to a shell console in other languages because it can be used to program interactively. It works by successively reading text input into Lisp data structures, evaluating them in the running environment (via compilation to JavaScript, in ClojureScript’s case), printing the results of the expression back to the console, and looping back and waiting for more input.</p><p class="calibre13">To start a basic REPL in a <span class="italic">lein-cljsbuild</span> project, type the following at the command line from anywhere in the project’s directory structure:</p><p class="calibre13"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">lein trampoline cljsbuild repl-rhino</tt></span></blockquote><p class="calibre14">This statement deserves some unpacking:</p><div class="calibre26"> </div><ul class="calibre35"><li value="1" class="calibre28"><blockquote class="calibre15"><tt class="calibre16">lein</tt> invokes the Leiningen build system.</blockquote></li><li value="2" class="calibre28"><blockquote class="calibre15"><tt class="calibre16">trampoline</tt> is some ceremony Leiningen requires for running tasks with interactive user input in the console.</blockquote></li><li value="3" class="calibre28"><blockquote class="calibre15"><tt class="calibre16">cljsbuild</tt> invokes the <span class="italic">lein-cljsbuild</span> plug-in.</blockquote></li><li value="4" class="calibre28"><blockquote class="calibre15"><tt class="calibre16">repl-rhino</tt> specifies that you’ll use the <span class="italic">Rhino</span> REPL. Rhino is a headless JavaScript engine that runs on the JVM, which is convenient for basic experimentation with ClojureScript.</blockquote></li></ul><p class="calibre13">Once the REPL starts up, you should see the ClojureScript REPL prompt:</p><p class="calibre13"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">ClojureScript:cljs.user&gt;</tt></span></blockquote><p class="calibre14">Type a ClojureScript expression (for example, the <tt class="calibre16">println</tt> function to print to standard out in Rhino), and press Enter to evaluate it:</p><p class="calibre13"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">ClojureScript:cljs.user&gt; (println “Hello, world!”) <br class="calibre6"/>Hello, world! <br class="calibre6"/>nil</tt></span></blockquote><p class="calibre14">You will immediately see the string you specified printed, and the return value of the expression (which is <tt class="calibre16">nil</tt>, in the case of <tt class="calibre16">println</tt>).</p><p class="calibre13">You can use the Rhino REPL like this to explore any of ClojureScript’s basic syntax and standard libraries.</p><blockquote class="calibre29"></blockquote><blockquote class="calibre30"><span class="calibre19"><span class="bold">RHINO REPL VERSUS THE BROWSER REPL</span></span></blockquote><blockquote class="calibre15"><span class="calibre19">ClojureScript actually ships with two REPLs: the Rhino REPL and the Browser REPL. The Rhino REPL is much simpler and easier to use, but runs in a sandboxed, headless JavaScript instance, implemented using </span><a href="http://www.mozilla.org/rhino/"><span class="calibre19"><span class="calibre3">Rhino</span></span></a><span class="calibre19">. For basic exploration of ClojureScript and its syntax, it works great.</span></blockquote><blockquote class="calibre15"><span class="calibre19">However, one major use case for ClojureScript is browser programming, and for that, ideally, one wants a REPL that actually runs against a real browser JavaScript environment with full access to the DOM (Document Object Model) and the ability to see changes reflected in a running browser. ClojureScript supports this, but out of necessity the model is slightly more complicated.</span></blockquote><blockquote class="calibre15"><span class="calibre19">The Browser REPL runs as two components: a client, which runs as ClojureScript in a browser, and a server, which is a separate Java process that runs on the developer’s machine and exposes an interactive console. The browser client maintains a long polling connection to the server, and whenever the developer enters an expression at the REPL console, it is compiled to JavaScript and sent to the browser, which evaluates the expression and sends back the result.</span></blockquote><blockquote class="calibre15"><span class="calibre19">Full instructions for configuring and using the Browser REPL are included in </span><a href="#filepos228815"><span class="calibre19"><span class="calibre3">Chapter 9</span></span></a><span class="calibre19">.</span></blockquote><p id="filepos38045" class="calibre32"><span class="calibre31"><span class="bold"><span class="calibre3">Compiling a ClojureScript File to JavaScript</span></span></span></p><p id="filepos38180" class="calibre14"><span class="calibre5"><span class="bold">Structuring the Leiningen project</span></span></p><p class="calibre13">To add a ClojureScript file to your Leiningen project, you’ll want to make a few tweaks to your project directory layout. Initially, your project layout will look something like this:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">- hello-world/<br class="calibre6"/>  - README.md<br class="calibre6"/>  - project.clj<br class="calibre6"/>  - src/<br class="calibre6"/>    - hello_world/<br class="calibre6"/>      - core.clj</tt></span></blockquote><p class="calibre14">(Note that test files and folders are omitted for clarity, but you should definitely write unit tests wherever appropriate.)</p><p class="calibre13">Since this default structure is designed around having only one type of source code (Clojure), you’ll want to modify the directory structure slightly, to match the following:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">- hello-world/<br class="calibre6"/>  - README.md<br class="calibre6"/>  - project.clj<br class="calibre6"/>  - src/<br class="calibre6"/>    - clj/<br class="calibre6"/>      - hello_world/<br class="calibre6"/>        - core.clj<br class="calibre6"/>    - cljs/<br class="calibre6"/>- hello_world<br class="calibre6"/>  - resources/<br class="calibre6"/>    - public/</tt></span></blockquote><p class="calibre14">As you can see, the <tt class="calibre16">src</tt> folder now has two subfolders, one for each type of source code. You’ll need to add a <tt class="calibre16">:source-paths</tt> configuration key to your <tt class="calibre16">project.clj</tt> file to reflect the new location of the Clojure source code (see the example below for what the new <tt class="calibre16">project.clj</tt> file will look like). You will also need to create a folder in which to place the compiled JavaScript: <tt class="calibre16">resources/public</tt> is a common choice.</p><p id="filepos40008" class="calibre14"><span class="calibre5"><span class="bold">Updating the project configuration</span></span></p><p class="calibre13">Then, you must add a build entry in the <tt class="calibre16">:cljsbuild</tt> configuration map in <tt class="calibre16">project.clj</tt>:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(defproject hello-world "0.1.0-SNAPSHOT"<br class="calibre6"/>  :plugins [[lein-cljsbuild "0.2.7"]]<br class="calibre6"/>  :dependencies [[org.clojure/clojure "1.4.0"]<br class="calibre6"/>                 [org.clojure/clojurescript "0.0-1450"]]<br class="calibre6"/>  :source-paths ["src/clj"]<br class="calibre6"/>  :cljsbuild {<br class="calibre6"/>    :builds [{<br class="calibre6"/>      :source-path "src/cljs"<br class="calibre6"/>      :compiler {<br class="calibre6"/>        :output-to "resources/public/hello.js"<br class="calibre6"/>        :optimizations :whitespace<br class="calibre6"/>        :pretty-print true}}]})</tt></span></blockquote><p class="calibre14">The <tt class="calibre16">:source-path</tt> key specifies where the build looks for ClojureScript source files, and the <tt class="calibre16">:output-to</tt> key of the <tt class="calibre16">:compiler</tt> option map specifies where the ClojureScript compiler will emit compiled JavaScript files. Other compiler options will be explained in more detail in the next chapter: for now, just use the ones provided.</p><p id="filepos41308" class="calibre14"><span class="calibre5"><span class="bold">Writing a ClojureScript file</span></span></p><p class="calibre13">Finally, write a ClojureScript file! You can start with something very simple, intended to be run in a browser. The following ClojureScript file just declares a namespace, and then prints out “Hello World” using the <tt class="calibre16">document.write</tt> JavaScript function. Place it in a file named <tt class="calibre16">hello.cljs</tt> in the <tt class="calibre16"><span class="italic">src/cljs/hello_world/</span></tt> folder (named to match the namespace you declared) in your ClojureScript source folder.</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(ns hello-world.hello)<br class="calibre6"/>(.write js/document "&lt;p&gt;Hello, world!&lt;/p&gt;")</tt></span></blockquote><p id="filepos42074" class="calibre14"><span class="calibre5"><span class="bold">Compiling</span></span></p><p class="calibre13">Your Leiningen project is now fully configured to compile ClojureScript. Try compiling your ClojureScript by invoking the <tt class="calibre16">lein cljsbuild once</tt> command from the command line, anywhere inside your Leiningen project folder. You should see a status message about successfully compiling <tt class="calibre16">resources/public/hello.js</tt>. If you like, you can inspect the emitted JavaScript file: Be aware, though, that it also includes the core ClojureScript runtime and parts of the standard library, so it’s quite long. See the next chapter for details of how this process works.</p><p class="calibre13">You might also want to try running <tt class="calibre16">lein cljsbuild auto</tt>. This will keep a process open that will watch all the <span class="italic">*.cljs</span> files in the specified source directories, and whenever one is saved, it will recompile it automatically and replace the output file.</p><p class="calibre13">You should also be aware of the <tt class="calibre16">lein cljsbuild clean</tt> command, which will delete all the compiled JavaScript files. By default, <span class="italic">lein-cljsbuild</span> will not recompile a file unless it detects that the file has been changed by comparing timestamps. Sometimes, however, it’s useful to force a recompile by wiping all the compiler output and restarting with a clean slate.</p><p id="filepos43458" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Running ClojureScript in the Browser</span></span></span></p><p class="calibre13">If you’ve written a ClojureScript file as described in the previous section, all you need to do to see it run in a browser is to write an HTML file that includes the emitted JS files in the standard way. It is common practice to place static HTML files in <tt class="calibre16">resources/public</tt>.</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">&lt;html&gt;<br class="calibre6"/>&lt;head&gt;&lt;title&gt;ClojureScript Hello World&lt;/title&gt;&lt;/head&gt;<br class="calibre6"/>&lt;body&gt;<br class="calibre6"/>    &lt;script type="text/javascript" src="hello.js"&gt;&lt;/script&gt;<br class="calibre6"/>&lt;/body&gt;<br class="calibre6"/>&lt;/html&gt;</tt></span></blockquote><p class="calibre14">Open this file in the browser, and you should see your greeting, as coded in your <tt class="calibre16">hello.cljs</tt> file. If you’re running <span class="italic">lein-cljsbuild</span> in automatic mode, simply edit the message in <tt class="calibre16">hello.cljs</tt>, save the file, and refresh the browser to see your change.</p><p id="filepos44571" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Other Capabilities of lein-cljsbuild</span></span></span></p><p class="calibre13">Note that in addition to this basic compilation, <span class="italic">lein-cljsbuild</span> provides several other useful development tools and options. These include:</p><div class="calibre26"> </div><ul class="calibre35"><li value="1" class="calibre28"><blockquote class="calibre15">Multiple ClojureScript builds with different options.</blockquote></li><li value="2" class="calibre28"><blockquote class="calibre15">Launching the browser REPL.</blockquote></li><li value="3" class="calibre28"><blockquote class="calibre15">Cross compiling the same code as both Clojure and ClojureScript (provided it meets certain requirements).</blockquote></li></ul><p class="calibre13">See <a href="#filepos228815"><span class="calibre3">Chapter 9</span></a> for full instructions on all the configuration options and features available.</p><div class="mbppagebreak"></div><p id="filepos45583" class="calibre11"><span class="calibre2"><span class="bold">Chapter 3. The Compilation Process</span></span></p><p class="calibre25">ClojureScript has a tight symbiotic relationship with other tools. This chapter will explain how all the different parts fit together and then demonstrate the ClojureScript compilation process.</p><p id="filepos45905" class="calibre11"><span class="calibre12"><span class="bold">Architecture</span></span></p><p class="calibre13">ClojureScript is a compiler—that is, a program that takes a “source” representation as input and emits a “target” representation as output. The source representation of the ClojureScript compiler is the ClojureScript language, and the target representation is JavaScript.</p><p class="calibre13">Unlike some JavaScript-generation tools and frameworks, ClojureScript itself does not do any “minification” or other optimizations to reduce the size of the JavaScript code it emits. Instead, ClojureScript is designed to work with the Google Closure Compiler to produce optimized JavaScript.</p><p id="filepos46618" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Google Closure Compiler</span></span></span></p><p class="calibre13">The Google Closure Compiler is a free, open-source compiler that uses JavaScript as both source and target representations. That is, it compiles JavaScript into JavaScript. Along the way, it can perform sophisticated optimizations to reduce the size and improve the runtime performance of JavaScript code.</p><blockquote class="calibre17"><span class="calibre10"><span class="bold"><span class="calibre18">NOTE</span></span></span></blockquote><blockquote class="calibre15"><span class="calibre19">The fact that “Clojure” and “Closure” are homophones is an unfortunate historical accident. The owners/authors of the two projects have no relationship to one another. In this book, we will always refer to the “Google Closure Compiler” and the “Google Closure Library” by their full names.</span></blockquote><p class="calibre21">The Google Closure Compiler can run in three different modes:</p><p class="calibre14">Whitespace Only</p><blockquote class="calibre15">This mode removes only comments and unnecessary whitespace from JavaScript source code. The target JavaScript is functionally identical to the source JavaScript. This is similar to some simple JavaScript “minifiers.”</blockquote><p class="calibre14">Simple Optimizations</p><blockquote class="calibre15">This mode does all the same optimizations as <span class="italic">Whitespace Only</span> mode and further reduces the size of target JavaScript by renaming local variables and function parameters to shorter names.</blockquote><p class="calibre14">Advanced Optimizations</p><blockquote class="calibre15">This mode does all the same optimizations as the previous two modes and also performs aggressive whole-program optimizations of JavaScript code. It will completely remove “dead” or unreachable code, rename functions and global variables to shorter names, and even rename inline function bodies when doing so will save space.</blockquote><p class="calibre13">While the more aggressive optimization modes of the compiler can dramatically reduce the size of JavaScript source code, they come with a few caveats. In order to perform the optimizations in <span class="italic">Simple</span> and <span class="italic">Advanced</span> modes, the Google Closure Compiler must make certain assumptions about the source JavaScript. If the source JavaScript code violates these assumptions, the Google Closure Compiler will produce target JavaScript code that does not work as intended.</p><p class="calibre13">For example, <span class="italic">Simple Optimizations</span> mode will break JavaScript code that uses JavaScript’s <tt class="calibre16">with</tt> operator, <tt class="calibre16">eval</tt> function, or any string representation of function or parameter names. <span class="italic">Advanced Optimizations</span> mode is even more restrictive: because it renames global variables and functions to shorten their names, it will break any code that depends on names being stable. For example, code that refers to object property names as strings (like <tt class="calibre16">user["name"]</tt> instead of <tt class="calibre16">user.name</tt>) will sometimes break under <span class="italic">Advanced</span> mode.</p><p class="calibre13">The documentation for the Google Closure Compiler explains all the effects of <span class="italic">Advanced Optimizations</span> mode in detail. Essentially, using the Google Closure Compiler in <span class="italic">Advanced</span> mode requires that developers follow strict conventions for how their JavaScript code is structured. The JavaScript code that results from following these conventions often looks “unnatural” to developers accustomed to writing optimized JavaScript code by hand, but the final result produced by the Google Closure Compiler is generally just as or more efficient than hand-optimized JavaScript run through a “minifier.”</p><blockquote class="calibre17"><span class="calibre10"><span class="bold"><span class="calibre18">NOTE</span></span></span></blockquote><blockquote class="calibre15"><span class="calibre19">Google makes a </span><a href="http://closure-compiler.appspot.com/"><span class="calibre19"><span class="calibre3">Closure Compiler demo application</span></span></a><span class="calibre19"> available for developers to experiment with the effects of different compilation modes.</span></blockquote><p id="filepos50922" class="calibre21"><span class="calibre31"><span class="bold"><span class="calibre3">The Google Closure Library</span></span></span></p><p class="calibre13">The Google Closure Compiler is distributed along with an extensive collection of free and open-source libraries, written in JavaScript, which follow all the conventions required by the compiler in <span class="italic">Advanced Optimizations</span> mode. These libraries include data structures, common algorithms, abstractions over browser quirks, and even a GUI toolkit. Because of the <span class="italic">Advanced</span>-mode conventions, the source code of these libraries may look “unnatural” to a JavaScript developer. The Google Closure Library code is written to target the Google Closure Compiler, so it is more verbose than most JavaScript written to target web browsers directly. Common by-hand JavaScript optimizations, such as using short names for common functions, do not matter in <span class="italic">Advanced</span> mode, because the compiler will rename everything anyway.</p><p class="calibre13">The Google Closure Library is much larger than most JavaScript libraries—several megabytes as opposed to a few hundred kilobytes. Again, a JavaScript developer accustomed to hand-optimized code would think this is grossly inefficient. But the Google Closure Compiler’s <span class="italic">Advanced</span>-mode optimizations ensure the actual code delivered in a production application is much smaller. Any “dead” library code not actually used by the application will be eliminated during compilation. In short, you only pay (in download size) for what you use.</p><blockquote class="calibre29"></blockquote><blockquote class="calibre30"><span class="calibre19"><span class="bold">A FEW WORDS ON CACHING</span></span></blockquote><blockquote class="calibre15"><span class="calibre19">The Google Closure Compiler is designed to reduce the </span><span class="calibre19"><span class="italic">overall</span></span><span class="calibre19"> download size of your application, but it does not facilitate re-use of JavaScript libraries across different applications in the same client. Experienced JavaScript developers may be more accustomed to fetching popular JavaScript libraries from Content Delivery Networks (CDNs) and relying on browser caches to reduce the overall download size. But caching is not a panacea (see Sam Saffron’s article, “</span><a href="http://samsaffron.com/archive/2012/02/17/stop-paying-your-jquery-tax"><span class="calibre19"><span class="calibre3">Stop paying your jQuery tax</span></span></a><span class="calibre19">”):</span></blockquote><div class="calibre26"> </div><ul class="calibre35"><li value="1" class="calibre28"><blockquote class="calibre15"><span class="calibre19">Many users will not have the library in their cache.</span></blockquote></li><li value="2" class="calibre28"><blockquote class="calibre15"><span class="calibre19">Even if a library is in the cache, web browsers will still perform an HTTP request to make sure the cache is up to date.</span></blockquote></li><li value="3" class="calibre28"><blockquote class="calibre15"><span class="calibre19">Parsing and executing a large JavaScript library takes time, even in the fastest browsers.</span></blockquote></li></ul><blockquote class="calibre15"><span class="calibre19">As with any performance optimization problem, only exhaustive testing can prove which method is more efficient overall. Using the Google Closure Compiler, you can still utilize CDNs and client-side caching for the application code itself. Given the growing diversity of JavaScript libraries and applications, this seems like a good approach. Google itself has used this technique to deploy large, complex browser applications such as GMail and Google Docs.</span></blockquote><p id="filepos54613" class="calibre32"><span class="calibre31"><span class="bold"><span class="calibre3">ClojureScript and Google Closure</span></span></span></p><p class="calibre13">ClojureScript is designed to work with the Google Closure Compiler and Library. The ClojureScript compiler emits JavaScript code that is fully compatible with the <span class="italic">Advanced Optimizations</span> mode of the Google Closure Compiler. As a result, when programming in ClojureScript you rarely need to think about the JavaScript conventions required by <span class="italic">Advanced</span> mode. Many of the core libraries included with ClojureScript make use of functions in the Google Closure Library.</p><p class="calibre13">Using ClojureScript does not mean that you are restricted to using code only in the Google Closure Library. ClojureScript can make use of any JavaScript library with a little additional configuration. However, most hand-optimized JavaScript libraries are <span class="italic">not</span> written with the Google Closure Compiler in mind, so they will not be compatible with <span class="italic">Advanced Optimizations</span> mode. ClojureScript can still use libraries such as jQuery or Prototype, but the libraries themselves will not receive the benefit of <span class="italic">Advanced</span>-mode compilation. <a href="#filepos179627"><span class="calibre3">Chapter 7</span></a> will cover using third-party JavaScript libraries in ClojureScript.</p><p id="filepos55959" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">The Compilation Pipeline</span></span></span></p><p class="calibre13">The final picture of ClojureScript compilation looks like <a href="#filepos56230"><span class="calibre3">Figure 3-1</span></a>.</p><blockquote id="filepos56230" class="calibre36"></blockquote><blockquote class="calibre37"><img src="images/00007.jpg" class="calibre38"/></blockquote><blockquote class="calibre36"><span class="calibre19"><span class="italic"><span class="calibre18">Figure 3-1. ClojureScript Compilation Process</span></span></span></blockquote><p class="calibre39">The entire compilation process happens inside a Java Virtual Machine (JVM), presumably running on a server or developer’s machine. The ClojureScript compiler is written in the Clojure language, which runs on the JVM. The Google Closure Compiler is written in the Java language.</p><p class="calibre13">The ClojureScript compiler takes ClojureScript source code and compiles it into unoptimized JavaScript, which it passes to the Google Closure Compiler along with JavaScript libraries. The Google Closure Compiler takes in all the unoptimized JavaScript and emits a single optimized JavaScript source file.</p><p class="calibre13">The JavaScript output by the Google Closure Compiler in <span class="italic">Advanced Optimizations</span> mode is intended for consumption by JavaScript execution engines, not humans. It is not readable and not very suitable for JavaScript debugging tools. When developing your application, it is more common to omit the Google Closure Compiler from the compilation process, which will result in readable JavaScript. Function and variable names in the emitted JavaScript can easily be correlated with sources in ClojureScript. Debugging support in ClojureScript still has room for improvement, but the process is already usable. In addition, ClojureScript has some unique debugging tools such as the browser-connected Read-Eval-Print-Loop (REPL), which we will cover in <a href="#filepos228815"><span class="calibre3">Chapter 9</span></a>.</p><p id="filepos58093" class="calibre11"><span class="calibre12"><span class="bold">How to Compile</span></span></p><p class="calibre13">In this section, we will walk through the ClojureScript compilation process in detail, showing how the parts interact.</p><blockquote class="calibre29"></blockquote><blockquote class="calibre30"><span class="calibre19"><span class="bold">THE JAVA CLASSPATH</span></span></blockquote><blockquote class="calibre15"><span class="calibre19">Most programming language implementations assume that source code libraries will be installed in some standard location, accessible system-wide. Java is different. Every time you launch the JVM, you must explicitly specify a </span><span class="calibre19"><span class="italic">classpath</span></span><span class="calibre19">, a list of directories and files to search when loading code. The classpath is fixed when the JVM starts and cannot be changed while it is running. (Technically, it is possible to manipulate the classpath using </span><span class="calibre19"><span class="italic">classloaders</span></span><span class="calibre19">, an esoteric JVM feature that is far outside the scope of this book.)</span></blockquote><blockquote class="calibre15"><span class="calibre19">Most Java libraries are published as Java Archive (JAR) files. JAR files are simply compressed files in the ZIP format with some additional metadata. The Clojure runtime, the ClojureScript compiler, and the Google Closure Compiler are all distributed as JAR files. (You can find links to download the JAR files at the </span><a href="http://search.maven.org/"><span class="calibre19"><span class="calibre3">Central Maven Repository</span></span></a><span class="calibre19">, the most widely-used repository of JAR files. Search for “clojurescript” or “google closure” to find the latest releases.) In addition, the ClojureScript authors have packaged and distributed a version of the Google Closure Library as a JAR file for convenience.</span></blockquote><blockquote class="calibre15"><span class="calibre19">Although it is possible to launch the Java Virtual Machine and specify the classpath directly from the command line, this is rarely done in practice. Managing the classpath is one of the principal concerns of build tools, IDEs, and application servers targeting the Java language. Clojure has its own such tool, Leiningen, which was introduced in </span><a href="#filepos23106"><span class="calibre19"><span class="calibre3">Chapter 2</span></span></a><span class="calibre19"> and will be covered further in </span><a href="#filepos228815"><span class="calibre19"><span class="calibre3">Chapter 9</span></span></a><span class="calibre19">.</span></blockquote><p id="filepos60650" class="calibre32"><span class="calibre31"><span class="bold"><span class="calibre3">Compiling ClojureScript</span></span></span></p><p class="calibre13">The entire ClojureScript build chain, including the ClojureScript compiler and the Google Closure Compiler, can be invoked as a single function in Clojure. In this section, we will use the Clojure REPL to explore the various options of the ClojureScript compiler. We’ll use a variant of the “Hello, World” example from <a href="#filepos23106"><span class="calibre3">Chapter 2</span></a>. Instead of using <span class="italic">lein-cljsbuild</span>, this example will invoke the ClojureScript compiler directly. This process is unlikely to become part of your day-to-day development workflow, but it is helpful to understand how the parts work. You can also use this section as a guide to incorporating ClojureScript into customized builds.</p><p id="filepos61518" class="calibre14"><span class="calibre5"><span class="bold">Hello, Compiler</span></span></p><p class="calibre13">Create a new project like this:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">lein new ch03-hello-compiler</tt></span></blockquote><p class="calibre14">Then modify the <tt class="calibre16">project.clj</tt> file to look like this:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(defproject ch03-hello-compiler "0.1.0-SNAPSHOT"<br class="calibre6"/>  :dependencies [[org.clojure/clojure "1.4.0"]<br class="calibre6"/>                 [org.clojure/clojurescript "0.0-1450"]]<br class="calibre6"/>  :source-paths ["src/clj"])</tt></span></blockquote><p class="calibre14">Create the <tt class="calibre16">src/clj</tt> and <tt class="calibre16">src/cljs</tt> directories as in <a href="#filepos23106"><span class="calibre3">Chapter 2</span></a>, then put the following ClojureScript source file in <tt class="calibre16">src/cljs/hello_compiler/hello.cljs</tt>:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(ns hello-compiler.hello)<br class="calibre6"/><br class="calibre6"/>(defn ^:export main []<br class="calibre6"/>  (.write js/document "&lt;p&gt;Hello, ClojureScript compiler!&lt;/p&gt;"))</tt></span></blockquote><p class="calibre14">Finally, create an HTML file at <span class="italic">public/resources/index.html</span>:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">&lt;!DOCTYPE html&gt;<br class="calibre6"/>&lt;html&gt;<br class="calibre6"/>&lt;head&gt;&lt;title&gt;ClojureScript Hello Compiler&lt;/title&gt;&lt;/head&gt;<br class="calibre6"/>&lt;body&gt;<br class="calibre6"/>    &lt;script src="hello.js" type="text/javascript"&gt;&lt;/script&gt;<br class="calibre6"/>    &lt;script&gt;hello_compiler.hello.main()&lt;/script&gt;<br class="calibre6"/>&lt;/body&gt;<br class="calibre6"/>&lt;/html&gt;</tt></span></blockquote><p id="filepos63342" class="calibre14"><span class="calibre5"><span class="bold">The Clojure REPL</span></span></p><p class="calibre13">Both Clojure and ClojureScript have their own REPLs. In this chapter, we are going to invoke the ClojureScript compiler, which is implemented in Clojure, so we will be using the <span class="italic">Clojure</span> REPL. In your new project, you can launch the Clojure REPL by running:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">lein repl</tt></span></blockquote><p class="calibre14">Then type the following to load the ClojureScript compiler:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(require 'cljs.closure)</tt></span></blockquote><p class="calibre14">Then type the following (long) expression to compile your project with the Google Closure Compiler in <span class="italic">Advanced Mode</span>:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(cljs.closure/build "src/cljs"<br class="calibre6"/>  {:output-to "resources/public/hello.js"<br class="calibre6"/>   :optimizations :advanced})</tt></span></blockquote><p class="calibre14">The <span class="italic">Advanced Mode</span> optimizations are time-consuming: this simple build may take 20 seconds or more. When it finishes, you will have an optimized JavaScript source file at <tt class="calibre16">resources/public/hello.js</tt>. Compare the size of this file with the unoptimized file you created in <a href="#filepos23106"><span class="calibre3">Chapter 2</span></a>—the optimized JavaScript emitted by the Google Closure Compiler is much smaller.</p><p id="filepos64923" class="calibre11"><span class="calibre12"><span class="bold">Compilation in Depth</span></span></p><p class="calibre13">When you type <tt class="calibre16">(cljs.closure/build ...)</tt> in the Clojure REPL you are invoking a function. The entire function call is wrapped in parentheses. The <tt class="calibre16">cljs.closure/build</tt> function takes two arguments, a <span class="italic">source</span> and a <span class="italic">map</span> of <span class="italic">options</span>:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(cljs.closure/build source options-map)</tt></span></blockquote><p id="filepos65452" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Compilation Sources</span></span></span></p><p class="calibre13">The <span class="italic">source</span> argument tells the compiler where to find our ClojureScript source files. Typically, it is the name of a directory, given as a string. The compiler will find all files with the <tt class="calibre16">.cljs</tt> extension in that directory and compile them together.</p><p class="calibre13">The <span class="italic">source</span> argument can also be the name of a single file to be compiled. This might be useful during development, when you only want to recompile part of a project.</p><p id="filepos66061" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Compilation and Optimization Options</span></span></span></p><p class="calibre13">The <span class="italic">options</span> are passed to the <tt class="calibre16">cljs.closure/build</tt> function in a Clojure <span class="italic">map</span>, written as a series of pairs inside curly braces.</p><p class="calibre13">In the previous example, we passed two options:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">:output-to       "resources/public/hello.js"<br class="calibre6"/>:optimizations   :advanced</tt></span></blockquote><p class="calibre14">The words that begin with colons are <span class="italic">keywords</span>, a special kind of literal data in Clojure and ClojureScript. For our purposes, they act like constants.</p><p id="filepos66837" class="calibre14"><span class="calibre5"><span class="bold">:optimizations</span></span></p><p class="calibre13">We have already seen two possible values for the <tt class="calibre16">:optimizations</tt> option, in this and the previous chapter. This option controls the optimization mode in which to run the Google Closure Compiler.</p><table border="1" valign="top" class="calibre40"><tr border="1" valign="top" class="calibre23"><th valign="top" class="calibre41"><span class="calibre10"><span class="bold"><span class="calibre18"> </span></span></span><span class="calibre10"><tt class="calibre16"><span class="bold"><span class="calibre18">:optimizations </span></span></tt></span><span class="calibre10"><span class="bold"><span class="calibre18"> Value</span></span></span></th><th valign="top" class="calibre41"><span class="calibre10"><span class="bold"><span class="calibre18"> Google Closure Compiler Mode </span></span></span></th></tr><tr border="1" valign="top" class="calibre23"><td border="1" valign="top" class="calibre24"><span class="calibre10"> :none </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> (disabled) </span></td></tr><tr border="1" valign="top" class="calibre23"><td border="1" valign="top" class="calibre24"><span class="calibre10"> :whitespace </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10">  </span><span class="calibre10"><span class="italic">Whitespace-Only</span></span></td></tr><tr border="1" valign="top" class="calibre23"><td border="1" valign="top" class="calibre24"><span class="calibre10"> :simple </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10">  </span><span class="calibre10"><span class="italic">Simple Optimizations</span></span></td></tr><tr border="1" valign="top" class="calibre23"><td border="1" valign="top" class="calibre24"><span class="calibre10"> :advanced </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10">  </span><span class="calibre10"><span class="italic">Advanced Optimizations</span></span></td></tr></table><p class="calibre14">With an <tt class="calibre16">:optimizations</tt> value of <tt class="calibre16">:none</tt>, the Google Closure Compiler will not be invoked at all, and the build will write out the JavaScript produced by the ClojureScript compiler directly. This mode is useful for development and debugging. However, the JavaScript output will be split across many individual files, requiring slightly different handling in a browser (more on this later).</p><p id="filepos69096" class="calibre14"><span class="calibre5"><span class="bold">Where do the files go?</span></span></p><p class="calibre13">The ClojureScript compiler produces one JavaScript file for each ClojureScript source file. These files go in a directory controlled by the <tt class="calibre16">:output-dir</tt> option, which defaults to a directory named <tt class="calibre16">out</tt> in the current working directory. The current working directory is whatever directory the Java (or Leiningen) process was started in. The JVM does not support changing the current working directory once a program has started.</p><p class="calibre13">The Google Closure Compiler is designed to optimize JavaScript for delivery over slow networks. As a consequence, it always produces a <span class="italic">single</span> JavaScript file for the entire compiled application. When any one of the optimization modes is enabled, the output of <tt class="calibre16">cljs.closure/build</tt> will always be a single JavaScript file.</p><p id="filepos70021" class="calibre14"><span class="calibre5"><span class="bold">Compiling with optimizations</span></span></p><p class="calibre13"><a href="#filepos70670"><span class="calibre3">Figure 3-2</span></a> shows the behavior of the <tt class="calibre16">cljs.closure/build</tt> function when compiling with optimizations. The <tt class="calibre16">:output-dir</tt> option controls where the ClojureScript compiler writes intermediate files. The <tt class="calibre16">:output-to</tt> option specifies the file location of the final output from the Google Closure Compiler. When you are compiling your application for production use, this is the JavaScript file you would put on your web server and reference in HTML pages.</p><blockquote id="filepos70670" class="calibre36"></blockquote><blockquote class="calibre37"><img src="images/00009.jpg" class="calibre42"/></blockquote><blockquote class="calibre36"><span class="calibre19"><span class="italic"><span class="calibre18">Figure 3-2. Compiler inputs and outputs with optimization</span></span></span></blockquote><p class="calibre39">If you do not specify an output file, the <tt class="calibre16">cljs.closure/build</tt> function simply returns the compiled JavaScript source code as one giant string. This might be interesting if you want to understand how the compiler works, but it’s still going to be a big blob of your entire application, so it’s probably not useful.</p><p id="filepos71408" class="calibre14"><span class="calibre5"><span class="bold">Loading optimized code in a browser</span></span></p><p class="calibre13">To run your optimized code in a browser, simply include the <tt class="calibre16">:output-to</tt> file in a <tt class="calibre16">&lt;script&gt;</tt> tag, like this:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">&lt;script src="hello.js" type="text/javascript"&gt;&lt;/script&gt;</tt></span></blockquote><p class="calibre14">ClojureScript programs usually do not act like “scripts” in the conventional sense. Loading the compiled JavaScript does not <span class="italic">do</span> anything except define functions. You typically launch your application with a “main” or “start” function invoked in a separate <tt class="calibre16">&lt;script&gt;</tt> tag, like this:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">&lt;script&gt;<br class="calibre6"/>  hello_compiler.hello.main();<br class="calibre6"/>&lt;/script&gt;</tt></span></blockquote><p class="calibre14">The details of how the ClojureScript function names translate to JavaScript object names will be covered in more detail in <a href="#filepos179627"><span class="calibre3">Chapter 7</span></a>, but the short version is that hyphens become underscores.</p><p id="filepos72664" class="calibre14"><span class="calibre5"><span class="bold">Compiling without optimizations</span></span></p><p class="calibre13">When you specify <tt class="calibre16">:optimizations :none</tt> the Google Closure Compiler does not run at all (<a href="#filepos73007"><span class="calibre3">Figure 3-3</span></a>). But the <tt class="calibre16">:output-to</tt> option is still important.</p><blockquote id="filepos73007" class="calibre36"></blockquote><blockquote class="calibre37"><img src="images/00003.jpg" class="calibre43"/></blockquote><blockquote class="calibre36"><span class="calibre19"><span class="italic"><span class="calibre18">Figure 3-3. Compiler inputs and outputs without optimization</span></span></span></blockquote><p class="calibre39">The Google Closure Library includes a dependency-resolution feature that makes it possible to split a JavaScript application across many source files and automatically load the right files in a web browser. This mechanism will be covered in detail in <a href="#filepos179627"><span class="calibre3">Chapter 7</span></a>. For now, just know that the dependency resolution mechanism requires a special file that declares all the dependency relationships in your source code. When compiling <span class="italic">without</span> optimizations, the ClojureScript compiler writes this information to the file specified by the <tt class="calibre16">:output-to</tt> option.</p><p class="calibre13">In order for a browser to load the individual files, the <tt class="calibre16">:output-dir</tt> option must be set to a directory that you can reference in the <tt class="calibre16">&lt;script&gt;</tt> tag of an HTML file. In our examples, the convention is <tt class="calibre16">"resources/public/js"</tt>.</p><p id="filepos74330" class="calibre14"><span class="calibre5"><span class="bold">Loading unoptimized code in a browser</span></span></p><p class="calibre13">To run your application in a browser without optimizations, you need <span class="italic">four</span>
<tt class="calibre16">&lt;script&gt;</tt> tags in your HTML, in precisely this order:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">&lt;script src="js/goog/base.js"&gt;&lt;/script&gt;<br class="calibre6"/>&lt;script src="hello.js"&gt;&lt;/script&gt;<br class="calibre6"/>&lt;script&gt; goog.require('hello_compiler.hello'); &lt;/script&gt;<br class="calibre6"/>&lt;script&gt; hello_compiler.hello.main(); &lt;/script&gt;</tt></span></blockquote><p class="calibre14">The first <tt class="calibre16">&lt;script&gt;</tt> tag loads the Google Closure Library from <tt class="calibre16">goog/base.js</tt>, which will be found in the directory specified by the <tt class="calibre16">:output-dir</tt> option.</p><p class="calibre13">The second <tt class="calibre16">&lt;script&gt;</tt> tag loads the dependency information for your application from the file specified by the <tt class="calibre16">:output-to</tt> option.</p><p class="calibre13">The third <tt class="calibre16">&lt;script&gt;</tt> tag uses the Google Closure Library function <tt class="calibre16">goog.require</tt> to load your application. The argument to <tt class="calibre16">goog.require</tt> is a JavaScript string naming the primary <span class="italic">namespace</span> of your application. Namespaces will be fully covered in <a href="#filepos179627"><span class="calibre3">Chapter 7</span></a>, but you have already seen them in all of the code examples. The ClojureScript expression <tt class="calibre16">(ns hello-compiler.hello)</tt> declares a namespace named <tt class="calibre16">hello-compiler.hello</tt>. Once again, hyphens become underscores in JavaScript, yielding <tt class="calibre16">hello_compiler.hello</tt>.</p><p class="calibre13">The fourth <tt class="calibre16">&lt;script&gt;</tt> tag launches your application, the same as in the optimized case. Because of the way <tt class="calibre16">goog.require</tt> works, the code to launch your application <span class="italic">must</span> be in a separate <tt class="calibre16">&lt;script&gt;</tt> tag coming <span class="italic">after</span> the <tt class="calibre16">&lt;script&gt;</tt> that calls <tt class="calibre16">goog.require</tt>.</p><p id="filepos76382" class="calibre14"><span class="calibre5"><span class="bold">An alternative: pretty-printing</span></span></p><p class="calibre13">In general, you will compile your ClojureScript application for production with <tt class="calibre16">:optimizations :advanced</tt>, and for development with <tt class="calibre16">:optimizations :none</tt>. But there is a third way, which is to use <tt class="calibre16">:optimizations :whitespace</tt> and also add the <tt class="calibre16">:pretty-print true</tt> option. This combination will still combine all of your JavaScript into a single source file and invoke the Google Closure Compiler, but it will reformat the JavaScript code for maximum readability.</p><p class="calibre13">The compilation process with <tt class="calibre16">:optimizations :whitespace</tt> and <tt class="calibre16">:pretty-print true</tt> takes slightly longer than with <tt class="calibre16">:optimizations :none</tt>, but it has the advantage of being simpler to use. You can use the exact same HTML <tt class="calibre16">&lt;script&gt;</tt> tags that you would use for fully-optimized production code, but you can still read and debug the JavaScript code directly in the browser.</p><p class="calibre13">The pretty-printing feature is provided by the Google Closure Compiler, so it has no effect with <tt class="calibre16">:optimizations :none</tt>.</p><p id="filepos77593" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Other Compilation Options</span></span></span></p><p class="calibre13">The default target for the ClojureScript compiler is web browsers. The compiler can also be used to emit JavaScript code for other execution environments, such as Node.js.<sup class="calibre44"><small class="calibre45"><span class="calibre46">[</span><a id="filepos77942"></a><a href="#filepos82861"><span class="calibre46">1</span></a><span class="calibre46">]</span></small></sup> Passing the option <tt class="calibre16">:target :nodejs</tt> to <tt class="calibre16">cljs.closure/build</tt> will tell the ClojureScript compiler to emit code, which is compatible with <span class="italic">Node.js</span>. Compiling ClojureScript for <span class="italic">Node.js</span> is still an experimental feature and not widely used, so we do not cover it in this book.</p><p class="calibre13">The <tt class="calibre16">:libs</tt>, <tt class="calibre16">:foreign-libs</tt>, and <tt class="calibre16">:externs</tt> options control access to external JavaScript libraries; these will be covered in <a href="#filepos179627"><span class="calibre3">Chapter 7</span></a>.</p><p id="filepos78585" class="calibre11"><span class="calibre12"><span class="bold">Summary</span></span></p><p class="calibre13">All the compilation options to <tt class="calibre16">cljs.closure/build</tt> are summarized in <a href="#filepos78828"><span class="calibre3">Table 3-1</span></a>.</p><p id="filepos78828" class="calibre47"></p><p class="calibre7"><span class="italic">Table 3-1. Compilation options</span></p><table border="1" valign="top" class="calibre40"><tr border="1" valign="top" class="calibre23"><th valign="top" class="calibre41"><span class="calibre10"><span class="bold"><span class="calibre18"> Option </span></span></span></th><th valign="top" class="calibre41"><span class="calibre10"><span class="bold"><span class="calibre18"> Possible Values </span></span></span></th></tr><tr border="1" valign="top" class="calibre23"><td border="1" valign="top" class="calibre24"><span class="calibre10"> </span><span class="calibre10"><tt class="calibre16">:output-to </tt></span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> file path as a string </span></td></tr><tr border="1" valign="top" class="calibre48"><td border="1" valign="top" class="calibre24"><span class="calibre10"> </span><span class="calibre10"><tt class="calibre16">:output-dir </tt></span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> directory path as a string </span></td></tr><tr border="1" valign="top" class="calibre23"><td border="1" valign="top" class="calibre24"><span class="calibre10"> </span><span class="calibre10"><tt class="calibre16">:optimizations </tt></span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> </span><span class="calibre10"><tt class="calibre16">:none</tt></span><span class="calibre10">, </span><span class="calibre10"><tt class="calibre16">:whitespace</tt></span><span class="calibre10">, </span><span class="calibre10"><tt class="calibre16">:advanced </tt></span></td></tr><tr border="1" valign="top" class="calibre48"><td border="1" valign="top" class="calibre24"><span class="calibre10"> </span><span class="calibre10"><tt class="calibre16">:pretty-print </tt></span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> </span><span class="calibre10"><tt class="calibre16">false</tt></span><span class="calibre10"> (default), </span><span class="calibre10"><tt class="calibre16">true </tt></span></td></tr><tr border="1" valign="top" class="calibre23"><td border="1" valign="top" class="calibre24"><span class="calibre10"> </span><span class="calibre10"><tt class="calibre16">:target </tt></span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> (browsers by default), </span><span class="calibre10"><tt class="calibre16">:nodejs </tt></span></td></tr><tr border="1" valign="top" class="calibre48"><td border="1" valign="top" class="calibre24"><span class="calibre10"> </span><span class="calibre10"><tt class="calibre16">:libs </tt></span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> See </span><a href="#filepos179627"><span class="calibre10"><span class="calibre3">Chapter 7 </span></span></a><span class="calibre10">.</span></td></tr><tr border="1" valign="top" class="calibre23"><td border="1" valign="top" class="calibre24"><span class="calibre10"> </span><span class="calibre10"><tt class="calibre16">:foreign-libs </tt></span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> See </span><a href="#filepos179627"><span class="calibre10"><span class="calibre3">Chapter 7 </span></span></a><span class="calibre10">.</span></td></tr><tr border="1" valign="top" class="calibre48"><td border="1" valign="top" class="calibre24"><span class="calibre10"> </span><span class="calibre10"><tt class="calibre16">:externs </tt></span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> See </span><a href="#filepos179627"><span class="calibre10"><span class="calibre3">Chapter 7 </span></span></a><span class="calibre10">.</span></td></tr></table><p class="calibre14">This chapter explained the high-level architecture ClojureScript compiler and its relationship with the Google Closure Compiler. We showed how to launch the Clojure and ClojureScript REPLs and how to invoke the ClojureScript compiler.</p><p class="calibre13">In subsequent chapters we will delve into the ClojureScript language itself. The Clojure/ClojureScript REPL shown in <a href="#filepos23106"><span class="calibre3">Chapter 2</span></a> and <a href="#filepos45583"><span class="calibre3">Chapter 3</span></a> should be sufficient to follow along with the examples that follow. After covering the language, we will circle back to compilation and development workflow in more detail.</p><br class="calibre6"/><hr class="calibre49"/><p class="calibre50"><sup class="calibre44"><small class="calibre45"><span class="calibre46">[</span><a id="filepos82861"></a><a href="#filepos77942"><span class="calibre46">1</span></a><span class="calibre46">] </span></small></sup><a href="http://nodejs.org/"><span class="calibre19"><span class="calibre3">http://nodejs.org/</span></span></a></p><div class="mbppagebreak"></div><p id="filepos83077" class="calibre11"><span class="calibre2"><span class="bold">Chapter 4. ClojureScript Basics</span></span></p><p class="calibre25">ClojureScript is a simple language, which is to say that it is based on a small number of fundamental concepts. If you have only written programs in imperative, object-oriented languages such as Java, C++, and JavaScript, then some of these concepts may be unfamiliar to you at first. However, by learning those concepts, you will be rewarded with a powerful new programming tool.</p><p id="filepos83583" class="calibre11"><span class="calibre12"><span class="bold">ClojureScript versus Clojure</span></span></p><p class="calibre13">At the language level, ClojureScript is designed to mimic Clojure as much as possible. However, neither ClojureScript nor Clojure makes any attempt to hide operational details of the underlying host platform, JavaScript or the JVM, respectively. As a result, there will be differences between the two languages wherever their host platforms are involved:</p><div class="calibre26"> </div><ul class="calibre35"><li value="1" class="calibre28"><blockquote class="calibre15">Calls to host methods or classes</blockquote></li><li value="2" class="calibre28"><blockquote class="calibre15">Built-in types such as strings and numbers</blockquote></li><li value="3" class="calibre28"><blockquote class="calibre15">Built-in operations such as arithmetic</blockquote></li><li value="4" class="calibre28"><blockquote class="calibre15">Concurrency and threading (JavaScript is single-threaded)</blockquote></li><li value="5" class="calibre28"><blockquote class="calibre15">Performance</blockquote></li></ul><p class="calibre13">At this time, ClojureScript does not implement all of the Clojure language. In particular, ClojureScript does not include most of the concurrency features for which Clojure is so well known; because JavaScript VMs are single-threaded, these features are less important. There are also features of Clojure that have not yet been implemented in ClojureScript simply because work has not yet been completed.</p><p class="calibre13">Clojure itself is a young programming language (first released in 2007) but it has grown rapidly in stability, ease of use, and performance. ClojureScript is even younger (first released in 2011) and is consequentially less mature. You can expect to find rough edges, bugs, and undocumented features. While we hope that this book will help to ameliorate the latter, nothing can take the place of experience that comes from building real-world applications.</p><p class="calibre13">This book does not attempt to fully document all the features of the Clojure language, or even all of the features currently implemented in ClojureScript. Instead, we will attempt to provide enough to get you started and working productively in ClojureScript. When you are ready to learn more, there are many books available on the Clojure language: most of their material will apply equally well to ClojureScript.</p><p id="filepos86123" class="calibre11"><span class="calibre12"><span class="bold">Expressions and Side Effects</span></span></p><p class="calibre13">Most mainstream programming languages, including JavaScript, have both <span class="italic">statements</span> and <span class="italic">expressions</span>. In JavaScript, statements end with a semicolon (usually) and are typically related to flow control: <tt class="calibre16">for</tt>, <tt class="calibre16">if</tt>, <tt class="calibre16">while</tt>, and so on. JavaScript expressions include literals (numbers, strings, regexes), function calls, and arithmetic operations. The key difference is that expressions always have a <span class="italic">value</span> whereas statements do not. Expressions can be nested: you can place a function call expression inside an <tt class="calibre16">if</tt> statement, but not the other way around.</p><p class="calibre13">In ClojureScript, everything is an expression and everything has a value, even the control structures. (Sometimes that value is <tt class="calibre16">null</tt>, but it’s still a value.) You can even define your own flow-control expressions using <span class="italic">macros</span>, which we will cover in <a href="#filepos215466"><span class="calibre3">Chapter 8</span></a>. The process of going from an expression to its value is called <span class="italic">evaluating</span> the expression.</p><p class="calibre13">Some expressions can have <span class="italic">side effects</span>, things that happen when they are evaluated other than simply returning a value. Printing output to the screen or manipulating an HTML document in a web browser are both side effects. ClojureScript favors a “functional” style of programming in which most code consists of “pure” expressions that return a value with no side effects. Of course, a program entirely without side effects cannot produce any output at all, so ClojureScript allows you to break out of the functional style when you need to.</p><p id="filepos87895" class="calibre11"><span class="calibre12"><span class="bold">Syntax and Data Structures</span></span></p><p class="calibre13">As we said, everything in ClojureScript is an expression, including the primitive data types, which “evaluate” to themselves. Comments begin with a semicolon and continue to the end of a line.</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">42, 3.14159          ; Numbers<br class="calibre6"/>"Hello, World!"      ; String<br class="calibre6"/>#"\d{3}-\d{3}-\d{4}" ; RegExp<br class="calibre6"/>true, false          ; Boolean<br class="calibre6"/>nil                  ; null</tt></span></blockquote><p class="calibre14">ClojureScript numbers and strings are the same as JavaScript <tt class="calibre16">Number</tt> and <tt class="calibre16">String</tt> objects, with essentially the same syntax. ClojureScript regular expressions evaluate to JavaScript <tt class="calibre16">RegExp</tt> but have slightly different syntax.</p><p id="filepos88837" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Symbols and Keywords</span></span></span></p><p class="calibre13"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">map, +, swap!  ; Symbols<br class="calibre6"/>:meta, :my-id  ; Keywords</tt></span></blockquote><p class="calibre14">ClojureScript has <span class="italic">symbols</span>, which are just bare words in your program. Symbols evaluate to other values, such as functions, and also serve a role similar to local variables, although they are not really variables. The <span class="italic">name</span> of a symbol can contain almost any character, including hyphens and other punctuation. Things that are typically special operators in other languages, such as the arithmetic operators <tt class="calibre16">+</tt>, <tt class="calibre16">-</tt>, <tt class="calibre16">*</tt>, and <tt class="calibre16">/</tt>, are just symbols in ClojureScript, which evaluate to the built-in arithmetic functions.</p><p class="calibre13">ClojureScript also has <span class="italic">keywords</span>, written as symbols with a leading colon. Keywords always evaluate to themselves. Unlike symbols, they never stand in for anything else. In JavaScript, strings are often used for constants or identifiers in code; keywords fill the same role in ClojureScript.</p><p id="filepos90047" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Data Structures</span></span></span></p><p class="calibre13"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(1 2 3), (print "Hello")  ; Lists<br class="calibre6"/>[:a :b :c 1 2 3]          ; Vector<br class="calibre6"/>{:a 1, "b" 2}             ; Map<br class="calibre6"/>#{3 7 :z}                 ; Set</tt></span></blockquote><p class="calibre14">Finally, there are the four basic data structures. Vectors, maps, and sets evaluate to themselves: they are literal data structures similar to JavaScript’s arrays and objects. Individual elements in a data structure must be separated by whitespace. In ClojureScript, commas count as whitespace in addition to the usual space, tab, and line break. We will talk more about these data structures in the next chapter.</p><p class="calibre13">Lists can be used as literal data, but more often they are used to construct expressions. When the ClojureScript compiler encounters a list, it examines the first element of the list and tries to invoke it. The first element is the <span class="italic">function position</span> of the list. It is usually a symbol naming a function, but it could also be a macro or special operator, which we will define later.</p><p class="calibre13">Even operators like <tt class="calibre16">+</tt> and <tt class="calibre16">*</tt> are functions, so they must appear in function position. ClojureScript code therefore uses <span class="italic">prefix notation</span> instead of the more common <span class="italic">algebraic notation</span> used by most programming languages. In ClojureScript, the parentheses are always required, but there are no “operator precedence” rules to remember:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(+ 9 (* 10 5))   ; 9 + 10 * 5 in algebraic notation</tt></span></blockquote><p class="calibre14">As for syntax, that’s (almost) all there is to it! Everything in ClojureScript is composed from these simple parts.</p><p class="calibre13">The following expression contains two lists, one nested inside the other:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(println (+ 3 4))</tt></span></blockquote><p class="calibre14">The outer list contains two elements: the symbol <tt class="calibre16">println</tt> in function position and the inner list. The inner list has the symbol <tt class="calibre16">+</tt> in function position, followed by two numbers.</p><p class="calibre13">Expressions are evaluated from the inside out, so this example will compile into JavaScript code, which adds <tt class="calibre16">3</tt> to <tt class="calibre16">4</tt> and then prints the result. Printing is a side effect; the whole expression <span class="italic">evaluates</span> to <tt class="calibre16">nil</tt>, which is the value returned by the <tt class="calibre16">println</tt> function. If you type this expression into the ClojureScript REPL, you will see <tt class="calibre16">7</tt> printed on one line and <tt class="calibre16">nil</tt> on the following line.</p><p id="filepos93016" class="calibre11"><span class="calibre12"><span class="bold">Special Forms and Definitions</span></span></p><p class="calibre13">As we mentioned in the previous section, the symbol in the function position of a list may be a function, macro, or special operator. Special operators are symbols that are defined by the ClojureScript compiler. These are the “primitives” of the language, and there are only a handful you will encounter, such as <tt class="calibre16">if</tt>, <tt class="calibre16">def</tt>, and <tt class="calibre16">do</tt>. Most of the standard operators in ClojureScript, such as arithmetic and control flow, are handled by functions and macros.</p><p class="calibre13">One special operator you will use often is <tt class="calibre16">def</tt>, which defines a new <span class="italic">binding</span> from a symbol to a value. After a new binding is created with <tt class="calibre16">def</tt>, evaluating the symbol will return its value.</p><p class="calibre13">For example, here we bind the symbol <tt class="calibre16">my-name</tt> to a string:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(def my-name "Leslie Q. Coder")</tt></span></blockquote><p class="calibre14">Symbol bindings created with <tt class="calibre16">def</tt> compile into JavaScript <tt class="calibre16">var</tt> declarations, but you should think of them as constants, not local variables. In particular, <tt class="calibre16">def</tt> expressions are not intended to be used inside functions, nor should they be used to rebind symbols to new values (except during interactive development at the REPL).</p><p id="filepos94494" class="calibre11"><span class="calibre12"><span class="bold">Functions</span></span></p><p class="calibre13">ClojureScript functions are very much like JavaScript functions. The <tt class="calibre16">fn</tt> macro creates unnamed, <span class="italic">anonymous</span> functions, like JavaScript’s <tt class="calibre16">function</tt> operator.</p><p class="calibre13">The <tt class="calibre16">fn</tt> symbol appears in function position of a list, followed by the <span class="italic">parameters</span> (arguments) to the function as a vector of symbols, followed by one or more expressions comprising the <span class="italic">body</span> of the function. Here is a simple function:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(fn [name] (str "Hello, " name))</tt></span></blockquote><p class="calibre14">This function takes one argument, called <tt class="calibre16">name</tt>, and calls the <tt class="calibre16">str</tt> function, which concatenates strings, in its body. It compiles to JavaScript that looks something like this:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">function(name) { return cljs.core.str("Hello, " name); }</tt></span></blockquote><p class="calibre14">A function isn’t very useful unless we can call it. Remember that the first element of a list is evaluated as a function, so we can place a literal <tt class="calibre16">fn</tt> at the front of a list to invoke it. The arguments we want to pass to the function are the remaining elements of the list:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">((fn [name] (str "Hello, " name)) "ClojureScript")<br class="calibre6"/>;;=&gt; "Hello, ClojureScript"</tt></span></blockquote><p class="calibre14">This example compiles to JavaScript that creates an anonymous function and immediately invokes it, like this:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(function(name) {<br class="calibre6"/>    return cljs.core.str("Hello, " name);<br class="calibre6"/>})("ClojureScript");</tt></span></blockquote><p class="calibre14">Even this is not very practical, so we usually want to give our functions names. Functions are values like any other, so we can use the <tt class="calibre16">def</tt> macro to bind them to symbols. Here we bind the symbol <tt class="calibre16">greeting</tt> to a function and then call it by name:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(def greeting<br class="calibre6"/>  (fn [name] (str "Hello, " name)))<br class="calibre6"/><br class="calibre6"/>(greeting "functions!")<br class="calibre6"/>;;=&gt; "Hello, functions!"</tt></span></blockquote><p class="calibre14">Binding symbols to functions is so common that ClojureScript has a macro to make it easier. The <tt class="calibre16">defn</tt> macro takes a symbol to define, followed by the parameter vector and function body as with <tt class="calibre16">fn</tt>.</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(defn greeting [name]<br class="calibre6"/>  (str "Hello, " name))</tt></span></blockquote><p class="calibre14">We will explore macros further in <a href="#filepos215466"><span class="calibre3">Chapter 8</span></a>. For now, just know that they can control the way things are evaluated.</p><p id="filepos97666" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Multi-Arity Functions</span></span></span></p><p class="calibre13">In JavaScript, any function can be called with any number of arguments, and those arguments can be accessed via the <tt class="calibre16">arguments</tt> array. ClojureScript allows functions to be defined with several <span class="italic">arities</span>, or numbers of arguments. Each arity of the function can have different behavior. A multi-arity function looks like this:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(defn greeting<br class="calibre6"/>  ([] (greeting "Hello" "world"))<br class="calibre6"/>  ([name] (greeting "Hello" name))<br class="calibre6"/>  ([salutation name] (str salutation ", " name "!")))</tt></span></blockquote><p class="calibre14">Each arity of the function is its own list inside the function definition. The first element of each list is the argument vector, followed by the function body. This example demonstrates a common use of multi-arity functions: to provide default values for some or all of the parameters. Multi-arity functions may feel similar to “function overloading” in languages such as C and Java, with the difference that they are overloaded only on the number, not the type, of their arguments.</p><p id="filepos98958" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Variadic Functions</span></span></span></p><p class="calibre13">In addition to having multiple arities, a ClojureScript function can be defined to take any number of arguments: this is called a <span class="italic">variadic</span> function. A variadic function has the special symbol <tt class="calibre16">&amp;</tt> (ampersand) before the last symbol in its argument vector, as in the following:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(defn average<br class="calibre6"/>  ([x] x)<br class="calibre6"/>  ([x y] (/ (+ x y) 2))<br class="calibre6"/>  ([x y &amp; extra] (/ (reduce + (+ x y) extra)<br class="calibre6"/>                    (+ 2 (count extra)))))</tt></span></blockquote><p class="calibre14">This example defines a function with three arities, the last of which is variadic. If the <tt class="calibre16">average</tt> function is called with one argument, it returns that argument. If it is called with two arguments, it adds them together and divides by 2. If it is called with three <span class="italic">or more</span> arguments, it computes their average using the <tt class="calibre16">reduce</tt> and <tt class="calibre16">count</tt> functions, which we will cover in <a href="#filepos164179"><span class="calibre3">Chapter 6</span></a>. Notice that a function can be both multi-arity and variadic at the same time, but only one of a function’s arities can be variadic.</p><p id="filepos100359" class="calibre11"><span class="calibre12"><span class="bold">Local Bindings</span></span></p><p class="calibre13">ClojureScript does not have variables like JavaScript because all data is immutable, but it does permit you to create a <span class="italic">local binding</span> between a symbol and a value with the <tt class="calibre16">let</tt> expression, as shown below:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(let </tt></span><span class="calibre19"><tt class="calibre16"><span class="italic">[binding-form value-expr<br class="calibre6"/>      ...]<br class="calibre6"/>  ... expressions ...)</span></tt></span></blockquote><p class="calibre14">The <tt class="calibre16">let</tt> expression begins with a vector of <span class="italic">bindings</span>. Each binding is a pair: first a <span class="italic">binding form</span>, usually a symbol, then a <span class="italic">value expression</span>. When evaluated, the <tt class="calibre16">let</tt> evaluates the value expressions, in order, and binds them to the symbols in the binding forms. This creates a local binding within the body of the <tt class="calibre16">let</tt>. For example:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(let [x 4<br class="calibre6"/>      y (+ x 3)]<br class="calibre6"/>  (println "The product of" x "and" y "is")<br class="calibre6"/>  (println (* x y)))<br class="calibre6"/>;; The product of 4 and 7 is<br class="calibre6"/>;; 28<br class="calibre6"/>;;=&gt; nil</tt></span></blockquote><p class="calibre14">Notice that the value expressions can include references to the symbols created in earlier bindings.</p><p id="filepos101802" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Destructuring</span></span></span></p><p class="calibre13">In addition to symbols, binding forms can include data structures such as vectors and maps. The result of the value expression will be <span class="italic">destructured</span> to match the binding form. For example:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(def nums (list 2 3 5 8 13 21))<br class="calibre6"/><br class="calibre6"/>(let [[a b c &amp; the-rest] nums]<br class="calibre6"/>  (println "a is" a)<br class="calibre6"/>  (println "b is" b)<br class="calibre6"/>  (println "c is" c)<br class="calibre6"/>  (println "the-rest is" the-rest))<br class="calibre6"/>;; a is 2<br class="calibre6"/>;; b is 3<br class="calibre6"/>;; c is 5<br class="calibre6"/>;; the-rest is (8 13 21)</tt></span></blockquote><p class="calibre14">In this example, the binding form is the vector <tt class="calibre16">[a b c &amp; the-rest]</tt>. It destructures the list <tt class="calibre16">nums</tt> and assigns <tt class="calibre16">a</tt> to <tt class="calibre16">2</tt>, <tt class="calibre16">b</tt> to <tt class="calibre16">3</tt>, and so on. The special symbol <tt class="calibre16">&amp;</tt> collects all the remaining elements into a list and binds it to the following symbol, <tt class="calibre16">the-rest</tt>.</p><p class="calibre13">The full syntax of destructuring is a rich and powerful mini-language of its own; refer to the Clojure language documentation for more details and examples.</p><p id="filepos103146" class="calibre11"><span class="calibre12"><span class="bold">Closures</span></span></p><p class="calibre13">Like JavaScript, ClojureScript supports <span class="italic">lexical closures</span>. A function can refer to symbols defined in the <span class="italic">lexical scope</span> in which it was created. Function arguments and the <tt class="calibre16">let</tt> form create lexical scopes. For example:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(defn make-adder [n]<br class="calibre6"/>  (fn [x] (+ x n)))<br class="calibre6"/><br class="calibre6"/>(def add4 (make-adder 4))<br class="calibre6"/>(def add7 (make-adder 7))<br class="calibre6"/><br class="calibre6"/>(add4 10)<br class="calibre6"/>;;=&gt; 14<br class="calibre6"/><br class="calibre6"/>(add7 10)<br class="calibre6"/>;;=&gt; 17</tt></span></blockquote><p class="calibre14">In this example, the <tt class="calibre16">make-adder</tt> function returns another function which “closes over” the value of <tt class="calibre16">n</tt> in its scope. We can use <tt class="calibre16">make-adder</tt> to define new functions <tt class="calibre16">add4</tt> and <tt class="calibre16">add7</tt>, which “remember” the binding of <tt class="calibre16">n</tt> that was in effect when they were created.</p><p id="filepos104179" class="calibre11"><span class="calibre12"><span class="bold">Flow Control</span></span></p><p class="calibre13">As we said at the start of this chapter, everything is an expression in ClojureScript. That includes the control-flow expressions. For our purposes, a flow-control expression is one that controls how its components are evaluated. For example, an <tt class="calibre16">if</tt> expression is only going to evaluate one branch. This is what makes <tt class="calibre16">if</tt> different from a function call, which always evaluates all of its arguments.</p><p class="calibre13">This section introduces some of the most common flow-control expressions in ClojureScript. Some of them are special forms defined in the compiler, and some are macros defined in the core library, but the difference doesn’t matter at this point.</p><p id="filepos104976" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Conditional Branching</span></span></span></p><p class="calibre13">In ClojureScript, the basic conditional branch is represented by an <tt class="calibre16">if</tt> expression:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(if </tt></span><span class="calibre19"><tt class="calibre16"><span class="italic">test-expr<br class="calibre6"/>  then-expr<br class="calibre6"/>  else-expr</span></tt></span><span class="calibre19"><tt class="calibre16">)</tt></span></blockquote><p class="calibre14">The <tt class="calibre16">if</tt> expression takes three subexpressions. First, it will evaluate the <tt class="calibre16"><span class="italic">test-expr</span></tt>. If the result of the <tt class="calibre16"><span class="italic">test-expr</span></tt> is <span class="italic">logical true</span> (see the sidebar on “Truthiness”), then it will evaluate the <tt class="calibre16"><span class="italic">then-expr</span></tt>, otherwise it will evaluate the <tt class="calibre16"><span class="italic">else-expr</span></tt>. For example:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(if (even? 42)<br class="calibre6"/>  (println "42 is even")<br class="calibre6"/>  (println "42 is odd"))</tt></span></blockquote><blockquote class="calibre29"></blockquote><blockquote class="calibre30"><span class="calibre19"><span class="bold">TRUTHINESS</span></span></blockquote><blockquote class="calibre15"><span class="calibre19">What is logical true? In ClojureScript, </span><span class="calibre19"><tt class="calibre16">nil</tt></span><span class="calibre19">, </span><span class="calibre19"><tt class="calibre16">false</tt></span><span class="calibre19">, and the undefined value (written </span><span class="calibre19"><tt class="calibre16">js/undefined</tt></span><span class="calibre19">) are logical false, and </span><span class="calibre19"><span class="italic">anything else</span></span><span class="calibre19"> is logical true. This is different from JavaScript, which also considers </span><span class="calibre19"><tt class="calibre16">0</tt></span><span class="calibre19">, </span><span class="calibre19"><tt class="calibre16">NaN</tt></span><span class="calibre19">, and the empty string to be logical false.</span></blockquote><blockquote class="calibre51"></blockquote><blockquote class="calibre34"><span class="calibre10"><tt class="calibre16">(if false :truthy :falsey)         ;=&gt; :falsey<br class="calibre6"/>(if nil :truthy :falsey)           ;=&gt; :falsey<br class="calibre6"/>(if js/undefined :truthy :falsey)  ;=&gt; :falsey<br class="calibre6"/><br class="calibre6"/>(if true :truthy :falsey)          ;=&gt; :truthy<br class="calibre6"/>(if 0 :truthy :falsey)             ;=&gt; :truthy<br class="calibre6"/>(if "" :truthy :falsey)            ;=&gt; :truthy<br class="calibre6"/>(if js/NaN :truthy :falsey)        ;=&gt; :truthy<br class="calibre6"/>(if [] :truthy :falsey)            ;=&gt; :truthy</tt></span></blockquote><blockquote class="calibre34"><span class="calibre19">Different programming languages have different ideas of truth. In C, </span><span class="calibre19"><tt class="calibre16">0</tt></span><span class="calibre19"> is false and any other number is true. Java has the primitive </span><span class="calibre19"><tt class="calibre16">boolean</tt></span><span class="calibre19"> type, which can be either </span><span class="calibre19"><tt class="calibre16">true</tt></span><span class="calibre19"> or </span><span class="calibre19"><tt class="calibre16">false</tt></span><span class="calibre19">. ClojureScript’s definition of logical truth is consistent with Clojure (except </span><span class="calibre19"><tt class="calibre16">js/undefined</tt></span><span class="calibre19">, which has no equivalent in Clojure). Using </span><span class="calibre19"><tt class="calibre16">nil</tt></span><span class="calibre19"> as a logical false value is useful in the context of sequences, which are covered in </span><a href="#filepos164179"><span class="calibre19"><span class="calibre3">Chapter 6</span></span></a><span class="calibre19">.</span></blockquote><blockquote class="calibre15"><span class="calibre19">The </span><span class="calibre19"><tt class="calibre16">js/NaN</tt></span><span class="calibre19"> value is JavaScript’s “not a number,” resulting from calculations like zero divided by zero. </span><span class="calibre19"><tt class="calibre16">js/NaN</tt></span><span class="calibre19"> is never equal to anything, including itself:</span></blockquote><blockquote class="calibre51"></blockquote><blockquote class="calibre34"><span class="calibre10"><tt class="calibre16">(if (= js/NaN js/NaN) :yes :no)    ;=&gt; :no</tt></span></blockquote><p id="filepos108969" class="calibre52"><span class="calibre5"><span class="bold">cond</span></span></p><p class="calibre13">It is possible to create multiple branches with nested <tt class="calibre16">if</tt> expressions, but it is more concise to use the <tt class="calibre16">cond</tt> macro instead:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(cond </tt></span><span class="calibre19"><tt class="calibre16"><span class="italic">test-expr-1 body-expr-1<br class="calibre6"/>      test-expr-2 body-expr-2<br class="calibre6"/>      ...</span></tt></span><span class="calibre19"><tt class="calibre16"><br class="calibre6"/>      :else </tt></span><span class="calibre19"><tt class="calibre16"><span class="italic">else-expr</span></tt></span><span class="calibre19"><tt class="calibre16">)</tt></span></blockquote><p class="calibre14">The <tt class="calibre16">cond</tt> macro contains matched pairs of <tt class="calibre16">test</tt> and <tt class="calibre16">body</tt> expressions. It evaluates each <tt class="calibre16">test</tt> expression in order. If one of the <tt class="calibre16">test</tt> expressions returns logical true, then <tt class="calibre16">cond</tt> evaluates the matching <tt class="calibre16">body</tt> expression and returns. If none of the <tt class="calibre16">test</tt> expressions returns logical true, then <tt class="calibre16">cond</tt> returns <tt class="calibre16">nil</tt>.</p><p class="calibre13">It is possible to add a “default” case to a <tt class="calibre16">cond</tt> expression by using the keyword <tt class="calibre16">:else</tt> as a <tt class="calibre16">test</tt> expression. Since <tt class="calibre16">:else</tt> is a keyword, it evaluates to itself, and because it is neither <tt class="calibre16">nil</tt> nor <tt class="calibre16">false</tt>, it is always logical true. In fact, any logical true value would work, but it is conventional to use the keyword <tt class="calibre16">:else</tt>.</p><p class="calibre13">As an example, here is a conditional written first with nested <tt class="calibre16">if</tt> expressions and then with <tt class="calibre16">cond</tt>:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(if (&lt;= x 10)<br class="calibre6"/>  "x is a small number"<br class="calibre6"/>  (if (&lt;= 11 x 100)<br class="calibre6"/>    "x is a medium-sized number"<br class="calibre6"/>    (if (&lt;= 101 x 1000)<br class="calibre6"/>      "x is a big number"<br class="calibre6"/>      "x is a REALLY big number")))<br class="calibre6"/><br class="calibre6"/>(cond (&lt;= x 10)<br class="calibre6"/>        "x is a small number"<br class="calibre6"/>      (&lt;= 11 x 100)<br class="calibre6"/>        "x is a medium-sized number"<br class="calibre6"/>      (&lt;= 101 x 1000)<br class="calibre6"/>        "x is a big number"<br class="calibre6"/>      :else<br class="calibre6"/>        "x is a REALLY big number")</tt></span></blockquote><p class="calibre14">The <tt class="calibre16">&lt;</tt> and <tt class="calibre16">&gt;=</tt> functions are the numeric less-than and greater-than-or-equal-to comparisons. Like all other functions in ClojureScript, they must be in function position, so the expression <tt class="calibre16">(&lt; x 10)</tt> can be read “is <tt class="calibre16">x</tt> less than 10?” The expression <tt class="calibre16">(&lt; 100 x 10000)</tt> can be read “is 100 less than <tt class="calibre16">x</tt> and <tt class="calibre16">x</tt> less than 10,000?”</p><p class="calibre13">Remember that whitespace is never significant in ClojureScript. The test and body expressions in the <tt class="calibre16">cond</tt> macro can be on the same line or on different lines. All that matters is the order in which they appear.</p><p id="filepos112027" class="calibre14"><span class="calibre5"><span class="bold">do</span></span></p><p class="calibre13">Each body inside an <tt class="calibre16">if</tt> or <tt class="calibre16">cond</tt> expression is limited to a single expression. Most of the time, when writing “pure” functions without side effects, this is sufficient. But sometimes side effects are necessary. ClojureScript’s <tt class="calibre16">do</tt> expression allows multiple expressions to be used in the place of one:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(do<br class="calibre6"/>  </tt></span><span class="calibre19"><tt class="calibre16"><span class="italic">... expressions ...</span></tt></span><span class="calibre19"><tt class="calibre16"><br class="calibre6"/>  )</tt></span></blockquote><p class="calibre14">The <tt class="calibre16">do</tt> form contains any number of expressions. When evaluated, it evaluates each expression in order. It is similar to JavaScript’s curly braces <tt class="calibre16">{}</tt>, except that it also returns a value. The return value of the last expression inside the <tt class="calibre16">do</tt> block is the return value of the entire <tt class="calibre16">do</tt> expression.</p><p class="calibre13">You can use a <tt class="calibre16">do</tt> expression to write multiple expressions in a place that normally only takes one expression. This is commonly used when you need to write expressions that have side effects:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(cond (&lt; x 10)<br class="calibre6"/>        (do (println "x is a small number")<br class="calibre6"/>            :small)<br class="calibre6"/>      (&lt; 100 x 1000)<br class="calibre6"/>        (do (println "x is a big number")<br class="calibre6"/>            :big)<br class="calibre6"/>      (&gt;= x 10000)<br class="calibre6"/>        (do (println "x is a REALLY big number")<br class="calibre6"/>            :huge)<br class="calibre6"/>      :else<br class="calibre6"/>        (do (println  "x is just a medium-sized number")<br class="calibre6"/>            :medium))</tt></span></blockquote><p class="calibre14">If the value of <tt class="calibre16">x</tt> is less than 10, this expression will print “x is a small number” <span class="italic">and then return</span> the keyword <tt class="calibre16">:small</tt>; if <tt class="calibre16">x</tt> is between 100 and 10,000, it will print “x is a big number” <span class="italic">and then return</span> the keyword <tt class="calibre16">:big</tt>; and so on.</p><p id="filepos114282" class="calibre14"><span class="calibre5"><span class="bold">when</span></span></p><p class="calibre13">ClojureScript provides several built-in macros that combine conditional expressions with an <span class="italic">implicit</span>
<tt class="calibre16">do</tt> form. This includes the <tt class="calibre16">defn</tt> macro for defining functions. As another example, the <tt class="calibre16">when</tt> macro combines the <tt class="calibre16">if</tt> and <tt class="calibre16">do</tt> expressions:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(when </tt></span><span class="calibre19"><tt class="calibre16"><span class="italic">condition<br class="calibre6"/>  ... expressions ...</span></tt></span><span class="calibre19"><tt class="calibre16">)<br class="calibre6"/><br class="calibre6"/>;; is the same as<br class="calibre6"/>(if </tt></span><span class="calibre19"><tt class="calibre16"><span class="italic">condition</span></tt></span><span class="calibre19"><tt class="calibre16"><br class="calibre6"/>  (do </tt></span><span class="calibre19"><tt class="calibre16"><span class="italic">... expressions ...</span></tt></span><span class="calibre19"><tt class="calibre16">))</tt></span></blockquote><p id="filepos115138" class="calibre11"><span class="calibre12"><span class="bold">JavaScript Interop</span></span></p><p class="calibre13">ClojureScript, like Clojure, is designed to stay as close as possible to the semantics of its host platform, only adding to them where necessary. So ClojureScript strings are JavaScript <tt class="calibre16">String</tt> objects, ClojureScript numbers are JavaScript <tt class="calibre16">Number</tt> objects, and ClojureScript functions are JavaScript <tt class="calibre16">Function</tt> objects. You can call JavaScript functions, methods, and constructors just like calling any other function in ClojureScript.</p><p id="filepos115707" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">The js Namespace</span></span></span></p><p class="calibre13">JavaScript, regrettably, has no concept of <span class="italic">namespaces</span>. Every function or variable defined in a JavaScript program lives in the same global scope. When two libraries want to use the same name, they often clash. Workarounds exist, such as using JavaScript objects as “modules” and defining things within the scope of anonymous functions, but they are just workarounds.</p><p class="calibre13">ClojureScript has built-in support for namespaces at the language level: this is one of the places where it extends the semantics of the host platform to provide a better developer experience. We will cover namespaces more completely in <a href="#filepos179627"><span class="calibre3">Chapter 7</span></a> but one namespace deserves special attention: the <tt class="calibre16">js</tt> namespace. ClojureScript uses the <tt class="calibre16">js</tt> namespace to refer to the global scope of a JavaScript program. Core JavaScript constructors such as <tt class="calibre16">String</tt> and <tt class="calibre16">Date</tt> are accessed through this namespace, as are browser-defined objects such as <tt class="calibre16">window</tt>. The following sections show examples of these.</p><p id="filepos116939" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Methods and Fields</span></span></span></p><p class="calibre13">ClojureScript can access methods and fields of JavaScript objects directly. A JavaScript method invocation is written in ClojureScript as a list beginning with the method name, prefixed with a <tt class="calibre16">.</tt> (period). A field access is written similarly but prefixed with a <tt class="calibre16">.-</tt> (period and hyphen):</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">// JavaScript<br class="calibre6"/>var message = "Hello, World!"<br class="calibre6"/>var msg_length = message.length;<br class="calibre6"/>var insult = message.replace(/World/, "idiots");</tt></span></blockquote><p class="calibre14"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">;; ClojureScript<br class="calibre6"/>(def message "Hello, World!")<br class="calibre6"/>(def msg-length (.-length message))<br class="calibre6"/>(def insult (.replace message #"World" "idiots"))</tt></span></blockquote><blockquote class="calibre17"><span class="calibre10"><span class="bold"><span class="calibre18">NOTE</span></span></span></blockquote><blockquote class="calibre15"><span class="calibre19">In Clojure on the JVM, the same </span><span class="calibre19"><tt class="calibre16">(.name object)</tt></span><span class="calibre19"> syntax was used for both method calls and field accesses. Since the Java language does not allow a method and a field in the same class to have the same name, there was never any ambiguity as to which was intended. But in JavaScript, methods are also fields with functions as values. To prevent ambiguity when calling methods from ClojureScript, the </span><span class="calibre19"><tt class="calibre16">(.-field object)</tt></span><span class="calibre19"> syntax was added for fields. This syntax was later backported to Clojure on the JVM, first appearing in release 1.4.0. Clojure on the JVM still accepts the </span><span class="calibre19"><tt class="calibre16">(.name object)</tt></span><span class="calibre19"> syntax for both fields and methods, but ClojureScript always treats </span><span class="calibre19"><tt class="calibre16">(.name object)</tt></span><span class="calibre19"> as a method call and </span><span class="calibre19"><tt class="calibre16">(.-name object)</tt></span><span class="calibre19"> as a field access.</span></blockquote><p class="calibre21">Notice that the syntaxes for field access and method calls are unified with ClojureScript’s syntax for function calls. The “target object” on which a method or field is called no longer has a special position before the method or field name; it becomes just another argument in the function call. Method and field names are not given a namespace qualifier like <tt class="calibre16">js/</tt> because they are already scoped within an object.</p><p id="filepos119582" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Constructor Functions</span></span></span></p><p class="calibre13">JavaScript constructor functions are also written as lists, but with a <tt class="calibre16">.</tt> (period or full stop) <span class="italic">appended</span> to the name of the function:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">// JavaScript<br class="calibre6"/>var today = new Date(2012, 6, 16);</tt></span></blockquote><p class="calibre14"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">;; ClojureScript<br class="calibre6"/>(def today (js/Date. 2012 6 16))</tt></span></blockquote><p class="calibre14">Notice that the <tt class="calibre16">Date</tt> constructor is accessed through the <tt class="calibre16">js</tt> namespace, written <tt class="calibre16">js/Date</tt>. The period in <tt class="calibre16">js/Date.</tt> (with no space in between the period and the function name) tells the ClojureScript compiler that this expression should compile to JavaScript’s <tt class="calibre16">new</tt> operator.</p><p class="calibre13">Some built-in JavaScript functions, such as <tt class="calibre16">Number</tt> and <tt class="calibre16">Date</tt>, can be called as either a constructor function or an ordinary function. Without the trailing period, the same function can be invoked as an ordinary function, without the <tt class="calibre16">new</tt> operator:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">// JavaScript<br class="calibre6"/>var today = Date();</tt></span></blockquote><p class="calibre14"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">;; ClojureScript<br class="calibre6"/>(def today (js/Date))</tt></span></blockquote><p id="filepos121197" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Scope of this</span></span></span></p><p class="calibre13">Because of JavaScript’s lack of namespaces, it is common practice to attach global functions to “module objects.” These functions can be invoked using <span class="italic">either</span> the namespace-qualified syntax or method call syntax. For example, if you were using the RaphaelJS library, <sup class="calibre44"><small class="calibre45"><span class="calibre46">[</span><a id="filepos121642"></a><a href="#filepos127173"><span class="calibre46">2</span></a><span class="calibre46">]</span></small></sup> you could call its <tt class="calibre16">color</tt> function like this:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">// JavaScript<br class="calibre6"/>var green = Raphael.color("#00ff00");</tt></span></blockquote><p class="calibre14"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">;; ClojureScript<br class="calibre6"/>(def green (Raphael/color "#00ff00"))</tt></span></blockquote><p class="calibre14">You could also invoke the <tt class="calibre16">color</tt> function as a method on the <tt class="calibre16">Raphael</tt> object in the global JavaScript scope, like this:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(defn green (.color js/Raphael "#00ff00"))</tt></span></blockquote><p class="calibre14">The difference comes in the handling of JavaScript’s <tt class="calibre16">this</tt>. The namespace-style syntax (<tt class="calibre16">Raphael/color</tt>) will compile to code that calls the <tt class="calibre16">color</tt> function with <tt class="calibre16">this</tt> bound to <tt class="calibre16">null</tt>. The method-style syntax (<tt class="calibre16">.color</tt>) will invoke the <tt class="calibre16">color</tt> function with <tt class="calibre16">this</tt> bound to the <tt class="calibre16">Raphael</tt> object. The former is more natural in ClojureScript code, but some JavaScript libraries depend on methods being invoked with <tt class="calibre16">this</tt> bound to the “module” object.</p><p class="calibre13">Functions defined in JavaScript’s global scope, such as web browsers’ built-in <tt class="calibre16">alert()</tt> function, are accessed through the <tt class="calibre16">js</tt> namespace, as shown below. (Note that this example may not work in Microsoft Internet Explorer, because IE’s JavaScript implementation defines <tt class="calibre16">alert</tt> as a special syntactic form, not a normal JavaScript function.)</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">// JavaScript<br class="calibre6"/>alert("Hello, World!");</tt></span></blockquote><p class="calibre14"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">;; ClojureScript<br class="calibre6"/>(js/alert "Hello, World!")</tt></span></blockquote><p id="filepos123763" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Exceptions</span></span></span></p><p class="calibre13">ClojureScript has <tt class="calibre16">try</tt>/<tt class="calibre16">catch</tt>/<tt class="calibre16">finally</tt> and <tt class="calibre16">throw</tt> forms that behave similarly to their JavaScript equivalents. The <tt class="calibre16">try</tt>/<tt class="calibre16">catch</tt>/<tt class="calibre16">finally</tt> form looks like this:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(try<br class="calibre6"/>  </tt></span><span class="calibre19"><tt class="calibre16"><span class="italic">;; ... body expressions ...</span></tt></span><span class="calibre19"><tt class="calibre16"><br class="calibre6"/>  (catch </tt></span><span class="calibre19"><tt class="calibre16"><span class="italic">ErrClass err</span></tt></span><span class="calibre19"><tt class="calibre16"><br class="calibre6"/>    </tt></span><span class="calibre19"><tt class="calibre16"><span class="italic">;; ... handle an exception of type ErrClass ...<br class="calibre6"/>    ;; ... the exception object is bound to err ...</span></tt></span><span class="calibre19"><tt class="calibre16"><br class="calibre6"/>    )<br class="calibre6"/>  (catch js/Error </tt></span><span class="calibre19"><tt class="calibre16"><span class="italic">err</span></tt></span><span class="calibre19"><tt class="calibre16"><br class="calibre6"/>    </tt></span><span class="calibre19"><tt class="calibre16"><span class="italic">;; ... handle an exception of type Error ...</span></tt></span><span class="calibre19"><tt class="calibre16"><br class="calibre6"/>    )<br class="calibre6"/>  (finally<br class="calibre6"/>    </tt></span><span class="calibre19"><tt class="calibre16"><span class="italic">;; ... always execute this ...</span></tt></span><span class="calibre19"><tt class="calibre16"><br class="calibre6"/>    ))</tt></span></blockquote><p class="calibre14">Both the <tt class="calibre16">catch</tt> and <tt class="calibre16">finally</tt> blocks are optional. Note that <tt class="calibre16">catch</tt> in ClojureScript takes a “class” (constructor function) and only handles exceptions of that class. You can have multiple <tt class="calibre16">catch</tt> blocks to handle different types of exceptions. This mimics the exception-handling behavior of Clojure on the JVM.</p><p class="calibre13">The <tt class="calibre16">throw</tt> form takes an exception object and throws it:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(throw (js/Error. "Houston, we have a problem."))</tt></span></blockquote><p class="calibre14">Although JavaScript and ClojureScript both permit you to throw primitives such as strings, this is not recommended. When using JavaScript exception types such as <tt class="calibre16">Error</tt>, you will need to qualify them in both <tt class="calibre16">throw</tt> and <tt class="calibre16">catch</tt> expressions as <tt class="calibre16">js/Error</tt>.</p><p id="filepos126049" class="calibre11"><span class="calibre12"><span class="bold">Summary</span></span></p><p class="calibre13">This chapter covered the essential syntax of the ClojureScript language. Most of this material is identical to Clojure on the JVM. We have not covered every kind of expression possible in ClojureScript, but any documentation written for Clojure on the JVM should apply equally well to ClojureScript.</p><p class="calibre13">JavaScript is already a dynamically-typed language with first-class functions, so some of these features may not be as unfamiliar to JavaScript programmers as they are for programmers accustomed to statically-typed languages such as Java.</p><p class="calibre13">There are many more features of the ClojureScript language that we did not have time to cover in this book. For example, multimethods, protocols, and records provide powerful mechanisms for polymorphism. These features are the same in both ClojureScript and Clojure, and there are many resources for them both online and in print.</p><br class="calibre6"/><hr class="calibre49"/><p class="calibre50"><sup class="calibre44"><small class="calibre45"><span class="calibre46">[</span><a id="filepos127173"></a><a href="#filepos121642"><span class="calibre46">2</span></a><span class="calibre46">] </span></small></sup><a href="http://raphaeljs.com/"><span class="calibre19"><span class="calibre3">http://raphaeljs.com/</span></span></a></p><div class="mbppagebreak"></div><p id="filepos127395" class="calibre11"><span class="calibre2"><span class="bold">Chapter 5. Data and State</span></span></p><p class="calibre25">As discussed earlier, ClojureScript is a member of the functional family of programming languages, meaning that the function is the primary unit of abstraction and composition. You can view any ClojureScript program as a collection of functions, and interpret its structure by observing the function call graph.</p><p class="calibre13">However, with only a very slight shift in viewpoint, you can also understand any functional program in terms of the <span class="italic">data</span> that it manipulates and how that data flows through the system. Every function takes some data as arguments and returns data when it is complete. Usually, the end <span class="italic">goal</span> of a program is not to invoke certain execution paths, but to create, retrieve, or transform data in one form or another. Functions are simply the tool for doing so. In a very real sense, one could say that “data-oriented programing” is a synonym for “functional programming.”</p><p class="calibre13">Clojure and ClojureScript recognize this, and therefore provide a carefully-designed set of data primitives and composite data structures that are both easy to use and philosophically aligned with basic theories about what data <span class="italic">is</span>. It is a common remark among experienced Clojure programmers that they came to Clojure for the concurrency, but stayed for the data structures. ClojureScript brings these data structures and their associated mindset to the browser, where they have proven to be an equally good fit.</p><p id="filepos128996" class="calibre11"><span class="calibre12"><span class="bold">Primitives</span></span></p><p class="calibre13">ClojureScript provides a small set of primitive data types. Each type maps directly to one of JavaScript’s native types. As in JavaScript, all of ClojureScript’s primitives are <span class="italic">immutable</span>, meaning that each is a value unto itself and cannot be changed. Immutability is an important feature of ClojureScript, and will be discussed in much greater detail later on.</p><p id="filepos129471" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Strings</span></span></span></p><p class="calibre13">Strings represent textual data, as a sequence of characters. They can be entered as literals in a ClojureScript program using double quotes. Although they are primitives, it is also possible to obtain a <span class="italic">sequence</span> view of a string as a sequence of characters (see the next chapter).</p><p class="calibre13">Under the hood, ClojureScript strings are JavaScript strings, and may be freely passed to (or received from) JavaScript functions and libraries that expect (or return) strings.</p><p id="filepos130095" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Keywords</span></span></span></p><p class="calibre13">Keywords are very similar to strings in that they are sequences of characters. Actually, in ClojureScript, they are nearly identical to strings except for their intended use. Typically keywords are used as keys in maps, for constants, or for enumerated sets of values. As a rule of thumb, it is idiomatic to use a keyword wherever the value is of interest to the program or programmer, rather than data for the user.</p><p class="calibre13">In Clojure, keywords are guaranteed to be <span class="italic">interned</span> (that is, all instances of the same keyword will always refer to the same object in memory, making them very efficient). This is not the case in ClojureScript, since at the JavaScript level keywords are implemented as plain old JavaScript strings. Still, it is good practice to create keywords only for a constrained, finite set of values.</p><p class="calibre13">Keywords may optionally be <span class="italic">namespace qualified</span>, meaning that they have a separate namespace component to them, and are logically associated with a particular namespace (namespaces are discussed in <a href="#filepos179627"><span class="calibre3">Chapter 7</span></a>). To create a namespace-qualified keyword as a literal, include a slash in the keyword. For example, <tt class="calibre16">:my-ns/foo</tt> creates a keyword with a name of “foo” in a namespace called “my-ns.” You can also use a double leading colon to create a namespace-qualified keyword in the current namespace (e.g., <tt class="calibre16">::foo</tt>).</p><p class="calibre13">Keywords also support some additional operations; for example, they can be used as functions that know how to look themselves up in maps, which we will see later.</p><p id="filepos131893" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Symbols</span></span></span></p><p class="calibre13">Symbols are also very similar to strings, and like keywords, they can be namespace-qualified. In ClojureScript they are used almost exclusively as named bindings (i.e., “variable” names, even though ClojureScript doesn’t really have variables as such). The literal form of a symbol is simply the raw text (<tt class="calibre16">foo</tt>), with a slash if it is namespace-qualified (<tt class="calibre16">foo/bar</tt>).</p><p class="calibre13">There is typically no reason to create or use symbols as data in your program, unless you’re working with macros (discussed in <a href="#filepos215466"><span class="calibre3">Chapter 8</span></a>). Although they’re a key part of the data that represents your program itself (remember, Lisp code is data), keywords or strings are usually better choices for the data your program actually manipulates.</p><p class="calibre13">In ClojureScript, symbols are also implemented as JavaScript strings.</p><p id="filepos132943" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Characters</span></span></span></p><p class="calibre13">Characters are a single textual character, and can be expressed as literals with a leading backslash (e.g., <tt class="calibre16">\a</tt> for the character “a”).</p><p class="calibre13">Since JavaScript doesn’t have a native character type, ClojureScript characters are implemented as single-character strings, and behave identically to strings.</p><p id="filepos133415" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Numbers</span></span></span></p><p class="calibre13">ClojureScript’s numbers are the same as JavaScript numerics and can be either integers or floating-point numbers. They are expressed literally as numerals (for example, <tt class="calibre16">42</tt> or <tt class="calibre16">3.14</tt>). Conversions and coercions between integer and floating point happen automatically; ClojureScript has the same arithmetic semantics as JavaScript.</p><p class="calibre13">You can pass a ClojureScript numeric value to any JavaScript function that expects a numeric, and receive them the same way.</p><p class="calibre13">Unlike Clojure, ClojureScript does not currently support additional numeric types such as Ratio, BigDecimal, or BigInteger.</p><p id="filepos134202" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Booleans</span></span></span></p><p class="calibre13">Boolean values are always one of two values, <tt class="calibre16">true</tt> or <tt class="calibre16">false</tt>, representing logical truth and falsehood, respectively. ClojureScript Booleans, like strings and numerics, are implemented directly as JavaScript Boolean values and may be used accordingly in interop scenarios.</p><blockquote class="calibre17"><span class="calibre10"><span class="bold"><span class="calibre18">NOTE</span></span></span></blockquote><blockquote class="calibre15"><span class="calibre19">Note that although the basic </span><span class="calibre19"><span class="italic">values</span></span><span class="calibre19"> for Boolean </span><span class="calibre19"><tt class="calibre16">true</tt></span><span class="calibre19"> and </span><span class="calibre19"><tt class="calibre16">false</tt></span><span class="calibre19"> are the same in ClojureScript and JavaScript, the semantics of what constitutes truth can be different. For example, the number zero, when used in a Boolean expression, is </span><span class="calibre19"><tt class="calibre16">false</tt></span><span class="calibre19"> in JavaScript but </span><span class="calibre19"><tt class="calibre16">true</tt></span><span class="calibre19"> in ClojureScript. See the sidebar on “Truthiness” in </span><a href="#filepos83077"><span class="calibre19"><span class="calibre3">Chapter 4</span></span></a><span class="calibre19">.</span></blockquote><p class="calibre21">To use a Boolean as a literal, just type one of the special symbols <tt class="calibre16">true</tt> or <tt class="calibre16">false</tt>.</p><p id="filepos135643" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Functions</span></span></span></p><p class="calibre13">In ClojureScript (like JavaScript), functions are first-class entities and, as befits a functional programming language, are themselves data. They can be created using the syntax discussed in the previous chapter, and once created can be passed around and added to composite data structures like any other data.</p><p class="calibre13">Importantly, ClojureScript functions are implemented as plain old JavaScript functions. This means that they can be passed to any JavaScript library that takes a function as a callback (for example), and given a JavaScript function, you can invoke it using ClojureScript syntax. (Unless, of course, the JavaScript function contains a reference to <tt class="calibre16">this</tt>. Internally, ClojureScript always invokes functions using their <tt class="calibre16">call</tt> method and passes in <tt class="calibre16">nil</tt> as the value for <tt class="calibre16">this</tt>.)</p><p id="filepos136622" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">nil</span></span></span></p><p class="calibre13">ClojureScript’s <tt class="calibre16">nil</tt> is identical to <tt class="calibre16">null</tt> in JavaScript; it is used where a value is logically absent, empty, or meaningless. To use it as a literal, just use the special symbol <tt class="calibre16">nil</tt>. ClojureScript does not use JavaScript's undefined value, but you can refer to it as <tt class="calibre16">js/undefined</tt>.</p><p class="calibre47"></p><p class="calibre7"><span class="italic">Table 5-1. Quick reference for primitive data types</span></p><table border="1" valign="top" class="calibre40"><tr border="1" valign="top" class="calibre23"><th valign="top" class="calibre41"><span class="calibre10"><span class="bold"><span class="calibre18"> ClojureScript type </span></span></span></th><th valign="top" class="calibre41"><span class="calibre10"><span class="bold"><span class="calibre18"> literal </span></span></span></th><th valign="top" class="calibre41"><span class="calibre10"><span class="bold"><span class="calibre18"> example(s) </span></span></span></th><th valign="top" class="calibre41"><span class="calibre10"><span class="bold"><span class="calibre18"> JS type </span></span></span></th></tr><tr border="1" valign="top" class="calibre23"><td border="1" valign="top" class="calibre24"><span class="calibre10"> string </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> double quotes </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> </span><span class="calibre10"><tt class="calibre16">“string” </tt></span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> string </span></td></tr><tr border="1" valign="top" class="calibre48"><td border="1" valign="top" class="calibre24"><span class="calibre10"> symbol </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> plain characters </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> </span><span class="calibre10"><tt class="calibre16">symbol </tt></span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> string </span></td></tr><tr border="1" valign="top" class="calibre23"><td border="1" valign="top" class="calibre24"><span class="calibre10"> keyword </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> leading colon </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> </span><span class="calibre10"><tt class="calibre16">:keyword </tt></span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> string </span></td></tr><tr border="1" valign="top" class="calibre48"><td border="1" valign="top" class="calibre24"><span class="calibre10"> character </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> leading backslash </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> </span><span class="calibre10"><tt class="calibre16">\c </tt></span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> string </span></td></tr><tr border="1" valign="top" class="calibre23"><td border="1" valign="top" class="calibre24"><span class="calibre10"> number </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> literal number </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> </span><span class="calibre10"><tt class="calibre16">42, 3.14 </tt></span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> numeric </span></td></tr><tr border="1" valign="top" class="calibre48"><td border="1" valign="top" class="calibre24"><span class="calibre10"> boolean </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> ‘true’ or ‘false’ </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> </span><span class="calibre10"><tt class="calibre16">true, false </tt></span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> boolean </span></td></tr><tr border="1" valign="top" class="calibre23"><td border="1" valign="top" class="calibre24"><span class="calibre10"> function </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> (fn ...) or #(...) </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> </span><span class="calibre10"><tt class="calibre16">#(* 2 %) </tt></span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> function </span></td></tr><tr border="1" valign="top" class="calibre48"><td border="1" valign="top" class="calibre24"><span class="calibre10"> nil </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> ‘nil’ </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> </span><span class="calibre10"><tt class="calibre16">nil </tt></span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> null </span></td></tr></table><p id="filepos141264" class="calibre11"><span class="calibre12"><span class="bold">Data Structures</span></span></p><p class="calibre13">ClojureScript also provides a full complement of composite collection types. These collections can contain ClojureScript’s primitive types or other collections, as well as any other object that JavaScript itself supports. However, using non-ClojureScript objects as values in ClojureScript collections may invalidate some of the guarantees ClojureScript can make regarding equality semantics and serializability.</p><p class="calibre13">ClojureScript collections that contain only primitives or other ClojureScript collections <span class="italic">do</span> make certain guarantees:</p><p class="calibre14">Equality</p><blockquote class="calibre15">Collections with the same semantics containing the same values are considered equal for all purposes, even if they are different instances in the JavaScript VM. ClojureScript equality is always value-dependent, and the value of a collection is defined in terms of its contents. Note that this is true even across implementations, as long as the semantics of the collection are the same. For example, a map can only be equal to another map, but that map may be any of the alternative map implementations (see the section on maps below).</blockquote><p class="calibre14">Serializability</p><blockquote class="calibre15">Obtaining the string value of a collection always results in a string that, when read back using the ClojureScript reader, will be equal to the original. This is extremely useful for simple cases of storing and transmitting data.</blockquote><p class="calibre14">Clojure compatibility</p><blockquote class="calibre15">The serialized string representation of ClojureScript objects and collections is fully compatible with that of Clojure. Objects printed in ClojureScript can be read in Clojure, and vice versa. This makes development Clojure on the server side and ClojureScript in the browser client very easy. We will demonstrate this technique in <a href="#filepos264235"><span class="calibre3">Chapter 10</span></a>.</blockquote><blockquote class="calibre29"></blockquote><blockquote class="calibre30"><span class="calibre19"><span class="bold">JSON AND CLOJURESCRIPT</span></span></blockquote><blockquote class="calibre15"><span class="calibre19">Because ClojureScript has such good string serialization for its own object types, using JSON in a ClojureScript program is not encouraged unless needed to interact with a third-party or legacy API. Just as JSON stands for “JavaScript Object Notation” and is useful precisely because it matches JavaScript’s syntax, Clojure’s collection literal strings can be thought of as “Clojure Collection Notation” and match ClojureScript’s syntax and semantics, with baked-in language support. Therefore, they are usually more suitable for the Clojure and ClojureScript environment. However, JSON parsers and serializers are still available via the Google Closure Library or built-in browser functions.</span></blockquote><blockquote class="calibre15"><span class="calibre19">Efforts are underway to create a formal specification for Clojure/ClojureScript data under the name “Extensible Data Notation.” Details are at </span><a href="https://github.com/edn-format/edn"><span class="calibre19"><span class="calibre3">https://github.com/edn-format/edn</span></span></a><span class="calibre19">.</span></blockquote><p id="filepos144713" class="calibre32"><span class="calibre31"><span class="bold"><span class="calibre3">Collection Types</span></span></span></p><p id="filepos144820" class="calibre14"><span class="calibre5"><span class="bold">Lists</span></span></p><p class="calibre13">Lists are ordered collections of items, implemented as singly-linked lists. As such, they support fast lookups and insertions at the head of the list and <span class="italic">O(n)</span> reads in the general case.</p><p class="calibre13">The literal syntax for writing lists is simply parentheses around the items (e.g., <tt class="calibre16">(1 2 3))</tt>. However, lists are also used in ClojureScript code to indicate a form that should be evaluated, meaning that if you try to enter a list that you <span class="italic">don’t</span> want evaluated (such as the one above), you’ll get an error as it tries to execute something it shouldn’t.</p><p class="calibre13">To avoid this and create a list literal, you can <span class="italic">quote</span> the form using either the <tt class="calibre16">quote</tt> special form or the single quote reader macro, which prevent evaluation of the forms to which they are applied. They are completely equivalent: <tt class="calibre16">'(1 2 3)</tt> is identical to <tt class="calibre16">(quote (1 2 3))</tt>, and both will evaluate to a list consisting of the numbers <tt class="calibre16">1</tt>, <tt class="calibre16">2</tt>, and <tt class="calibre16">3</tt> without attempting to evaluate <tt class="calibre16">1</tt> as a function.</p><p class="calibre13">To prepend an item to a list, use the ).<tt class="calibre16">conj</tt> function, which takes a collection as its first argument and any number of additional items to add. The items will be added at the beginning of the list. To retrieve items from a list, use the sequence functions (described in </p><p id="filepos146319" class="calibre14"><span class="calibre5"><span class="bold">Vectors</span></span></p><p class="calibre13">Vectors are also ordered collections of items, and should generally be preferred to lists in most ClojureScript code. They fill the role played by arrays in JavaScript and most other programming languages, having near-constant lookup, update, and append operations. Technically, the computational complexity of a vector lookup is <span class="italic">O(log<sub class="calibre53"><small class="calibre45"><span class="calibre46"><span class="italic">32</span></span></small></sub>(n))</span>, but this is so close to constant time that the distinction is practically meaningless on any data structure that will fit in memory on a modern computer.</p><p class="calibre13">The literal syntax for a vector is square brackets surrounding the items, such as <tt class="calibre16">[1 2 3]</tt> or <tt class="calibre16">[:a :b :c]</tt>. You’ve already seen literal vectors: they are used for specifying function parameters.</p><p class="calibre13">To append an item to a vector, use the <tt class="calibre16">conj</tt> function as you would for a list. However, in the case of a vector, the item(s) will be appended rather than prepended (<tt class="calibre16">conj</tt> works differently depending on the type of collection).</p><p class="calibre13">You can retrieve items from a vector using the sequence functions. The <tt class="calibre16">nth</tt> function will efficiently retrieve the item at a particular index. Vectors themselves can also be invoked as functions, passing an integer as the argument will return the item stored at that index (e.g., <tt class="calibre16">([:a :b :c] 1)</tt> returns <tt class="calibre16">:b</tt>). To return a vector with an updated value at a particular index, use the <tt class="calibre16">assoc</tt> function (which takes a vector, an index, and a value) and returns a vector with the update applied.</p><p id="filepos148047" class="calibre14"><span class="calibre5"><span class="bold">Maps</span></span></p><p class="calibre13">Maps are associative collections; that is, they associate keys with values, and allow efficient retrieval of a value by its key. They are similar to Hashes in Ruby, HashTables in Java, or associative arrays (i.e., objects) in JavaScript.</p><p class="calibre13">The literal syntax for a map is alternating key/value pairs surrounded by curly braces, such as <tt class="calibre16">{:key1 :val1 :key2 :val2}</tt>. Because commas are whitespace in ClojureScript, some people like to add them to maps for greater visual distinction between key/value pairs like <tt class="calibre16">{:k1 :v1, :k2 :v2}</tt>, but this is strictly optional.</p><p class="calibre13">Note that keys can be any primitive or data type that supports proper equality. Keywords are idiomatic and efficient, but strings and integers are also commonly used as map keys. It is even perfectly acceptable to use other data structures as keys if they support good equality semantics (as ClojureScript’s do).</p><p class="calibre13">Maps may actually be implemented in a number of different ways, using different algorithms. ClojureScript includes array maps (backed by arrays), hash maps (backed by hash tables), and tree maps (backed by red-black balanced binary search trees). There are no semantic differences between these implementations, although they do have different performance characteristics. (The sorted tree map does actually make one additional guarantee that other implementations don’t: when iterating over its entry set, the entries will be returned in the specified sort order of the keys.) Typically, however, you don’t need to worry about them. When you create a map using a literal, ClojureScript chooses the best algorithm based on the size of the map, and will swap out the type to keep it efficient as it grows. If you wish, however, you can create a particular type of map using the <tt class="calibre16">array-map</tt>, <tt class="calibre16">hash-map</tt>, or <tt class="calibre16">sorted-map</tt>/<tt class="calibre16">sorted-map-by</tt> functions (for array maps, hash maps, and tree maps, respectively).</p><p class="calibre13">There are several techniques for retrieving values from a map:</p><div class="calibre26"> </div><ul class="calibre35"><li value="1" class="calibre28"><blockquote class="calibre15">The <tt class="calibre16">get</tt> function, which takes a map and a key value, and returns the value mapped to the key.</blockquote></li><li value="2" class="calibre28"><blockquote class="calibre15">The map itself can be invoked as a function. Passing it a key will return the value mapped to that key.</blockquote></li><li value="3" class="calibre28"><blockquote class="calibre15">If the key is a keyword, you can invoke it as a function, passing the map as an argument. When used as a function, keywords can look themselves up in the map they are provided and return the associated value.</blockquote></li></ul><p class="calibre13">To obtain a map with an inserted or updated value at a particular field, use the <tt class="calibre16">assoc</tt> function, passing a map and a series of alternating keys and values. This will return the map, but with the specified keys mapped to the specified values. If the map previously contained values associated with the keys, they will be replaced.</p><p id="filepos151364" class="calibre14"><span class="calibre5"><span class="bold">Sets</span></span></p><p class="calibre13">Sets are unordered collections of unique items, meaning that the same item cannot be duplicated in the set (similar to the mathematical notion of a set). If you add an item to a set that is equal to an item the set already contains, the set is unaffected. Sets can also be thought of as maps with only keys and no values. They support fast insertion, removal, and membership checks.</p><p class="calibre13">The literal syntax for a set is a pound sign followed by members enclosed in curly braces, like <tt class="calibre16">#{:a :b :c}</tt>.</p><p class="calibre13">To add an item to a set, use the <tt class="calibre16">conj</tt> function, passing the set and the item to add. Sets also support <tt class="calibre16">disj</tt>, which does the opposite of <tt class="calibre16">conj</tt> and returns a set with the item removed. To test if an item is a member of a set, use the <tt class="calibre16">contains?</tt> function, which takes a set and an item and returns true if the item is a member of the set.</p><p class="calibre13">ClojureScript also provides the <tt class="calibre16">clojure.set</tt> namespace containing dedicated set operations such as <tt class="calibre16">union</tt>, <tt class="calibre16">intersection</tt>, and <tt class="calibre16">difference</tt>.</p><p id="filepos152595" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Immutability</span></span></span></p><p class="calibre13">An important feature of all of ClojureScript’s collections is that they are <span class="italic">immutable</span>, meaning that they can’t be changed. Functions that “modify” collections don’t actually ever change them, but instead create and return a new one based on the original with the specified differences in place.</p><p class="calibre13">This is highly nonintuitive to most programmers who don’t have prior experience with purely functional languages. However, it becomes clearer once you understand Clojure(Script)’s concept of <span class="italic">value</span>.</p><p class="calibre13"><span class="italic">Values don’t change.</span> Consider the number 3. If you add 3 + 1, you haven’t <span class="italic">changed</span> the value of 3 (which would wreak havoc with math and physics everywhere). Instead, you’ve acquired a <span class="italic">new</span> value. The same is true of words: if you use the word “good” together with the word “morning” to say “good morning,” you haven’t changed the global meaning of the word “good,” you’ve used it to create a new utterance. In ClojureScript, the very <span class="italic">definition</span> of a value means that it can’t change—if it does, it’s no longer the same value.</p><p class="calibre13">ClojureScript’s collections are all values. If I take the vector <tt class="calibre16">[1 2]</tt> and append the value 4, I haven’t changed the meaning of <tt class="calibre16">[1 2]</tt>. I <span class="italic">can’t</span> change it. By definition, it can only ever mean “the two element vector consisting of the integers 1 and 2.” If I could literally change it, it would no longer meet its own definition. But what I <span class="italic">can</span> do is create an entirely new vector, using <tt class="calibre16">[1 2]</tt> as a base: <tt class="calibre16">[1 2 4]</tt>.</p><p class="calibre13">The same thing is true of all ClojureScript’s other collection types. When you add a member to a set, you’re creating a different set with different members (which, incidentally, conforms to the mathematical definition of a set). When you add an item to the front of a list, you create a new list consisting of both the old list and the new item. When you add a new key to a map, you’re creating a new map, with a different set of keys.</p><p id="filepos154873" class="calibre14"><span class="calibre5"><span class="bold">Why immutability?</span></span></p><p class="calibre13">In Clojure, concurrency is always listed as a compelling reason to use immutable collections: preventing unexpected changes to data goes a long way towards preventing race conditions. HTML 5 WebWorkers do allow concurrent execution in modern browsers. However, they sidestep many of the difficulties associated with concurrent programming by forbidding shared state between threads, instead operating solely on the basis of message passing. But what about ClojureScript, which always runs in a single-threaded JavaScript environment?</p><p class="calibre13">There are two possible answers to this question. First, there is a sense in which treating collections as values is philosophically <span class="italic">correct</span>, irrespective of performance or design implications. It makes programs easier to formalize and reason about. For example, having a firm concept of collections as values also allows a rigorous notion of equality (which can greatly simplify programs), and allows functions dealing with collections to remain formally pure.</p><p class="calibre13">Second, there are indeed practical benefits to having immutable objects besides full concurrency. Even though JavaScript is single-threaded, code is often structured in terms of asynchronous callbacks and event loops, and it isn’t always easy to reconstruct the exact sequence of execution a program might take. With immutable values, you can rely on the fact that once you have obtained a collection, you can save it (either explicitly or by closing over it) and use it later without any risk that it will have changed. Having immutable objects means never having to worry about mentally keeping track of what’s going on—all value changes are explicit and apparent in the code.</p><p id="filepos156731" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Persistence</span></span></span></p><p class="calibre13">One question that almost invariably follows a discussion of immutability is that of the performance implications. No matter what the benefits are, isn’t cloning an entire data structure every time it’s updated prohibitively wasteful of computational resources?</p><p class="calibre13">The answer would be yes, if that were what actually happens. Fortunately, ClojureScript provides some extremely sophisticated data structure implementations that utilize the concept of <span class="italic">persistence</span> to provide objects that are logically immutable, but share structure with previous versions of themselves to minimize their computational overhead.</p><p class="calibre13">A full discussion of the implementation of persistent data structures is beyond the scope of this book, but essentially what happens is that when a data structure is modified, the new value is not a full clone of the original one. Instead, it incorporates the original (which it can safely do, because the old one is immutable) plus the changes, and then exposes a unified view of the whole package in a way that hides the internal structure.</p><p class="calibre13">In practical terms, persistence means that while using immutable objects does incur some small overhead compared with mutating traditional objects, it (hopefully) falls well within the realm of acceptable cost relative to the benefit provided. Typically, unless you’re writing extremely performance-sensitive code (which is rare in JavaScript to begin with), ClojureScript’s immutable collections are more than fast enough. And if you ever do need to eke out every last drop of performance, ClojureScript’s interop syntax makes it easy to drop down to native JavaScript objects and arrays.</p><p id="filepos158612" class="calibre11"><span class="calibre12"><span class="bold">Identity and State</span></span></p><p class="calibre13">Having data structures be immutable values is all very well, but it opens another question: if values are immutable, then how does ClojureScript model state and change over time? After all, not every program can be a purely functional transformation of inputs to outputs. Most of the time, programs need to store and change values.</p><p class="calibre13">The answer lies in ClojureScript’s (and Clojure’s) conceptual distinctions among value, identity, and state.</p><div class="calibre26"> </div><ul class="calibre35"><li value="1" class="calibre28"><blockquote class="calibre15">A value is, as the name implies, an immutable value. As discussed above, values can’t change, by definition.</blockquote></li><li value="2" class="calibre28"><blockquote class="calibre15">Identity refers to a named entity in the system that may refer to different values at different points in time.</blockquote></li><li value="3" class="calibre28"><blockquote class="calibre15">State refers to the value of an identity at a particular point in time.</blockquote></li></ul><p class="calibre13">Most languages don’t make a clear distinction between these concepts—for example, a variable in JavaScript has bits of all three. It is a named thing, but it has a value, and its value can change.</p><p class="calibre13">By teasing apart these concepts, ClojureScript makes state management <span class="italic">explicit</span>. Identities are clearly visible as the only things that can change, and state transitions to new values are clearly intentional.</p><p class="calibre13">This leads to a unique program structure in large ClojureScript programs. Rather than having state smeared thinly across the whole program, it is isolated from the main bulk of the code. Only a few functions update state, the rest remain pure functions of values. When done correctly, this makes ClojureScript programs <span class="italic">much</span> easier to reason about than those written in object-oriented or imperative paradigms.</p><p id="filepos160743" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Atoms</span></span></span></p><p class="calibre13">In Clojure, there are several constructs for creating identities, including atoms, refs, and agents. The different types of identities differ in the concurrency semantics they support. In ClojureScript, which doesn’t need to support shared-memory concurrency, there is only one type: atoms.</p><p class="calibre13">Atoms are identities that refer to a single value (though that value, of course, may be one of Clojure’s collections). All updates to the state of an atom are <span class="italic">atomic</span>, that is, they occur in a single operation.</p><p class="calibre13">To create an atom, just use the <tt class="calibre16">atom</tt> function, passing a value for the initial state. For example:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(def my-atom (atom {}))</tt></span></blockquote><p class="calibre14">This constructs an atom with an initial state of an empty map, and binds it to a var called <tt class="calibre16">my-atom</tt>.</p><p class="calibre13">To retrieve the current value of an atom, use the <tt class="calibre16">deref</tt> function, which also has a shortened syntax using the reader macro <tt class="calibre16">@</tt>. The following two expressions are equivalent:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(deref my-atom)   ;=&gt; {}<br class="calibre6"/>@my-atom   ;=&gt; {}</tt></span></blockquote><p class="calibre14">There are two ways to update the state of an atom, <tt class="calibre16">swap!</tt> and <tt class="calibre16">reset!</tt>. <tt class="calibre16">swap!</tt> is used to update the atom’s state in terms of the previous state, <tt class="calibre16">reset!</tt> sets the state without regard for the previous state. Both functions return the value of the atom’s new state.</p><p class="calibre13"><tt class="calibre16">swap!</tt> always takes at least two arguments; the first is the atom, the second is the update function. The update function will be applied with the value of the atom as its first argument, with any additional arguments to <tt class="calibre16">swap!</tt> used as additional arguments.</p><p class="calibre13">So, for example, to add a new entry to the map that is the current value of <tt class="calibre16">my-atom</tt>, you could invoke <tt class="calibre16">swap!</tt> like so:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(swap! my-atom assoc :a "1")  ;=&gt; {:a 1}</tt></span></blockquote><p class="calibre14">Subsequently, retrieving the value of the atom returns the new value:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">@my-atom   ;=&gt; {:a 1}</tt></span></blockquote><p class="calibre14">Or, you can use <tt class="calibre16">reset!</tt>, passing the atom and the new value to update the state:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(reset! my-atom {:x 42})  ;=&gt; {:x 42}<br class="calibre6"/>@my-atom   ;=&gt; {:x 42}</tt></span></blockquote><p class="calibre14">Initially, this might seem like too much ceremony to do something as easy as changing some state. But the ceremony is (almost) the whole point. State should <span class="italic">not</span> be something implicit in a program, quietly multiplying complexity exponentially with each new variable. Instead, it should be carefully, knowingly managed. In ClojureScript, atoms provide this capability.</p><div class="mbppagebreak"></div><p id="filepos164179" class="calibre11"><span class="calibre2"><span class="bold">Chapter 6. Sequences</span></span></p><p class="calibre25">One of the key features of the Lisp family of languages is their orientation around lists—not just as data structures, but as a structural metaphor for algorithms and execution flow. Recursive algorithms, for example, can be very cleanly structured around lists in Lisp variants.</p><p class="calibre13">Unfortunately, in most Lisps, this metaphor is tightly bound to the actual implementation of a singly-linked list, which has performance characteristics that make it unsuitable for many purposes.</p><p class="calibre13">To resolve this problem, Clojure introduced a new abstraction around the concept of a list, called a <span class="italic">sequence</span>, which is shared by ClojureScript. A sequence is a logical list, similar to those in most Lisps, with a well-defined set of operations. However, Clojure sequences are not a concrete type, but rather an abstract contract that may be satisfied concretely by a variety of different types of objects. All of ClojureScript’s collections, as well as many other types of logical collections in JavaScript, can be used as sequences. This allows ClojureScript code to be constructed in an idiomatic list-based Lisp style, while using whatever data structure is actually most appropriate for the job.</p><p class="calibre13">Many common operations in ClojureScript are part of the <span class="italic">sequence API</span>. Functions from the sequence API are used to select items from sequences, add items to sequences, and produce, consume, and transform sequences. Understanding how sequences work will give you a major leg up in understanding and writing idiomatic ClojureScript code and, once you get the hang of it, will help you write functions of your own that are highly general and composable with other sequence functions.</p><p id="filepos166061" class="calibre11"><span class="calibre12"><span class="bold">The Sequence Abstraction</span></span></p><p class="calibre13">The basic definition of a sequence is very simple. All sequences have two elements: a <span class="italic">first</span>, which is the first element, and a <span class="italic">rest</span>, a sequence of the remaining elements. An empty <span class="italic">first</span> and <span class="italic">rest</span> in ClojureScript are directly analogous to the <span class="italic">car</span> and <span class="italic">cdr</span> of older Lisps. They are renamed to be clearer and to emphasize that they are abstract concepts, not inherently bound to any particular implementation of a sequence. A <span class="italic">nil</span>
<span class="italic">rest</span> signals the end of the sequence. You can obtain the first or rest of a sequence by using the <tt class="calibre16">first</tt> or <tt class="calibre16">rest</tt> functions.</p><p class="calibre13">Anything that can be represented as a first and a rest can be a sequence. The <tt class="calibre16">seq</tt> function is used to polymorphically obtain a sequence view of any object that supports it. Calling <tt class="calibre16">seq</tt> explicitly to convert a collection is rarely necessary, however, since sequence functions (including <tt class="calibre16">first</tt> and <tt class="calibre16">rest</tt>) call <tt class="calibre16">seq</tt> on their argument for you.</p><p class="calibre13">Lists and vectors are the most obvious sequences, being naturally ordered collections of elements:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(first [:a :b :c])  ;=&gt; :a<br class="calibre6"/>(rest [:a :b :c])   ;=&gt; (:b :c)<br class="calibre6"/><br class="calibre6"/>(first '(1 2 3))    ;=&gt; 1<br class="calibre6"/>(rest '(1 2 3))     ;=&gt; (2 3)</tt></span></blockquote><p class="calibre14">Sets are also sequences. Although they are unordered, you can still use sequence functions on them; the elements will just be cast into an arbitrary (though consistent, for the same set) order:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(first #{:b :c :a})  ;=&gt; :a<br class="calibre6"/>(rest #{:b :c :a})   ;=&gt; (:b :c)</tt></span></blockquote><p class="calibre14">Maps are also sequences of key-value pairs, represented as two-element vectors and returned in arbitrary order:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(first {:b 2 :a 1 :c 3})  ;=&gt; [:a 1]<br class="calibre6"/>(rest {:b 2 :a 1 :c 3})   ;=&gt; ([:c 3] [:b 2])</tt></span></blockquote><p class="calibre14">Other items which can be viewed as a sequence (<span class="italic">sequable</span> objects) include native JavaScript arrays and strings (as sequences of their constituent characters).</p><p id="filepos168645" class="calibre11"><span class="calibre12"><span class="bold">Lazy Sequences</span></span></p><p class="calibre13">Despite their obvious utility for working with data structures, one of the advantages of sequences is that they don’t <span class="italic">need</span> to be backed by an actual data structure in memory. All they have to do is implement <tt class="calibre16">first</tt> and <tt class="calibre16">rest</tt> meaningfully.</p><p class="calibre13">This leads to an interesting and extremely useful feature: it is possible to have sequences with a rest that isn’t actually created until you call the <tt class="calibre16">rest</tt> function. Sequences with a nonrealized rest are known as <span class="italic">lazy sequences</span>. Because lazy sequences don’t have to fully exist in memory all at once, they can be arbitrarily large, even infinite.</p><p class="calibre13">For example, in ClojureScript, it is possible to construct an infinite sequence of every positive integer using the <tt class="calibre16">iterate</tt> function:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(do<br class="calibre6"/>  (def i (iterate inc 0))<br class="calibre6"/>  nil)</tt></span></blockquote><p class="calibre14">As an aside, note that the <tt class="calibre16">def</tt> is wrapped in a <tt class="calibre16">do</tt>, which returns <tt class="calibre16">nil</tt>. This is only to prevent the value of the <tt class="calibre16">i</tt> symbol from being printed back at the REPL, which ClojureScript does by default. <tt class="calibre16">i</tt> can exist as a lazy sequence using hardly any memory, but if you try to print it, it will try to print the entire thing to the REPL. Obviously, this is impossible. This is one thing to be careful of when using infinite lazy sequences: don’t do something that would cause them to be printed! This will almost certainly crash your process and force you to restart.</p><p class="calibre13"><tt class="calibre16">iterate</tt> is a higher-order function that takes two arguments, a function and an initial value. It returns a lazy sequence with a first element of the initial value. Its rest sequence is lazily constructed, and in turn has an first value of the function applied to the initial value. Its rest, also lazy, is the result of applying the function to the previous value, and so on.</p><p class="calibre13">So, by starting with the <tt class="calibre16">inc</tt> function and an initial value of <tt class="calibre16">0</tt>, the above expression constructs a sequence where each successive element is constructed by incrementing the previous element; this is a sequence of the positive integers. But the calculation is only performed when the sequence is actually realized, so it doesn’t end up using an infinite amount of memory.</p><p id="filepos171235" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Letting Go of the Head</span></span></span></p><p class="calibre13">Lazy sequences are cached, so each element is realized only once, and then stored instead of being recalculated. This means that expensive computations won’t be run unnecessarily. It also means that it’s safe to have sequence generating functions with side effects—they may not happen at all, if the sequence is never realized, but they’ll never be executed repeatedly.</p><p class="calibre13">The downside is that lazy sequences <span class="italic">do</span> consume memory, once they’ve been realized. For this reason, if you’re processing a very large or infinite sequence, it’s important not to maintain a reference to the head of the sequence as you iterate over it. That way, the earlier parts of the sequence can be garbage collected each time you move forward on the sequence. But if you maintain a reference to the entire sequence, its elements will be cached, not garbage collected, and you’re likely to get out-of-memory errors.</p><p id="filepos172321" class="calibre11"><span class="calibre12"><span class="bold">The Sequence API</span></span></p><p class="calibre13">ClojureScript has a large library of functions that operate on sequences. Although you don’t have to know them all, familiarity with the basic ones covered here is critical to writing idiomatic functional code. In particular, you should become very comfortable with <tt class="calibre16">map</tt>, <tt class="calibre16">reduce</tt>, and <tt class="calibre16">filter</tt> if you’re not already; these are the staples of the functional programming style.</p><p id="filepos172832" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">map</span></span></span></p><p class="calibre13"><tt class="calibre16">map</tt> is a higher order function that takes a function (which takes a single argument) and a sequence, and returns a sequence of items resulting from applying the function to each item in the input sequence. It is lazy; the input sequence is only consumed and the mapping function applied when the resulting sequence is realized. As such, it can be used on an infinite sequence to return a new infinite sequence.</p><p class="calibre13">For example, the following expression applies a function to obtain the square of every number in the input sequence:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(map (fn [n] (* n n)) [1 2 3 4 5])  ;=&gt; (1 4 9 16 25)</tt></span></blockquote><p class="calibre14"><tt class="calibre16">map</tt> can also take more than one sequence. In this case, the function provided must take the same number of arguments as there are sequences, and the function is applied to the first member of each sequence, then the second, third, and so on. Processing stops at the end of the shortest sequence. For example:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(map (fn [a b] (+ a b)) [1 2 3] [10 20 30 40])  ;=&gt; (11, 22, 33)</tt></span></blockquote><p id="filepos174257" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">reduce</span></span></span></p><p class="calibre13"><tt class="calibre16">reduce</tt> is a function that takes a function and a sequence and uses the provided function to consume the entire sequence and return a single value. As such, it is not lazy and should not be used on infinite sequences.</p><p class="calibre13">The supplied function must take two arguments; it is first invoked on the first two elements of the sequence, then invoked again with the resulting value and the third item, then with the result of <span class="italic">that</span> and the fourth item, and so on until the sequence is consumed.</p><p class="calibre13">The following example uses the <tt class="calibre16">+</tt> function to obtain a sum of the numbers in a sequence:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(reduce + [1 2 3 4])  ;=&gt; 10</tt></span></blockquote><p class="calibre14">You can also invoke <tt class="calibre16">reduce</tt> with three arguments, supplying an initial value as the second argument to <tt class="calibre16">reduce</tt>. It will be used along with the first element from the sequence in the first function invocation, instead of using the first two values from the sequence.</p><p id="filepos175507" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">filter</span></span></span></p><p class="calibre13"><tt class="calibre16">filter</tt> takes a function and a sequence, and returns a sequence consisting only of the items for which applying the function to items in the input sequence returns logical true. It is fully lazy, although consuming a single item in the resulting sequence may “jump” forward in the input sequence until it finds one that meets the specified criteria.</p><p class="calibre13">The following example uses the built-in <tt class="calibre16">integer?</tt> function to return a filtered sequence only of numbers that are integers:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(filter integer? [1 2.71 3.14 5 42])  ;=&gt; (1 5 42)</tt></span></blockquote><p id="filepos176336" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Other Useful Sequence Functions</span></span></span></p><p class="calibre13">Although there are a great many other sequence functions you’ll want to explore, here are some of the most frequently used:</p><p class="calibre14">cons</p><blockquote class="calibre15">Takes an item and a sequence, and returns a new sequence with the item as its first and the sequence as its rest.</blockquote><p class="calibre14">count</p><blockquote class="calibre15">Takes a sequence as its argument, and returns the length of a sequence. It must realize the entire sequence to do so, so don’t call it on an infinite sequence as it will never return.</blockquote><p class="calibre14">nth</p><blockquote class="calibre15">Takes a sequence and an index (starting from zero), and returns the item at that location in the sequence. For example, <tt class="calibre16">(nth x 5)</tt> returns the <span class="italic">sixth</span> item in <tt class="calibre16">x</tt>.</blockquote><p class="calibre14">take</p><blockquote class="calibre15">Takes a number <tt class="calibre16">n</tt> and a sequence, and returns a new sequence consisting of the first <tt class="calibre16">n</tt> items in the input sequence. It is fully lazy; it will only realize the input sequence when and if the returned sequence is realized.</blockquote><p class="calibre14">drop</p><blockquote class="calibre15">Takes a number <tt class="calibre16">n</tt> and a sequence, and returns a new sequence of all the items in the input sequence <span class="italic">except</span> for the first <tt class="calibre16">n</tt> items. It is also lazy.</blockquote><p class="calibre14">concat</p><blockquote class="calibre15">Takes any number of sequences as arguments, and returns a single sequence containing all the items in each of the input sequences. It is lazy.</blockquote><p class="calibre14">reverse</p><blockquote class="calibre15">Takes a single sequence and returns a sequence of its items in reverse order. It cannot be lazy, since it needs to realize the entire input sequence in order to get its last item.</blockquote><p class="calibre13">Finally, there is a special sequence generator that’s actually a macro, not a function:</p><p class="calibre14">lazy-seq</p><blockquote class="calibre15">This is the basic, low-level way to create lazy sequences. It is a macro that takes any number of forms as its body. The body, when evaluated, should return a sequence or <tt class="calibre16">nil</tt>. However, the body isn’t evaluated right away. Instead, it’s stored in a closure, and <tt class="calibre16">lazy-seq</tt> returns an <span class="italic">unrealized</span> lazy sequence. Only if the sequence is eventually realized will the body be invoked, returning the result of the body as the realized sequence.</blockquote><p class="calibre13">By making recursive function calls in the body of <tt class="calibre16">lazy-seq</tt>, it’s possible to construct lazy sequences of arbitrary or infinite length.</p><p class="calibre13">Normally, it’s not necessary to use <tt class="calibre16">lazy-seq</tt> directly; usually, one of the provided sequence-generating functions is more suitable. <tt class="calibre16">iterate</tt>, in particular, is very flexible. However, when you need it, <tt class="calibre16">lazy-seq</tt> can be a powerful tool to create arbitrary lazy sequences.</p><div class="mbppagebreak"></div><p id="filepos179627" class="calibre11"><span class="calibre2"><span class="bold">Chapter 7. Namespaces, Libraries, and Google Closure</span></span></p><p class="calibre25">So far, we’ve talked mostly about basic features of the language such as syntax, semantics, and the compilation process. ClojureScript also offers compelling features at a higher structural level to facilitate code organization and sharing libraries.</p><p class="calibre13">In ClojureScript, as in Clojure, the highest level of code organization is namespaces, used to scope global definitions. However, despite superficial similarities, namespaces in ClojureScript are implemented completely differently than they are in Clojure because it runs in a different environment. This chapter will cover what these differences are and how to use namespaces effectively in ClojureScript.</p><p class="calibre13">Additionally, this chapter will describe how to create and utilize libraries. Unfortunately, one of the negative effects of ClojureScript’s reliance on the Google Closure Compiler is the fact that creating and consuming libraries is not always straightforward, particularly in light of Google Closure’s <span class="italic">Advanced Optimizations</span> mode.</p><p id="filepos180838" class="calibre11"><span class="calibre12"><span class="bold">Namespaces</span></span></p><p class="calibre13">To avoid name collisions, ClojureScript symbols and keywords have a namespace component. Each <span class="italic">*.cljs</span> file has its own namespace, and every REPL session has a <span class="italic">current</span> namespace (<tt class="calibre16">cljs.user</tt> by default). Whenever you define a symbol using <tt class="calibre16">def</tt> or one of its derivatives (such as <tt class="calibre16">defn</tt>), the namespace of the symbol is set to the current namespace. Symbols with the same name in different namespaces are completely different, and will not clash.</p><p class="calibre13">In addition to name disambiguation, namespaces are also ClojureScript’s unit of code dependency management. A namespace may <span class="italic">require</span> or <span class="italic">use</span> other namespaces as dependencies, and dependent namespaces are always loaded before the namespace that required them when the program is run. ClojureScript does not support circular references between namespaces.</p><p class="calibre13">One very important difference between namespaces in ClojureScript and Clojure is that while Clojure namespaces are first-class entities that can be dynamically created and loaded at runtime, ClojureScript namespaces are statically resolved at <span class="italic">compile time only</span>. You can’t create or load a namespace during program execution.</p><p id="filepos182184" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Using Namespaces</span></span></span></p><p class="calibre13">As you have already seen, if you refer to a symbol without specifying a namespace, ClojureScript will attempt to resolve the symbol in the current namespace. To specify a namespace, use a slash between the namespace and the name. For example, <tt class="calibre16">foo.bar/hello</tt> references a symbol named <tt class="calibre16">hello</tt> in the <tt class="calibre16">foo.bar</tt> namespace, which is distinct from a symbol named <tt class="calibre16">hello</tt> in any other namespace.</p><p class="calibre13">To specify a namespace for a source file, use the <tt class="calibre16">ns</tt> special form as the first form in the file. (Unlike Clojure, <tt class="calibre16">ns</tt> is not just a macro wrapping more primitive functions (such as <tt class="calibre16">load</tt> and <tt class="calibre16">require</tt>) but built in to the language directly.) In its most basic form, declaring a namespace called <tt class="calibre16">foo.bar</tt> looks like this:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(ns foo.bar)</tt></span></blockquote><p class="calibre14">In ClojureScript, as in Clojure, the namespace of a file needs to match its location on the Java classpath. In the case of ClojureScript, this is the classpath of the compiler. Each <tt class="calibre16">.</tt> (period or full stop) in the namespace translates to a subdirectory on the classpath. For example, the namespace <tt class="calibre16">foo.bar.baz</tt> should be in a file with the path <tt class="calibre16">foo/bar/baz.cljs</tt>, relative to the classpath. This is necessary for the ClojureScript compiler to find the file that corresponds to a namespace.</p><p class="calibre13">To specify that a namespace depends on another namespace, add a <tt class="calibre16">:require</tt> form in the <tt class="calibre16">ns</tt> form, containing any number of specifications:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(ns application<br class="calibre6"/>    (:require [foo.bar :as bar]<br class="calibre6"/>              [foo.baz :as baz]))</tt></span></blockquote><p class="calibre14">This will force loading of the <tt class="calibre16">foo.bar</tt> and <tt class="calibre16">foo.baz</tt> namespaces before <tt class="calibre16">application</tt> itself is loaded. Labeling the namespaces with the <tt class="calibre16">:as</tt> clause means that within the <tt class="calibre16">foo</tt> namespace, you can reference the symbols in <tt class="calibre16">foo.bar</tt> via a shorter “alias” <tt class="calibre16">bar</tt>. In this example, the symbol <tt class="calibre16">foo.bar/function</tt> can be written <tt class="calibre16">bar/function</tt>. ClojureScript, unlike Clojure, does not permit “bare” namespaces in a <tt class="calibre16">:require</tt> clause. The compiler will throw an exception if you specify a <tt class="calibre16">:require</tt> without <tt class="calibre16">:as</tt>.</p><p class="calibre13">You may also reference namespaces with <tt class="calibre16">:use</tt> instead of <tt class="calibre16">:require</tt>, like so:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(ns application<br class="calibre6"/>    (:use [foo.bar :only [hello goodbye]]))</tt></span></blockquote><p class="calibre14">The <tt class="calibre16">:use</tt> form also causes the specified namespace(s) to be loaded, but differs from <tt class="calibre16">:require</tt> in that, for each of the symbols specified in the <tt class="calibre16">:only</tt> vector, it establishes a synonym in the current namespace so you can refer to symbols in the used namespace without explicitly qualifying them. For example, given the above <tt class="calibre16">ns</tt> declaration, you can now use the symbols <tt class="calibre16">hello</tt> and <tt class="calibre16">goodbye</tt> directly in the <tt class="calibre16">foo</tt> namespace to refer to <tt class="calibre16">foo.bar/hello</tt> and <tt class="calibre16">foo.bar/goodbye</tt>.</p><p class="calibre13">Again, the use of <tt class="calibre16">:only</tt> in a <tt class="calibre16">:use</tt> specification is mandatory in ClojureScript, and will cause a compile error if missing. Additionally, unlike Clojure, <tt class="calibre16">:require</tt> and <tt class="calibre16">:use</tt> are the only forms allowed within an <tt class="calibre16">ns</tt> declaration. Clojure’s <tt class="calibre16">:import</tt>, <tt class="calibre16">:refer</tt>, etc., are not supported. Therefore, although a valid ClojureScript <tt class="calibre16">ns</tt> declaration is also always a valid Clojure <tt class="calibre16">ns</tt> declaration, the inverse is not true: ClojureScript has much narrower requirements for validity.</p><p id="filepos186315" class="calibre14"><span class="calibre5"><span class="bold">Using namespaces at the REPL</span></span></p><p class="calibre13">The <tt class="calibre16">ns</tt> form will not work in the ClojureScript REPL (either the Rhino REPL or the browser REPL). To switch the current namespace in the REPL, you can use the <tt class="calibre16">in-ns</tt> special form, passing it the quoted namespace:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">ClojureScript:cljs.user&gt; (in-ns 'foo.bar)</tt></span></blockquote><p class="calibre14">This switches the REPL’s current namespace to be <tt class="calibre16">foo.bar</tt>.</p><p class="calibre13">Note that <tt class="calibre16">in-ns</tt> is a special tool for REPL development, and doesn’t actually exist in ClojureScript’s standard library. It is implemented as a special case in the REPL’s reader. As such, it won’t work at all in <span class="italic">*.cljs</span> source files, or anywhere else except in a REPL session.</p><p class="calibre13">Also, because ClojureScript namespaces can be defined only at compile time, using <tt class="calibre16">in-ns</tt> to switch to a namespace does not implicitly create the namespace (as it does in Clojure). If you specify a namespace that isn’t already loaded, the REPL will switch to it, but almost everything you try to do will fail with a “namespace is not defined” error.</p><p id="filepos187647" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Using Namespaces Effectively</span></span></span></p><p class="calibre13">Fundamentally, namespaces are just a tool to prevent name clashes, but they also help structure your code into logical units. They function a bit like modules or packages in other languages. Here are a few hints to use namespaces effectively:</p><div class="calibre26"> </div><ol class="calibre27"><li value="1" class="calibre28"><blockquote class="calibre15">Group similar or related functions together in the same namespace.</blockquote></li><li value="2" class="calibre28"><blockquote class="calibre15">Try to minimize the number of dependencies (<tt class="calibre16">:require</tt> and <tt class="calibre16">:use</tt> expressions) in each namespace, except for one main namespace that ties together everything in your application.</blockquote></li><li value="3" class="calibre28"><blockquote class="calibre15">Never have circular dependencies between two namespaces (namespace <span class="italic">A</span> depends on <span class="italic">B</span>, which depends on <span class="italic">A</span>).</blockquote></li></ol><p id="filepos188748" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">The Implementation of Namespaces</span></span></span></p><p class="calibre13">To really understand how ClojureScript namespaces work, it’s helpful to know something about their implementation.</p><p id="filepos189018" class="calibre14"><span class="calibre5"><span class="bold">Namespaces and *.js files</span></span></p><p class="calibre13">When you compile a directory containing <span class="italic">*.cljs</span> files, the compiler emits a directory with the same structure containing compiled <span class="italic">*.js</span> files; each input <span class="italic">*.cljs</span> file has exactly one output <span class="italic">*.js</span> file with the same name and path.</p><p class="calibre13">Each emitted <span class="italic">*.js</span> file contains code allowing it to participate in the namespace system provided by the Google Closure Library. You can read about the Google Closure Library’s dependency management system <a href="https://developers.google.com/closure/library/"><span class="calibre3">here</span></a>. Note that as a user of ClojureScript, you don’t have to worry about writing a <span class="italic">deps.js</span> file, or using the ClojureBuilder or DepsWriter scripts described in the Google Closure documentation. The ClojureScript compiler performs those functions internally. This is the mechanism by which ClojureScript actually resolves namespace dependencies: under the hood, ClojureScript’s namespace dependency system <span class="italic">is</span> that of Google Closure.</p><p class="calibre13">In the Google Closure Library, dependency management is handled by two functions: <tt class="calibre16">goog.provide()</tt> and <tt class="calibre16">goog.require()</tt>. The <tt class="calibre16">goog.provide()</tt> function is intended to be called once per file, and passes the namespace the file contains. The <tt class="calibre16">goog.require()</tt> function may be called multiple times, each time with a dependency of the file. Both are emitted directly by ClojureScript when compiling an <tt class="calibre16">ns</tt> form. The mapping is very straightforward:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(ns application<br class="calibre6"/>    (:require [foo.bar :as bar]<br class="calibre6"/>              [foo.baz :as baz]))</tt></span></blockquote><p class="calibre14">It is compiled to:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">goog.provide("application");<br class="calibre6"/>goog.require("foo.bar");<br class="calibre6"/>goog.require("foo.baz");</tt></span></blockquote><p class="calibre14">What happens next depends on what <tt class="calibre16">:optimizations</tt> mode the ClojureScript compiler is running in.</p><p class="calibre13">When using <tt class="calibre16">:optimizations :none</tt>, the ClojureScript compiler will write a list of calls to <tt class="calibre16">goog.addDependency()</tt> to the specified <tt class="calibre16">:output-to</tt> file. These serve to create mappings between namespace names, dependencies, and relative paths, and are necessary to inform Google Closure of the location of dependencies (unlike ClojureScript, Google Closure has no convention regarding source file location). After you include this dependencies file in your web page, calls to <tt class="calibre16">goog.require()</tt> will dynamically add new <tt class="calibre16">&lt;script&gt;</tt> tags to the page using the provided relative path.</p><p class="calibre13">It follows, then, that when using <tt class="calibre16">:optimizations :none</tt> you must also make the compiler output directory (specified with <tt class="calibre16">:output-dir</tt>) publicly available on a relative path appropriate to the URL of the page. This is necessary because the page will end up loading each of the needed <span class="italic">*.js</span> files directly. You must also manually include <tt class="calibre16">goog/base.js</tt> first in your HTML, to bootstrap the Google Closure Library, as we showed in <a href="#filepos45583"><span class="calibre3">Chapter 3</span></a>.</p><p class="calibre13">On the other hand, when using any <tt class="calibre16">:optimizations</tt> mode <span class="italic">other</span> than <tt class="calibre16">:none</tt>, the compiler will concatenate all the required files into one gigantic JavaScript file, in dependency order, and write it out as the <tt class="calibre16">:output-to</tt> file. This is the only <span class="italic">*.js</span> file you need to include on your HTML page, since it contains a full copy of every dependency, even the core Google Closure library. Therefore, in this case, it <span class="italic">isn’t</span> necessary to expose the output directory like it is with <tt class="calibre16">:optimizations :none</tt>.</p><p id="filepos193097" class="calibre14"><span class="calibre5"><span class="bold">Namespaces and variable names</span></span></p><p class="calibre13">Because vanilla JavaScript has no built-in namespace support, it’s standard practice to use objects as a poor man’s namespace system, nesting all the variables a library uses under a single top-level object.</p><p class="calibre13">The ClojureScript compiler does exactly the same thing, when compiling ClojureScript symbols to JavaScript variables. Each dot-separated level of the namespace becomes a nested object, with the symbol’s name as the final name. For example, the symbol <tt class="calibre16">my.cool.new-project/some-data</tt> in ClojureScript will be <tt class="calibre16">my.cool.new_project.some_data</tt> in JavaScript. (Hyphens in ClojureScript symbols become underscores in JavaScript.)</p><p class="calibre13">For pure ClojureScript applications, this is just an implementation detail. However, it does become important when you want to call a ClojureScript function from JavaScript, since you must refer to it by its fully qualified (i.e., nested) name.</p><p id="filepos194177" class="calibre11"><span class="calibre12"><span class="bold">Advanced Compilation Mode</span></span></p><p class="calibre13">For the subsequent sections on consuming and producing libraries, one of the major challenges is working with the implications of the Google Closure Compiler’s <span class="italic">Advanced Optimizations</span> mode. Before moving on, it will help to have a complete idea of what <span class="italic">Advanced</span> mode actually does.</p><p class="calibre13"><span class="italic">Advanced</span> mode’s blessing, and its curse, is that it deeply and radically transforms your program. It does so in very beneficial ways, decreasing both code size and execution time, sometimes drastically. <span class="italic">Advanced</span> mode can and does:</p><div class="calibre26"> </div><ul class="calibre35"><li value="1" class="calibre28"><blockquote class="calibre15">Rename variables and functions to shorter names (sometimes called <span class="italic">munging</span>)</blockquote></li><li value="2" class="calibre28"><blockquote class="calibre15">Flatten object nesting</blockquote></li><li value="3" class="calibre28"><blockquote class="calibre15">Eliminate unused code</blockquote></li><li value="4" class="calibre28"><blockquote class="calibre15">Create inline functions</blockquote></li><li value="5" class="calibre28"><blockquote class="calibre15">Optimize performance based on known characteristics of JavaScript runtimes</blockquote></li></ul><p class="calibre13">Essentially, there is nothing that advanced mode might not do to your code, while maintaining the same semantics. Consider the following example:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">function print_sum(sum) {<br class="calibre6"/>    alert('The sum is ' + sum);<br class="calibre6"/>}<br class="calibre6"/>print_sum(3 + 4);</tt></span></blockquote><p class="calibre14"><span class="italic">Advanced</span> mode can convert this to the following:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">alert("The sum is 7");</tt></span></blockquote><p class="calibre14">The level of sophistication evident in this transformation speaks for itself.</p><p class="calibre13">But <span class="italic">Advanced</span> mode’s power comes at a price. Specifically, it imposes two major requirements:</p><div class="calibre26"> </div><ol class="calibre27"><li value="1" class="calibre28"><blockquote class="calibre15">It must operate on the entire program, as a whole, at once. Otherwise, it cannot safely rename variables or enact other transformations.</blockquote></li><li value="2" class="calibre28"><blockquote class="calibre15">It only works on a subset of JavaScript. The exact restrictions can be found <a href="https://developers.google.com/closure/compiler/docs/limitations"><span class="calibre3">here</span></a>. You don’t have to worry about this for ClojureScript code, since the ClojureScript compiler only emits compatible JavaScript. However, there are frequently issues with third-party libraries not designed with Google Closure in mind.</blockquote></li></ol><p id="filepos197268" class="calibre11"><span class="calibre12"><span class="bold">Consuming Libraries</span></span></p><p class="calibre13">A compelling feature of ClojureScript is that it is capable of utilizing any JavaScript library. Unfortunately, because of its reliance on Google Closure dependency management and advanced mode compilation, doing so is admittedly difficult. There are several different techniques, and choosing the wrong one will result in errors, or worse, subtle bugs in your application’s behavior.</p><p class="calibre13">Fortunately, it <span class="italic">is</span> possible to import and use any library safely, as explained below. See the flowchart at the end of the section for a high-level overview of the options you have.</p><p id="filepos197985" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">ClojureScript Libraries</span></span></span></p><p class="calibre13">If the library you want to use is written in ClojureScript, your task is done. All you need to do is make sure the <span class="italic">*.cljs</span> files for the library are available on the classpath either as a JAR dependency or a source folder, depending on how the library is distributed.</p><p class="calibre13">Once the source files are on the classpath, you can <tt class="calibre16">:require</tt> or <tt class="calibre16">:use</tt> them exactly the same way you would a namespace that you wrote—in fact, from the point of view of the system, there isn’t any difference. They will be compiled and optimized along with your code.</p><p id="filepos198721" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">JavaScript Libraries</span></span></span></p><p class="calibre13">You can also use libraries not originally intended for use with ClojureScript by using interop forms in your code to reference JavaScript variables (see <a href="#filepos83077"><span class="calibre3">Chapter 4</span></a>).</p><p class="calibre13">How exactly to go about including such a library depends on the characteristics of the library in question. The procedure is different for libraries that were written with Google Closure in mind. For those that weren’t, there is another choice: compiling them in <span class="italic">Advanced</span> mode along with your application, or leaving them completely external.</p><p id="filepos199466" class="calibre14"><span class="calibre5"><span class="bold">Google Closure libraries</span></span></p><p class="calibre13">These are files that include a call to <tt class="calibre16">goog.provide()</tt>, allowing them to participate in Google Clojure’s dependency management system, and by extension, ClojureScript’s. A JS file that invokes <tt class="calibre16">goog.provide('x.y.z')</tt> effectively has the namespace <tt class="calibre16">x.y.z</tt>.</p><p class="calibre13">Unless you work at Google, you aren’t likely to see many libraries that fit into this category, as Google Closure doesn’t have a particularly large uptake in the JavaScript community. However, if you’re using a mixed JavaScript/ClojureScript codebase, and you’d like anyone to have the freedom to modify the library, you can consider making your JavaScript compatible with Google Closure to make it easier to use with ClojureScript.</p><p class="calibre13">First, to use them, you must start by putting the <span class="italic">*.js</span> files on the classpath so they are accessible to the compiler (just like ClojureScript files).</p><p class="calibre13">Second, you must tell the ClojureScript compiler <span class="italic">where</span> on the classpath the files are located. Unlike ClojureScript file paths, <span class="italic">*.js</span> pathnames don’t necessary have any relationship to the namespaces they provide. To indicate this to the compiler, use the <tt class="calibre16">:libs</tt> compiler option, which is a vector of <span class="italic">*.js</span> pathnames relative to the classpath. The compiler will inspect these files for calls to <tt class="calibre16">goog.provide()</tt> and handle them appropriately.</p><p class="calibre13">For example, to include a library in a file located at <tt class="calibre16">jslib/magic.js</tt>, the compiler options map might look something like this:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">{:output-to "resources/public/js/main.js"<br class="calibre6"/> :optimizations :advanced<br class="calibre6"/> :libs ["jslib/magic.js"]}</tt></span></blockquote><p class="calibre14">Finally, to use these libraries in your ClojureScript code, <tt class="calibre16">:require</tt> or <tt class="calibre16">:use</tt> their namespaces in your <tt class="calibre16">ns</tt> declaration form. This will ensure that the library is available. Then, use ClojureScript’s JS interop to reference the JavaScript vars. Note that the namespace of a Google Closure library doesn’t always match the names of the variables it declares; that’s another ClojureScript convention that is stricter than what Google Closure alone requires.</p><p class="calibre13">Because libraries built for Google Clojure should already be compatible with <span class="italic">Advanced</span> mode compilation, you shouldn’t need to worry about preserving variable names against munging: <span class="italic">Advanced</span>-mode processing will be consistent across the entire codebase, including the required libraries.</p><p id="filepos202281" class="calibre14"><span class="calibre5"><span class="bold">Plain old JavaScript libraries</span></span></p><p class="calibre13">This is likely the most common type of library you might wish to use in ClojureScript: a normal, possibly popular JavaScript library that wasn’t written with ClojureScript or Google Closure in mind.</p><p class="calibre13">With these libraries, there is just one major choice to make: do you want to attempt to use the Google Closure Compiler’s <span class="italic">Advanced Optimizations</span> mode to compile the library together with your code, or include it separately on the HTML page? When you use <span class="italic">Advanced</span> mode, the Google Closure Compiler will perform whole-program optimization across both the library and your code. When you leave it separate, your program will still be compiled, but the external library will be loaded and run without any transformations.</p><p class="calibre13">As discussed above, compiling in <span class="italic">Advanced</span> mode has many benefits in emitted code size and runtime speed. Also, as you will see below, it’s slightly easier to use with ClojureScript. However, the fact is that most JavaScript code written without <span class="italic">Advanced</span> mode in mind probably doesn’t meet its rather stringent requirements.</p><p class="calibre13">If you <span class="italic">do</span> want to compile an existing library in <span class="italic">Advanced</span> mode, you should do a careful audit of the library’s code to make sure it meets the restrictions of <span class="italic">Advanced</span> mode. Be cautious: this is the one area where it is possible to go badly wrong. Sometimes incompatibilities don’t manifest in an obvious way until they’ve caused you serious trouble.</p><p id="filepos203950" class="calibre14"><span class="calibre54">With Advanced mode</span></p><p class="calibre14">Compiling a library into your application with <span class="italic">Advanced</span> mode is fairly easy, given the major caveat that the library’s code is <span class="italic">Advanced</span>-mode compatible. The process is very similar to including a library that <span class="italic">is</span> built for Google Closure, the only difference being that instead of just telling the compiler the location of the file, it is necessary to tell it the location and the namespace it provides using the <tt class="calibre16">:foreign-libs</tt> compiler option.</p><p class="calibre13"><tt class="calibre16">:foreign-libs</tt> must be a sequence of maps, each containing a <tt class="calibre16">:file</tt> and a <tt class="calibre16">:provides</tt> key. The <tt class="calibre16">:file</tt> value is a path or URL indicating the absolute or classpath-relative location of the file. The <tt class="calibre16">:provides</tt> key is a vector of strings naming the namespaces that the file provides. Put together, it looks like this:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">{:output-to "resources/public/js/main.js"<br class="calibre6"/> :optimizations :advanced<br class="calibre6"/> :foreign-libs [{:file "http://foo.com/foobar.js"<br class="calibre6"/>                 :provides ["foo.bar"]}]}</tt></span></blockquote><p class="calibre14">This will tell the ClojureScript compiler that when it’s concatenating all the sources prior to running them through the Google Closure Compiler, it should also include the source of the given file, and it should inject a call to <tt class="calibre16">goog.provide()</tt> in the source for each of the given namespaces.</p><p class="calibre13">The effect is the same as if the library had included a <tt class="calibre16">goog.provide()</tt> call on its own, and been included using the <tt class="calibre16">:libs</tt> option.</p><p class="calibre13">Again, this will only work if the library’s code conforms to the standards required by <span class="italic">Advanced</span> mode. Be especially aware that any nonconformities might not show up at compile time, although Google Closure will do its best to give warnings.</p><p id="filepos206032" class="calibre14"><span class="calibre54">Without Advanced mode</span></p><p class="calibre14">This is likely to be the most common case: you have a library you want to use, but it wasn’t built for ClojureScript or Google Clojure, and you’re not confident it is compatible with advanced-mode compilation.</p><p class="calibre13">The basic premise for using such a library is very simple: just include it on your HTML page using a separate <tt class="calibre16">&lt;script&gt;</tt> tag, which will load it into the JavaScript runtime environment. Since your ClojureScript program has access to the root environment through its interop forms, you can directly reference any of the variables the external library has created using interop forms (such as the <tt class="calibre16">js/</tt> pseudo-namespace).</p><p class="calibre13">Unfortunately, although this is fine for <span class="italic">Whitespace Only</span> or <span class="italic">Simple Optimizations</span> compilation, <span class="italic">Advanced</span> mode will cause errors without some extra work. The reason for this is variable munging. <span class="italic">Advanced</span> mode will potentially rename every symbol or property name mentioned in your ClojureScript code. If you’re compiling everything together with <span class="italic">Advanced</span> mode, the renaming will be consistent and everything will work. But if you’re only compiling your ClojureScript code and not the library, then things will be renamed with no way to match them back up, and you’ll end up with errors like “<span class="italic">X</span> is not a function” or “no such property <span class="italic">X”</span> errors.</p><p class="calibre13">For a real-world example, consider the following snippet of ClojureScript, which draws a circle using the excellent <span class="italic">Raphael.js</span> vector graphics <a href="http://raphaeljs.com/"><span class="calibre3">library</span></a>:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(let [image (js/Raphael. 10 50 320 200)]<br class="calibre6"/>    (.circle image 50 50 50))</tt></span></blockquote><p class="calibre14">This works great with <span class="italic">Whitespace Only</span> or <span class="italic">Simple</span> compilation. It uses the <tt class="calibre16">js/</tt> namespace to call the global <tt class="calibre16">Raphael</tt> function as a constructor, which creates a Raphael drawing object of the specified dimensions. It then invokes the <tt class="calibre16">circle</tt> method on that object to draw a circle.</p><p class="calibre13">But try it in <span class="italic">Advanced</span> mode, and you’ll get a cryptic error, something like <tt class="calibre16">new Raphael(10, 50, 320, 200)).K is not a function</tt>. Initially, this doesn’t make sense: what is the <tt class="calibre16">K</tt> function it’s trying to invoke?</p><p class="calibre13">In this case, <tt class="calibre16">K</tt> is the munged name of <tt class="calibre16">circle</tt>. Google Closure doesn’t know that <tt class="calibre16">circle</tt> is a name that needs to be preserved. It has no knowledge of the Raphael library at all, since that wasn’t included in its compilation pass.</p><p class="calibre13">What’s needed is a way to inform the Google Closure Compiler that <tt class="calibre16">circle</tt> is an external reference, and should be left alone when compiling. Fortunately, Google provides such a mechanism: it allows you to create an <span class="italic">externs file</span>.</p><p class="calibre13">An externs file is just a JavaScript file that contains a JavaScript variable and property declarations. Any variable or property referenced in the externs file will not be munged. It isn’t actually compiled itself, so the variable references don’t have to be meaningful, they just have to be present to signal the compiler not to munge them. A very simple externs file that would make the Raphael code work would be something like this:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">var Raphael = {};<br class="calibre6"/>Raphael.circle = function() {};</tt></span></blockquote><p class="calibre14">Of course, Raphael has many more functions than just <tt class="calibre16">circle</tt>, but you only need to declare the ones you want to consume from ClojureScript.</p><p class="calibre13">Finally, you need to tell the ClojureScript compiler about the externs file using the <tt class="calibre16">:externs</tt> compiler options, which is a sequence of strings of the classpath-relative paths of extern files. For example, to include this externs file for Raphael:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">{:output-to "resources/public/js/main.js"<br class="calibre6"/> :optimizations :advanced<br class="calibre6"/> :externs ["raphael_externs.js"]}</tt></span></blockquote><p class="calibre14">That’s it! If you’ve included the necessary references in an externs file, then you can reference variables and properties from an outside context without munging, and successfully consume any JavaScript library you like.</p><p id="filepos210817" class="calibre11"><span class="calibre12"><span class="bold">Creating Libraries</span></span></p><p class="calibre13">It’s fairly straightforward to use ClojureScript to write libraries for distribution and consumption by other applications. You will need to package it differently, however, depending on whether you intend clients of your library to consume it using ClojureScript or JavaScript (<a href="#filepos211277"><span class="calibre3">Figure 7-1</span></a>).</p><blockquote id="filepos211277" class="calibre36"></blockquote><blockquote class="calibre37"><img src="images/00004.jpg" class="calibre55"/></blockquote><blockquote class="calibre36"><span class="calibre19"><span class="italic"><span class="calibre18">Figure 7-1. Flowchart for determining how to use a library in ClojureScript</span></span></span></blockquote><p id="filepos211674" class="calibre32"><span class="calibre31"><span class="bold"><span class="calibre3">For Consumption by ClojureScript</span></span></span></p><p class="calibre13">The best way to distribute a ClojureScript library for use by ClojureScript is to distribute the <span class="italic">*.cljs</span> source files directly, either by giving clients a directory full of source code or distributing a JAR file containing the <span class="italic">*.cljs</span> files. In either case, the clients will need to add the directory or JAR to their compiler classpath so the ClojureScript compiler can find them.</p><p class="calibre13">All the client has to do to use the library is to consume it as described in the section above on consuming ClojureScript libraries.</p><p id="filepos212385" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">For Consumption by JavaScript</span></span></span></p><p class="calibre13">If you want JavaScript applications to be able to call your ClojureScript code, you’ll need to distribute the <span class="italic">compiled</span> version of your app. Typically, the easiest way to do this is to compile your library to a single <span class="italic">*.js</span> file using the Google Closure Compiler and give that file to your clients. They can then reference that file in a <tt class="calibre16">&lt;script&gt;</tt> tag on their page, and start using it.</p><p class="calibre13">Fortunately, actually using the library should be fairly easy. ClojureScript functions are just JavaScript functions, and namespaces are just nested objects (following the JavaScript convention). So, for example, if you have a ClojureScript function <tt class="calibre16">foo.bar/hello-world</tt>, your JavaScript clients can easily call it using <tt class="calibre16">foo.bar.hello_world()</tt>.</p><p class="calibre13">You will have to be careful not to expect arguments or return objects they won’t be able to use easily, such as ClojureScript vectors or maps. If you really intend your library to be used extensively from JavaScript, you’ll probably want to create a set of public API functions that accept and return more familiar types. For example, you might convert ClojureScript maps to JavaScript objects, sequences to JavaScript arrays, and keywords to strings before returning them.</p><p id="filepos213851" class="calibre14"><span class="calibre5"><span class="bold">^:export metadata</span></span></p><p class="calibre13">If you want to compile your libraries with <span class="italic">Advanced</span> mode, you’ll need to make one small additional change. JavaScript libraries can reference ClojureScript vars by name, but <span class="italic">Advanced</span> mode compilation munges all the var names. If you want to be able to reference a var from external JavaScript, you’ll need to mark it specifically for preservation.</p><p class="calibre13">To do this, tag the vars whose names you want to preserve using the <tt class="calibre16">:export</tt> metadata tag. ClojureScript metadata is data that can be attached to any ClojureScript object, and since it can be inspected by the compiler it can be used to alter the emitted JavaScript. In the case of <tt class="calibre16">:export</tt>, it indicates that the tagged var should not be munged.</p><p class="calibre13">Adding the <tt class="calibre16">:export</tt> metadata tag to a function using the metadata reader macro looks like this:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(ns foo)<br class="calibre6"/><br class="calibre6"/>(defn ^:export hello [name]<br class="calibre6"/>    (js/alert (str "Hello, " name)))</tt></span></blockquote><p class="calibre14">This code defines a very simple function called <tt class="calibre16">hello</tt> in the <tt class="calibre16">foo</tt> namespace, but tags it with <tt class="calibre16">:export</tt> so that it won’t be munged during advanced compilation. This means that a JavaScript caller can invoke it directly: <tt class="calibre16">foo.hello("Luke")</tt> would result in an alert box popping up that says “Hello, Luke”.</p><div class="mbppagebreak"></div><p id="filepos215466" class="calibre11"><span class="calibre2"><span class="bold">Chapter 8. Macros</span></span></p><p class="calibre25">ClojureScript, like Clojure, uses <span class="italic">macros</span> to extend the syntax of the language. Fundamentally, a macro is just a function that manipulates data structures. What makes macros special is that they are invoked during the compilation process, to manipulate the data structures representing ClojureScript source code. Many of ClojureScript’s core flow-control operators are implemented as macros, and you can write your own macros to extend the language.</p><p id="filepos216035" class="calibre11"><span class="calibre12"><span class="bold">Code as Data</span></span></p><p class="calibre13">Remember from <a href="#filepos83077"><span class="calibre3">Chapter 4</span></a> that all ClojureScript code is composed of data structures: lists, vectors, symbols, and so on. For example:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(println "Three plus four is" (+ 3 4))</tt></span></blockquote><p class="calibre14">We can read this expression as a list containing a symbol, a string, and another list. But to the ClojureScript compiler, that list represents a function call.</p><p class="calibre13">Macros allow you to manipulate the data structures in your code <span class="italic">before</span> they get to the compiler. This is very powerful: a macro can effectively rewrite code before it gets to the compiler.</p><p id="filepos216904" class="calibre11"><span class="calibre12"><span class="bold">Writing Macros</span></span></p><p class="calibre13">Macros are applied during the <span class="italic">compilation</span> process. They do not exist at runtime. Because the ClojureScript compiler is implemented in Clojure, ClojureScript macros must be <span class="italic">written</span> in Clojure, not ClojureScript. Fortunately, Clojure and ClojureScript are almost identical when it comes to manipulating data structures, so switching between the two languages is not difficult.</p><p class="calibre13">As an example, consider the <tt class="calibre16">when</tt> macro introduced in <a href="#filepos83077"><span class="calibre3">Chapter 4</span></a>:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(when condition<br class="calibre6"/>  ;; </tt></span><span class="calibre19"><tt class="calibre16"><span class="italic">... expressions ...</span></tt></span><span class="calibre19"><tt class="calibre16"><br class="calibre6"/>  )<br class="calibre6"/><br class="calibre6"/>;; which expands to:<br class="calibre6"/>(if condition<br class="calibre6"/>  (do<br class="calibre6"/>    ;; </tt></span><span class="calibre19"><tt class="calibre16"><span class="italic">... expressions ...</span></tt></span><span class="calibre19"><tt class="calibre16"><br class="calibre6"/>    ))</tt></span></blockquote><p class="calibre14">The <tt class="calibre16">when</tt> macro is simply a way to avoid the extra <tt class="calibre16">do</tt> block when we want multiple expressions in an <tt class="calibre16">if</tt> expression. Usually this happens when the code inside the <tt class="calibre16">when</tt> macro is performing side effects.</p><p class="calibre13">To write a macro, first think about the expression you want to be able to <span class="italic">write</span> in your code. Second, think about what you want it to <span class="italic">become</span>. Finally, write a function that converts the first into the second. Here is a simple version of the <tt class="calibre16">when</tt> macro:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(defmacro when [condition &amp; body]<br class="calibre6"/>  (list 'if condition<br class="calibre6"/>        (cons 'do body)))</tt></span></blockquote><p class="calibre14">Notice that a macro definition looks just like a function definition, but it starts with <tt class="calibre16">defmacro</tt> instead of <tt class="calibre16">defn</tt>. This function is variadic: it takes one argument called <tt class="calibre16">condition</tt> followed by any number of arguments that will be collected into the list called <tt class="calibre16">body</tt>. It then constructs a list starting with the symbol <tt class="calibre16">if</tt>, followed by the condition, followed by <tt class="calibre16">body</tt> with the <tt class="calibre16">do</tt> symbol inserted at the head.</p><p class="calibre13">Applying a macro is called <span class="italic">macroexpansion</span>, and it happens at the beginning of the ClojureScript compilation process. You can test it at the REPL with the <tt class="calibre16">macroexpand-1</tt> function at the Clojure REPL. Remember, macros are written in Clojure, not ClojureScript, so you must write and test them at the Clojure REPL.</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">user=&gt; (macroexpand-1 '(when (even? 2) (println "2 is even")))<br class="calibre6"/>(if (even? 2) (do (println "2 is even")))</tt></span></blockquote><p class="calibre14">Notice that we are calling the <tt class="calibre16">macroexpand-1</tt> function on a <span class="italic">quoted</span> form. We don’t want to <span class="italic">evaluate</span> the <tt class="calibre16">when</tt> expression; we want to see what it will expand to during compilation. The <tt class="calibre16">macroexpand-1</tt> function performs one round of macroexpansion. However, a macro can expand to code, which begins with another macro. To see the final result of all the expansions, you can call the <tt class="calibre16">macroexpand</tt> function, which keeps expanding macros until it reaches an expression that is not a macro.</p><p class="calibre13">There is also <tt class="calibre16">macroexpand-all</tt>, which recursively expands all the macros anywhere in an expression. It is available in the Clojure namespace <tt class="calibre16">clojure.walk</tt>. This <tt class="calibre16">macroexpand-all</tt> is not entirely correct because it doesn’t recognize special forms such as <tt class="calibre16">let</tt>, but it is usually adequate for debugging macro expressions.</p><p id="filepos220872" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Syntax-Quote</span></span></span></p><p class="calibre13">Macros manipulate data structures that represent code. However, as the code they produce grows more complex, it becomes tedious to manually construct the data structures to represent it. To help, Clojure has the <span class="italic">syntax-quote</span> operator to construct “templates” for expansion. Syntax-quote is written using the backtick (<tt class="calibre16">`</tt>) symbol. It behaves like the normal single quote in that it prevents evaluation, but syntax-quote also allows values to be <span class="italic">unquoted</span>.</p><p class="calibre13">Here is a version of <tt class="calibre16">when</tt> written with syntax-quote:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(defmacro [condition &amp; body]<br class="calibre6"/>  `(if ~condition (do ~@body)))</tt></span></blockquote><p class="calibre14">Notice that we don’t have to do any manual construction, such as invoking <tt class="calibre16">list</tt>, as in the previous example. Instead, the syntax-quoted form looks similar to the form we ultimately want to produce. Within that form, we have unquoted the <tt class="calibre16">condition</tt> symbol by prefixing it with a tilde (<tt class="calibre16">~</tt>). We have used a variant of unquote called <span class="italic">unquote-splicing</span> on the <tt class="calibre16">body</tt> symbol. The unquote-splicing operator (<tt class="calibre16">~@</tt>) operates on lists by inserting the contents of the list at the expansion point, without the enclosing parentheses of the list itself. Unquote-splicing is like “unwrapping” a list before placing it in the expansion.</p><p id="filepos222475" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Auto-Gensyms</span></span></span></p><p class="calibre13">It is often necessary to create new symbols in the body of a macro, such as <tt class="calibre16">let</tt> bindings. To prevent these symbols from clashing with symbols already in use elsewhere around the code, Clojure’s macros provide <span class="italic">auto-gensyms</span>, or automatically-generated symbols, guaranteed to have unique names. These symbols are generated by placing a hash sign (<tt class="calibre16">#</tt>) after the symbol name. Auto-gensyms are only available within a syntax-quoted expression.</p><p class="calibre13">For example, here is a macro that expands to some debugging code:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(defmacro debug [expr]<br class="calibre6"/>  `(let [result# ~expr]<br class="calibre6"/>     (println "Evaluating:" '~expr)<br class="calibre6"/>     (println "Result:" result#)<br class="calibre6"/>     result#))</tt></span></blockquote><p class="calibre14">In this example, the <tt class="calibre16">debug</tt> macro takes a single expression and uses it twice. To avoid evaluating <tt class="calibre16">expr</tt> more than once, it has to create an intermediate <tt class="calibre16">let</tt> binding. The <tt class="calibre16">result#</tt> symbol will expand to an auto-gensym, which is guaranteed to have a unique name that doesn’t clash with any other symbols. Macroexpansion shows the result:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">user=&gt; (macroexpand-1 '(debug (println "hello")))<br class="calibre6"/>(clojure.core/let [result__6__auto__ (println "hello")]<br class="calibre6"/>  (clojure.core/println "Evaluating:" (quote (println "hello")))<br class="calibre6"/>  (clojure.core/println "Result:" result__6__auto__))</tt></span></blockquote><p class="calibre14">The <tt class="calibre16">debug</tt> macro also contains a clever trick: the “quote-unquote” in <tt class="calibre16">'~expr</tt>. This allows the expansion to print the literal code of <tt class="calibre16">expr</tt> without evaluating it.</p><p id="filepos224474" class="calibre11"><span class="calibre12"><span class="bold">Using Macros</span></span></p><p class="calibre13">Because macros are written in Clojure, they must be loaded differently in the ClojureScript compiler. To reference a macro from another namespace, add it to the <tt class="calibre16">ns</tt> declaration using the <tt class="calibre16">:require-macros</tt> form. For example:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(ns my-project.main<br class="calibre6"/>  (:require-macros [my-project.foo :as foo]))<br class="calibre6"/><br class="calibre6"/>(foo/my-macro)</tt></span></blockquote><p class="calibre14">This assumes that a <span class="italic">Clojure</span> source file is available on the classpath at <tt class="calibre16">my_project/foo.clj</tt> containing <tt class="calibre16">defmacro foo</tt>.</p><p class="calibre13">With the exception of the <tt class="calibre16">ns</tt> declaration, you generally do not need to think about whether you are calling a function or a macro in ClojureScript code. Many of the core flow-control structures of ClojureScript are implemented as macros (many of the core ClojureScript macros are actually the same as the core Clojure macros, invoked directly by the ClojureScript compiler!). The flow-control macros do not behave exactly like functions, because they can cause some of their arguments not to be evaluated. But well-written macros generally follow the behavior you expect: for example, ClojureScript’s <tt class="calibre16">and</tt> and <tt class="calibre16">or</tt> macros are “short-circuiting” just like the Boolean operators in JavaScript.</p><p id="filepos225966" class="calibre11"><span class="calibre12"><span class="bold">When to Write Macros</span></span></p><p class="calibre13">The first answer to “When should I write a macro?” is usually “Don’t!” Macros are the most powerful feature of a Lisp-like language, and the easiest to misuse. In general, you should always use functions and values as the primary units of abstraction in your code. Typically you only need macros in three cases:</p><div class="calibre26"> </div><ol class="calibre27"><li value="1" class="calibre28"><blockquote class="calibre15">To do things functions cannot do. For example, the <tt class="calibre16">and</tt> conditional operation cannot be written as a function, because it needs to prevent evaluation of some of its arguments. Macros can control when and how their arguments are evaluated.<sup class="calibre44"><small class="calibre45"><span class="calibre46">[</span><a id="filepos226797"></a><a href="#filepos228528"><span class="calibre46">3</span></a><span class="calibre46">]</span></small></sup></blockquote></li><li value="2" class="calibre28"><blockquote class="calibre15">To add a layer of syntactic sugar. For example, the <tt class="calibre16">when</tt> macro doesn’t do anything different from what you can already accomplish with <tt class="calibre16">if</tt> and <tt class="calibre16">do</tt>, but it makes the syntax shorter and easier to read.</blockquote></li><li value="3" class="calibre28"><blockquote class="calibre15">To improve performance. Because macros are evaluated during compilation, they can potentially convert an expression into a more-efficient form before it reaches the compiler. The ClojureScript compiler uses macros internally to produce more efficient code, but you are unlikely to encounter this situation in everyday programming.</blockquote></li></ol><p id="filepos227657" class="calibre11"><span class="calibre12"><span class="bold">Summary</span></span></p><p class="calibre13">Macros are an extremely powerful language tool, so powerful that they are rarely needed in everyday programming. However, for advanced tasks, such as defining new control structures or embedding domain-specific languages, they can be invaluable. This chapter has barely scratched the surface of what macros can do. For more examples, refer to books about Clojure. For even deeper exploration of macros, look to books on Common Lisp, such as Paul Graham’s classic <a href="http://www.paulgraham.com/onlisptext.html"><span class="italic"><span class="calibre3">On Lisp</span></span></a>, available free online. Note that most other Lisps use the comma character instead of tilde for <tt class="calibre16">unquote</tt>.</p><br class="calibre6"/><hr class="calibre49"/><p class="calibre50"><sup class="calibre44"><small class="calibre45"><span class="calibre46">[</span><a id="filepos228528"></a><a href="#filepos226797"><span class="calibre46">3</span></a><span class="calibre46">] </span></small></sup><span class="calibre19">Technically, you can prevent evaluation of function arguments by wrapping each argument in an anonymous function, but this is syntactically cumbersome.</span></p><div class="mbppagebreak"></div><p id="filepos228815" class="calibre11"><span class="calibre2"><span class="bold">Chapter 9. Development Process and Workflow</span></span></p><p class="calibre25">At the beginning of the book, we introduced Leiningen with <span class="italic">lein-cljsbuild</span> as an easy way to get started with ClojureScript. However, it is far from being the only way to work with ClojureScript.</p><p class="calibre13">This chapter will give a brief overview of some alternative means of installing ClojureScript (including the cutting-edge development branch), as well as instructions on how to use the more low-level tools included with ClojureScript to compile manually or script your own personal workflow. It will also include some pointers to more advanced features of Leiningen that you may find useful for particular tasks.</p><p class="calibre13">Most importantly, perhaps, it also includes a discussion of the ClojureScript browser REPL, which you can use for interactive coding in a live browser environment.</p><p id="filepos229793" class="calibre11"><span class="calibre12"><span class="bold">Installing ClojureScript</span></span></p><p class="calibre13">Leiningen works by referencing the ClojureScript JAR file directly from a public Maven repository (via a local cache on your computer, of course). The Maven release, however, does not include some of the command-line tools and tests included in the source release.</p><p class="calibre13">In addition, the source release includes cutting-edge features from the master Git branch, whereas the Maven repository will only contain the latest milestone releases. For most production or educational work, the milestone releases are desirable, but bug fixes are often available much sooner on the master branch. If you’re developing a ClojureScript library or tools for working with ClojureScript, you should consider testing your code on the master branch frequently for advance warning of any incompatibilities, so you can have them sorted out before the next milestone release.</p><p class="calibre13">There are two ways of obtaining the ClojureScript source code: checking out directly from Git, and downloading a zip or tar archive from GitHub.</p><p id="filepos230968" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Checking Out from Source Control</span></span></span></p><p class="calibre13">Start up a command line, and navigate to the directory where you would like to install ClojureScript. Then, just execute the following Git command to clone the repository:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">git clone https://github.com/clojure/clojurescript.git</tt></span></blockquote><p class="calibre14">By default, Git will check out the most recent code from the master branch into a directory called <tt class="calibre16">clojurescript</tt>. If you want to run the bleeding-edge development version of ClojureScript, nothing else is required. However, you might wish to use a tagged milestone release, for greater reliability. (Although broken code is rarely checked in to master, it can happen on occasion).</p><p class="calibre13">To see a list of available tags, just use the <tt class="calibre16">git tag</tt> command. At the time of this writing, the most recent tag is <tt class="calibre16">r1450</tt>. To check out the tagged code, run a Git checkout on the tag. For example:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">git checkout r1450</tt></span></blockquote><p class="calibre14">Your “clojurescript” directory will now contain the r1450 version of ClojureScript.</p><p id="filepos232380" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Downloading a Compressed Archive</span></span></span></p><p class="calibre13">GitHub provides the capability to download the repository as a zip or tar file, which does not require you to install the <tt class="calibre16">git</tt> program itself. The easiest place to do this is from the GitHub <span class="italic">tags</span> view, located <a href="https://github.com/clojure/clojurescript/tags"><span class="calibre3">here</span></a>. This page lists all the tagged versions of ClojureScript; each is a hyperlink to a zip file. Hovering over the link will also reveal a link to a tar archive. Click the most recent tag to download that version. If you wish to download the latest master branch, visit <a href="https://github.com/clojure/clojurescript/downloads"><span class="calibre3">this page</span></a> and click “download as zip” or “download as tar.gz”.</p><p class="calibre13">Extracting the downloaded file will create a directory that contains the entire ClojureScript repository, which is everything you need to get started using ClojureScript. You may wish to rename the directory to something simpler (such as “clojurescript”), instead of the default name, which includes the full repository name and commit hash ID.</p><p class="calibre13">Whether you installed via Git or archive, you should have ended up with a directory somewhere on your system containing the ClojureScript distribution. A common practice is to set up a <tt class="calibre16">CLOJURESCRIPT_HOME</tt> environment variable pointing to this directory, for convenience. The installation directory will be referred to as <tt class="calibre16">CLOJURESCRIPT_HOME</tt> throughout the rest of this chapter.</p><p id="filepos234089" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Installing Dependencies</span></span></span></p><p class="calibre13">Before you can use ClojureScript, you will need to download and install ClojureScript’s dependencies.</p><p class="calibre13">For Unix-based systems (including OS X), ClojureScript provides a script that makes the process easy. Just navigate to the <tt class="calibre16">CLOJURESCRIPT_HOME</tt> directory you just set up, and run the <tt class="calibre16">bootstrap</tt> script:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">./script/bootstrap</tt></span></blockquote><p class="calibre14">This will automatically download and install everything else ClojureScript needs to run.</p><p class="calibre13">Unfortunately there is no automatic bootstrap script for Windows users. Instead, you must install ClojureScript’s dependencies yourself.<sup class="calibre44"><small class="calibre45"><span class="calibre46">[</span><a id="filepos235037"></a><a href="#filepos263865"><span class="calibre46">4</span></a><span class="calibre46">]</span></small></sup></p><p class="calibre13"> These instructions may change over time as features are added to ClojureScript, so rather than committing them to print, you should look them up on the Windows installation wiki page on the <a href="https://github.com/clojure/clojurescript/wiki/Windows-Setup"><span class="calibre3">ClojureScript GitHub site</span></a>.</p><p id="filepos235486" class="calibre11"><span class="calibre12"><span class="bold">The Built-In Tools</span></span></p><p id="filepos235565" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Command-Line Compilation</span></span></span></p><p class="calibre13">ClojureScript includes a command-line tool for compiling <span class="italic">*.cljs</span> files to <span class="italic">*.js</span> files: the <tt class="calibre16">cljsc</tt> or <tt class="calibre16">cljsc.bat</tt> script (depending on platform) located in <tt class="calibre16">ClOJURESCRIPT_HOME/bin</tt>. It is a common practice to add <tt class="calibre16">CLOJURESCRIPT_HOME/bin</tt> to your system’s executable <tt class="calibre16">PATH</tt>, so you can easily run <tt class="calibre16">cljsc</tt> from anywhere.</p><p class="calibre13">The command takes two arguments. The first is the path of either a single <span class="italic">*.cljs</span> file or a directory containing <span class="italic">*.cljs</span> files (in which case they will all be compiled together). The second argument is a string representation of the ClojureScript compiler options map, and should be enclosed in single quotes. Invoking <tt class="calibre16">cljsc</tt> looks something like this:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">cljsc my/src/dir '{:optimizations :advanced, :output-to "out.js"}'</tt></span></blockquote><p class="calibre14">Note that you’ll definitely want to specify an <tt class="calibre16">:output-to</tt> key in the compiler options; if you don’t, the entire compiled output will be dumped to standard out, which in most cases is not what you want (although it can be useful, on occasion, as part of a longer scripted compilation chain).</p><p id="filepos237008" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Clojure REPL</span></span></span></p><p class="calibre13">If you just want to get started with a Clojure REPL, but with all the ClojureScript classes loaded on the classpath and ready to go, you can use the <tt class="calibre16">script/repl</tt> (or <tt class="calibre16">script/repl.bat</tt> for Windows) script in <tt class="calibre16">CLOJURESCRIPT_HOME</tt>. Launching it will start a basic Clojure REPL, but with everything you need to use ClojureScript already loaded into the classpath.</p><p id="filepos237523" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">ClojureScript REPL</span></span></span></p><p class="calibre13">If all you want to do is run ClojureScript itself in a headless (nonbrowser) REPL, the fastest way to get started is to run the <tt class="calibre16">script/repljs</tt> script (<tt class="calibre16">script/repljs.bat</tt> for Windows), which launches straight into a ClojureScript REPL running in the headless Rhino JavaScript interpreter. You won’t have access to any browser-specific features, but will be able to experiment freely with the language itself, as well as its standard libraries.</p><p id="filepos238123" class="calibre11"><span class="calibre12"><span class="bold">The Browser REPL</span></span></p><p class="calibre13">One of the main benefits of using a language from the Lisp family is the dynamic, highly interactive development workflow. However, since ClojureScript does not natively support the <tt class="calibre16">eval</tt> function, it requires the support of a Clojure runtime running the ClojureScript compiler to compile forms for execution in a REPL.</p><p class="calibre13">For local REPLs (such as the Rhino REPL), this is easy: the REPL just runs in the same JVM/Clojure process as the ClojureScript compiler and hands off forms for compilation. To achieve the same effect in the browser, however, requires that there be some sort of communication channel between the browser’s JavaScript runtime environment, and the ClojureScript compiler running in a JVM.</p><p class="calibre13">Therefore, there are two parts to the ClojureScript browser REPL (often abbreviated <span class="italic">bREPL</span>), which operate in a client/server configuration. The bREPL <span class="italic">server</span> runs in the same JVM process as the ClojureScript compiler and exposes a REPL for developer interaction. The bREPL <span class="italic">client</span> runs in ClojureScript in the browser itself, and maintains a long-poll connection to the server so it can receive push messages (<a href="#filepos240009"><span class="calibre3">Figure 9-1</span></a>).</p><p class="calibre13">Whenever you type a form in the bREPL, the server feeds it to the ClojureScript compiler and pushes the emitted JavaScript code to the client. There, it is evaluated in the browser’s JavaScript context, where it may cause side effects that will be visible in the browser window. The return value of the expression is stringified (using the ClojureScript <tt class="calibre16">pr-str</tt> function) and sent back to the bREPL, where it is printed out as the expression’s return value.</p><blockquote id="filepos240009" class="calibre36"></blockquote><blockquote class="calibre37"><img src="images/00002.jpg" class="calibre56"/></blockquote><blockquote class="calibre36"><span class="calibre19"><span class="italic"><span class="calibre18">Figure 9-1. The ClojureScript Browser REPL</span></span></span></blockquote><p id="filepos240373" class="calibre32"><span class="calibre31"><span class="bold"><span class="calibre3">Setting Up the Browser REPL</span></span></span></p><p class="calibre13">Needless to say, this does require a bit of configuration—not only is it necessary to start the bREPL server, but you must also initiate the bREPL on the client side to establish the client/server connection.</p><p class="calibre13">Unfortunately, there is also one more requirement to use the browser REPL. Due to the restrictions browsers enforce to prevent cross-site scripting attacks, and the fact that the bREPL runs on <tt class="calibre16">localhost</tt>, the client page must <span class="italic">also</span> run on <tt class="calibre16">localhost</tt>. This means that, unlike the examples presented earlier in this book, you can’t just create a static HTML page referencing your ClojureScript code and load it from a <tt class="calibre16">file:</tt> URL. Instead, you must serve the client page from an actual HTTP server running on <tt class="calibre16">localhost</tt>.</p><p class="calibre13">The most straightforward way to do this is to set up your Leiningen project to include a Ring application running on an embedded Jetty web server, and use Compojure to configure it to serve HTML files from the <tt class="calibre16">resources/public</tt> directory. Ring is a low-level HTTP web application library with wide adoption in the Clojure community. It is used as the foundation for most Clojure web applications. You can learn about it on its <a href="http://bit.ly/QTxucf"><span class="calibre3">GitHub page</span></a>. Compojure is a popular web routing library for Ring that makes it easy to configure web routes. Its page is <a href="http://bit.ly/PP4gQU"><span class="calibre3">here</span></a>.</p><p class="calibre13">Although any technique for serving resources from a <tt class="calibre16">localhost</tt> address will work, we will use Ring and Compojure since they are relatively easy to set up, and are by far the most popular ways to set up a Clojure web app.</p><p class="calibre13">Once you’re set up to serve resources, all you need to do is start the Ring server at the beginning of your development session, and you can serve up the HTML files as you work on them just as you did when referencing the files statically.</p><p id="filepos242576" class="calibre14"><span class="calibre5"><span class="bold">Serving your HTML via Ring and Compojure</span></span></p><p class="calibre13">Modify your Leiningen project (or create a new one) so the <tt class="calibre16">project.clj</tt> includes Compojure and the Ring-Jetty adapter as dependencies. It should look something like the following:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(defproject brepl-hello "0.1.0-SNAPSHOT"<br class="calibre6"/> :plugins [[lein-cljsbuild "0.2.7"]]<br class="calibre6"/> :dependencies [[org.clojure/clojure "1.4.0"]<br class="calibre6"/>                [org.clojure/clojurescript "0.0-1450"]<br class="calibre6"/>                [compojure "1.1.0"]<br class="calibre6"/>                [ring/ring-jetty-adapter "1.1.1"]]<br class="calibre6"/> :source-paths ["src/clj"]<br class="calibre6"/> :cljsbuild {<br class="calibre6"/>   :builds [{<br class="calibre6"/>       :source-path "src/cljs"<br class="calibre6"/>       :compiler {<br class="calibre6"/>         :output-to "resources/public/brepl-hello.js"<br class="calibre6"/>         :optimizations :whitespace<br class="calibre6"/>         :pretty-print true}}]})</tt></span></blockquote><p class="calibre14">Then, at a Clojure REPL, you can start a Ring server configured to serve resources from the <tt class="calibre16">resources/public</tt> directory on port 3000:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(use 'ring.adapter.jetty)<br class="calibre6"/>(use 'compojure.route)<br class="calibre6"/>(run-jetty (resources "/") {:port 3000 :join? false})</tt></span></blockquote><p class="calibre14">You can verify that the server is working by placing a file (for example, <tt class="calibre16">test.html</tt>) in <tt class="calibre16">resources/public</tt>, then hitting <tt class="calibre16">http://localhost:3000/test.html</tt> in your browser. You should see the contents of <tt class="calibre16">test.html</tt> served correctly.</p><p class="calibre13">If you don’t want to start a Clojure REPL every time you start a server, you can use the <span class="italic">lein-ring</span> Leiningen plug-in, which allows you to add a server configuration directly to your <tt class="calibre16">project.clj</tt>, and start it by running <tt class="calibre16">lein ring server</tt> on the command line. See the <span class="italic">lein-ring</span>
<a href="https://github.com/weavejester/lein-ring/"><span class="calibre3">GitHub page</span></a> for configuration instructions.</p><p id="filepos244894" class="calibre14"><span class="calibre5"><span class="bold">Starting the bREPL server</span></span></p><p class="calibre13">Next, you must start the server component of the bREPL. This can be done from within a Clojure REPL (which you should already have open, after starting the Ring server). <span class="italic">lein-cljsbuild</span> also provides some convenience functions for starting a browser REPL server, which are covered later in <a href="#filepos251212"><span class="calibre3">Additional lein-cljsbuild Features</span></a>.</p><p class="calibre13">From the Clojure REPL, run the following forms to start the browser REPL:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(require 'cljs.repl)<br class="calibre6"/>(require 'cljs.repl.browser)<br class="calibre6"/>(cljs.repl/repl (cljs.repl.browser/repl-env))</tt></span></blockquote><p class="calibre14">This will drop you into a ClojureScript REPL. Note that if you try to evaluate a form at this point, rather than returning a response, the REPL will simply hang. This is because we haven’t yet configured the client side of the bREPL, which is required to actually evaluate the compiled JavaScript.</p><p class="calibre13">By default, the bREPL server runs on port 9000. If for some reason you need to run it on a different port, you can specify a <tt class="calibre16">:port</tt> key and value when creating a bREPL environment with the <tt class="calibre16">repl-env</tt> function:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(cljs.repl/repl (cljs.repl.browser/repl-env :port 8888))</tt></span></blockquote><p id="filepos246489" class="calibre14"><span class="calibre5"><span class="bold">Configuring the bREPL client</span></span></p><p class="calibre13">To connect to the bREPL server from within a browser, you must invoke the <tt class="calibre16">clojure.browser.repl/connect</tt> ClojureScript function in your client-side code. Typically, the easiest way to do this is to add an invocation to it as a top-level form in a ClojureScript namespace.</p><p class="calibre13">You can add it to an existing namespace, or create a new one as shown:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(ns brepl-hello<br class="calibre6"/>  (:require [clojure.browser.repl :as repl]))<br class="calibre6"/><br class="calibre6"/>(repl/connect "http://localhost:9000/repl")</tt></span></blockquote><p class="calibre14">If you changed the port on which you’re running the bREPL server, you’ll need to reflect that change in the URL passed to the <tt class="calibre16">connect</tt> function.</p><p class="calibre13">At the command line, compile the file with <tt class="calibre16">lein cljsbuild once</tt>. If your <tt class="calibre16">project.clj</tt> is configured like the example given above, this will emit a <tt class="calibre16">resources/public/brepl-hello.js</tt> file. Include it on an HTML page:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">&lt;!DOCTYPE html&gt;<br class="calibre6"/>&lt;html&gt;<br class="calibre6"/>&lt;head&gt;&lt;title&gt;ClojureScript bREPL Hello World&lt;/title&gt;&lt;/head&gt;<br class="calibre6"/>&lt;body&gt;<br class="calibre6"/>    &lt;script type="text/javascript" src="brepl-hello.js"&gt;&lt;/script&gt;<br class="calibre6"/>&lt;/body&gt;<br class="calibre6"/>&lt;/html&gt;</tt></span></blockquote><p class="calibre14">If your Ring server and bREPL server are running, you can visit <tt class="calibre16">localhost:3000/brepl-hello.html</tt> in your browser, and upon loading, the bREPL client will establish a connection to the bREPL server and you can start evaluating forms. If you had already entered a form prior to starting the bREPL client, the REPL should have come “unstuck” as soon as you started the client and an execution environment became available.</p><p class="calibre13">To see an example of a live update to the HTML page, enter the following form at the browser REPL:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">ClojureScript:cljs.user&gt; (js/alert "Hello from bREPL!")</tt></span></blockquote><p class="calibre14">You should see a JavaScript alert box pop up from the web page. Congratulations! You now have a live REPL running against a real web page.</p><p class="calibre13">If you like, you can start your browser’s debugging console and watch the bREPL send messages back and forth via AJAX requests as you type forms at the REPL.</p><blockquote class="calibre29"></blockquote><blockquote class="calibre30"><span class="calibre19"><span class="bold">STABILITY OF THE BREPL</span></span></blockquote><blockquote class="calibre15"><span class="calibre19">Unfortunately, the browser REPL isn’t as stable as it could be, although it is getting better. If it hangs, it’s easy enough to restart, usually by refreshing the browser, but this can get annoying if you’ve already established state in the browser environment that you’re working with.</span></blockquote><blockquote class="calibre15"><span class="calibre19">A few tips to help you avoid bREPL crashes and lockups:</span></blockquote><div class="calibre26"> </div><ul class="calibre35"><li value="1" class="calibre28"><blockquote class="calibre15"><span class="calibre19">Always start the bREPL server before loading the HTML page containing the bREPL client.</span></blockquote></li><li value="2" class="calibre28"><blockquote class="calibre15"><span class="calibre19">Don’t enter any expressions that return something that’s not easily printable. These include infinite or very long sequences, very large data structures, and native browser objects that don’t have a reasonable string representation.</span></blockquote></li><li value="3" class="calibre28"><blockquote class="calibre15"><span class="calibre19">Don’t enter any expressions that wipe the contents of the page (such as </span><span class="calibre19"><tt class="calibre16">document.write</tt></span><span class="calibre19">). If you erase the page, it will also remove all scripts on the page and the bREPL client will disappear, causing the bREPL to hang.</span></blockquote></li><li value="4" class="calibre28"><blockquote class="calibre15"><span class="calibre19">Try not to enter any expressions that will take longer than a few seconds to process. Some browsers will assume that the script has become unresponsive and will behave erratically, or prompt you to terminate it.</span></blockquote></li></ul><p id="filepos251212" class="calibre21"><span class="calibre12"><span class="bold">Additional lein-cljsbuild Features</span></span></p><p class="calibre13"><span class="italic">lein-cljsbuild</span> provides several features beyond the basic functionality we have covered so far.</p><p id="filepos251441" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Launching a Browser REPL</span></span></span></p><p class="calibre13">As you may have noticed while working through the browser REPL section above, starting up a Clojure REPL just to start a bREPL server can be annoying, and tedious if you have to do it often.</p><p class="calibre13">To alleviate this problem, <span class="italic">lein-cljsbuild</span> includes the <tt class="calibre16">repl-listen</tt> task, which will start a bREPL server and drop you into a ClojureScript REPL in a single step. Run it using this command:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">lein trampoline cljsbuild repl-listen</tt></span></blockquote><p class="calibre14">(Recall that the <tt class="calibre16">trampoline</tt> task is necessary for Leiningen to receive interactive input.)</p><p class="calibre13">This command will start the bREPL server and a ClojureScript REPL in your current console. Note that you will still need to configure the bREPL client side as discussed above—the REPL started with <tt class="calibre16">repl-listen</tt> will not be functional until you’ve loaded a browser page with the client side code to establish the client-server connection.</p><p id="filepos252677" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Custom bREPL Launch Commands</span></span></span></p><p class="calibre13"><span class="italic">lein-cljsbuild</span> also offers a <tt class="calibre16">repl-launch</tt> command which, in addition to starting the bREPL server, also launches a browser for the bREPL client.</p><p class="calibre13"><tt class="calibre16">repl-launch</tt> does essentially the same thing as <tt class="calibre16">repl-listen</tt>, but also executes shell commands defined in the <tt class="calibre16">:repl-launch-commands</tt> key in the <tt class="calibre16">:cljsbuild</tt> configuration of <tt class="calibre16">project.clj</tt>. By specifying a vector representing a shell command that launches a browser, you can launch both the bREPL client and server with the same command. For example:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(defproject my-project "1.0.0-SNAPSHOT"<br class="calibre6"/>   ;; other leiningen configuration items<br class="calibre6"/>   :cljsbuild {<br class="calibre6"/>     ;; other configuration items &amp; build configurations<br class="calibre6"/>     :repl-launch-commands {"firefox" ["firefox" "page.html"]}})</tt></span></blockquote><p class="calibre14">If you have the “firefox” binary on your system’s PATH, you can run <tt class="calibre16">lein trampoline cljsbuild repl-launch firefox</tt>. The final parameter, <tt class="calibre16">firefox</tt>, will be looked up in the <tt class="calibre16">:repl-launch-commands</tt> map, and the associated command (<tt class="calibre16">firefox page.html</tt>) will be executed, launching Firefox and opening the specified page.</p><p class="calibre13">Of course, you are still responsible for ensuring that the page you specified (in this case, <tt class="calibre16">page.html</tt>) calls the <tt class="calibre16">clojure.browser.repl/connect</tt> function to launch the client side of the bREPL.</p><p id="filepos254431" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Hooking Into Default Leiningen Tasks</span></span></span></p><p class="calibre13">Normally, ClojureScript-specific build actions are triggered using the <tt class="calibre16">lein cljsbuild</tt> command, which pertains exclusively to ClojureScript code. However, for some projects, it’s desirable to set up Leiningen to build everything at once.</p><p class="calibre13">To do this, it is necessary to add <span class="italic">hooks</span> to Leiningen’s default tasks so that when you run <tt class="calibre16">lein compile</tt>, <tt class="calibre16">lein clean</tt>, or <tt class="calibre16">lein jar</tt>, the appropriate <span class="italic">lein-cljsbuild</span> plug-in task is also executed. <span class="italic">lein-cljsbuild</span> already includes these hooks; all you have to do is add them to the <tt class="calibre16">:hooks</tt> configuration key at the root of your <tt class="calibre16">project.clj</tt>:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(defproject my-project "1.0.0-SNAPSHOT"<br class="calibre6"/>   ;; ...<br class="calibre6"/>   :hooks [leiningen.cljsbuild])</tt></span></blockquote><p class="calibre14">Once you’ve added this line, invoking <tt class="calibre16">lein compile</tt> will kick off a ClojureScript compilation (the same as <tt class="calibre16">lein cljsbuild once</tt>). <tt class="calibre16">lein clean</tt> will also run <tt class="calibre16">lein cljsbuild clean</tt>, and <tt class="calibre16">lein jar</tt> will add ClojureScript source to the JAR if it’s configured for that cljs build (see <a href="#filepos259227"><span class="calibre3">Including ClojureScript in JAR Files</span></a>).</p><p id="filepos255936" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Testing ClojureScript Code</span></span></span></p><p class="calibre13">There are a variety of ways to test ClojureScript code. <span class="italic">lein-cljsbuild</span> does not attempt to dictate a particular testing methodology or tools, but instead provides a generic hook for executing tests. By specifying a map of test configurations in a <tt class="calibre16">:test-commands</tt> key in the <tt class="calibre16">:cljsbuild</tt> configuration map, you can set up <span class="italic">lein-cljsbuild</span> to invoke any command-line sequence after compilation by invoking <tt class="calibre16">lein cljsbuild test</tt>.</p><p class="calibre13">For example, if you have ClojureScript tests that compile to a file called <tt class="calibre16">resources/test/test.js</tt>, you might wish to run the script in a headless browser such as <a href="http://phantomjs.org/"><span class="calibre3">PhantomJS</span></a>. At the command line, you would run them by executing <tt class="calibre16">phantomjs resources/test/test.js</tt>. To set up the same script to run within Leiningen, do something like this:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(defproject my-project "1.0.0-SNAPSHOT"<br class="calibre6"/>   ;; other leiningen configuration items<br class="calibre6"/>   :cljsbuild {<br class="calibre6"/>     ;; other configuration items &amp; build configurations<br class="calibre6"/>     :test-commands {"unit" ["phantomjs" "resources/test/test.js"]}})</tt></span></blockquote><p class="calibre14">This will create a test configuration (named “unit”), so that when you run <tt class="calibre16">lein cljsbuild test</tt> it will first compile the ClojureScript, then execute the <tt class="calibre16">phantomjs resources/test/test.js</tt> shell command in a single step. Because the test command is just a system shell invocation, you can replace it with any command you like, making it flexible enough to use any testing runtime or framework you might choose. The downside is, of course, that you’ll have to set up the test execution code yourself. But as long as you can run the tests from the command line, you can add them to the Leiningen test cycle using this technique.</p><p class="calibre13">The <tt class="calibre16">:test-commands</tt> configuration also supports capturing the <tt class="calibre16">stdout</tt> and <tt class="calibre16">stderr</tt> output streams from commands that it runs. To do this, add <tt class="calibre16">:stdout</tt> or <tt class="calibre16">:stderr</tt> key/value pairs after the command sequence:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(defproject my-project "1.0.0-SNAPSHOT"<br class="calibre6"/>   ;; ... other leiningen configuration items ...<br class="calibre6"/>   :cljsbuild {<br class="calibre6"/>     ;; ... other configuration items &amp; build configurations ...<br class="calibre6"/>     :test-commands {"unit" ["phantomjs" "test.js" :stdout "test.out.txt"<br class="calibre6"/>                                                   :stderr "test.err.txt"]}})</tt></span></blockquote><p class="calibre14">With this configuration, output from the <tt class="calibre16">phantomjs</tt> process will be redirected to the <tt class="calibre16">test.out.txt</tt> and <tt class="calibre16">test.out.err</tt> files.</p><p class="calibre13">Note that you can also capture the output of <tt class="calibre16">:repl-launch-commands</tt> in the same way.</p><p id="filepos259227" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Including ClojureScript in JAR Files</span></span></span></p><p class="calibre13">If you’re creating a ClojureScript library that you’d like to be available for other projects, it’s a good idea to bundle it as a JAR file so that your clients can just add the JAR to their ClojureScript compiler classpath and start referencing your namespaces in their ClojureScript code.</p><p class="calibre13">By default, however, Leiningen does <span class="italic">not</span> include <span class="italic">*.cljs</span> files when creating a JAR file. To tell it to do so, you must first enable the <span class="italic">lein-cljsbuild</span> Leiningen hooks as described above.</p><p class="calibre13">Then, you must add the <tt class="calibre16">:jar true</tt> key to the ClojureScript build configurations you want included in the JAR file. When added, your <tt class="calibre16">project.clj</tt> looks something like this:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(defproject my-project "1.0.0-SNAPSHOT"<br class="calibre6"/>   ;; ... other leiningen configuration items ...<br class="calibre6"/>   :hooks [leiningen.cljsbuild]<br class="calibre6"/>   :cljsbuild {<br class="calibre6"/>     ;; ... other cljsbuild configuration items ...<br class="calibre6"/>     :builds [{:source-path "src/cljs"<br class="calibre6"/>               ;; ... other build options ...<br class="calibre6"/>               :jar true}]})</tt></span></blockquote><p class="calibre14">Once you’ve added these configuration items, you can build a JAR like you normally would in Leiningen, with <tt class="calibre16">lein jar</tt>. The emitted JAR file will contain all the <span class="italic">*.cljs</span> files specified in the build configuration, making them available on the classpath for any program that includes the JAR.</p><p id="filepos261019" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">Compiling the Same Code as Clojure and ClojureScript</span></span></span></p><p class="calibre13">If you have code that is both valid Clojure and ClojureScript, <span class="italic">lein-cljsbuild</span> supports cross-compiling the code using its <span class="italic">crossovers</span> feature. Obviously, such code must consist only of the subset of Clojure that is also valid ClojureScript, and vice versa. It must not use any of the interop forms from either language, nor can it rely on any platform-specific features.</p><p class="calibre13">To use crossovers, specify a <tt class="calibre16">:crossovers</tt> key in the <tt class="calibre16">:cljsbuild</tt> configuration map. The value should be a vector of Clojure namespaces, which will then also be compiled as ClojureScript.</p><p class="calibre13">So, for example, if you have a namespace called <tt class="calibre16">myapp.shared</tt> that you want to be available as both Clojure and ClojureScript code, your <tt class="calibre16">project.clj</tt> might look something like this:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(defproject myapp "1.0.0-SNAPSHOT"<br class="calibre6"/>   ;; ... other leiningen configuration items ...<br class="calibre6"/>   :cljsbuild {<br class="calibre6"/>     ;; ... other cljsbuild configuration items &amp; builds ...<br class="calibre6"/>     :crossovers [myapp.shared]})</tt></span></blockquote><p class="calibre14">Under the hood, <span class="italic">lein-cljsbuild</span> implements this feature by literally copying the <span class="italic">*.clj</span> files containing the specified namespaces, giving them a <span class="italic">*.cljs</span> extension, and placing them in a interim directory, which is added to the ClojureScript source path. By default, it is <span class="italic">.crossover-cljs</span>. If you wish to use a different directory for this purpose, you may do so by specifying the desired path as the value of a <tt class="calibre16">:crossover-path</tt> key in the <tt class="calibre16">:cljsbuild</tt> configuration map. If you set <tt class="calibre16">:crossover-jar</tt> to true, the copied crossover <span class="italic">*.cljs</span> files will also be added when building JAR files (if <span class="italic">lein-cljsbuild</span> is configured to do so, as described in the previous section).</p><p class="calibre13">There is one additional caveat when using crossovers: code that contains macros. Because ClojureScript macros are actually written in Clojure, it isn’t possible to simply copy Clojure files that contain macros to ClojureScript, and thus they won’t work as crossover code as outlined above. <span class="italic">lein-cljsbuild</span> does provide some (arcane) tools for resolving this situation. Refer to <span class="italic">lein-cljsbuild</span>’s documentation on the feature <a href="https://github.com/emezeske/lein-cljsbuild/blob/master/doc/CROSSOVERS.md"><span class="calibre3">here</span></a>.</p><br class="calibre6"/><hr class="calibre49"/><p class="calibre50"><sup class="calibre44"><small class="calibre45"><span class="calibre46">[</span><a id="filepos263865"></a><a href="#filepos235037"><span class="calibre46">4</span></a><span class="calibre46">] </span></small></sup><span class="calibre19">At the time of this writing, the command-line ClojureScript tools have not been tested on the Cygwin Unix environment for Windows. We recommend either running a Linux virtual machine or following the Windows installation instructions.</span></p><div class="mbppagebreak"></div><p id="filepos264235" class="calibre11"><span class="calibre2"><span class="bold">Chapter 10. Integration with Clojure</span></span></p><p class="calibre25">ClojureScript, as we have seen, is targeted primarily at web browsers. Although this makes it possible to design complete applications that run in a browser, it is even more powerful when combined with a web server running Clojure on the JVM. Clojure’s literal data structures provide a rich data format for communication between a client and server, and with a little care you can even share code between the two languages.</p><p id="filepos264792" class="calibre11"><span class="calibre12"><span class="bold">AJAX</span></span></p><p class="calibre13">In spite of its original definition, Asynchronous JavaScript and XML, <span class="italic">AJAX</span> has become a catch-all term for rich client applications running in web browsers, communicating with a web server. The Google Closure Library provides the <tt class="calibre16">goog.net.XhrIo</tt> class to support asynchronous HTTP requests to a server across many different browser implementations.</p><p class="calibre13">Here is a simple example function that performs an HTTP POST request to a server:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(ns example<br class="calibre6"/>  (:require [goog.net.XhrIo :as xhr]))<br class="calibre6"/><br class="calibre6"/>(defn receiver [event]<br class="calibre6"/>  (let [response (.-target event)]<br class="calibre6"/>    (.write js/document (.getResponseText response))))<br class="calibre6"/><br class="calibre6"/>(defn post [url content]<br class="calibre6"/>  (xhr/send url receiver "POST" content))</tt></span></blockquote><p class="calibre14">The <tt class="calibre16">goog.net.XhrIo/send</tt> function takes a URL, a callback function, a method name, and an optional request body. When the server responds to the request, it will invoke the callback function on an object from which you can retrieve the status code, headers, and response body sent by the server.</p><p class="calibre13">The <tt class="calibre16">goog.net.XhrIo</tt> class and the associated <tt class="calibre16">goog.net.XhrManager</tt> class provide many more options for controlling HTTP server requests. Covering all of them is outside the scope of this book, but for more information you can consult the Google Closure Library<sup class="calibre44"><small class="calibre45"><span class="calibre46">[</span><a id="filepos266476"></a><a href="#filepos291613"><span class="calibre46">5</span></a><span class="calibre46">]</span></small></sup> or Chapter 7 of Michael Bolin’s <span class="italic">Closure: The Definitive Guide</span> (O’Reilly). In addition, some ClojureScript libraries are growing to support easier access to the HTTP features in the Google Closure Library; see <a href="#filepos292999"><span class="calibre3">Appendix A</span></a> for details.</p><p id="filepos266873" class="calibre11"><span class="calibre12"><span class="bold">The Reader and Printer</span></span></p><p class="calibre13">Although they started with XML, many web browser applications now use <span class="italic">JSON</span> (JavaScript Object Notation) for communication between client and server. You can use JSON in ClojureScript as well: the Google Closure Library class <tt class="calibre16">goog.json.Serializer</tt> can serialize data to and from JSON, and there are several JSON libraries for Clojure.</p><p class="calibre13">However, JSON is a feeble data format when compared with Clojure’s own literal syntax. It cannot distinguish between strings and keywords, and its maps (objects) only support strings as keys. Almost any application using JSON as a data format will eventually need to translate between native application data structures and their “lossy” JSON representations.</p><p class="calibre13">Clojure’s data structures, on the other hand, are rich enough to represent almost any application domain, and they have a string representation that is just as compact as JSON. Furthermore, Clojure’s literal data syntax is extensible, which we will explore later in this chapter.</p><p class="calibre13"><a href="#filepos268204"><span class="calibre3">Table 10-1</span></a> highlights the differences between JSON and Clojure data.</p><p id="filepos268204" class="calibre47"></p><p class="calibre7"><span class="italic">Table 10-1. JSON and Clojure data differences</span></p><table border="1" valign="top" class="calibre40"><tr border="1" valign="top" class="calibre23"><th valign="top" class="calibre41"><span class="calibre10"><span class="bold"><span class="calibre18"> Feature </span></span></span></th><th valign="top" class="calibre41"><span class="calibre10"><span class="bold"><span class="calibre18"> JSON </span></span></span></th><th valign="top" class="calibre41"><span class="calibre10"><span class="bold"><span class="calibre18"> Clojure </span></span></span></th></tr><tr border="1" valign="top" class="calibre23"><td border="1" valign="top" class="calibre24"><span class="calibre10"> Numbers </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> Yes </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> Yes </span></td></tr><tr border="1" valign="top" class="calibre48"><td border="1" valign="top" class="calibre24"><span class="calibre10"> Strings </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> Yes </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> Yes </span></td></tr><tr border="1" valign="top" class="calibre23"><td border="1" valign="top" class="calibre24"><span class="calibre10"> Symbols </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> - </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> Yes </span></td></tr><tr border="1" valign="top" class="calibre48"><td border="1" valign="top" class="calibre24"><span class="calibre10"> Keywords </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> - </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> Yes </span></td></tr><tr border="1" valign="top" class="calibre23"><td border="1" valign="top" class="calibre24"><span class="calibre10"> Lists (Arrays) </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> Yes </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> Yes </span></td></tr><tr border="1" valign="top" class="calibre48"><td border="1" valign="top" class="calibre24"><span class="calibre10"> Maps with string keys </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> Yes </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> Yes </span></td></tr><tr border="1" valign="top" class="calibre23"><td border="1" valign="top" class="calibre24"><span class="calibre10"> Maps with arbitrary keys </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> - </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> Yes </span></td></tr><tr border="1" valign="top" class="calibre48"><td border="1" valign="top" class="calibre24"><span class="calibre10"> Sets </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> - </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> Yes </span></td></tr><tr border="1" valign="top" class="calibre23"><td border="1" valign="top" class="calibre24"><span class="calibre10"> Metadata </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> - </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> Yes </span></td></tr><tr border="1" valign="top" class="calibre48"><td border="1" valign="top" class="calibre24"><span class="calibre10"> Extensibility </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> - </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> Yes </span></td></tr></table><p class="calibre14">Like any LISP-like language, both Clojure and ClojureScript have a <span class="italic">reader</span>, a function that transforms a stream of characters into data structures such as lists, maps, and sets. The ClojureScript compiler uses the same reader as the Clojure language runtime. The Clojure reader (invoked through the functions <tt class="calibre16">read</tt> and <tt class="calibre16">read-string</tt>) is implemented in the Java language, so it is not available to ClojureScript programs. But ClojureScript has its own reader, implemented in ClojureScript, which is designed to be fully compatible with the Clojure reader.</p><p class="calibre13">The ClojureScript reader is invoked through the function <tt class="calibre16">cljs.reader/read-string</tt>. As the name suggests, it takes a string argument and returns a single data structure read from that string:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(ns example (:require [cljs.reader :as reader]))<br class="calibre6"/><br class="calibre6"/>(reader/read-string "{:a 1 :b 2}")<br class="calibre6"/>;;=&gt; {:a 1, :b 2}</tt></span></blockquote><p class="calibre14">The opposite of <tt class="calibre16">read-string</tt> is the built-in ClojureScript function <tt class="calibre16">pr-str</tt>, or “print to string,” which takes a data structure and returns its string representation:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(pr-str {:language "ClojureScript"})<br class="calibre6"/>;;=&gt; "{:language \"ClojureScript\"}"</tt></span></blockquote><p class="calibre14">Notice that <tt class="calibre16">pr-str</tt> automatically escapes special characters and places strings in double quotes, which the <tt class="calibre16">print</tt> and <tt class="calibre16">println</tt> functions do not:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(println {:language "ClojureScript"})<br class="calibre6"/>;; {:language ClojureScript}<br class="calibre6"/>;;=&gt; nil</tt></span></blockquote><p class="calibre14">In general, the <tt class="calibre16">print</tt>, <tt class="calibre16">println</tt>, and <tt class="calibre16">str</tt> functions are used for human-readable output, whereas the <tt class="calibre16">pr</tt>, <tt class="calibre16">prn</tt>, and <tt class="calibre16">pr-str</tt> functions are used for machine-readable output.</p><p id="filepos274040" class="calibre11"><span class="calibre12"><span class="bold">Example Client-Server Application</span></span></p><p class="calibre13">Building a complete client-server application in Clojure and ClojureScript requires some knowledge of Clojure web libraries, which are outside the scope of this book. But the following example should give you an idea of how easy it is to communicate between the two languages.</p><p class="calibre13">This simple application will allow you to type Clojure expressions into a web form, evaluate them on the server, and display the result back in the web page.</p><p class="calibre13">Create a new project directory with the following <tt class="calibre16">project.clj</tt> file:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(defproject client-server "0.1.0-SNAPSHOT"<br class="calibre6"/> :plugins [[lein-cljsbuild "0.2.7"]]<br class="calibre6"/> :dependencies [[org.clojure/clojure "1.4.0"]<br class="calibre6"/>                [org.clojure/clojurescript "0.0-1450"]<br class="calibre6"/>                [domina "1.0.0"]<br class="calibre6"/>                [compojure "1.1.0"]<br class="calibre6"/>                [ring/ring-jetty-adapter "1.1.1"]]<br class="calibre6"/> :source-paths ["src/clj"]<br class="calibre6"/> :main client-server.server<br class="calibre6"/> :cljsbuild {<br class="calibre6"/>   :builds [{<br class="calibre6"/>       :source-path "src/cljs"<br class="calibre6"/>       :compiler {<br class="calibre6"/>         :output-to "resources/public/client.js"<br class="calibre6"/>         :optimizations :whitespace<br class="calibre6"/>         :pretty-print true}}]})</tt></span></blockquote><p class="calibre14">Our application will use the Clojure libraries Ring<sup class="calibre44"><small class="calibre45"><span class="calibre46">[</span><a id="filepos275769"></a><a href="#filepos291880"><span class="calibre46">6</span></a><span class="calibre46">]</span></small></sup> and Compojure<sup class="calibre44"><small class="calibre45"><span class="calibre46">[</span><a id="filepos275911"></a><a href="#filepos292147"><span class="calibre46">7</span></a><span class="calibre46">]</span></small></sup> for the server side of the application, and the ClojureScript library Domina<sup class="calibre44"><small class="calibre45"><span class="calibre46">[</span><a id="filepos276116"></a><a href="#filepos292414"><span class="calibre46">8</span></a><span class="calibre46">]</span></small></sup> for the client. Here is the server implementation, in the file <tt class="calibre16">src/clj/client_server/server.clj</tt>:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(ns client-server.server<br class="calibre6"/>  (:require [compojure.route :as route]<br class="calibre6"/>            [compojure.core :as compojure]<br class="calibre6"/>            [ring.util.response :as response]<br class="calibre6"/>            [ring.adapter.jetty :as jetty]))<br class="calibre6"/><br class="calibre6"/>(defn eval-clojure [request]<br class="calibre6"/>  (try<br class="calibre6"/>    (let [expr (read-string (slurp (:body request)))]<br class="calibre6"/>      (pr-str (eval expr)))<br class="calibre6"/>    (catch Throwable t<br class="calibre6"/>      (str "ERROR: " t))))<br class="calibre6"/><br class="calibre6"/>(compojure/defroutes app<br class="calibre6"/>  (compojure/POST "/eval" request (eval-clojure request))<br class="calibre6"/>  (compojure/GET "/" request<br class="calibre6"/>    (response/resource-response "public/index.html"))<br class="calibre6"/>  (route/resources "/"))<br class="calibre6"/><br class="calibre6"/>(defn -main []<br class="calibre6"/>  (prn "View the example at http://localhost:4000/")<br class="calibre6"/>  (jetty/run-jetty app {:join? true :port 4000}))</tt></span></blockquote><p class="calibre14">Next, the client side, at <tt class="calibre16">src/cljs/client_server/client.cljs</tt>:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(ns client-server.client<br class="calibre6"/>  (:require [goog.net.XhrIo :as xhr]<br class="calibre6"/>            [domina :as d]<br class="calibre6"/>            [domina.events :as events]))<br class="calibre6"/><br class="calibre6"/>(def result-id "eval-result")<br class="calibre6"/>(def expr-id "eval-expr")<br class="calibre6"/>(def button-id "eval-button")<br class="calibre6"/>(def url "/eval")<br class="calibre6"/><br class="calibre6"/>(defn receive-result [event]<br class="calibre6"/>  (d/set-text! (d/by-id result-id)<br class="calibre6"/>               (.getResponseText (.-target event))))<br class="calibre6"/><br class="calibre6"/>(defn post-for-eval [expr-str]<br class="calibre6"/>  (xhr/send url receive-result "POST" expr-str))<br class="calibre6"/><br class="calibre6"/>(defn get-expr []<br class="calibre6"/>  (.-value (d/by-id expr-id)))<br class="calibre6"/><br class="calibre6"/>(defn ^:export main []<br class="calibre6"/>  (events/listen! (d/by-id button-id)<br class="calibre6"/>                  :click<br class="calibre6"/>                  (fn [event]<br class="calibre6"/>                    (post-for-eval (get-expr))<br class="calibre6"/>                    (events/stop-propagation event)<br class="calibre6"/>                    (events/prevent-default event))))</tt></span></blockquote><p class="calibre14">Finally, we need an HTML page to contain the application:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">&lt;html&gt;<br class="calibre6"/>  &lt;head&gt;<br class="calibre6"/>    &lt;title&gt;ClojureScript Client-Server Example&lt;/title&gt;<br class="calibre6"/>  &lt;/head&gt;<br class="calibre6"/>  &lt;body&gt;<br class="calibre6"/>    &lt;h1&gt;ClojureScript Client-Server Example&lt;/h1&gt;<br class="calibre6"/>    &lt;form id="eval-form"&gt;<br class="calibre6"/>      &lt;p&gt;&lt;label for="eval-expr"&gt;<br class="calibre6"/>          Enter a Clojure expression to evaluate on the server:<br class="calibre6"/>      &lt;/label&gt;&lt;/p&gt;<br class="calibre6"/>      &lt;p&gt;&lt;input id="eval-expr" name="eval-expr" type="text" size="70" /&gt;&lt;/p&gt;<br class="calibre6"/>      &lt;p&gt;&lt;input id="eval-button" type="button" value="Eval" /&gt;&lt;/p&gt;<br class="calibre6"/>    &lt;/form&gt;<br class="calibre6"/>    &lt;p&gt;The result:&lt;/p&gt;<br class="calibre6"/>    &lt;pre id="eval-result"&gt;<br class="calibre6"/>    &lt;/pre&gt;<br class="calibre6"/>    &lt;script src="/client.js" language="javascript"&gt;&lt;/script&gt;<br class="calibre6"/>    &lt;script type="text/javascript" language="javascript"&gt;<br class="calibre6"/>        client_server.client.main()<br class="calibre6"/>    &lt;/script&gt;<br class="calibre6"/>  &lt;/body&gt;<br class="calibre6"/>&lt;/html&gt;</tt></span></blockquote><p class="calibre14">This example is slightly different from most of the HTML in this book: the <tt class="calibre16">&lt;script&gt;</tt> tags are at the <span class="italic">bottom</span> of the file rather than in the <tt class="calibre16">&lt;head&gt;</tt>. This is necessary because the <tt class="calibre16">main</tt> function we defined in ClojureScript depends on the DOM elements for the form already being available. If the <tt class="calibre16">script</tt> tags were at the top of the file, there would be no reported errors but the event handler would never get attached to the Eval button and the application wouldn’t work.</p><p class="calibre13">The Google Closure Library does not have an “on DOM ready” event as is commonly found in other JavaScript libraries. This was a deliberate choice for performance reasons: web browsers load JavaScript synchronously, blocking other rendering tasks. If you have a large <tt class="calibre16">&lt;script&gt;</tt> at the top of your HTML file, the browser will not render anything until that JavaScript has been downloaded, parsed, and evaluated. The Google Closure development team actually advocates placing <tt class="calibre16">&lt;script&gt;</tt> tags inline with HTML, just after the elements they depend on.<sup class="calibre44"><small class="calibre45"><span class="calibre46">[</span><a id="filepos281307"></a><a href="#filepos292681"><span class="calibre46">9</span></a><span class="calibre46">]</span></small></sup> This approach yields maximum responsiveness but is complicated to implement. Placing <tt class="calibre16">&lt;script&gt;</tt> tags at the end of the document is an easier alternative that works consistently and is fast enough for most applications.</p><p class="calibre13">Once you have created the files for this application, you can compile it with <tt class="calibre16">lein cljsbuild once</tt> and run it with <tt class="calibre16">lein run</tt>. Visit <tt class="calibre16">http://localhost:4000/</tt> in your web browser and you should see an application page like <a href="#filepos281980"><span class="calibre3">Figure 10-1</span></a>.</p><blockquote id="filepos281980" class="calibre36"></blockquote><blockquote class="calibre37"><img src="images/00008.jpg" class="calibre57"/></blockquote><blockquote class="calibre36"><span class="calibre19"><span class="italic"><span class="calibre18">Figure 10-1. Screen shot of the demo application for this chapter</span></span></span></blockquote><p class="calibre39">You can type an expression into the text box and click the Eval button to evaluate it. The result will appear below the form. Remember these expressions are being evaluated on the server, so they are in Clojure, not ClojureScript. You can see that by evaluating expressions that are only valid on the JVM, such as a BigInteger calculation:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">(.pow (BigInteger. "2") 128)</tt></span></blockquote><p class="calibre14">Obviously this is a naïve implementation, and completely insecure. But it presents an idea of the possibilities of communicating between a client and server written in the same language, using the native data structures of that language as the data format.</p><p class="calibre13">You can even send ClojureScript expressions to the server, compile them with the ClojureScript compiler, and return JavaScript source code back to the browser for evaluation. ClojureScript’s browser-attached REPL uses this technique, as do some experimental hybrid development environments.</p><blockquote class="calibre17"><span class="calibre10"><span class="bold"><span class="calibre18">NOTE</span></span></span></blockquote><blockquote class="calibre15"><span class="calibre19"><span class="italic">Session</span></span><span class="calibre19"> is an experimental browser-based REPL by Kovas Boguta; </span><a href="http://bit.ly/RUcLZ7"><span class="calibre19"><span class="calibre3">source code</span></span></a><span class="calibre19"> and a </span><a href="http://bit.ly/W1in7n"><span class="calibre19"><span class="calibre3">demo video</span></span></a><span class="calibre19"> are available. </span><span class="calibre19"><span class="italic">Himera</span></span><span class="calibre19">, by Michael Fogus, presents the ClojureScript compiler as a web service; </span><a href="http://bit.ly/SVk1jP"><span class="calibre19"><span class="calibre3">source code</span></span></a><span class="calibre19"> and a </span><a href="http://bit.ly/RiBTG9"><span class="calibre19"><span class="calibre3">demo application</span></span></a><span class="calibre19"> are available.</span></blockquote><p id="filepos284441" class="calibre21"><span class="calibre12"><span class="bold">Extending the Reader</span></span></p><p class="calibre13">Clojure 1.4.0 added extensibility to the reader in the form of <span class="italic">tagged literals</span>. A tagged literal is written as a hash (#) sign, followed by a symbol, followed by any other Clojure data structure. When the reader encounters a tagged literal, it looks up the tag in a table to find its associated reader function, then invokes that function to the following data structure as an argument. User code can define new tags and override the behavior of existing tags.</p><p class="calibre13">Clojure has a few built-in reader literals already, with more likely to come. For example, the <tt class="calibre16">#inst</tt> tag specifies an instant in time as a string in <a href="http://bit.ly/W1ib87"><span class="calibre3">RFC 3339 format</span></a>, like this:</p><p class="calibre33"></p><blockquote class="calibre34"><span class="calibre19"><tt class="calibre16">#inst "2012-07-19T18:46:35.886-00:00"</tt></span></blockquote><p class="calibre14">The key feature of tagged literals is that they specify a precise <span class="italic">literal</span> representation but allow for different in-memory representations. The string after <tt class="calibre16">#inst</tt> must conform to RFC 3339, but Clojure on the JVM can parse it into one of several classes, such as <tt class="calibre16">java.util.Date</tt> or <tt class="calibre16">java.util.Calendar</tt>. The ClojureScript reader will parse the same instant literal into a JavaScript <tt class="calibre16">Date</tt>. When constructing a client-server application using both Clojure and ClojureScript, you no longer need to worry about converting dates to and from strings: you can print and read dates like any other native Clojure data structure.</p><p id="filepos286143" class="calibre25"><span class="calibre31"><span class="bold"><span class="calibre3">User-Defined Tagged Literals</span></span></span></p><p class="calibre13">You can define your own reader literals as well. User-defined tags must be namespace-qualified symbols; all non-qualified symbols are reserved for future Clojure language extensions.</p><p class="calibre13">In Clojure on the JVM, the special file <tt class="calibre16">data_readers.clj</tt> contains a map from tag symbols to the fully-qualified names of functions that read them. You can also locally override the tagged literal functions by rebinding <tt class="calibre16">*data-readers*</tt>. In ClojureScript, you can add tagged literal functions with the <tt class="calibre16">cljs.reader/register-tag-parser!</tt> function, which takes a tag symbol and a function.</p><p class="calibre13">Keep in mind that tagged literal readers do <span class="italic">not</span> have access to the raw character stream. The Clojure(Script) reader will read in the characters that follow the tag, interpret them as a normal Clojure data structure, then invoke the tagged literal function <span class="italic">on the data structure</span>. The function should return a value, which <span class="italic">replaces</span> the tagged data structure in the final result.</p><p class="calibre13">Tagged literals are still a new feature in the Clojure language ecosystem, and support is evolving. Right now there is no well-defined API for printing tagged literals (in Clojure on the JVM, you can extend <tt class="calibre16">print-method</tt> to new types).</p><p id="filepos287620" class="calibre11"><span class="calibre12"><span class="bold">Sharing Code</span></span></p><p class="calibre13">As we have mentioned several times throughout this book, one of ClojureScript’s strengths is that it is the same language as Clojure. As a result, you can share code between Clojure and ClojureScript. This is particularly powerful for client-server applications on the web. The <span class="italic">same code</span> can run on the client, compiled into JavaScript, as on the server, compiled into JVM bytecode.</p><p class="calibre13">As we have also stated repeatedly, shared code has to conform to a common subset of the features available in both environments. Code that does any of the following will <span class="italic">not</span> be shareable:</p><div class="calibre26"> </div><ul class="calibre35"><li value="1" class="calibre28"><blockquote class="calibre15">Calls methods or classes of the host environment</blockquote></li><li value="2" class="calibre28"><blockquote class="calibre15">Interacts with host-environment resources such as the DOM</blockquote></li><li value="3" class="calibre28"><blockquote class="calibre15">Uses features that are only implemented in one host environment (such as Clojure’s refs and vars, which ClojureScript does not support)</blockquote></li><li value="4" class="calibre28"><blockquote class="calibre15">Depends on behavior peculiar to the host environment (such as JavaScript’s automatic conversion between strings and numbers)</blockquote></li></ul><p class="calibre13">Again, the point of ClojureScript is not to simulate Clojure and the JVM in a web browser. Clojure and ClojureScript are the same language, ported to different platforms. Clojure has been ported to other platforms, such as the .NET Common Language Runtime. Intrepid developers have even started modifying the ClojureScript compiler to emit code for other target languages including Scheme, Lua, and Objective C.</p><p class="calibre13">Techniques for sharing code between Clojure and ClojureScript are still evolving. In the simplest case, one can simply copy or symlink code in two directories. The <span class="italic">lein-cljsbuild</span> plug-in has a feature called <span class="italic">crossovers</span> to facilitate cross-language copying, as described in <a href="#filepos228815"><span class="calibre3">Chapter 9</span></a>. If you want more precise control over how your code is compiled, you can invoke the ClojureScript compiler directly from Clojure. Future versions of Clojure and ClojureScript will likely include some kind of conditional evaluation or “feature expressions,” making it possible to maintain a single source file that targets multiple host environments.</p><p class="calibre13">In any case, the possibilities of having a unified language across servers and web browsers are exciting. Consider some examples:</p><div class="calibre26"> </div><ul class="calibre35"><li value="1" class="calibre28"><blockquote class="calibre15">The classic Model-View-Controller pattern, in which the Model can be mirrored on both client and server</blockquote></li><li value="2" class="calibre28"><blockquote class="calibre15">Unit-testing client and server code in the same process</blockquote></li><li value="3" class="calibre28"><blockquote class="calibre15">Debugging client code before running it in a browser</blockquote></li></ul><p id="filepos291011" class="calibre11"><span class="calibre12"><span class="bold">Summary</span></span></p><p class="calibre13">Being able to work in the same language and data model in both web browsers and web servers is the most compelling feature of ClojureScript. With a little care, most algorithmic or data-centric code can be made to work identically in Clojure and ClojureScript. As both languages continue to develop, they will converge towards a common core, making it even easier to write code that targets both environments.</p><br class="calibre6"/><hr class="calibre49"/><p class="calibre50"><sup class="calibre44"><small class="calibre45"><span class="calibre46">[</span><a id="filepos291613"></a><a href="#filepos266476"><span class="calibre46">5</span></a><span class="calibre46">] </span></small></sup><a href="http://bit.ly/TdqTtU"><span class="calibre19"><span class="calibre3">http://bit.ly/TdqTtU</span></span></a></p><p class="calibre13"><sup class="calibre44"><small class="calibre45"><span class="calibre46">[</span><a id="filepos291880"></a><a href="#filepos275769"><span class="calibre46">6</span></a><span class="calibre46">] </span></small></sup><a href="http://bit.ly/QiaNjY"><span class="calibre19"><span class="calibre3">http://bit.ly/QiaNjY</span></span></a></p><p class="calibre13"><sup class="calibre44"><small class="calibre45"><span class="calibre46">[</span><a id="filepos292147"></a><a href="#filepos275911"><span class="calibre46">7</span></a><span class="calibre46">] </span></small></sup><a href="http://bit.ly/QiaS7h"><span class="calibre19"><span class="calibre3">http://bit.ly/QiaS7h</span></span></a></p><p class="calibre13"><sup class="calibre44"><small class="calibre45"><span class="calibre46">[</span><a id="filepos292414"></a><a href="#filepos276116"><span class="calibre46">8</span></a><span class="calibre46">] </span></small></sup><a href="http://bit.ly/SQL6sZ"><span class="calibre19"><span class="calibre3">http://bit.ly/SQL6sZ</span></span></a></p><p class="calibre13"><sup class="calibre44"><small class="calibre45"><span class="calibre46">[</span><a id="filepos292681"></a><a href="#filepos281307"><span class="calibre46">9</span></a><span class="calibre46">] </span></small></sup><span class="calibre19">This was discussed in a thread on the Google Closure Library </span><a href="http://bit.ly/SXAKth"><span class="calibre19"><span class="calibre3">mailing list</span></span></a><span class="calibre19">.</span></p><div class="mbppagebreak"></div><p id="filepos292999" class="calibre11"><span class="calibre2"><span class="bold">Appendix A. Libraries</span></span></p><p class="calibre25">Hopefully, this book has helped you to understand the basics of ClojureScript and how it works. But in order to build a real ClojureScript application, you’ll need more than the basics. You’ll need to manipulate the DOM. You’ll need to send and receive AJAX requests and long-poll messages. You’ll need to do drawing and visualizations.</p><p class="calibre13">Any one of these topics can be (and is) the subject of its own book, and unfortunately there isn’t room to cover them all adequately here. However, you already have all the tools you need: with ClojureScript’s capability to interoperate with JavaScript, you can access any JavaScript browser API, and consume any JavaScript library.</p><p class="calibre13">Additionally, despite the relative youth of ClojureScript, there is already a healthy crop of libraries designed not only to be compatible with ClojureScript, but to follow ClojureScript idioms and fit seamlessly into your application. Here, we will briefly introduce several of them to help give you an idea of the landscape.</p><p id="filepos294185" class="calibre11"><span class="calibre12"><span class="bold">ClojureScript’s Standard Library</span></span></p><p class="calibre13">Lots of things you might want to do are actually already included in ClojureScript. There are many library namespaces available besides just <tt class="calibre16">cljs.core</tt>.</p><p class="calibre14">cljs.reader</p><blockquote class="calibre15">We covered the reader in <a href="#filepos264235"><span class="calibre3">Chapter 10</span></a>. Unlike Clojure’s reader, the ClojureScript reader lives in a separate namespace.</blockquote><p class="calibre14">clojure.set</p><blockquote class="calibre15">Contains set manipulation functions such as <tt class="calibre16">union</tt>, <tt class="calibre16">intersection</tt>, <tt class="calibre16">difference</tt>, etc.</blockquote><p class="calibre14">clojure.string</p><blockquote class="calibre15">Contains a variety of useful string manipulation functions, including <tt class="calibre16">split</tt>, <tt class="calibre16">join</tt>, and <tt class="calibre16">replace</tt>.</blockquote><p class="calibre14">clojure.walk</p><blockquote class="calibre15">Contains tools for recursively walking and manipulating nested data structures in a functional style.</blockquote><p class="calibre14">clojure.zip</p><blockquote class="calibre15">Contains an efficient implementation of <span class="italic">zippers</span>, a useful data structure for fully-functional yet performant tree navigation and manipulation.</blockquote><p id="filepos295596" class="calibre11"><span class="calibre12"><span class="bold">Google Closure Library</span></span></p><p class="calibre13">Although the Google Closure library isn’t itself written in ClojureScript, it is still extremely easy to use from ClojureScript. In fact, it’s bundled with the ClojureScript distribution, and ClojureScript’s standard library itself uses it. All you need to use it is to <tt class="calibre16">:require</tt> the namespace you want—it’s already on your project’s compile classpath.</p><p class="calibre13">The library itself is quite large. It contains over 50 namespaces, ranging from basic low-level functionality all the way up to elaborate UI widgets. Documentation can be found <a href="http://closure-library.googlecode.com/svn/docs/index.html"><span class="calibre3">here</span></a>.</p><p class="calibre13">For ClojureScript, some pieces of the library are more useful than others. Components written in a functional style (such as most of <tt class="calibre16">string</tt>, <tt class="calibre16">math</tt>, <tt class="calibre16">dom</tt>, and <tt class="calibre16">crypt</tt>) fit into any ClojureScript application seamlessly.</p><p class="calibre13">Others, like most of the UI code, are written in a very object-oriented style that, while completely usable from ClojureScript, are less convenient. These libraries will require a bit more work to fit into a ClojureScript program cleanly, but can provide powerful capabilities that would be extremely time-consuming to rewrite in pure ClojureScript.</p><p id="filepos297060" class="calibre11"><span class="calibre12"><span class="bold">Domina</span></span></p><p class="calibre13"><a href="https://github.com/levand/domina"><span class="calibre3">Domina</span></a> is a DOM manipulation library for ClojureScript aiming to provide basic DOM manipulation capabilities in a convenient and idiomatic way. It is cross-browser, wrapping the DOM component of the Google Closure library.</p><p class="calibre13">It is loosely inspired by jQuery in that it supports easy querying to retrieve sets of nodes, and its operations usually accept and return node sets. The major difference from JQuery is that the concept of a “NodeSet” (called “DomContent” in Domina) is not a reified object, but a polymorphic abstraction over a variety of native concrete types including HTML NodeLists, individual nodes, arrays of nodes, XPath or CSS selections, etc.</p><p class="calibre13">In theory, this allows it to be more composable, allowing other libraries to supply new operations on DomContent, or create implementations of it against new concrete types.</p><p id="filepos298137" class="calibre11"><span class="calibre12"><span class="bold">Enfocus</span></span></p><p class="calibre13"><a href="http://ckirkendall.github.com/enfocus-site/"><span class="calibre3">Enfocus</span></a> is another excellent DOM manipulation and templating library. It focuses on higher-level manipulations such as transformations, events, and animation effects, and is heavily influenced by the popular Enlive templating library for Clojure.</p><p class="calibre13">Enfocus is intended to be complimentary to Domina—in fact, Enfocus builds its high-level transformations on top of the lower-level features Domina provides.</p><p id="filepos298760" class="calibre11"><span class="calibre12"><span class="bold">Jayq</span></span></p><p class="calibre13"><a href="https://github.com/ibdknox/jayq"><span class="calibre3">Jayq</span></a> is a thin but quite complete wrapper for the extremely popular JQuery library for JavaScript. It allows users to leverage JQuery’s DOM manipulation capabilities, cross-browser compatibility, and large mindshare in ClojureScript.</p><p class="calibre13">If you are familiar and comfortable with JQuery, then Jayq is likely to be a good choice for you.</p><p id="filepos299296" class="calibre11"><span class="calibre12"><span class="bold">C2</span></span></p><p class="calibre13"><a href="http://keminglabs.com/c2/"><span class="calibre3">C2</span></a> is a powerful data visualization library for ClojureScript inspired by the excellent D3 JavaScript library. It provides mechanisms for making declarative mappings from your ClojureScript data to interactive, dynamic visualizations such as charts, graphs, and maps.</p><p class="calibre13">It supports a heavily data-driven approach, meaning that once a data binding is established between ClojureScript data structures and visual elements, the visual elements can watch the data and update automatically based on changes.</p><p class="calibre13">If you intend to do any charting, graphing, or other graphical data representation in ClojureScript, C2 is worth a very close look.</p><p id="filepos300154" class="calibre11"><span class="calibre12"><span class="bold">core.logic</span></span></p><p class="calibre13">Originally built for Clojure, <a href="https://github.com/clojure/core.logic/"><span class="calibre3">core.logic</span></a> is an extremely powerful logic/relational/declarative programming system that now supports ClojureScript as well. It is based on <span class="italic">miniKanren</span>, a logic programming system for Scheme invented by Daniel Friedman, William Byrd, and Oleg Kiselyov and explained in the wonderful book <span class="italic">The Reasoned Schemer</span> (MIT Press).</p><p class="calibre13">Logic programming allows users to express a problem declaratively, letting the implementation worry about the actual steps required to compute a solution. For certain classes of problems, this approach can be extremely concise and elegant.</p><p class="calibre13">Although the learning curve for logic programming can be steep, exploring core.logic is well worth it not just for the practical benefit to your programs, but as an educational tool to help you think about software development itself in new ways.</p><div class="mbppagebreak"></div><p id="filepos301268" class="calibre33"><span class="calibre31">About the Authors</span></p><p class="calibre13">Stuart Sierra is a Clojure/ClojureScript developer, a member of Clojure/core, and a co-author of Practical Clojure (Apress, 2010). Stuart lives in New York City.</p><p class="calibre13">Luke VanderHart is a Clojure/ClojureScript developer, a member of Clojure/core, and a co-author of Practical Clojure (Apress, 2010). Luke lives in Maryland.</p><div class="mbppagebreak"></div><p id="filepos301736" class="calibre33"></p><p class="calibre33"><span class="calibre31">ClojureScript: Up and Running</span></p><p class="calibre14"><span class="calibre5">Stuart Sierra</span></p><p class="calibre14"><span class="calibre5">Luke VanderHart</span></p><p class="calibre25"><span class="calibre10"><span class="calibre18">Editor</span></span></p><p class="calibre33"><span class="calibre10"><span class="calibre18">Meghan Blanchette</span></span></p><table border="1" valign="top" class="calibre40"><tr border="1" valign="top" class="calibre23"><th colspan="2" valign="top" class="calibre41"><span class="calibre10"><span class="bold"><span class="calibre18"> Revision History </span></span></span></th></tr><tr border="1" valign="top" class="calibre48"><td border="1" valign="top" class="calibre24"><span class="calibre10"> 2012-10-24 </span></td><td border="1" valign="top" class="calibre24"><span class="calibre10"> First release </span></td></tr></table><p class="calibre14">Copyright © 2012 Stuart Sierra, Luke VanderHart</p><p class="calibre33"></p><p class="calibre13"><span class="calibre10">O’Reilly books may be purchased for educational, business, or sales promotional use. Online editions are also available for most titles (</span><a href="http://my.safaribooksonline.com/?portal=oreilly"><span class="calibre10"><span class="calibre3">http://my.safaribooksonline.com</span></span></a><span class="calibre10">). For more information, contact our corporate/institutional sales department: 800-998-9938 or </span><a href="mailto:corporate@oreilly.com"><span class="calibre10"><span class="calibre3">corporate@oreilly.com</span></span></a><span class="calibre10">.</span></p><p class="calibre33"></p><p class="calibre13"><span class="calibre10">Nutshell Handbook, the Nutshell Handbook logo, and the O’Reilly logo are registered trademarks of O’Reilly Media, Inc. </span><span class="calibre10"><span class="italic">ClojureScript: Up and Running</span></span><span class="calibre10">, the image of a yellow-back duiker, and related trade dress are trademarks of O’Reilly Media, Inc.</span></p><p class="calibre13"><span class="calibre10">Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks. Where those designations appear in this book, and O’Reilly Media, Inc., was aware of a trademark claim, the designations have been printed in caps or initial caps.</span></p><p class="calibre33"></p><p class="calibre13"><span class="calibre10">While every precaution has been taken in the preparation of this book, the publisher and authors assume no responsibility for errors or omissions, or for damages resulting from the use of the information contained herein.</span></p><p class="calibre33"></p><p class="calibre14"><span class="calibre10">O’Reilly Media</span><br class="calibre6"/></p><p class="calibre33"><span class="calibre10">1005 Gravenstein Highway North</span></p><p class="calibre33"><span class="calibre10">Sebastopol, CA 95472 </span></p><p class="calibre58"><span class="calibre10">2012-10-24T11:09:50-07:00</span></p><div class="mbppagebreak"></div><p id="filepos304761" class="calibre1"><span class="calibre2"><span class="bold">Table of Contents</span></span></p><p class="calibre59"><a href="#filepos109">ClojureScript: Up and Running</a></p><p class="calibre60"><a href="#filepos829">Preface</a></p><blockquote class="calibre51"><a href="#filepos897">Who Should Read This Book</a></blockquote><blockquote class="calibre51"><a href="#filepos2107">How to Use This Book</a></blockquote><blockquote class="calibre51"><a href="#filepos6795">Conventions Used in This Book</a></blockquote><blockquote class="calibre51"><a href="#filepos8341">Using Code Examples</a></blockquote><blockquote class="calibre51"><a href="#filepos9689">Safari® Books Online</a></blockquote><blockquote class="calibre51"><a href="#filepos11928">How to Contact Us</a></blockquote><blockquote class="calibre51"><a href="#filepos14315">Acknowledgments</a></blockquote><p class="calibre60"><a href="#filepos14967">1. Introduction: Why ClojureScript?</a></p><blockquote class="calibre51"><a href="#filepos15329">The Rise of Browser Applications</a></blockquote><blockquote class="calibre51"><a href="#filepos17144">The Rise of JavaScript</a></blockquote><blockquote class="calibre51"><a href="#filepos19098">The Need for a Better Language</a></blockquote><blockquote class="calibre51"><a href="#filepos21253">Introducing ClojureScript</a></blockquote><p class="calibre60"><a href="#filepos23106">2. Hello World</a></p><blockquote class="calibre51"><a href="#filepos25528">Leiningen</a></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos27299">Installing Leiningen on OS X and Linux</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos29274">Installing Leiningen on Windows</a></blockquote></blockquote></blockquote><blockquote class="calibre51"><a href="#filepos30507">Using lein-cljsbuild</a></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos33210">Getting Started with the REPL</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos38045">Compiling a ClojureScript File to JavaScript</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos38180">Structuring the Leiningen project</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos40008">Updating the project configuration</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos41308">Writing a ClojureScript file</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos42074">Compiling</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos43458">Running ClojureScript in the Browser</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos44571">Other Capabilities of lein-cljsbuild</a></blockquote></blockquote></blockquote><p class="calibre60"><a href="#filepos45583">3. The Compilation Process</a></p><blockquote class="calibre51"><a href="#filepos45905">Architecture</a></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos46618">Google Closure Compiler</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos50922">The Google Closure Library</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos54613">ClojureScript and Google Closure</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos55959">The Compilation Pipeline</a></blockquote></blockquote></blockquote><blockquote class="calibre51"><a href="#filepos58093">How to Compile</a></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos60650">Compiling ClojureScript</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos61518">Hello, Compiler</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos63342">The Clojure REPL</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre51"><a href="#filepos64923">Compilation in Depth</a></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos65452">Compilation Sources</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos66061">Compilation and Optimization Options</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos66837">:optimizations</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos69096">Where do the files go?</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos70021">Compiling with optimizations</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos71408">Loading optimized code in a browser</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos72664">Compiling without optimizations</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos74330">Loading unoptimized code in a browser</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos76382">An alternative: pretty-printing</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos77593">Other Compilation Options</a></blockquote></blockquote></blockquote><blockquote class="calibre51"><a href="#filepos78585">Summary</a></blockquote><p class="calibre60"><a href="#filepos83077">4. ClojureScript Basics</a></p><blockquote class="calibre51"><a href="#filepos83583">ClojureScript versus Clojure</a></blockquote><blockquote class="calibre51"><a href="#filepos86123">Expressions and Side Effects</a></blockquote><blockquote class="calibre51"><a href="#filepos87895">Syntax and Data Structures</a></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos88837">Symbols and Keywords</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos90047">Data Structures</a></blockquote></blockquote></blockquote><blockquote class="calibre51"><a href="#filepos93016">Special Forms and Definitions</a></blockquote><blockquote class="calibre51"><a href="#filepos94494">Functions</a></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos97666">Multi-Arity Functions</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos98958">Variadic Functions</a></blockquote></blockquote></blockquote><blockquote class="calibre51"><a href="#filepos100359">Local Bindings</a></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos101802">Destructuring</a></blockquote></blockquote></blockquote><blockquote class="calibre51"><a href="#filepos103146">Closures</a></blockquote><blockquote class="calibre51"><a href="#filepos104179">Flow Control</a></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos104976">Conditional Branching</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos108969">cond</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos112027">do</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos114282">when</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre51"><a href="#filepos115138">JavaScript Interop</a></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos115707">The js Namespace</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos116939">Methods and Fields</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos119582">Constructor Functions</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos121197">Scope of this</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos123763">Exceptions</a></blockquote></blockquote></blockquote><blockquote class="calibre51"><a href="#filepos126049">Summary</a></blockquote><p class="calibre60"><a href="#filepos127395">5. Data and State</a></p><blockquote class="calibre51"><a href="#filepos128996">Primitives</a></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos129471">Strings</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos130095">Keywords</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos131893">Symbols</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos132943">Characters</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos133415">Numbers</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos134202">Booleans</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos135643">Functions</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos136622">nil</a></blockquote></blockquote></blockquote><blockquote class="calibre51"><a href="#filepos141264">Data Structures</a></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos144713">Collection Types</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos144820">Lists</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos146319">Vectors</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos148047">Maps</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos151364">Sets</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos152595">Immutability</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos154873">Why immutability?</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos156731">Persistence</a></blockquote></blockquote></blockquote><blockquote class="calibre51"><a href="#filepos158612">Identity and State</a></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos160743">Atoms</a></blockquote></blockquote></blockquote><p class="calibre60"><a href="#filepos164179">6. Sequences</a></p><blockquote class="calibre51"><a href="#filepos166061">The Sequence Abstraction</a></blockquote><blockquote class="calibre51"><a href="#filepos168645">Lazy Sequences</a></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos171235">Letting Go of the Head</a></blockquote></blockquote></blockquote><blockquote class="calibre51"><a href="#filepos172321">The Sequence API</a></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos172832">map</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos174257">reduce</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos175507">filter</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos176336">Other Useful Sequence Functions</a></blockquote></blockquote></blockquote><p class="calibre60"><a href="#filepos179627">7. Namespaces, Libraries, and Google Closure</a></p><blockquote class="calibre51"><a href="#filepos180838">Namespaces</a></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos182184">Using Namespaces</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos186315">Using namespaces at the REPL</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos187647">Using Namespaces Effectively</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos188748">The Implementation of Namespaces</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos189018">Namespaces and *.js files</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos193097">Namespaces and variable names</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre51"><a href="#filepos194177">Advanced Compilation Mode</a></blockquote><blockquote class="calibre51"><a href="#filepos197268">Consuming Libraries</a></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos197985">ClojureScript Libraries</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos198721">JavaScript Libraries</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos199466">Google Closure libraries</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos202281">Plain old JavaScript libraries</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos203950">With Advanced mode</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos206032">Without Advanced mode</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre51"><a href="#filepos210817">Creating Libraries</a></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos211674">For Consumption by ClojureScript</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos212385">For Consumption by JavaScript</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos213851">^:export metadata</a></blockquote></blockquote></blockquote></blockquote></blockquote><p class="calibre60"><a href="#filepos215466">8. Macros</a></p><blockquote class="calibre51"><a href="#filepos216035">Code as Data</a></blockquote><blockquote class="calibre51"><a href="#filepos216904">Writing Macros</a></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos220872">Syntax-Quote</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos222475">Auto-Gensyms</a></blockquote></blockquote></blockquote><blockquote class="calibre51"><a href="#filepos224474">Using Macros</a></blockquote><blockquote class="calibre51"><a href="#filepos225966">When to Write Macros</a></blockquote><blockquote class="calibre51"><a href="#filepos227657">Summary</a></blockquote><p class="calibre60"><a href="#filepos228815">9. Development Process and Workflow</a></p><blockquote class="calibre51"><a href="#filepos229793">Installing ClojureScript</a></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos230968">Checking Out from Source Control</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos232380">Downloading a Compressed Archive</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos234089">Installing Dependencies</a></blockquote></blockquote></blockquote><blockquote class="calibre51"><a href="#filepos235486">The Built-In Tools</a></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos235565">Command-Line Compilation</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos237008">Clojure REPL</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos237523">ClojureScript REPL</a></blockquote></blockquote></blockquote><blockquote class="calibre51"><a href="#filepos238123">The Browser REPL</a></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos240373">Setting Up the Browser REPL</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos242576">Serving your HTML via Ring and Compojure</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos244894">Starting the bREPL server</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos246489">Configuring the bREPL client</a></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote class="calibre51"><a href="#filepos251212">Additional lein-cljsbuild Features</a></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos251441">Launching a Browser REPL</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos252677">Custom bREPL Launch Commands</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos254431">Hooking Into Default Leiningen Tasks</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos255936">Testing ClojureScript Code</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos259227">Including ClojureScript in JAR Files</a></blockquote></blockquote></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos261019">Compiling the Same Code as Clojure and ClojureScript</a></blockquote></blockquote></blockquote><p class="calibre60"><a href="#filepos264235">10. Integration with Clojure</a></p><blockquote class="calibre51"><a href="#filepos264792">AJAX</a></blockquote><blockquote class="calibre51"><a href="#filepos266873">The Reader and Printer</a></blockquote><blockquote class="calibre51"><a href="#filepos274040">Example Client-Server Application</a></blockquote><blockquote class="calibre51"><a href="#filepos284441">Extending the Reader</a></blockquote><blockquote class="calibre61"><blockquote class="calibre61"><blockquote class="calibre51"><a href="#filepos286143">User-Defined Tagged Literals</a></blockquote></blockquote></blockquote><blockquote class="calibre51"><a href="#filepos287620">Sharing Code</a></blockquote><blockquote class="calibre51"><a href="#filepos291011">Summary</a></blockquote><p class="calibre60"><a href="#filepos292999">A. Libraries</a></p><blockquote class="calibre51"><a href="#filepos294185">ClojureScript’s Standard Library</a></blockquote><blockquote class="calibre51"><a href="#filepos295596">Google Closure Library</a></blockquote><blockquote class="calibre51"><a href="#filepos297060">Domina</a></blockquote><blockquote class="calibre51"><a href="#filepos298137">Enfocus</a></blockquote><blockquote class="calibre51"><a href="#filepos298760">Jayq</a></blockquote><blockquote class="calibre51"><a href="#filepos299296">C2</a></blockquote><blockquote class="calibre51"><a href="#filepos300154">core.logic</a></blockquote><p class="calibre60"><a href="#filepos301268">About the Authors</a></p><p class="calibre60"><a href="#filepos301736">Copyright</a></p><div class="mbppagebreak"></div><a></a>
<a></a>
<a></a></div>

{% endraw %}

