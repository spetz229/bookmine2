---
layout: page
title: "Scala in Depth"
prev: kindle_split_020.html
next: kindle_split_022.html
book_path: books/scala-in-depth-joshua-d-suereth--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

<div class="calibre5"></div><h2 class="chapter" id="lof">List of Figures</h2>
      <p class="noind">Chapter 2. The core rules</p>
      <blockquote class="toc">
         <p class="ind"><a href="kindle_split_010.html#ch02fig01" class="calibre7">Figure 2.1. REPL return values</a><br class="calibre4"/></p>
         <p class="ind"><a href="kindle_split_010.html#ch02fig02" class="calibre7">Figure 2.2. Immutable versus mutable service worst-case scenario</a><br class="calibre4"/></p>
         <p class="ind"><a href="kindle_split_010.html#ch02fig03" class="calibre7">Figure 2.3. Immutable versus mutable service “one golden run” scenario</a><br class="calibre4"/></p>
      </blockquote>
      <p class="noind">Chapter 3. Modicum of style—coding conventions</p>
      <blockquote class="toc">
         <p class="ind"><a href="kindle_split_011.html#ch03fig01" class="calibre7">Figure 3.1. Fourier transform equation</a><br class="calibre4"/></p>
      </blockquote>
      <p class="noind">Chapter 4. Utilizing object orientation</p>
      <blockquote class="toc">
         <p class="ind"><a href="kindle_split_012.html#ch04fig01" class="calibre7">Figure 4.1. Simulation class hierarchy</a><br class="calibre4"/></p>
         <p class="ind"><a href="kindle_split_012.html#ch04fig02" class="calibre7">Figure 4.2. Linearization of Router with NetworkEntity</a><br class="calibre4"/></p>
         <p class="ind"><a href="kindle_split_012.html#ch04fig03" class="calibre7">Figure 4.3. Abstract interface between software modules.</a><br class="calibre4"/></p>
      </blockquote>
      <p class="noind">Chapter 6. The Type System</p>
      <blockquote class="toc">
         <p class="ind"><a href="kindle_split_014.html#ch06fig01" class="calibre7">Figure 6.1. Defining type parameters on a method</a><br class="calibre4"/></p>
         <p class="ind"><a href="kindle_split_014.html#ch06fig02" class="calibre7">Figure 6.2. Covariance</a><br class="calibre4"/></p>
         <p class="ind"><a href="kindle_split_014.html#ch06fig03" class="calibre7">Figure 6.3. Contravariance</a><br class="calibre4"/></p>
      </blockquote>
      <p class="noind">Chapter 7. Using implicits and types together</p>
      <blockquote class="toc">
         <p class="ind"><a href="kindle_split_015.html#ch07fig01" class="calibre7">Figure 7.1. Sample heterogeneous list</a><br class="calibre4"/></p>
         <p class="ind"><a href="kindle_split_015.html#ch07fig02" class="calibre7">Figure 7.2. IndexedView</a><br class="calibre4"/></p>
         <p class="ind"><a href="kindle_split_015.html#ch07fig03" class="calibre7">Figure 7.3. Recursive HListViewN</a><br class="calibre4"/></p>
      </blockquote>
      <p class="noind">Chapter 8. Using the right collection</p>
      <blockquote class="toc">
         <p class="ind"><a href="kindle_split_016.html#ch08fig01" class="calibre7">Figure 8.1. Generic collections hierarchy</a><br class="calibre4"/></p>
         <p class="ind"><a href="kindle_split_016.html#ch08fig02" class="calibre7">Figure 8.2. Example index trie with a branching factor of two</a><br class="calibre4"/></p>
         <p class="ind"><a href="kindle_split_016.html#ch08fig03" class="calibre7">Figure 8.3. Update to trie with sharing</a><br class="calibre4"/></p>
         <p class="ind"><a href="kindle_split_016.html#ch08fig04" class="calibre7">Figure 8.4. Vector’s array structure with branching factor of 2</a><br class="calibre4"/></p>
         <p class="ind"><a href="kindle_split_016.html#ch08fig05" class="calibre7">Figure 8.5. Internal structure of a list</a><br class="calibre4"/></p>
         <p class="ind"><a href="kindle_split_016.html#ch08fig06" class="calibre7">Figure 8.6. Changing evaluation semantics</a><br class="calibre4"/></p>
         <p class="ind"><a href="kindle_split_016.html#ch08fig07" class="calibre7">Figure 8.7. Splitting parallel collection iterators</a><br class="calibre4"/></p>
         <p class="ind"><a href="kindle_split_016.html#ch08fig08" class="calibre7">Figure 8.8. Parallel task breakdown of sum method</a><br class="calibre4"/></p>
      </blockquote>
      <p class="noind">Chapter 9. Actors</p>
      <blockquote class="toc">
         <p class="ind"><a href="kindle_split_017.html#ch09fig01" class="calibre7">Figure 9.1. Scatter phase</a><br class="calibre4"/></p>
         <p class="ind"><a href="kindle_split_017.html#ch09fig02" class="calibre7">Figure 9.2. Gather phase</a><br class="calibre4"/></p>
         <p class="ind"><a href="kindle_split_017.html#ch09fig03" class="calibre7">Figure 9.3. Modified scatter-gather search</a><br class="calibre4"/></p>
         <p class="ind"><a href="kindle_split_017.html#ch09fig04" class="calibre7">Figure 9.4. Failure zones for scatter-gather example</a><br class="calibre4"/></p>
         <p class="ind"><a href="kindle_split_017.html#ch09fig05" class="calibre7">Figure 9.5. Scatter-gather scheduling zones</a><br class="calibre4"/></p>
         <p class="ind"><a href="kindle_split_017.html#ch09fig06" class="calibre7">Figure 9.6. Topology state change</a><br class="calibre4"/></p>
      </blockquote>
      <p class="noind">Chapter 11. Patterns in functional programming</p>
      <blockquote class="toc">
         <p class="ind"><a href="kindle_split_019.html#ch11fig01" class="calibre7">Figure 11.1. Functor transforming types and functions</a><br class="calibre4"/></p>
      </blockquote>
      <div class="calibre4" id="calibre_pb_21"></div></div>

{% endraw %}

