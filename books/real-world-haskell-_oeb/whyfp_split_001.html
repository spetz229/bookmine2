---
layout: page
title: "Real World Haskell, 1st Edition"
prev: whyfp_split_000.html
next: starting_split_000.html
book_path: books/real-world-haskell-_oeb/
---
{% include JB/setup %}
{% raw %}
<div>

<h2 id="title-IDAVCSOB" class="docPrefaceTitle">Preface</h2><a name="I_sect1_d1e159" class="calibre5" id="I_sect1_d1e159"></a><h3 id="643999-801" class="docSection1Title">P.1. Have We Got a Deal for You!</h3><a name="x_Jx" class="calibre5" id="x_Jx"></a><p class="docText">Haskell is a deep language; we think learning it is a
    hugely rewarding experience. We will focus on three elements as we explain
    why. The first is <span class="docEmphasis">novelty</span>: we invite you to think
    about programming from a different and valuable perspective. The second is
    <span class="docEmphasis">power</span>: we'll show you how to create software that is
    short, fast, and safe. Lastly, we offer you a lot of
    <span class="docEmphasis">enjoyment</span>: the pleasure of applying beautiful
    programming techniques to solve real problems.</p><a name="I_sect1_d1e159d1e182" class="calibre5" id="I_sect1_d1e159d1e182"></a><h4 id="title-IDAGDSOB" class="docSection1Title">P.1.1. Novelty</h4><a name="x_Kx" class="calibre5" id="x_Kx"></a><p class="docText">Haskell is most likely quite different from any language
      you've ever used before. Compared to the usual set of concepts in a
      programmer's mental toolbox, functional programming offers us a
      profoundly different way to think about software.</p><a name="x_Lx" class="calibre5" id="x_Lx"></a><p class="docText">In Haskell, we deemphasize code that modifies data.
      Instead, we focus on functions that take immutable values as input and
      produce new values as output. Given the same inputs, these functions
      always return the same results. This is a core idea behind functional
      programming.</p><a name="x_Mx" class="calibre5" id="x_Mx"></a><p class="docText">Along with not modifying data, our Haskell functions
      usually don't talk to the external world; we call these functions
      <span class="docEmphasis">pure</span>. We make a strong distinction between pure
      code and the parts of our programs that read or write files, communicate
      over network connections, or make robot arms move. This makes it easier
      to organize, reason about, and test our programs.</p><a name="x_Nx" class="calibre5" id="x_Nx"></a><p class="docText">We abandon some ideas that might seem fundamental, such
      as having a <tt class="calibre34">for</tt> loop built into the language. We have
      other, more flexible, ways to perform repetitive tasks.</p><a name="x_Ox" class="calibre5" id="x_Ox"></a><p class="docText">Even the way in which we evaluate expressions is
      different in Haskell. We defer every computation until its result is
      actually needed—Haskell is a <span class="docEmphasis">lazy</span> language.
      Laziness is not merely a matter of moving work around, it profoundly
      affects how we write <span class="docEmphasis">programs</span>.</p><a name="I_sect1_d1e159d1e208" class="calibre5" id="I_sect1_d1e159d1e208"></a><h4 id="title-IDAEESOB" class="docSection1Title">P.1.2. Power</h4><a name="x_Px" class="calibre5" id="x_Px"></a><p class="docText">Throughout this book, we will show you how Haskell's
      alternatives to the features of traditional languages are powerful and
      flexible and lead to reliable code. Haskell is positively crammed full
      of cutting-edge ideas about how to create great software.</p><a name="x_Rx" class="calibre5" id="x_Rx"></a><p class="docText">Since pure code has no dealings with the outside world,
      and the data it works with is never modified, the kind of nasty surprise
      in which one piece of code invisibly corrupts data used by another is
      very rare. Whatever context we use a pure function in, the function will
      behave consistently.</p><a name="x_Sx" class="calibre5" id="x_Sx"></a><p class="docText">Pure code is easier to test than code that deals with
      the outside world. When a function responds only to its visible inputs,
      we can easily state properties of its behavior that should always be
      true. We can automatically test that those properties hold for a huge
      body of random inputs, and when our tests pass, we move on. We still use
      traditional techniques to test code that must interact with files,
      networks, or exotic hardware. Since there is much less of this impure
      code than we would find in a traditional language, we gain much more
      assurance that our software is solid.</p><a name="x_Tx" class="calibre5" id="x_Tx"></a><p class="docText">Lazy evaluation has some spooky effects. Let's say we
      want to find the <span class="docEmphasis">k</span> least-valued elements of an
      unsorted list. In a traditional language, the obvious approach would be
      to sort the list and take the first <span class="docEmphasis">k</span> elements, but
      this is expensive. For efficiency, we would instead write a special
      function that takes these values in one pass, and that would have to
      perform some moderately complex bookkeeping. In Haskell, the
      sort-then-take approach actually performs well: laziness ensures that
      the list will only be sorted enough to find the <span class="docEmphasis">k</span>
      minimal elements.</p><a name="x_Ux" class="calibre5" id="x_Ux"></a><p class="docText">Better yet, our Haskell code that operates so
      efficiently is tiny and uses standard library functions:</p><pre class="calibre35">-- file: ch00/KMinima.hs
-- lines beginning with "--" are comments.

minima k xs = take k (sort xs)</pre><br class="calibre20"/>
<a name="x_Vx" class="calibre5" id="x_Vx"></a><p class="docText">It can take a while to develop an intuitive feel for
      when lazy evaluation is important, but when we exploit it, the resulting
      code is often clean, brief, and efficient.</p><a name="x_Wx" class="calibre5" id="x_Wx"></a><p class="docText">As the preceding example shows, an important aspect of
      Haskell's power lies in the compactness of the code we write. Compared
      to working in popular traditional languages, when we develop in Haskell
      we often write much less code, in substantially less time and with fewer
      bugs.</p><a name="I_sect1_d1e159d1e236" class="calibre5" id="I_sect1_d1e159d1e236"></a><h4 id="title-IDAHFSOB" class="docSection1Title">P.1.3. Enjoyment</h4><a name="x_Xx" class="calibre5" id="x_Xx"></a><p class="docText">We believe that it is easy to pick up the basics of
      Haskell programming and that you will be able to successfully write
      small programs within a matter of hours or days.</p><a name="x_Yx" class="calibre5" id="x_Yx"></a><p class="docText">Since effective programming in Haskell differs greatly
      from other languages, you should expect that mastering both the language
      itself and functional programming techniques will require plenty of
      thought and practice.</p><a name="x_Zx" class="calibre5" id="x_Zx"></a><p class="docText">Harking back to our own days of getting started with
      Haskell, the good news is that the fun begins early: it's simply an
      entertaining challenge to dig into a new language— in which so many
      commonplace ideas are different or missing—and to figure out how to
      write simple programs.</p><a name="x_ax" class="calibre5" id="x_ax"></a><p class="docText">For us, the initial pleasure lasted as our experience
      grew and our understanding deepened. In other languages, it's difficult
      to see any connection between science and the nuts-and-bolts of
      programming. In Haskell, we have imported some ideas from abstract
      mathematics and put them to work. Even better, we find that not only are
      these ideas easy to pick up, but they also have a practical payoff in
      helping us to write more compact, reusable code.</p><a name="x_bx" class="calibre5" id="x_bx"></a><p class="docText">Furthermore, we won't be putting any "brick
      walls" in your way. There are no especially difficult or gruesome
      techniques in this book that you must master in order to be able to
      program effectively.</p><a name="x_cx" class="calibre5" id="x_cx"></a><p class="docText">That being said, Haskell is a rigorous language: it will
      make you perform more of your thinking up front. It can take a little
      while to adjust to debugging much of your code before you ever run it,
      in response to the compiler telling you that something about your
      program does not make sense. Even with years of experience, we remain
      astonished and pleased by how often our Haskell programs simply work on
      the first try, once we fix those compilation errors.</p><a name="I_sect1_d1e245" class="calibre5" id="I_sect1_d1e245"></a><h3 id="643999-801" class="docSection1Title">P.2. What to Expect from This Book</h3><a name="x_Tl" class="calibre5" id="x_Tl"></a><p class="docText">We started this project because a growing number of people
    are using Haskell to solve everyday problems. Because Haskell has its
    roots in academia, few of the Haskell books that currently exist focus on
    the problems and techniques of the typical programming that we're
    interested in.</p><a name="x_Rl" class="calibre5" id="x_Rl"></a><p class="docText">With this book, we want to show you how to use functional
    programming and Haskell to solve realistic problems. We take a hands-on
    approach: every chapter contains dozens of code samples, and many contain
    complete applications. Here are a few examples of the libraries,
    techniques, and tools that we'll show you how to develop:</p><ul class="calibre28"><li class="calibre36"><p class="docText">Create an application that downloads podcast episodes
        from the Internet and stores its history in an SQL database.</p></li><li class="calibre36"><p class="docText">Test your code in an intuitive and powerful way.
        Describe properties that ought to be true, and then let the QuickCheck
        library generate test cases automatically.</p></li><li class="calibre36"><p class="docText">Take a grainy phone camera snapshot of a barcode and
        turn it into an identifier that you can use to query a library or
        bookseller's website.</p></li><li class="calibre36"><p class="docText">Write code that thrives on the Web. Exchange data with
        servers and clients written in other languages using JSON notation.
        Develop a concurrent link checker.</p></li></ul><a name="I_sect1_d1e245d1e275" class="calibre5" id="I_sect1_d1e245d1e275"></a><h4 id="title-IDA1GSOB" class="docSection1Title">P.2.1. A Little Bit About You</h4><a name="x_hx" class="calibre5" id="x_hx"></a><p class="docText">What will you need to know before reading this book? We
      expect that you already know how to program, but if you've never used a
      functional language, that's fine.</p><a name="x_ix" class="calibre5" id="x_ix"></a><p class="docText">No matter what your level of experience is, we tried to
      anticipate your needs; we go out of our way to explain new and
      potentially tricky ideas in depth, usually with examples and images to
      drive our points home.</p><a name="x_P" class="calibre5" id="x_P"></a><p class="docText">As a new Haskell programmer, you'll inevitably start out
      writing quite a bit of code by hand for which you could have used a
      library function or programming technique, had you just known of its
      existence. We packed this book with information to help you get up to
      speed as quickly as possible.</p><a name="x_jx" class="calibre5" id="x_jx"></a><p class="docText">Of course, there will always be a few bumps along the
      road. If you start out anticipating an occasional surprise or difficulty
      along with the fun stuff, you will have the best experience. Any rough
      patches you might hit won't last long.</p><a name="x_kx" class="calibre5" id="x_kx"></a><p class="docText">As you become a more seasoned Haskell programmer, the
      way that you write code will change. Indeed, over the course of this
      book, the way that we present code will evolve, as we move from the
      basics of the language to increasingly powerful and productive features
      and techniques.</p><a name="I_sect1_d1e279" class="calibre5" id="I_sect1_d1e279"></a><h3 id="643999-801" class="docSection1Title">P.3. What to Expect from Haskell</h3><a name="x_lx" class="calibre5" id="x_lx"></a><p class="docText">Haskell is a general-purpose programming language. It was
    designed without any application niche in mind. Although it takes a strong
    stand on how programs should be written, it does not favor one problem
    domain over others.</p><a name="x_mx" class="calibre5" id="x_mx"></a><p class="docText">While at its core, the language encourages a pure, lazy
    style of functional programming, this is the <span class="docEmphasis">default</span>,
    not the only option. Haskell also supports the more traditional models of
    procedural code and strict evaluation. Additionally, although the focus of
    the language is squarely on writing statically typed programs, it is
    possible (though rarely seen) to write Haskell code in a dynamically typed
    manner.</p><a name="I_sect1_d1e279d1e298" class="calibre5" id="I_sect1_d1e279d1e298"></a><h4 id="title-IDA0HSOB" class="docSection1Title">P.3.1. Compared to Traditional Static Languages</h4><a name="x_nx" class="calibre5" id="x_nx"></a><p class="docText">Languages that use simple static type systems have been
      the mainstay of the programming world for decades. Haskell is statically
      typed, but its notion of what types are for and what we can do with them
      is much more flexible and powerful than traditional languages. Types
      make a major contribution to the brevity, clarity, and efficiency of
      Haskell programs.</p><a name="x_ox" class="calibre5" id="x_ox"></a><p class="docText">Although powerful, Haskell's type system is often also
      unobtrusive. If we omit explicit type information, a Haskell compiler
      will automatically infer the type of an expression or function. Compared
      to traditional static languages, to which we must spoon-feed large
      amounts of type information, the combination of power and inference in
      Haskell's type system significantly reduces the clutter and redundancy
      of our code.</p><a name="x_px" class="calibre5" id="x_px"></a><p class="docText">Several of Haskell's other features combine to further
      increase the amount of work we can fit into a screenful of text. This
      brings improvements in development time and agility; we can create
      reliable code quickly and easily refactor it in response to changing
      requirements.</p><a name="x_qx" class="calibre5" id="x_qx"></a><p class="docText">Sometimes, Haskell programs may run more slowly than
      similar programs written in C or C++. For most of the code we write,
      Haskell's large advantages in productivity and reliability outweigh any
      small performance disadvantage.</p><a name="x_mA1" class="calibre5" id="x_mA1"></a><p class="docText">Multicore processors are now ubiquitous, but they
      remain notoriously difficult to program using traditional techniques.
      Haskell provides unique technologies to make <span class="docEmphasis">multicore</span> programming more tractable. It
      supports parallel programming, software transactional memory for
      reliable concurrency, and it scales to hundreds of thousands of <span class="docEmphasis">concurrent</span> threads.</p><a name="I_sect1_d1e279d1e317" class="calibre5" id="I_sect1_d1e279d1e317"></a><h4 id="title-IDAYISOB" class="docSection1Title">P.3.2. Compared to Modern Dynamic Languages</h4><a name="x_sx" class="calibre5" id="x_sx"></a><p class="docText">Over the past decade, dynamically typed, interpreted
      languages have become increasingly popular. They offer substantial
      benefits in developer productivity. Although this often comes at the
      cost of a huge performance hit, for many programming tasks productivity
      trumps performance, or performance isn't a significant factor in any
      case.</p><a name="x_tx" class="calibre5" id="x_tx"></a><p class="docText">Brevity is one area in which Haskell and dynamically
      typed languages perform similarly: in each case, we write much less code
      to solve a problem than in a traditional language. Programs are often
      around the same size in dynamically typed languages and Haskell.</p><a name="x_ux" class="calibre5" id="x_ux"></a><p class="docText">When we consider runtime performance, Haskell almost
      always has a huge advantage. Code compiled by the Glasgow Haskell
      Compiler (<span class="docMonofont">GHC</span>) is typically
      between 20 to 60 times faster than code run through a dynamic language's
      interpreter. <span class="docMonofont">GHC</span> also
      provides an interpreter, so you can run scripts without compiling
      them.</p><a name="x_vx" class="calibre5" id="x_vx"></a><p class="docText">Another big difference between dynamically typed
      languages and Haskell lies in their philosophies around types. A major
      reason for the popularity of dynamically typed languages is that only
      rarely do we need to explicitly mention types. Through automatic type
      inference, Haskell offers the same advantage.</p><a name="x_wx" class="calibre5" id="x_wx"></a><p class="docText">Beyond this surface similarity, the differences run
      deep. In a dynamically typed <span class="docEmphasis">language</span>, we can create constructs that
      are difficult to express in a statically typed language. However, the
      same is true in reverse: with a type system as powerful as Haskell's, we
      can structure a program in a way that would be unmanageable or
      infeasible in a dynamically typed language.</p><a name="x_xx" class="calibre5" id="x_xx"></a><p class="docText">It's important to recognize that each of these
      approaches involves trade-offs. Very briefly put, the Haskell
      perspective emphasizes safety, while the dynamically typed outlook
      favors flexibility. If someone had already discovered one way of
      thinking about types that was always best, we imagine that everyone
      would know about it by now.</p><a name="x_yx" class="calibre5" id="x_yx"></a><p class="docText">Of course, we, the authors, have our own opinions about
      which trade-offs are more beneficial. Two of us have years of experience
      programming in dynamically typed languages. We love working with them;
      we still use them every day; but usually, we prefer Haskell.</p><a name="I_sect1_d1e279d1e343" class="calibre5" id="I_sect1_d1e279d1e343"></a><h4 id="title-IDA3JSOB" class="docSection1Title">P.3.3. Haskell in Industry and Open Source</h4><a name="x_zx" class="calibre5" id="x_zx"></a><p class="docText">Here are just a few examples of large software systems
      that have been created in Haskell. Some of these are open source, while
      others are proprietary products:</p><ul class="calibre28"><li class="calibre36"><p class="docText">ASIC and FPGA design software (Lava, products from
          Bluespec, Inc.)</p></li><li class="calibre36"><p class="docText">Music composition software (Haskore)</p></li><li class="calibre36"><p class="docText">Compilers and compiler-related tools (most notably
          <span class="docMonofont">GHC</span>)</p></li><li class="calibre36"><p class="docText">Distributed revision control (Darcs)</p></li><li class="calibre36"><p class="docText">Web middleware (HAppS, products from Galois,
          Inc.)</p></li></ul><a name="x_nA1" class="calibre5" id="x_nA1"></a><p class="docText">The following is a sample of some of the companies
      using Haskell in late 2008, taken from the <a class="docLink" target="_blank" href="http://www.haskell.org/haskellwiki/Haskell_in_industry">Haskell
      wiki</a>:</p><dl class="docList"><dt class="calibre20"><br class="calibre20"/><p class="calibre37"><i class="docEmphasis"><span class="docPubcolor">ABN AMRO</span></i></p></dt><dd class="calibre38"><p class="docText">An international bank. It uses Haskell in investment
            banking, in order to measure the counterparty risk on portfolios
            of financial derivatives.</p></dd><dt class="calibre20"><br class="calibre20"/><p class="calibre37"><i class="docEmphasis"><span class="docPubcolor">Anygma</span></i></p></dt><dd class="calibre38"><p class="docText">A startup company. It develops multimedia content creation
            tools using Haskell.</p></dd><dt class="calibre20"><br class="calibre20"/><p class="calibre37"><i class="docEmphasis"><span class="docPubcolor">Amgen</span></i></p></dt><dd class="calibre38"><p class="docText">A biotech company. It creates mathematical models and other
            complex applications in Haskell.</p></dd><dt class="calibre20"><br class="calibre20"/><p class="calibre37"><i class="docEmphasis"><span class="docPubcolor">Bluespec</span></i></p></dt><dd class="calibre38"><p class="docText">An ASIC and FPGA design software vendor. Its products are
            developed in Haskell, and the chip design languages that its
            products provide are influenced by Haskell.</p></dd><dt class="calibre20"><br class="calibre20"/><p class="calibre37"><i class="docEmphasis"><span class="docPubcolor">Eaton</span></i></p></dt><dd class="calibre38"><p class="docText">Uses Haskell for the design and verification of hydraulic
            hybrid vehicle <span class="docEmphasis">systems</span>.</p></dd></dl><a name="I_sect1_d1e279d1e406" class="calibre5" id="I_sect1_d1e279d1e406"></a><h4 id="title-IDA4LSOB" class="docSection1Title">P.3.4. Compilation, Debugging, and Performance Analysis</h4><a name="x_Fy" class="calibre5" id="x_Fy"></a><p class="docText">For practical work, almost as important as a language
      itself is the ecosystem of libraries and tools around it. Haskell has a
      strong showing in this area.</p><a name="x_Gy" class="calibre5" id="x_Gy"></a><p class="docText">The most widely used compiler, <span class="docMonofont">GHC</span>, has been actively developed for over
      15 years and provides a mature and stable set of features:</p><ul class="calibre28"><li class="calibre36"><p class="docText">Compiles to efficient native code on all major
          modern operating systems and CPU architectures</p></li><li class="calibre36"><p class="docText">Easy deployment of compiled binaries, unencumbered
          by licensing restrictions</p></li><li class="calibre36"><p class="docText">Code coverage analysis</p></li><li class="calibre36"><p class="docText">Detailed profiling of performance and memory
          usage</p></li><li class="calibre36"><p class="docText">Thorough documentation</p></li><li class="calibre36"><p class="docText">Massively scalable support for concurrent and
          multicore programming</p></li><li class="calibre36"><p class="docText">Interactive interpreter and debugger</p></li></ul><a name="I_sect1_d1e279d1e438" class="calibre5" id="I_sect1_d1e279d1e438"></a><h4 id="title-IDAJNSOB" class="docSection1Title">P.3.5. Bundled and Third-Party Libraries</h4><a name="x_Oy" class="calibre5" id="x_Oy"></a><p class="docText">The <span class="docMonofont">GHC</span>
      compiler ships with a collection of useful libraries. Here are a few of
      the common programming needs that these libraries address:</p><ul class="calibre28"><li class="calibre36"><p class="docText">File I/O and filesystem traversal and
          manipulation</p></li><li class="calibre36"><p class="docText">Network client and server programming</p></li><li class="calibre36"><p class="docText">Regular expressions and parsing</p></li><li class="calibre36"><p class="docText">Concurrent programming</p></li><li class="calibre36"><p class="docText">Automated testing</p></li><li class="calibre36"><p class="docText">Sound and graphics</p></li></ul><a name="x_Vy" class="calibre5" id="x_Vy"></a><p class="docText">The Hackage package database is the Haskell community's
      collection of open source libraries and applications. Most libraries
      published on Hackage are licensed under liberal terms that permit both
      commercial and open source use. Some of the areas covered by these open
      source libraries include the following:</p><ul class="calibre28"><li class="calibre36"><p class="docText">Interfaces to all major open source and commercial
          databases</p></li><li class="calibre36"><p class="docText">XML, HTML, and XQuery processing</p></li><li class="calibre36"><p class="docText">Network and web client and server development</p></li><li class="calibre36"><p class="docText">Desktop GUIs, including cross-platform
          toolkits</p></li><li class="calibre36"><p class="docText">Support for Unicode and other text encodings</p></li></ul><a name="I_sect1_d1e474" class="calibre5" id="I_sect1_d1e474"></a><h3 id="643999-801" class="docSection1Title">P.4. A Brief Sketch of Haskell's History</h3><a name="x_by" class="calibre5" id="x_by"></a><p class="docText">The development of Haskell is rooted in mathematics and
    computer science research.</p><a name="I_sect1_d1e474d1e488" class="calibre5" id="I_sect1_d1e474d1e488"></a><h4 id="title-IDAMPSOB" class="docSection1Title">P.4.1. Prehistory</h4><a name="x_cy" class="calibre5" id="x_cy"></a><p class="docText">A few decades before modern computers were invented, the
      mathematician Alonzo Church developed a language called <span class="docEmphasis">lambda
      calculus</span>. He intended it as a tool for investigating the
      foundations of mathematics. The first person to realize the practical
      connection between programming and lambda calculus was John McCarthy,
      who created Lisp in 1958.</p><a name="x_dy" class="calibre5" id="x_dy"></a><p class="docText">During the 1960s, computer scientists began to recognize
      and study the importance of lambda calculus. Peter Landin and
      Christopher Strachey developed ideas about the foundations of
      programming languages: how to reason about what they do (operational
      semantics) and how to understand what they mean (denotational
      semantics).</p><a name="x_ey" class="calibre5" id="x_ey"></a><p class="docText">In the early 1970s, Robin Milner created a more rigorous
      functional programming language named <span class="docEmphasis">ML</span>. While ML
      was developed to help with automated proofs of mathematical theorems, it
      gained a following for more general computing tasks.</p><a name="x_fy" class="calibre5" id="x_fy"></a><p class="docText">The 1970s also saw the emergence of lazy evaluation as a
      novel strategy. David Turner developed SASL and KRC, while Rod Burstall
      and John Darlington developed NPL and Hope. NPL, KRC, and ML influenced
      the development of several more languages in the 1980s, including Lazy
      ML, Clean, and Miranda.</p><a name="I_sect1_d1e474d1e505" class="calibre5" id="I_sect1_d1e474d1e505"></a><h4 id="title-IDADQSOB" class="docSection1Title">P.4.2. Early Antiquity</h4><a name="x_gy" class="calibre5" id="x_gy"></a><p class="docText">By the late 1980s, the efforts of researchers working on
      lazy functional languages were scattered across more than a dozen
      languages. Concerned by this diffusion of effort, a number of
      researchers decided to form a committee to design a common language.
      After three years of work, the committee published the Haskell 1.0
      specification in 1990. It named the language after Haskell Curry, an
      influential logician.</p><a name="x_hy" class="calibre5" id="x_hy"></a><p class="docText">Many people are rightfully suspicious of "design by
      committee," but the output of the Haskell committee is a beautiful
      example of the best work a committee can do. They produced an elegant,
      considered language design and succeeded in unifying the fractured
      efforts of their research community. Of the thicket of lazy functional
      languages that existed in 1990, only Haskell is still actively
      used.</p><a name="x_iy" class="calibre5" id="x_iy"></a><p class="docText">Since its publication in 1990, the Haskell language
      standard has seen five revisions, most recently in 1998. A number of
      Haskell implementations have been written, and several are still
      actively developed.</p><a name="x_jy" class="calibre5" id="x_jy"></a><p class="docText">During the 1990s, Haskell served two main purposes. On
      one side, it gave language researchers a stable language in which to
      experiment with making lazy functional <span class="docEmphasis">programs</span> run efficiently and on the other
      side researchers explored how to construct programs using lazy
      functional techniques, and still others used it as a teaching <span class="docEmphasis">language</span>.</p><a name="I_sect1_d1e474d1e523" class="calibre5" id="I_sect1_d1e474d1e523"></a><h4 id="title-IDA2QSOB" class="docSection1Title">P.4.3. The Modern Era</h4><a name="x_ky" class="calibre5" id="x_ky"></a><p class="docText">While these basic explorations of the 1990s proceeded,
      Haskell remained firmly an academic affair. The informal slogan of those
      inside the community was to "avoid success at all costs." Few outsiders
      had heard of the language at all. Indeed, functional programming as a
      field was quite obscure.</p><a name="x_ly" class="calibre5" id="x_ly"></a><p class="docText">During this time, the mainstream programming world
      experimented with relatively small tweaks, from programming in C, to
      C++, to Java. Meanwhile, on the fringes, programmers were beginning to
      tinker with new, more dynamic languages. Guido van Rossum designed
      Python; Larry Wall created Perl; and Yukihiro Matsumoto developed
      Ruby.</p><a name="x_my" class="calibre5" id="x_my"></a><p class="docText">As these newer languages began to seep into wider use,
      they spread some crucial ideas. The first was that programmers are not
      merely capable of working in expressive languages; in fact, they
      flourish. The second was in part a byproduct of the rapid growth in raw
      computing power of that era: it's often smart to sacrifice some
      execution performance in exchange for a big increase in programmer
      productivity. Finally, several of these languages borrowed from
      functional programming.</p><a name="x_ny" class="calibre5" id="x_ny"></a><p class="docText">Over the past half decade, Haskell has successfully
      escaped from academia, buoyed in part by the visibility of Python, Ruby,
      and even JavaScript. The language now has a vibrant and fast-growing
      culture of open source and commercial users, and researchers continue to
      use it to push the boundaries of performance and expressiveness.</p><a name="whyfp_resources" class="calibre5" id="whyfp_resources"></a><h3 id="643999-801" class="docSection1Title">P.5. Helpful Resources</h3><a name="x_Ul" class="calibre5" id="x_Ul"></a><p class="docText">As you work with Haskell, you're sure to have questions
    and want more information about things. The following paragraphs describe
    some Internet resources where you can look up information and interact
    with other Haskell programmers.</p><a name="whyfp_resources_reference" class="calibre5" id="whyfp_resources_reference"></a><h4 id="title-IDATRSOB" class="docSection1Title">P.5.1. Reference Material</h4><dl class="docList"><dt class="calibre20"><br class="calibre20"/><p class="calibre37"><i class="docEmphasis"><span class="docPubcolor">The Haskell Hierarchical Libraries reference</span></i></p></dt><dd class="calibre38"><p class="docText">Provides the documentation for the standard library that
            comes with your compiler. This is one of the most valuable online
            assets for Haskell programmers.</p></dd><dt class="calibre20"><br class="calibre20"/><p class="calibre37"><i class="docEmphasis"><span class="docPubcolor">Haskell 98 Report</span></i></p></dt><dd class="calibre38"><p class="docText">Describes the Haskell 98 language standard.</p></dd><dt class="calibre20"><br class="calibre20"/><p class="calibre37"><i class="docEmphasis"><span class="docPubcolor">GHC Users's Guide</span></i></p></dt><dd class="calibre38"><p class="docText">Contains detailed documentation on the extensions supported
            by <span class="docMonofont">GHC</span>, as well as some
            GHC-specific features.</p></dd><dt class="calibre20"><br class="calibre20"/><p class="calibre37"><i class="docEmphasis"><span class="docPubcolor">Hoogle and Hayoo</span></i></p></dt><dd class="calibre38"><p class="docText">Haskell API search engines. They can search for functions by
            name or type.</p></dd></dl><a name="whyfp_resources_apps" class="calibre5" id="whyfp_resources_apps"></a><h4 id="title-IDANSSOB" class="docSection1Title">P.5.2. Applications and Libraries</h4><a name="x_Zl" class="calibre5" id="x_Zl"></a><p class="docText">If you're looking for a Haskell library to use for a
      particular task or an application written in Haskell, check out the
      following resources:</p><dl class="docList"><dt class="calibre20"><br class="calibre20"/><p class="calibre37"><i class="docEmphasis"><span class="docPubcolor">The Haskell community</span></i></p></dt><dd class="calibre38"><p class="docText">Maintains a central repository of open source Haskell
            libraries called <a class="docLink" target="_blank" href="http://hackage.haskell.org/">Hackage</a>. It lets you
            search for software to download, or browse its collection by
            category.</p></dd><dt class="calibre20"><br class="calibre20"/><p class="calibre37"><span class="docPubcolor">The <a class="docLink" target="_blank" href="http://haskell.org/haskellwiki/Applications_and_libraries">Haskell
          wiki</a></span></p></dt><dd class="calibre38"><p class="docText">Contains a section dedicated to information about particular
            Haskell libraries.</p></dd></dl><a name="whyfp_resources_community" class="calibre5" id="whyfp_resources_community"></a><h4 id="title-IDAGTSOB" class="docSection1Title">P.5.3. The Haskell Community</h4><a name="x_cl" class="calibre5" id="x_cl"></a><p class="docText">There are a number of ways you can get in touch with
      other Haskell programmers, in order to ask questions, learn what other
      people are talking about, and simply do some social networking with your
      peers:</p><ul class="calibre28"><li class="calibre36"><p class="docText">The first stop on your search for community
          resources should be the <a class="docLink" target="_blank" href="http://www.haskell.org/">Haskell
          website</a>. This page contains the most current links to
          various communities and information, as well as a huge and actively
          maintained wiki.</p></li><li class="calibre36"><p class="docText">Haskellers use a number of <a class="docLink" target="_blank" href="http://haskell.org/haskellwiki/Mailing_lists">mailing
          lists</a> for topical discussions. Of these, the most generally
          interesting is named <tt class="calibre34">haskell-cafe</tt>. It has a relaxed,
          friendly atmosphere, where professionals and academics rub shoulders
          with casual hackers and beginners.</p></li><li class="calibre36"><p class="docText">For real-time chat, the <a class="docLink" target="_blank" href="http://haskell.org/haskellwiki/IRC_channel">Haskell IRC
          channel</a>, named <tt class="calibre34">#haskell</tt>, is large and lively.
          Like <tt class="calibre34">haskell-cafe</tt>, the atmosphere stays friendly and
          helpful in spite of the huge number of concurrent users.</p></li><li class="calibre36"><p class="docText">There are many local user groups, meetups, academic
          workshops, and the like; there is <a class="docLink" target="_blank" href="http://haskell.org/haskellwiki/User_groups">a list of the known
          user groups and workshops</a>.</p></li><li class="calibre36"><p class="docText">The <a class="docLink" target="_blank" href="http://sequence.complete.org/">Haskell Weekly News</a> is a
          very-nearly-weekly summary of activities in the Haskell community.
          You can find pointers to interesting mailing list discussions, new
          software releases, and similar things.</p></li><li class="calibre36"><p class="docText">The <a class="docLink" target="_blank" href="http://haskell.org/communities/">Haskell Communities and
          Activities Report</a> collects information about people that use
          Haskell and what they're doing with it. It's been running for years,
          so it provides a good way to peer into Haskell's past.</p></li></ul><a name="I_sect1_d1e636" class="calibre5" id="I_sect1_d1e636"></a><h3 id="643999-801" class="docSection1Title">P.6. Conventions Used in This Book</h3><p class="docText">The following typographical conventions are used in this
    book:</p><dl class="docList"><dt class="calibre20"><br class="calibre20"/><p class="calibre37"><i class="docEmphasis"><span class="docPubcolor">Italic</span></i></p></dt><dd class="calibre38"><p class="docText">Indicates new terms, URLs, email addresses, filenames, and
          file extensions.</p></dd><dt class="calibre20"><br class="calibre20"/><p class="calibre37"><span class="docPubcolor">
<span class="docPubcolor"><span class="docMonofont">Constant width</span></span>
</span></p></dt><dd class="calibre38"><p class="docText">Used for program listings, as well as within paragraphs to
          refer to program elements such as variable or function names,
          databases, data types, environment variables, statements, and
          keywords.</p></dd><dt class="calibre20"><br class="calibre20"/><p class="calibre37"><span class="docPubcolor">
</span><pre class="calibre39"><b class="calibre40">Constant width bold</b></pre>
</p></dt><dd class="calibre38"><p class="docText">Shows commands or other text that should be typed literally by
          the user.</p></dd><dt class="calibre20"><br class="calibre20"/><p class="calibre37"><span class="docPubcolor">
<tt class="calibre34"><i class="docEmphasis">Constant width
        italic</i></tt>
</span></p></dt><dd class="calibre38"><p class="docText">Shows text that should be replaced with user-supplied values
          or by values determined by context.</p></dd></dl><p class="calibre37"><table border="0" cellspacing="0" cellpadding="1" width="90%" class="calibre41"><tr class="calibre16"><td class="v3"><table width="100%" border="0" cellspacing="0" cellpadding="6" class="calibre42"><tr class="calibre16"><td width="60" valign="top" class="v3"><img src="tip_yellow.gif" alt="" class="calibre43"/></td><td valign="top" class="v3"><p class="docText">This icon signifies a tip, suggestion, or general note.</p></td></tr></table></td></tr></table></p><br class="calibre20"/><p class="calibre37"><table border="0" cellspacing="0" cellpadding="1" width="90%" class="calibre41"><tr class="calibre16"><td class="v3"><table width="100%" border="0" cellspacing="0" cellpadding="6" class="calibre42"><tr class="calibre16"><td width="60" valign="top" class="v3"><img src="warning_yellow.gif" alt="" class="calibre44"/></td><td valign="top" class="v3"><p class="docText">This icon indicates a warning or caution.</p></td></tr></table></td></tr></table></p><br class="calibre20"/><a name="I_sect1_d1e675" class="calibre5" id="I_sect1_d1e675"></a><h3 id="643999-801" class="docSection1Title">P.7. Using Code Examples</h3><p class="docText">This book is here to help you get your job done. In general, you may
    use the code in this book in your programs and documentation. You do not
    need to contact us for permission unless you're reproducing a significant
    portion of the code. For example, writing a program that uses several
    chunks of code from this book does not require permission. Selling or
    distributing a CD-ROM of examples from O'Reilly books does require
    permission. Answering a question by citing this book and quoting example
    code does not require permission. Incorporating a significant amount of
    example code from this book into your product's documentation does require
    permission.</p><p class="docText">We appreciate, but do not require, attribution. An attribution
    usually includes the title, author, publisher, and ISBN. For example:
    "<span class="docEmphasis">Real World Haskell</span>, by Bryan O'Sullivan, John
    Goerzen, and Don Stewart. Copyright 2009 Bryan O'Sullivan, John Goerzen,
    and Donald Stewart, 978-0-596-51498-3."</p><p class="docText">If you feel your use of code examples falls outside fair use or the
    permission given above, feel free to contact us at <a class="docLink" href="mailto:permissions@oreilly.com">permissions@oreilly.com</a>.</p><a name="I_sect1_d1e690" class="calibre5" id="I_sect1_d1e690"></a><h3 id="643999-801" class="docSection1Title">P.8. Safari® Books Online</h3><a name="I_sect1_d1e690d1e708" class="calibre5" id="I_sect1_d1e690d1e708"></a><div class="docNote"><p class="docNormalTitle">NOTE</p><p class="calibre37"></p><p class="docText">When you see a Safari® Books Online icon on the cover of your
      favorite technology book, that means the book is available online
      through the O'Reilly Network Safari Bookshelf.</p></div><p class="docText">Safari offers a solution that's better than e-books. It's a virtual
    library that lets you easily search thousands of top tech books, cut and
    paste code samples, download chapters, and find quick answers when you
    need the most accurate, current information. Try it for free at .</p><a name="I_sect1_d1e700" class="calibre5" id="I_sect1_d1e700"></a><h3 id="643999-801" class="docSection1Title">P.9. How to Contact Us</h3><p class="docText">Please address comments and questions concerning this book to the
    publisher:</p><dl class="docList"><dd class="calibre38">O'Reilly Media, Inc.</dd><dd class="calibre38">1005 Gravenstein Highway North</dd><dd class="calibre38">Sebastopol, CA 95472</dd><dd class="calibre38">800-998-9938 (in the United States or Canada)</dd><dd class="calibre38">707-829-0515 (international or local)</dd><dd class="calibre38">707-829-0104 (fax)</dd></dl><p class="docText">We have a web page for this book, where we list errata, examples,
    and any additional information. You can access this page at:</p><dl class="docList"><dd class="calibre38">

</dd></dl><p class="docText">To comment or ask technical questions about this book, send email
    to:</p><dl class="docList"><dd class="calibre38">
<a class="docLink1" href="mailto:bookquestions@oreilly.com">bookquestions@oreilly.com</a>
</dd></dl><p class="docText">For more information about our books, conferences, Resource Centers,
    and the <span class="docEmphasis">O'Reilly</span> Network, see our
    website at:</p><dl class="docList"><dd class="calibre38">
<a class="docLink1" target="_blank" href="http://www.oreilly.com">http://www.oreilly.com</a>
</dd></dl><a name="I_sect1_d1e741" class="calibre5" id="I_sect1_d1e741"></a><h3 id="643999-801" class="docSection1Title">P.10. Acknowledgments</h3><a name="x_wN1" class="calibre5" id="x_wN1"></a><p class="docText">This book would not exist without the Haskell community:
    an anarchic, hopeful cabal of artists, theoreticians and engineers, who
    for 20 years have worked to create a better, bug-free programming world.
    The people of the Haskell community are unique in their combination of
    friendliness and intellectual depth.</p><a name="x_xN1" class="calibre5" id="x_xN1"></a><p class="docText">We wish to thank our editor, Mike Loukides, and the
    production team at O'Reilly for all of their advice and assistance.</p><a name="I_sect1_d1e741d1e769" class="calibre5" id="I_sect1_d1e741d1e769"></a><h4 id="title-IDABZSOB" class="docSection1Title">P.10.1. Bryan</h4><a name="x_yN1" class="calibre5" id="x_yN1"></a><p class="docText">I had a great deal of fun working with John and Don.
      Their independence, good nature, and formidable talent made the writing
      process remarkably smooth.</p><a name="x_zN1" class="calibre5" id="x_zN1"></a><p class="docText">Simon Peyton Jones took a chance on a college student
      who emailed him out of the blue in early 1994. Interning for him over
      that summer remains a highlight of my <span class="docEmphasis">professional</span> life. With his generosity,
      boundless energy, and drive to collaborate, he inspires the whole
      Haskell community.</p><a name="x_AO1" class="calibre5" id="x_AO1"></a><p class="docText">My children, Cian and Ruairi, always stood ready to
      help me to unwind with wonderful, madcap, little-boy games.</p><a name="x_BO1" class="calibre5" id="x_BO1"></a><p class="docText">Finally, of course, I owe a great debt to my wife,
      Shannon, for her love, wisdom, and support during the long gestation of
      this book.</p><a name="I_sect1_d1e741d1e783" class="calibre5" id="I_sect1_d1e741d1e783"></a><h4 id="title-IDAVZSOB" class="docSection1Title">P.10.2. John</h4><a name="x_CO1" class="calibre5" id="x_CO1"></a><p class="docText">I am so glad to be able to work with Bryan and Don on
      this project. The depth of their Haskell knowledge and experience is
      amazing. I enjoyed finally being able to have the three of us sit down
      in the same room—over a year after we started writing.</p><p class="docText">My 2-year-old Jacob, who decided that it would be fun to use a
      keyboard too and was always eager to have me take a break from the
      computer and help him make some fun typing noises on a 50-year-old
      Underwood typewriter.</p><p class="docText">Most importantly, I wouldn't have ever been involved in this
      project without the love, support, and encouragement from my wife,
      Terah.</p><a name="I_sect1_d1e741d1e792" class="calibre5" id="I_sect1_d1e741d1e792"></a><h4 id="title-IDA4ZSOB" class="docSection1Title">P.10.3. Don</h4><a name="x_DO1" class="calibre5" id="x_DO1"></a><p class="docText">Before all else, I'd like to thank my amazing
      coconspirators, John and Bryan, for <span class="docEmphasis">encouragment</span>, advice, and
      motivation.</p><a name="x_EO1" class="calibre5" id="x_EO1"></a><p class="docText">My colleagues at Galois, Inc., who daily wield Haskell
      in the real world, provided regular feedback and war stories and helped
      ensure a steady supply of espresso.</p><a name="x_FO1" class="calibre5" id="x_FO1"></a><p class="docText">My Ph.D. supervisor, Manuel Chakravarty, and the PLS
      research group, who provided encouragement, vision, and energy and
      showed me that a rigorous, foundational approach to programming can make
      the impossible happen.</p><a name="x_GO1" class="calibre5" id="x_GO1"></a><p class="docText">And, finally, thanks to Suzie, for her insight,
      patience, and love.</p><a name="I_sect1_d1e741d1e806" class="calibre5" id="I_sect1_d1e741d1e806"></a><h4 id="title-IDAS0SOB" class="docSection1Title">P.10.4. Thank You to Our Reviewers</h4><a name="x_HO1" class="calibre5" id="x_HO1"></a><p class="docText">We developed this book in the open, posting drafts of
      chapters to our website as we completed them. Readers then submitted
      feedback using a web application that we developed. By the time we
      finished writing the book, about 800 people had submitted over 7,500
      comments—an astounding figure.</p><a name="x_IO1" class="calibre5" id="x_IO1"></a><p class="docText">We deeply appreciate the time that so many people
      volunteered to help us to improve our book. Their encouragement and
      enthusiasm over the 15 months we spent writing made the process a
      pleasure.</p><a name="x_JO1" class="calibre5" id="x_JO1"></a><p class="docText">The breadth and depth of the comments we received have
      profoundly improved the quality of this book. Nevertheless, all errors
      and omissions are, of course, ours.</p><a name="x_KO1" class="calibre5" id="x_KO1"></a><p class="docText">The following people each contributed over 1% of the
      total number of review comments that we received. We would like to thank
      them for their care in providing us with so much detailed
      feedback:</p><a name="x_LO1" class="calibre5" id="x_LO1"></a><p class="docText">Alex Stangl, Andrew Bromage, Brent Yorgey, Bruce
      Turner, Calvin Smith, David Teller, Henry Lenzi, Jay Scott, John Dorsey,
      Justin Dressel, Lauri Pesonen, Lennart Augustsson, Luc Duponcheel, Matt
      Hellige, Michael T. Richter, Peter McLain, Rob deFriesse, Rüdiger Hanke,
      Tim Chevalier, Tim Stewart, William N. Halchin.</p><a name="x_MO1" class="calibre5" id="x_MO1"></a><p class="docText">We are also grateful to the people below, each of whom
      contributed at least 0.2% of all comments:</p><a name="x_NO1" class="calibre5" id="x_NO1"></a><p class="docText">Achim Schneider, Adam Jones, Alexander Semenov, Andrew
      Wagner, Arnar Birgisson, Arthur van Leeuwen, Bartek Cwik<img src="u0142.gif" border="0" class="calibre45"/>owski, Bas Kok,
      Ben Franksen, Björn Buckwalter, Brian Brunswick, Bryn Keller, Chris
      Holliday, Chris Smith, Dan Scott, Dan Weston, Daniel Larsson, Davide
      Marchignoli, Derek Elkins, Dirk Ullrich, Doug Kirk, Douglas Silas,
      Emmanuel Delaborde, Eric Lavigne, Erik Haugen, Erik Jones, Fred Ross,
      Geoff King, George Moschovitis, Hans van Thiel, Ionut Artarisi, Isaac
      Dupree, Isaac Freeman, Jared Updike, Joe Thornber, Joeri van Eekelen,
      Joey Hess, Johan Tibell, John Lenz, Josef Svenningsson, Joseph Garvin,
      Josh Szepietowski, Justin Bailey, Kai Gellien, Kevin Watters, Konrad
      Hinsen, Lally Singh, Lee Duhem, Luke Palmer, Magnus Therning, Marc
      DeRosa, Marcus Eskilsson, Mark Lee Smith, Matthew Danish, Matthew
      Manela, Michael Vanier, Mike Brauwerman, Neil Mitchell, Nick Seow, Pat
      Rondon, Raynor Vliegendhart, Richard Smith, Runar Bjarnason, Ryan W.
      Porter, Salvatore Insalaco, Sean Brewer, Sebastian Sylvan, Sebastien
      Bocq, Sengan Baring-Gould, Serge Le Huitouze, Shahbaz Chaudhary, Shawn M
      Moore, Tom Tschetter, Valery V. Vorotyntsev, Will Newton, Wolfgang
      Meyer, Wouter Swierstra.</p><a name="x_OO1" class="calibre5" id="x_OO1"></a><p class="docText">We would like to acknowledge the following people, many
      of whom submitted a number of comments:</p><a name="x_PO1" class="calibre5" id="x_PO1"></a><p class="docText">Aaron Hall, Abhishek Dasgupta, Adam Copp, Adam Langley,
      Adam Warrington, Adam Winiecki, Aditya Mahajan, Adolfo Builes, Al Hoang,
      Alan Hawkins, Albert Brown, Alec Berryman, Alejandro Dubrovsky, Alex
      Hirzel, Alex Rudnick, Alex Young, Alexander Battisti, Alexander
      Macdonald, Alexander Strange, Alf Richter, Alistair Bayley, Allan Clark,
      Allan Erskine, Allen Gooch, Andre Nathan, Andreas Bernstein, <span class="docEmphasis">Andreas</span> Schropp, Andrei Formiga, Andrew
      Butterfield, Andrew Calleja, Andrew Rimes, Andrew The, Andy Carson, Andy
      Payne, Angelos Sphyris, Ankur Sethi, António Pedro Cunha, Anthony
      Moralez, Antoine Hersen, Antoine Latter, Antoine S., Antonio <span class="docEmphasis">Cangiano</span>, Antonio Piccolboni, Antonios
      Antoniadis, Antonis Antoniadis, Aristotle <span class="docEmphasis">Pagaltzis</span>, Arjen van Schie, Artyom
      Shalkhakov, Ash Logan, Austin Seipp, Avik Das, Avinash Meetoo, BVK
      Chaitanya, Babu Srinivasan, Barry Gaunt, Bas van Dijk, Ben Burdette, Ben
      Ellis, Ben Moseley, Ben Sinclair, Benedikt Huber, Benjamin Terry, Benoit
      Jauvin-Girard, Bernie Pope, Björn Edström, Bob Holness, Bobby Moretti,
      Boyd Adamson, Brad Ediger, Bradley Unterrheiner, Brendan J. Overdiep,
      Brendan Macmillan, Brett Morgan, Brian Bloniarz, Brian Lewis, Brian
      Palmer, Brice Lin, C Russell, Cale Gibbard, Carlos Aya, Chad Scherrer,
      Chaddaï Fouché, Chance Coble, Charles Krohn, Charlie Paucard, Chen
      Yufei, Cheng Wei, Chip Grandits, Chris Ball, Chris Brew, Chris Czub,
      Chris Gallagher, Chris Jenkins, Chris Kuklewicz, Chris Wright, Christian
      <span class="docEmphasis">Lasarczyk</span>, Christian Vest Hansen,
      Christophe Poucet, Chung-chieh Shan, Conal Elliott, Conor McBride,
      Conrad Parker, Cosmo Kastemaa, Creighton Hogg, Crutcher Dunnavant,
      Curtis Warren, D Hardman, Dafydd Harries, Dale Jordan, Dan Doel, Dan
      Dyer, Dan Grover, Dan Orias, Dan Schmidt, Dan Zwell, Daniel Chicayban
      Bastos, Daniel Karch, Daniel Lyons, Daniel Patterson, Daniel Wagner,
      Daniil Elovkov, Danny Yoo, Darren Mutz, Darrin Thompson, Dave Bayer,
      Dave Hinton, Dave Leimbach, Dave Peterson, Dave Ward, David Altenburg,
      David B. Wildgoose, David Carter, David Einstein, David Ellis, David
      Fox, David Frey, David Goodlad, David Mathers, David McBride, David
      Sabel, Dean Pucsek, Denis Bueno, Denis Volk, Devin Mullins, Diego Moya,
      Dino Morelli, Dirk Markert, Dmitry Astapov, Dougal Stanton, Dr Bean,
      Drew Smathers, Duane Johnson, Durward McDonell, E. Jones, Edwin
      DeNicholas, Emre Sevinc, Eric Aguiar, Eric Frey, Eric Kidd, Eric Kow,
      Eric Schwartz, Erik Hesselink, Erling Alf, Eruc Frey, Eugene Grigoriev,
      Eugene Kirpichov, Evan Farrer, Evan Klitzke, Evan Martin, Fawzi Mohamed,
      Filippo Tampieri, Florent Becker, Frank Berthold, Fred <span class="docEmphasis">Rotbart</span>, Frederick Ross, Friedrich
      Dominicus, Gal Amram, Ganesh Sittampalam, Gen Zhang, Geoffrey King,
      George Bunyan, George Rogers, German Vidal, Gilson Silveira, Gleb
      Alexeyev, Glenn Ehrlich, Graham Fawcett, Graham Lowe, Greg Bacon, Greg
      Chrystall, Greg Steuck, Grzegorz Chrupa<img src="u0142.gif" border="0" class="calibre45"/>a, Guillaume Marceau, Haggai
      Eran, Harald Armin Massa, Henning Hasemann, Henry Laxen, Hitesh Jasani,
      Howard B. Golden, Ilmari Vacklin, Imam Tashdid ul Alam, Ivan Lazar
      Miljenovic, Ivan Miljenovic, J. Pablo Fernández, J.A. Zaratiegui, Jaap
      Weel, Jacques Richer, Jake McArthur, Jake Poznanski, Jakub Kotowski,
      Jakub Labath, James Cunningham, James Smith, Jamie Brandon, Jan Sabbe,
      Jared Roberts, Jason Dusek, Jason F, Jason Kikel, Jason Mobarak, Jason
      <span class="docEmphasis">Morton</span>, Jason Rogers, Jeff Balogh,
      Jeff Caldwell, Jeff Petkau, Jeffrey Bolden, Jeremy <span class="docEmphasis">Crosbie</span>, Jeremy Fitzhardinge, Jeremy
      O'Donoghue, Jeroen Pulles, Jim Apple, Jim Crayne, Jim Snow, Joan
      Jiménez, Joe Fredette, Joe Healy, Joel Lathrop, Joeri Samson, Johannes
      Laire, John Cowan, John Doe, John Hamilton, John Hornbeck, John Lien,
      John Stracke, Jonathan Guitton, Joseph Bruce, Joseph H. Buehler, Josh
      Goldfoot, Josh Lee, Josh Stone, Judah Jacobson, Justin George, Justin
      Goguen, Kamal Al-Marhubi, Kamil Dworakowski, Keegan Carruthers-Smith,
      Keith Fahlgren, Keith Willoughby, Ken <span class="docEmphasis">Allen</span>, Ken Shirriff, Kent Hunter, Kevin
      Hely, Kevin Scaldeferri, Kingdon Barrett, Kristjan Kannike, Kurt Jung,
      Lanny Ripple, Laurențiu Nicola, Laurie Cheers, Lennart <span class="docEmphasis">Kolmodin</span>, Liam Groener, Lin Sun, Lionel
      Barret de Nazaris, Loup Vaillant, Luke Plant, Lutz Donnerhacke, Maarten
      Hazewinkel, Malcolm Reynolds, Marco Piccioni, Mark <span class="docEmphasis">Hahnenberg</span>, Mark Woodward, Marko Tosic,
      Markus Schnell, Martijn van Egdom, Martin Bayer, Martin DeMello, Martin
      Dybdal, Martin Geisler, Martin Grabmueller, Matú<img src="u0161.gif" border="0" class="calibre45"/> Teji<img src="u0161.gif" border="0" class="calibre45"/>cák, Mathew
      Manela, Matt Brandt, Matt Russell, Matt Trinneer, Matti <span class="docEmphasis">Niemenmaa</span>, Matti Nykänen, Max Cantor,
      Maxime Henrion, Michael Albert, Michael <span class="docEmphasis">Brauwerman</span>, Michael Campbell, Michael
      Chermside, Michael Cook, Michael <span class="docEmphasis">Dougherty</span>, Michael Feathers, Michael
      Grinder, Michael Kagalenko, Michael Kaplan, Michael <span class="docEmphasis">Orlitzky</span>, Michael Smith, Michael Stone,
      Michael Walter, Michel Salim, <span class="docEmphasis">Mikael</span> <span class="docEmphasis">Vejdemo</span> Johansson, Mike Coleman, Mike
      Depot, Mike Tremoulet, Mike Vanier, Mirko Rahn, Miron Brezuleanu, Morten
      <span class="docEmphasis">Andersen</span>, Nathan Bronson, Nathan
      Stien, Naveen Nathan, Neil Bartlett, Neil Whitaker, Nick Gibson, Nick
      Messenger, Nick Okasinski, Nicola Paolucci, Nicolas Frisby, Niels Aan de
      Brugh, Niels Holmgaard Andersen, Nima <span class="docEmphasis">Negahban</span>, Olaf Leidinger, Oleg Anashkin,
      Oleg Dopertchouk, Oleg Taykalo, Oliver Charles, Olivier Boudry, Omar
      Antolín Camarena, Parnell Flynn, Patrick Carlisle, Paul Brown, Paul
      Delhanty, Paul Johnson, Paul Lotti, Paul Moore, Paul Stanley, Paulo
      <span class="docEmphasis">Tanimoto</span>, Per Vognsen, Pete
      Kazmier, Peter Aarestad, Peter Ipacs, Peter Kovaliov, Peter Merel, Peter
      Seibel, Peter Sumskas, Phil Armstrong, Philip Armstrong, Philip Craig,
      Philip Neustrom, Philip Turnbull, Piers Harding, Piet Delport, Pragya
      Agarwal, Raúl Gutiérrez, Rafael Alemida, Rajesh Krishnan, Ralph Glass,
      Rauli <span class="docEmphasis">Ruohonen</span>, Ravi Nanavati,
      Raymond Pasco, Reid Barton, Reto Kramer, Reza Ziaei, Rhys Ulerich,
      <span class="docEmphasis">Ricardo</span> Herrmann, Richard Harris,
      Richard Warburton, Rick van Hattem, Rob Grainger, Robbie Kop, Rogan
      Creswick, Roman Gonzalez, Rory Winston, <span class="docEmphasis">Ruediger</span> Hanke, Rusty Mellinger, Ryan
      Grant, Ryan Ingram, Ryan Janzen, Ryan Kaulakis, Ryan <span class="docEmphasis">Stutsman</span>, Ryan T. Mulligan, S Pai, Sam
      Lee, Sandy Nicholson, Scott Brickner, Scott Rankin, Scott Ribe, Sean
      Cross, Sean Leather, Sergei Trofimovich, Sergio <span class="docEmphasis">Urinovsky</span>, Seth <span class="docEmphasis">Gordon</span>, Seth Tisue, Shawn Boyette, Simon
      Brenner, Simon Farnsworth, Simon Marlow, Simon Meier, Simon Morgan,
      Sriram Srinivasan, Stefan Aeschbacher, Stefan Muenzel, <span class="docEmphasis">Stephan</span> Friedrichs, Stephan Nies,
      Stephan-A. Posselt, Stephyn Butcher, Steven Ashley, Stuart Dootson,
      Terry Michaels, Thomas Cellerier, Thomas Fuhrmann, Thomas <span class="docEmphasis">Hunger</span>, Thomas M. DuBuisson, Thomas
      Moertel, Thomas <span class="docEmphasis">Schilling</span>,
      Thorsten Seitz, Tibor Simic, Tilo Wiklund, Tim Clark, Tim Eves, Tim
      <span class="docEmphasis">Massingham</span>, Tim Rakowski, Tim
      Wiess, Timo B. Hübel, Timothy Fitz, Tom Moertel, Tomá<img src="u0161.gif" border="0" class="calibre45"/> Janou<img src="u0161.gif" border="0" class="calibre45"/>ek, Tony
      <span class="docEmphasis">Colston</span>, Travis B. Hartwell,
      Tristan Allwood, Tristan Seligmann, Tristram Brelstaff, Vesa <span class="docEmphasis">Kaihlavirta</span>, Victor Nazarov, Ville Aine,
      Vincent Foley, Vipul Ved Prakash, Vlad Skvortsov, Vojtech Fried, Wei
      Cheng, Wei Hu, Will Barrett, Will Farr, Will Leinweber, Will <span class="docEmphasis">Robertson</span>, Will Thompson, Wirt Wolff,
      Wolfgang Jeltsch, Yuval Kogman, Zach Kozatek, Zachary Smestad, Zohar
      Kelrich.</p><a name="x_QO1" class="calibre5" id="x_QO1"></a><p class="docText">Finally, we wish to thank those readers who submitted
      over 800 comments <span class="docEmphasis">anonymously</span>.</p>
<ul class="calibre28"></ul><table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody"><tr class="calibre6"><td valign="middle" class="v1" height="5"><img src="pixel.gif" alt="" border="0" class="calibre8"/></td></tr><tr class="calibre6"><td valign="middle" class="v1"><table cellpadding="0" cellspacing="0" border="0" width="100%" class="sfbody"><tr class="calibre6"><td class="v"><span class="calibre9"> </span>
                   
                  <span class="calibre9">   </span>
             <span class="calibre9"> </span></td></tr></table></td><td class="v1"/><td valign="middle" class="v2"><a href="21061538.html" class="calibre13"><img src="btn_next_.gif" alt="Next" border="0" class="calibre26"/></a> 
           
          <span class="calibre9"><a target="_self" href="_dedication.html" title="Previous section" class="calibre13"><img border="0" src="btn_prev.gif" alt="Previous section" id="btn_prev" class="calibre14"/></a></span>
				
				 
				
				<span class="calibre9"><a target="_self" href="starting_split_000.html" title="Next section" class="calibre13"><img border="0" src="btn_next.gif" alt="Next section" id="btn_next" class="calibre14"/></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2" class="sfbody"><tr class="calibre6"><td valign="top" class="v2"><span class="calibre9"></span></td></tr></table><!--IP User 2--><td class="calibre7">
                         
                      </td><tr class="calibre6"><td colspan="3" valign="bottom" class="calibre7"><br class="calibre20"/><p class="v4"></p><br class="calibre20"/></td></tr></div>

{% endraw %}

