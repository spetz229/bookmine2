---
layout: page
title: "Java Concurrency in Practice"
prev: ch03lev1sec2.html
next: ch03lev1sec4.html
book_path: books/brian-goetz-tim-peierls-joshua-bloch-joseph-bowbeer-david-holmes-doug-lea-java-concurrency-in-practice--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a href="21021536.html" class="calibre2"><img src="pixel.jpg" alt="" border="0" class="calibre26"/></a><a name="ch03lev1sec3" class="calibre18" id="ch03lev1sec3"></a>
<h3 id="title-IDA3ILNJ" class="docSection1Title">3.3. Thread Confinement</h3>
<p class="docText1">Accessing shared, mutable data requires using synchronization; one way to avoid this requirement is to <span class="docEmphasis">not share</span>. If data is only accessed from a single thread, no synchronization is needed. This technique, <span class="docEmphasis">thread confinement</span>, is one of the simplest ways to achieve thread safety. When an object is confined to a thread, such usage is automatically thread-safe even if the confined object itself is not [CPJ 2.3.2].</p>
<p class="docText1">Swing uses thread confinement extensively. The Swing visual components and data model objects are not thread safe; instead, safety is achieved by confining them to the Swing event dispatch thread. To use Swing properly, code running in threads other than the event thread should not access these objects. (To make this easier, Swing provides the <tt class="calibre25">invokeLater</tt> mechanism to schedule a <tt class="calibre25">Runnable</tt> for <a name="iddle1046" class="calibre18" id="iddle1046"></a><a name="iddle1539" class="calibre18" id="iddle1539"></a><a name="iddle1547" class="calibre18" id="iddle1547"></a><a name="iddle1548" class="calibre18" id="iddle1548"></a><a name="iddle1782" class="calibre18" id="iddle1782"></a><a name="iddle1783" class="calibre18" id="iddle1783"></a><a name="iddle1798" class="calibre18" id="iddle1798"></a><a name="iddle1799" class="calibre18" id="iddle1799"></a><a name="iddle1931" class="calibre18" id="iddle1931"></a><a name="iddle2395" class="calibre18" id="iddle2395"></a><a name="iddle2905" class="calibre18" id="iddle2905"></a><a name="iddle2906" class="calibre18" id="iddle2906"></a><a name="iddle2907" class="calibre18" id="iddle2907"></a><a name="iddle3035" class="calibre18" id="iddle3035"></a><a name="iddle3601" class="calibre18" id="iddle3601"></a><a name="iddle4298" class="calibre18" id="iddle4298"></a><a name="iddle4751" class="calibre18" id="iddle4751"></a><a name="iddle4851" class="calibre18" id="iddle4851"></a><a name="iddle5128" class="calibre18" id="iddle5128"></a>execution in the event thread.) Many concurrency errors in Swing applications stem from improper use of these confined objects from another thread.</p>
<p class="docText1">Another common application of thread confinement is the use of pooled JDBC (Java Database Connectivity) <tt class="calibre25">Connection</tt> objects. The JDBC specification does not require that <tt class="calibre25">Connection</tt> objects be thread-safe.<sup class="docFootnote"><a class="calibre2" href="#ch03fn09">[9]</a></sup> In typical server applications, a thread acquires a connection from the pool, uses it for processing a single request, and returns it. Since most requests, such as servlet requests or EJB (Enterprise JavaBeans) calls, are processed synchronously by a single thread, and the pool will not dispense the same connection to another thread until it has been returned, this pattern of connection management implicitly confines the <tt class="calibre25">Connection</tt> to that thread for the duration of the request.</p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch03fn09" class="calibre18" id="ch03fn09">[9]</a></sup> The connection <span class="docEmphasis">pool</span> implementations provided by application servers are thread-safe; connection pools are necessarily accessed from multiple threads, so a non-thread-safe implementation would not make sense.</p></blockquote>
<p class="docText1">Just as the language has no mechanism for enforcing that a variable is guarded by a lock, it has no means of confining an object to a thread. Thread confinement is an element of your program's design that must be enforced by its implementation. The language and core libraries provide mechanisms that can help in maintaining thread confinementlocal variables and the <tt class="calibre25">ThreadLocal</tt> classbut even with these, it is still the programmer's responsibility to ensure that thread-confined objects do not escape from their intended thread.</p>
<a name="ch03lev2sec6" class="calibre18" id="ch03lev2sec6"></a>
<h4 id="title-IDAGRLNJ" class="docSection2Title">3.3.1. Ad-hoc Thread Confinement</h4>
<p class="docText1"><span class="docEmphasis">Ad-hoc thread confinement</span> describes when the responsibility for maintaining thread confinement falls entirely on the implementation. Ad-hoc thread confinement can be fragile because none of the language features, such as visibility modifiers or local variables, helps confine the object to the target thread. In fact, references to thread-confined objects such as visual components or data models in GUI applications are often held in public fields.</p>
<p class="docText1">The decision to use thread confinement is often a consequence of the decision to implement a particular subsystem, such as the GUI, as a single-threaded subsystem. Single-threaded subsystems can sometimes offer a simplicity benefit that outweighs the fragility of ad-hoc thread confinement.<sup class="docFootnote"><a class="calibre2" href="#ch03fn10">[10]</a></sup></p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch03fn10" class="calibre18" id="ch03fn10">[10]</a></sup> Another reason to make a subsystem single-threaded is deadlock avoidance; this is one of the primary reasons most GUI frameworks are single-threaded. Single-threaded subsystems are covered in <a class="calibre2" href="ch09.html#ch09">Chapter 9</a>.</p></blockquote>
<p class="docText1">A special case of thread confinement applies to volatile variables. It is safe to perform read-modify-write operations on shared volatile variables as long as you ensure that the volatile variable is only written from a single thread. In this case, you are confining the <span class="docEmphasis">modification</span> to a single thread to prevent race conditions, and the visibility guarantees for volatile variables ensure that other threads see the most up-to-date value.</p>
<p class="docText1">Because of its fragility, ad-hoc thread confinement should be used sparingly; if possible, use one of the stronger forms of thread confinment (stack confinement or <tt class="calibre25">ThreadLocal</tt>) instead.</p>
<a name="ch03lev2sec7" class="calibre18" id="ch03lev2sec7"></a>
<h4 id="title-IDAQSLNJ" class="docSection2Title">3.3.2. Stack Confinement</h4>
<p class="docText1"><a name="iddle1535" class="calibre18" id="iddle1535"></a><a name="iddle1536" class="calibre18" id="iddle1536"></a><a name="iddle2013" class="calibre18" id="iddle2013"></a><a name="iddle2402" class="calibre18" id="iddle2402"></a><a name="iddle2850" class="calibre18" id="iddle2850"></a><a name="iddle3036" class="calibre18" id="iddle3036"></a><a name="iddle3360" class="calibre18" id="iddle3360"></a><a name="iddle3361" class="calibre18" id="iddle3361"></a><a name="iddle3653" class="calibre18" id="iddle3653"></a><a name="iddle3654" class="calibre18" id="iddle3654"></a><a name="iddle3821" class="calibre18" id="iddle3821"></a><a name="iddle3822" class="calibre18" id="iddle3822"></a><a name="iddle4356" class="calibre18" id="iddle4356"></a><a name="iddle4357" class="calibre18" id="iddle4357"></a><a name="iddle4358" class="calibre18" id="iddle4358"></a><a name="iddle4756" class="calibre18" id="iddle4756"></a><a name="iddle4757" class="calibre18" id="iddle4757"></a><a name="iddle5052" class="calibre18" id="iddle5052"></a><a name="iddle5053" class="calibre18" id="iddle5053"></a><span class="docEmphasis">Stack confinement</span> is a special case of thread confinement in which an object can only be reached through local variables. Just as encapsulation can make it easier to preserve invariants, local variables can make it easier to confine objects to a thread. Local variables are intrinsically confined to the executing thread; they exist on the executing thread's stack, which is not accessible to other threads. Stack confinement (also called <span class="docEmphasis">within-thread</span> or <span class="docEmphasis">thread-local</span> usage, but not to be confused with the <tt class="calibre25">THReadLocal</tt> library class) is simpler to maintain and less fragile than ad-hoc thread confinement.</p>
<p class="docText1">For primitively typed local variables, such as <tt class="calibre25">numPairs</tt> in <tt class="calibre25">loadTheArk</tt> in <a class="calibre2" href="#ch03list09">Listing 3.9</a>, you cannot violate stack confinement even if you tried. There is no way to obtain a reference to a primitive variable, so the language semantics ensure that primitive local variables are always stack confined.</p>
<a name="ch03list09" class="calibre18" id="ch03list09"></a><h5 id="title-IDAR0LNJ" class="docExampleTitle">Listing 3.9. Thread Confinement of Local Primitive and Reference Variables.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">public int loadTheArk(Collection&lt;Animal&gt; candidates) {
    SortedSet&lt;Animal&gt; animals;
    int numPairs = 0;
    Animal candidate = null;

    <span class="docEmphasis">// animals confined to method, don't let them escape!</span>
    animals = new TreeSet&lt;Animal&gt;(new SpeciesGenderComparator());
    animals.addAll(candidates);
    for (Animal a : animals) {
        if (candidate == null || !candidate.isPotentialMate(a))
            candidate = a;
        else {
            ark.load(new AnimalPair(candidate, a));
            ++numPairs;
            candidate = null;
        }
    }
    return numPairs;
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1">Maintaining stack confinement for object references requires a little more assistance from the programmer to ensure that the referent does not escape. In <tt class="calibre25">loadTheArk</tt>, we instantiate a <tt class="calibre25">treeSet</tt> and store a reference to it in <tt class="calibre25">animals</tt>. At this point, there is exactly one reference to the <tt class="calibre25">Set</tt>, held in a local variable and therefore confined to the executing thread. However, if we were to publish a reference to the <tt class="calibre25">Set</tt> (or any of its internals), the confinement would be violated and the animals would escape.</p>
<p class="docText1">Using a non-thread-safe object in a within-thread context is still thread-safe. However, be careful: the design requirement that the object be confined to the executing thread, or the awareness that the confined object is not thread-safe, <a name="iddle1546" class="calibre18" id="iddle1546"></a><a name="iddle1549" class="calibre18" id="iddle1549"></a><a name="iddle1965" class="calibre18" id="iddle1965"></a><a name="iddle2448" class="calibre18" id="iddle2448"></a><a name="iddle2449" class="calibre18" id="iddle2449"></a><a name="iddle4305" class="calibre18" id="iddle4305"></a><a name="iddle4306" class="calibre18" id="iddle4306"></a><a name="iddle4670" class="calibre18" id="iddle4670"></a><a name="iddle4671" class="calibre18" id="iddle4671"></a><a name="iddle4758" class="calibre18" id="iddle4758"></a><a name="iddle4849" class="calibre18" id="iddle4849"></a><a name="iddle5062" class="calibre18" id="iddle5062"></a>often exists only in the head of the developer when the code is written. If the assumption of within-thread usage is not clearly documented, future maintainers might mistakenly allow the object to escape.</p>
<a name="ch03lev2sec8" class="calibre18" id="ch03lev2sec8"></a>
<h4 id="title-IDAV5LNJ" class="docSection2Title">3.3.3. ThreadLocal</h4>
<p class="docText1">A more formal means of maintaining thread confinement is <tt class="calibre25">ThreadLocal</tt>, which allows you to associate a per-thread value with a value-holding object. <tt class="calibre25">Thread-Local</tt> provides <tt class="calibre25">get</tt> and <tt class="calibre25">set</tt> accessormethods that maintain a separate copy of the value for each thread that uses it, so a <tt class="calibre25">get</tt> returns the most recent value passed to <tt class="calibre25">set</tt> <span class="docEmphasis">from the currently executing thread</span>.</p>
<p class="docText1">Thread-local variables are often used to prevent sharing in designs based on mutable Singletons or global variables. For example, a single-threaded application might maintain a global database connection that is initialized at startup to avoid having to pass a <tt class="calibre25">Connection</tt> to every method. Since JDBC connections may not be thread-safe, a multithreaded application that uses a global connection without additional coordination is not thread-safe either. By using a <tt class="calibre25">ThreadLocal</tt> to store the JDBC connection, as in <tt class="calibre25">ConnectionHolder</tt> in <a class="calibre2" href="#ch03list10">Listing 3.10</a>, each thread will have its own connection.</p>
<a name="ch03list10" class="calibre18" id="ch03list10"></a><h5 id="title-IDADBMNJ" class="docExampleTitle">Listing 3.10. Using <tt class="calibre33">ThreadLocal</tt> to Ensure thread Confinement.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">private static ThreadLocal&lt;Connection&gt; connectionHolder
    = new ThreadLocal&lt;Connection&gt;() {
        public Connection initialValue() {
            return DriverManager.getConnection(DB_URL);
        }
    };

public static Connection getConnection() {
    return connectionHolder.get();
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1">This technique can also be used when a frequently used operation requires a temporary object such as a buffer and wants to avoid reallocating the temporary object on each invocation. For example, before Java 5.0, <tt class="calibre25">Integer.toString</tt> used a <tt class="calibre25">ThreadLocal</tt> to store the 12-byte buffer used for formatting its result, rather than using a shared static buffer (which would require locking) or allocating a new buffer for each invocation.<sup class="docFootnote"><a class="calibre2" href="#ch03fn11">[11]</a></sup></p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch03fn11" class="calibre18" id="ch03fn11">[11]</a></sup> This technique is unlikely to be a performance win unless the operation is performed very frequently or the allocation is unusually expensive. In Java 5.0, it was replaced with the more straightforward approach of allocating a new buffer for every invocation, suggesting that for something as mundane as a temporary buffer, it is not a performance win.</p></blockquote>
<p class="docText1">When a thread calls <tt class="calibre25">ThreadLocal.get</tt> for the first time, <tt class="calibre25">initialValue</tt> is consulted to provide the initial value for that thread. Conceptually, you can think of a <tt class="calibre25">ThreadLocal&lt;T&gt;</tt> as holding a <tt class="calibre25">Map&lt;Thread,T&gt;</tt> that stores the thread-specific <a name="iddle1109" class="calibre18" id="iddle1109"></a><a name="iddle1983" class="calibre18" id="iddle1983"></a><a name="iddle2408" class="calibre18" id="iddle2408"></a><a name="iddle2409" class="calibre18" id="iddle2409"></a><a name="iddle2532" class="calibre18" id="iddle2532"></a><a name="iddle2705" class="calibre18" id="iddle2705"></a><a name="iddle2706" class="calibre18" id="iddle2706"></a><a name="iddle2711" class="calibre18" id="iddle2711"></a><a name="iddle2860" class="calibre18" id="iddle2860"></a><a name="iddle2861" class="calibre18" id="iddle2861"></a><a name="iddle3350" class="calibre18" id="iddle3350"></a><a name="iddle4126" class="calibre18" id="iddle4126"></a><a name="iddle4127" class="calibre18" id="iddle4127"></a><a name="iddle4852" class="calibre18" id="iddle4852"></a>values, though this is not how it is actually implemented. The thread-specific values are stored in the <tt class="calibre25">Thread</tt> object itself; when the thread terminates, the thread-specific values can be garbage collected.</p>
<p class="docText1">If you are porting a single-threaded application to a multithreaded environment, you can preserve thread safety by converting shared global variables into <tt class="calibre25">ThreadLocal</tt>s, if the semantics of the shared globals permits this; an applicationwide cache would not be as useful if it were turned into a number of thread-local caches.</p>
<p class="docText1"><tt class="calibre25">ThreadLocal</tt> is widely used in implementing application frameworks. For example, J2EE containers associate a transaction context with an executing thread for the duration of an EJB call. This is easily implemented using a static <tt class="calibre25">THRead-Local</tt> holding the transaction context: when framework code needs to determine what transaction is currently running, it fetches the transaction context from this <tt class="calibre25">ThreadLocal</tt>. This is convenient in that it reduces the need to pass execution context information into every method, but couples any code that uses this mechanism to the framework.</p>
<p class="docText1">It is easy to abuse <tt class="calibre25">THReadLocal</tt> by treating its thread confinement property as a license to use global variables or as a means of creating "hidden" method arguments. Like global variables, thread-local variables can detract from reusability and introduce hidden couplings among classes, and should therefore be used with care.</p>
<a href="21021536.html" class="calibre2"><img src="pixel.jpg" alt="" border="0" class="calibre26"/></a>
<p class="calibre3"> </p>

</div>

{% endraw %}

