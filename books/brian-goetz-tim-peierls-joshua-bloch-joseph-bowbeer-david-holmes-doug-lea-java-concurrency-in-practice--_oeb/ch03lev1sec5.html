---
layout: page
title: "Java Concurrency in Practice"
prev: ch03lev1sec4.html
next: ch04.html
book_path: books/brian-goetz-tim-peierls-joshua-bloch-joseph-bowbeer-david-holmes-doug-lea-java-concurrency-in-practice--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="ch03lev1sec5" class="calibre18" id="ch03lev1sec5"></a>
<h3 id="631532-902" class="docSection1Title">3.5. Safe Publication</h3>
<p class="docText1">So far we have focused on ensuring that an object <span class="docEmphasis">not</span> be published, such as when it is supposed to be confined to a thread or within another object. Of course, sometimes we <span class="docEmphasis">do</span> want to share objects across threads, and in this case we must do so safely. Unfortunately, simply storing a reference to an object into a public field, as in <a class="calibre2" href="#ch03list14">Listing 3.14</a>, is <span class="docEmphasis">not</span> enough to publish that object safely.</p>
<p class="docText1"></p><a name="ch03list13" class="calibre18" id="ch03list13"></a><h5 id="title-IDA3ULNJ" class="docExampleTitle">Listing 3.13. Caching the Last Result Using a Volatile Reference to an Immutable Holder Object.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">@ThreadSafe
public class VolatileCachedFactorizer implements Servlet {
    private volatile OneValueCache cache =
        new OneValueCache(null, null);

    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = cache.getFactors(i);
        if (factors == null) {
            factors = factor(i);
            cache = new OneValueCache(i, factors);
        }
        encodeIntoResponse(resp, factors);
    }
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<a name="ch03list14" class="calibre18" id="ch03list14"></a><h5 id="title-IDAOVLNJ" class="docExampleTitle">Listing 3.14. Publishing an Object without Adequate Synchronization. <span class="docEmphasis">Don't Do this.</span></h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<img border="0" alt="" id="195131084199" src="face.jpg" class="calibre29"/>
<pre class="calibre30"><span class="docEmphasis">// Unsafe publication</span>
public Holder holder;

public void initialize() {
    holder = new Holder(42);
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1"><a name="iddle1569" class="calibre18" id="iddle1569"></a><a name="iddle1570" class="calibre18" id="iddle1570"></a><a name="iddle2216" class="calibre18" id="iddle2216"></a><a name="iddle3723" class="calibre18" id="iddle3723"></a>You may be surprised at how badly this harmless-looking example could fail. Because of visibility problems, the <tt class="calibre25">Holder</tt> could appear to another thread to be in an inconsistent state, even though its invariants were properly established by its constructor! This improper publication could allow another thread to observe a <span class="docEmphasis">partially constructed object</span>.</p>
<a name="ch03lev2sec11" class="calibre18" id="ch03lev2sec11"></a>
<h4 id="title-IDA1XLNJ" class="docSection2Title">3.5.1. Improper Publication: When Good Objects Go Bad</h4>
<p class="docText1">You cannot rely on the integrity of partially constructed objects. An observing thread could see the object in an inconsistent state, and then later see its state suddenly change, even though it has not been modified since publication. In fact, if the <tt class="calibre25">Holder</tt> in <a class="calibre2" href="#ch03list15">Listing 3.15</a> is published using the unsafe publication idiom in <a class="calibre2" href="#ch03list14">Listing 3.14</a>, and a thread other than the publishing thread were to call <tt class="calibre25">assertSanity</tt>, it could throw <tt class="calibre25">AssertionError</tt>!<sup class="docFootnote"><a class="calibre2" href="#ch03fn15">[15]</a></sup></p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch03fn15" class="calibre18" id="ch03fn15">[15]</a></sup> The problem here is not the <tt class="calibre35">Holder</tt> class itself, but that the <tt class="calibre35">Holder</tt> is not properly published. However, <tt class="calibre35">Holder</tt> can be made immune to improper publication by declaring the <tt class="calibre35">n</tt> field to be <tt class="calibre35">final</tt>, which would make <tt class="calibre35">Holder</tt> immutable; see <a class="calibre2" href="#ch03lev2sec12">Section 3.5.2</a>.</p></blockquote>
<p class="docText1"></p><a name="ch03list15" class="calibre18" id="ch03list15"></a><h5 id="title-IDAXZLNJ" class="docExampleTitle">Listing 3.15. Class at Risk of Failure if Not Properly Published.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<img border="0" alt="" id="195131084199" src="face1.jpg" class="calibre31"/>
<pre class="calibre30">public class Holder {
    private int n;

    public Holder(int n) { this.n = n; }

    public void assertSanity() {
        if (n != n)
            throw new AssertionError("This statement is false.");
    }
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1"><a name="iddle2150" class="calibre18" id="iddle2150"></a><a name="iddle2709" class="calibre18" id="iddle2709"></a><a name="iddle2718" class="calibre18" id="iddle2718"></a><a name="iddle2740" class="calibre18" id="iddle2740"></a><a name="iddle2741" class="calibre18" id="iddle2741"></a><a name="iddle2896" class="calibre18" id="iddle2896"></a><a name="iddle3351" class="calibre18" id="iddle3351"></a><a name="iddle3722" class="calibre18" id="iddle3722"></a><a name="iddle4033" class="calibre18" id="iddle4033"></a><a name="iddle4034" class="calibre18" id="iddle4034"></a><a name="iddle4365" class="calibre18" id="iddle4365"></a>Because synchronization was not used to make the <tt class="calibre25">Holder</tt> visible to other threads, we say the <tt class="calibre25">Holder</tt> was <span class="docEmphasis">not properly published</span>. Two things can go wrong with improperly published objects. Other threads could see a stale value for the <tt class="calibre25">holder</tt> field, and thus see a <tt class="calibre25">null</tt> reference or other older value even though a value has been placed in <tt class="calibre25">holder</tt>. But far worse, other threads could see an up-todate value for the <tt class="calibre25">holder</tt> reference, but stale values for the <span class="docEmphasis">state</span> of the <tt class="calibre25">Holder</tt>.<sup class="docFootnote"><a class="calibre2" href="#ch03fn16">[16]</a></sup> To make things even less predictable, a thread may see a stale value the first time it reads a field and then a more up-to-date value the next time, which is why <tt class="calibre25">assertSanity</tt> can throw <tt class="calibre25">AssertionError</tt>.</p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch03fn16" class="calibre18" id="ch03fn16">[16]</a></sup> While it may seem that field values set in a constructor are the first values written to those fields and therefore that there are no "older" values to see as stale values, the <tt class="calibre35">Object</tt> constructor first writes the default values to all fields before subclass constructors run. It is therefore possible to see the default value for a field as a stale value.</p></blockquote>
<p class="docText1">At the risk of repeating ourselves, some very strange things can happen when data is shared across threads without sufficient synchronization.</p>
<a name="ch03lev2sec12" class="calibre18" id="ch03lev2sec12"></a>
<h4 id="title-IDAS5LNJ" class="docSection2Title">3.5.2. Immutable Objects and Initialization Safety</h4>
<p class="docText1">Because immutable objects are so important, the JavaMemory Model offers a special guarantee of <span class="docEmphasis">initialization safety</span> for sharing immutable objects. As we've seen, that an object reference becomes visible to another thread does not necessarily mean that the state of that object is visible to the consuming thread. In order to guarantee a consistent view of the object's state, synchronization is needed.</p>
<p class="docText1">Immutable objects, on the other hand, can be safely accessed <span class="docEmphasis">even when synchronization is not used to publish the object reference</span>. For this guarantee of initialization safety to hold, all of the requirements for immutability must be met: unmodi-fiable state, all fields are <tt class="calibre25">final</tt>, and proper construction. (If <tt class="calibre25">Holder</tt> in <a class="calibre2" href="#ch03list15">Listing 3.15</a> were immutable, <tt class="calibre25">assertSanity</tt> could not throw <tt class="calibre25">AssertionError</tt>, even if the <tt class="calibre25">Holder</tt> was not properly published.)</p>
<a name="ch03sb09" class="calibre18" id="ch03sb09"></a><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<p class="docText1"><span class="docEmphasis">Immutable</span> objects can be used safely by any thread without additional synchronization, even when synchronization is not used to publish them.</p>
</td></tr></table></p><p class="calibre1"> </p>
<p class="docText1">This guarantee extends to the values of all final fields of properly constructed objects; final fields can be safely accessed without additional synchronization. However, if final fields refer to mutable objects, synchronization is still required to access the state of the objects they refer to.</p>
<a name="ch03lev2sec13" class="calibre18" id="ch03lev2sec13"></a>
<h4 id="title-IDAHBMNJ" class="docSection2Title">3.5.3. Safe Publication Idioms</h4>
<p class="docText1">Objects that are not immutable must be <span class="docEmphasis">safely published</span>, which usually entails synchronization by both the publishing and the consuming thread. For the moment, let's focus on ensuring that the consuming thread can see the object in its aspublished state; we'll deal with visibility of modifications made after publication soon.</p>
<a name="ch03sb10" class="calibre18" id="ch03sb10"></a><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<p class="docText1">To publish an object safely, both the reference to the object and the object's state must be made visible to other threads at the same time. A properly constructed object can be safely published by:</p>
<ul class="calibre15"><li class="calibre16"><p class="docText1">Initializing an object reference from a static initializer;</p></li><li class="calibre16"><p class="docText1">Storing a reference to it into a <tt class="calibre25">volatile</tt> field or <tt class="calibre25">AtomicReference</tt>;</p></li><li class="calibre16"><p class="docText1">Storing a reference to it into a <tt class="calibre25">final</tt> field of a properly constructed object; or</p></li><li class="calibre16"><p class="docText1">Storing a reference to it into a field that is properly guarded by a lock.</p></li></ul>
</td></tr></table></p><p class="calibre1"> </p>
<p class="docText1">The internal synchronization in thread-safe collections means that placing an object in a thread-safe collection, such as a <tt class="calibre25">Vector</tt> or <tt class="calibre25">synchronizedList</tt>, fulfills the last of these requirements. If thread <span class="docEmphasis">A</span> places object <span class="docEmphasis">X</span> in a thread-safe collection and thread <span class="docEmphasis">B</span> subsequently retrieves it, <span class="docEmphasis">B</span> is guaranteed to see the state of <span class="docEmphasis">X</span> as <span class="docEmphasis">A</span> left it, even though the application code that hands <span class="docEmphasis">X</span> off in this manner has no <span class="docEmphasis">explicit</span> synchronization. The thread-safe library collections offer the following safe publication guarantees, even if the Javadoc is less than clear on the subject:</p>
<ul class="calibre15"><li class="calibre16"><p class="docText1">Placing a key or value in a <tt class="calibre25">Hashtable</tt>, <tt class="calibre25">synchronizedMap</tt>, or <tt class="calibre25">Concurrent-Map</tt> safely publishes it to any thread that retrieves it from the <tt class="calibre25">Map</tt> (whether directly or via an iterator);</p></li><li class="calibre16"><p class="docText1">Placing an element in a <tt class="calibre25">Vector</tt>, <tt class="calibre25">CopyOnWriteArrayList</tt>, <tt class="calibre25">CopyOnWrite-ArraySet</tt>, <tt class="calibre25">synchronizedList</tt>, or <tt class="calibre25">synchronizedSet</tt> safely publishes it to any thread that retrieves it from the collection;</p></li><li class="calibre16"><p class="docText1">Placing an element on a <tt class="calibre25">BlockingQueue</tt> or a <tt class="calibre25">ConcurrentLinkedQueue</tt> safely publishes it to any thread that retrieves it from the queue.</p></li></ul>
<p class="docText1"><a name="iddle1785" class="calibre18" id="iddle1785"></a><a name="iddle1786" class="calibre18" id="iddle1786"></a><a name="iddle2240" class="calibre18" id="iddle2240"></a><a name="iddle2426" class="calibre18" id="iddle2426"></a><a name="iddle2530" class="calibre18" id="iddle2530"></a><a name="iddle2531" class="calibre18" id="iddle2531"></a><a name="iddle2708" class="calibre18" id="iddle2708"></a><a name="iddle2888" class="calibre18" id="iddle2888"></a><a name="iddle3348" class="calibre18" id="iddle3348"></a><a name="iddle4437" class="calibre18" id="iddle4437"></a><a name="iddle4438" class="calibre18" id="iddle4438"></a><a name="iddle4439" class="calibre18" id="iddle4439"></a>Other handoff mechanisms in the class library (such as <tt class="calibre25">Future</tt> and <tt class="calibre25">Exchanger</tt>) also constitute safe publication; we will identify these as providing safe publication as they are introduced.</p>
<p class="docText1">Using a static initializer is often the easiest and safest way to publish objects that can be statically constructed:</p>
<div class="docText2"><pre class="calibre36">public static Holder holder = new Holder(42);
</pre></div><p class="calibre1"> </p>
<p class="docText1">Static initializers are executed by the JVM at class initialization time; because of internal synchronization in the JVM, this mechanism is guaranteed to safely publish any objects initialized in this way [JLS 12.4.2].</p>
<a name="ch03lev2sec14" class="calibre18" id="ch03lev2sec14"></a>
<h4 id="title-IDAGJMNJ" class="docSection2Title">3.5.4. Effectively Immutable Objects</h4>
<p class="docText1">Safe publication is sufficient for other threads to safely access objects that are not going to be modified after publication without additional synchronization. The safe publication mechanisms all guarantee that the as-published state of an object is visible to all accessing threads as soon as the reference to it is visible, and if that state is not going to be changed again, this is sufficient to ensure that any access is safe.</p>
<p class="docText1">Objects that are not technically immutable, but whose state will not be modified after publication, are called <span class="docEmphasis">effectively immutable</span>. They do not need to meet the strict definition of immutability in <a class="calibre2" href="ch03lev1sec4.html#ch03lev1sec4">Section 3.4</a>; they merely need to be treated by the program as if they were immutable after they are published. Using effectively immutable objects can simplify development and improve performance by reducing the need for synchronization.</p>
<a name="ch03sb11" class="calibre18" id="ch03sb11"></a><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<p class="docText1">Safely published <span class="docEmphasis">effectively immutable</span> objects can be used safely by any thread without additional synchronization.</p>
</td></tr></table></p><p class="calibre1"> </p>
<p class="docText1">For example, <tt class="calibre25">Date</tt> is mutable,<sup class="docFootnote"><a class="calibre2" href="#ch03fn17">[17]</a></sup> but if you use it as if it were immutable, you may be able to eliminate the locking that would otherwise be required when shared a <tt class="calibre25">Date</tt> across threads. Suppose you want to maintain a <tt class="calibre25">Map</tt> storing the last login time of each user:</p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch03fn17" class="calibre18" id="ch03fn17">[17]</a></sup> This was probably a mistake in the class library design.</p></blockquote>
<div class="docText2"><pre class="calibre36">public Map&lt;String, Date&gt; lastLogin =
    Collections.synchronizedMap(new HashMap&lt;String, Date&gt;());
</pre></div><p class="calibre1"> </p>
<p class="docText1">If the <tt class="calibre25">Date</tt> values are not modified after they are placed in the <tt class="calibre25">Map</tt>, then the synchronization in the <tt class="calibre25">synchronizedMap</tt> implementation is sufficient to publish the <tt class="calibre25">Date</tt> values safely, and no additional synchronization is needed when accessing them.</p>
<a name="ch03lev2sec15" class="calibre18" id="ch03lev2sec15"></a>
<h4 id="title-IDAPLMNJ" class="docSection2Title">3.5.5. Mutable Objects</h4>
<p class="docText1"><a name="iddle1175" class="calibre18" id="iddle1175"></a><a name="iddle1238" class="calibre18" id="iddle1238"></a><a name="iddle1383" class="calibre18" id="iddle1383"></a><a name="iddle1384" class="calibre18" id="iddle1384"></a><a name="iddle1486" class="calibre18" id="iddle1486"></a><a name="iddle1489" class="calibre18" id="iddle1489"></a><a name="iddle1666" class="calibre18" id="iddle1666"></a><a name="iddle1669" class="calibre18" id="iddle1669"></a><a name="iddle1670" class="calibre18" id="iddle1670"></a><a name="iddle2354" class="calibre18" id="iddle2354"></a><a name="iddle2569" class="calibre18" id="iddle2569"></a><a name="iddle2593" class="calibre18" id="iddle2593"></a><a name="iddle2594" class="calibre18" id="iddle2594"></a><a name="iddle2627" class="calibre18" id="iddle2627"></a><a name="iddle2700" class="calibre18" id="iddle2700"></a><a name="iddle2958" class="calibre18" id="iddle2958"></a><a name="iddle2959" class="calibre18" id="iddle2959"></a><a name="iddle2960" class="calibre18" id="iddle2960"></a><a name="iddle3002" class="calibre18" id="iddle3002"></a><a name="iddle3003" class="calibre18" id="iddle3003"></a><a name="iddle3728" class="calibre18" id="iddle3728"></a><a name="iddle4038" class="calibre18" id="iddle4038"></a><a name="iddle4039" class="calibre18" id="iddle4039"></a><a name="iddle4216" class="calibre18" id="iddle4216"></a><a name="iddle4555" class="calibre18" id="iddle4555"></a><a name="iddle4583" class="calibre18" id="iddle4583"></a><a name="iddle4584" class="calibre18" id="iddle4584"></a><a name="iddle5071" class="calibre18" id="iddle5071"></a><a name="iddle5072" class="calibre18" id="iddle5072"></a><a name="iddle5120" class="calibre18" id="iddle5120"></a><a name="iddle1967" class="calibre18" id="iddle1967"></a><a name="iddle2477" class="calibre18" id="iddle2477"></a><a name="iddle2570" class="calibre18" id="iddle2570"></a><a name="iddle2582" class="calibre18" id="iddle2582"></a><a name="iddle3279" class="calibre18" id="iddle3279"></a><a name="iddle3280" class="calibre18" id="iddle3280"></a><a name="iddle3349" class="calibre18" id="iddle3349"></a><a name="iddle3353" class="calibre18" id="iddle3353"></a><a name="iddle3354" class="calibre18" id="iddle3354"></a><a name="iddle3591" class="calibre18" id="iddle3591"></a><a name="iddle3730" class="calibre18" id="iddle3730"></a><a name="iddle4041" class="calibre18" id="iddle4041"></a><a name="iddle4235" class="calibre18" id="iddle4235"></a><a name="iddle4236" class="calibre18" id="iddle4236"></a>If an object may be modified after construction, safe publication ensures only the visibility of the as-published state. Synchronization must be used not only to publish a mutable object, but also every time the object is accessed to ensure visibility of subsequent modifications. To share mutable objects safely, they must be safely published <span class="docEmphasis">and</span> be either thread-safe or guarded by a lock.</p>
<a name="ch03sb12" class="calibre18" id="ch03sb12"></a><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<p class="docText1">The publication requirements for an object depend on its mutability:</p>
<ul class="calibre15"><li class="calibre16"><p class="docText1"><span class="docEmphasis">Immutable objects</span> can be published through any mechanism;</p></li><li class="calibre16"><p class="docText1"><span class="docEmphasis">Effectively immutable objects</span> must be safely published;</p></li><li class="calibre16"><p class="docText1"><span class="docEmphasis">Mutable objects</span> must be safely published, and must be either threadsafe or guarded by a lock.</p></li></ul>
</td></tr></table></p><p class="calibre1"> </p>
<a name="ch03lev2sec16" class="calibre18" id="ch03lev2sec16"></a>
<h4 id="title-IDAM1MNJ" class="docSection2Title">3.5.6. Sharing Objects Safely</h4>
<p class="docText1">Whenever you acquire a reference to an object, you should know what you are allowed to do with it. Do you need to acquire a lock before using it? Are you allowed to modify its state, or only to read it? Many concurrency errors stem from failing to understand these "rules of engagement" for a shared object. When you publish an object, you should document how the object can be accessed.</p>
<a name="ch03sb13" class="calibre18" id="ch03sb13"></a><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<p class="docText1">The most useful policies for using and sharing objects in a concurrent program are:</p>
<blockquote class="calibre19"><p class="calibre21"></p><p class="docText1"><span class="docEmphStrong">Thread-confined.</span> A thread-confined object is owned exclusively by and confined to one thread, and can be modifled by its owning thread.</p></blockquote></td></tr></table></p><p class="calibre21"></p><p class="docText1"><span class="docEmphStrong">Shared read-only.</span> A shared read-only object can be accessed concurrently by multiple threads without additional synchronization, but cannot be modified by any thread. Shared read-only objects include immutable and effectively immutable objects.</p><p class="calibre21"></p><p class="docText1"><span class="docEmphStrong">Shared thread-safe.</span> A thread-safe object performs synchronization internally, so multiple threads can freely access it through its public interface without further synchronization.</p><p class="calibre21"></p><p class="docText1"><span class="docEmphStrong">Guarded.</span> A guarded object can be accessed only with a specific lock held. Guarded objects include those that are encapsulated within other thread-safe objects and published objects that are known to be guarded by a specific lock.</p>
<p class="calibre1"> </p>

<p class="calibre1"> </p>

</div>

{% endraw %}

