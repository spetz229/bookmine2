---
layout: page
title: "Java Concurrency in Practice"
prev: ch02lev1sec3.html
next: ch02lev1sec5.html
book_path: books/brian-goetz-tim-peierls-joshua-bloch-joseph-bowbeer-david-holmes-doug-lea-java-concurrency-in-practice--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a href="21021536.html" class="calibre2"><img src="pixel.jpg" alt="" border="0" class="calibre26"/></a><a name="ch02lev1sec4" class="calibre18" id="ch02lev1sec4"></a>
<h3 id="title-IDAMDROJ" class="docSection1Title">2.4. Guarding State with Locks</h3>
<p class="docText1">Because locks enable serialized <sup class="docFootnote"><a class="calibre2" href="#ch02fn08">[8]</a></sup> access to the code paths they guard, we can use them to construct protocols for guaranteeing exclusive access to shared state. Following these protocols consistently can ensure state consistency.</p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch02fn08" class="calibre18" id="ch02fn08">[8]</a></sup> Serializing access to an object has nothing to do with object serialization (turning an object into a byte stream); serializing access means that threads take turns accessing the object exclusively, rather than doing so concurrently.</p></blockquote>
<p class="docText1">Compound actions on shared state, such as incrementing a hit counter (read-modify-write) or lazy initialization (check-then-act), must be made atomic to avoid race conditions. Holding a lock for the <span class="docEmphasis">entire duration</span> of a compound action can make that compound action atomic. However, just wrapping the compound action with a <tt class="calibre25">synchronized</tt> block is not sufficient; if synchronization is used to coordinate access to a variable, it is needed <span class="docEmphasis">everywhere that variable is accessed</span>. Further, when using locks to coordinate access to a variable, the <span class="docEmphasis">same</span> lock must be used wherever that variable is accessed.</p>
<p class="docText1"><a name="iddle1095" class="calibre18" id="iddle1095"></a><a name="iddle1178" class="calibre18" id="iddle1178"></a><a name="iddle1326" class="calibre18" id="iddle1326"></a><a name="iddle1327" class="calibre18" id="iddle1327"></a><a name="iddle2035" class="calibre18" id="iddle2035"></a><a name="iddle2036" class="calibre18" id="iddle2036"></a><a name="iddle2364" class="calibre18" id="iddle2364"></a><a name="iddle2475" class="calibre18" id="iddle2475"></a><a name="iddle2476" class="calibre18" id="iddle2476"></a><a name="iddle2595" class="calibre18" id="iddle2595"></a><a name="iddle2836" class="calibre18" id="iddle2836"></a><a name="iddle3112" class="calibre18" id="iddle3112"></a><a name="iddle3130" class="calibre18" id="iddle3130"></a><a name="iddle3131" class="calibre18" id="iddle3131"></a><a name="iddle3367" class="calibre18" id="iddle3367"></a><a name="iddle3368" class="calibre18" id="iddle3368"></a><a name="iddle3595" class="calibre18" id="iddle3595"></a><a name="iddle3710" class="calibre18" id="iddle3710"></a><a name="iddle3711" class="calibre18" id="iddle3711"></a><a name="iddle4569" class="calibre18" id="iddle4569"></a><a name="iddle4940" class="calibre18" id="iddle4940"></a><a name="iddle4941" class="calibre18" id="iddle4941"></a>It is a common mistake to assume that synchronization needs to be used only when <span class="docEmphasis">writing</span> to shared variables; <span class="docEmphasis">this is simply not true</span>. (The reasons for this will become clearer in <a class="calibre2" href="ch03lev1sec1.html#ch03lev1sec1">Section 3.1</a>.)</p>
<a name="ch02sb09" class="calibre18" id="ch02sb09"></a><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<p class="docText1">For each mutable state variable that may be accessed by more than one thread, <span class="docEmphasis">all</span> accesses to that variable must be performed with the <span class="docEmphasis">same</span> lock held. In this case, we say that the variable is <span class="docEmphasis">guarded by</span> that lock.</p>
</td></tr></table></p><p class="calibre1"> </p>
<p class="docText1">In <tt class="calibre25">SynchronizedFactorizer</tt> in <a class="calibre2" href="ch02lev1sec3.html#ch02list06">Listing 2.6</a>, <tt class="calibre25">lastNumber</tt> and <tt class="calibre25">lastFactors</tt> are guarded by the servlet object's intrinsic lock; this is documented by the <tt class="calibre25">@GuardedBy</tt> annotation.</p>
<p class="docText1">There is no inherent relationship between an object's intrinsic lock and its state; an object's fields need not be guarded by its intrinsic lock, though this is a perfectly valid locking convention that is used by many classes. Acquiring the lock associated with an object does <span class="docEmphasis">not</span> prevent other threads from accessing that objectthe only thing that acquiring a lock prevents any other thread from doing is acquiring that same lock. The fact that every object has a built-in lock is just a convenience so that you needn't explicitly create lock objects. <sup class="docFootnote"><a class="calibre2" href="#ch02fn09">[9]</a></sup> It is up to you to construct <span class="docEmphasis">locking protocols</span> or <span class="docEmphasis">synchronization policies</span> that let you access shared state safely, and to use them consistently throughout your program.</p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch02fn09" class="calibre18" id="ch02fn09">[9]</a></sup> In retrospect, this design decision was probably a bad one: not only can it be confusing, but it forces JVM implementors to make tradeoffs between object size and locking performance.</p></blockquote>
<a name="ch02sb10" class="calibre18" id="ch02sb10"></a><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<p class="docText1">Every shared, mutable variable should be guarded by exactly one lock. Make it clear to maintainers which lock that is.</p>
</td></tr></table></p><p class="calibre1"> </p>
<p class="docText1">A common locking convention is to encapsulate all mutable state within an object and to protect it from concurrent access by synchronizing any code path that accesses mutable state using the object's intrinsic lock. This pattern is used by many thread-safe classes, such as <tt class="calibre25">Vector</tt> and other synchronized collection classes. In such cases, all the variables in an object's state are guarded by the object's intrinsic lock. However, there is nothing special about this pattern, and neither the compiler nor the runtime enforces this (or any other) pattern of locking. <sup class="docFootnote"><a class="calibre2" href="#ch02fn10">[10]</a></sup> It is also easy to subvert this locking protocol accidentally by adding a new method or code path and forgetting to use synchronization.</p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch02fn10" class="calibre18" id="ch02fn10">[10]</a></sup> Code auditing tools like FindBugs can identify when a variable is frequently but not always accessed with a lock held, which may indicate a bug.</p></blockquote>
<p class="docText1">Not all data needs to be guarded by locksonly mutable data that will be accessed from multiple threads. In <a class="calibre2" href="ch01.html#ch01">Chapter 1</a>, we described how adding a simple asynchronous event such as a <tt class="calibre25">TimerTask</tt> can create thread safety requirements that ripple throughout your program, especially if your program state is poorly encapsulated. Consider a single-threaded program that processes a large amount of data. Single-threaded programs require no synchronization, because no data is shared across threads. Now imagine you want to add a feature to create periodic <a name="iddle1427" class="calibre18" id="iddle1427"></a><a name="iddle2544" class="calibre18" id="iddle2544"></a><a name="iddle2545" class="calibre18" id="iddle2545"></a><a name="iddle2857" class="calibre18" id="iddle2857"></a><a name="iddle3025" class="calibre18" id="iddle3025"></a><a name="iddle3026" class="calibre18" id="iddle3026"></a><a name="iddle3276" class="calibre18" id="iddle3276"></a><a name="iddle3497" class="calibre18" id="iddle3497"></a><a name="iddle3498" class="calibre18" id="iddle3498"></a><a name="iddle4206" class="calibre18" id="iddle4206"></a><a name="iddle4419" class="calibre18" id="iddle4419"></a><a name="iddle4738" class="calibre18" id="iddle4738"></a>snapshots of its progress, so that it does not have to start again from the beginning if it crashes or must be stopped. You might choose to do this with a <tt class="calibre25">TimerTask</tt> that goes off every ten minutes, saving the program state to a file.</p>
<p class="docText1">Since the <tt class="calibre25">TimerTask</tt> will be called from another thread (one managed by <tt class="calibre25">Timer</tt>), any data involved in the snapshot is now accessed by two threads: the main program thread and the <tt class="calibre25">Timer</tt> tHRead. This means that not only must the <tt class="calibre25">TimerTask</tt> code use synchronization when accessing the program state, but so must any code path in the rest of the program that touches that same data. What used to require no synchronization now requires synchronization throughout the program.</p>
<p class="docText1">When a variable is guarded by a lockmeaning that <span class="docEmphasis">every</span> access to that variable is performed with that lock heldyou've ensured that only one thread at a time can access that variable. When a class has invariants that involve more than one state variable, there is an additional requirement: each variable participating in the invariant must be guarded by the <span class="docEmphasis">same</span> lock. This allows you to access or update them in a single atomic operation, preserving the invariant. <tt class="calibre25">SynchronizedFactorizer</tt> demonstrates this rule: both the cached number and the cached factors are guarded by the servlet object's intrinsic lock.</p>
<a name="ch02sb11" class="calibre18" id="ch02sb11"></a><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<p class="docText1">For every invariant that involves more than one variable, <span class="docEmphasis">all</span> the variables involved in that invariant must be guarded by the <span class="docEmphasis">same</span> lock.</p>
</td></tr></table></p><p class="calibre1"> </p>
<p class="docText1">If synchronization is the cure for race conditions, why not just declare every method <tt class="calibre25">synchronized</tt>? It turns out that such indiscriminate application of <tt class="calibre25">synchronized</tt> might be either too much or too little synchronization. Merely synchronizing every method, as <tt class="calibre25">Vector</tt> does, is not enough to render compound actions on a <tt class="calibre25">Vector</tt> atomic:</p>
<div class="docText2"><pre class="calibre36">if (!vector.contains(element))
    vector.add(element);
</pre></div><p class="calibre1"> </p>
<p class="docText1">This attempt at a put-if-absent operation has a race condition, even though both <tt class="calibre25">contains</tt> and <tt class="calibre25">add</tt> are atomic. While synchronized methods can make individual operations atomic, additional locking is requiredwhen multiple operations are combined into a compound action. (See <a class="calibre2" href="ch04lev1sec4.html#ch04lev1sec4">Section 4.4</a> for some techniques for safely adding additional atomic operations to thread-safe objects.) At the same time, synchronizing every method can lead to liveness or performance problems, as we saw in <tt class="calibre25">SynchronizedFactorizer</tt>.</p>
<a href="21021536.html" class="calibre2"><img src="pixel.jpg" alt="" border="0" class="calibre26"/></a>
<p class="calibre3"> </p>

</div>

{% endraw %}

