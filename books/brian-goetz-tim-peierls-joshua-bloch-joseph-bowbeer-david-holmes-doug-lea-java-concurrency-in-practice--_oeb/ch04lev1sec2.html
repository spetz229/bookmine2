---
layout: page
title: "Java Concurrency in Practice"
prev: ch04lev1sec1.html
next: ch04lev1sec3.html
book_path: books/brian-goetz-tim-peierls-joshua-bloch-joseph-bowbeer-david-holmes-doug-lea-java-concurrency-in-practice--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a name="ch04lev1sec2" class="calibre18" id="ch04lev1sec2"></a>
<h3 id="title-IDAL42AH" class="docSection1Title">4.2. Instance Confinement</h3>
<p class="docText1">If an object is not thread-safe, several techniques can still let it be used safely in a multithreaded program. You can ensure that it is only accessed from a single thread (thread confinement), or that all access to it is properly guarded by a lock.</p>
<p class="docText1"><a name="iddle1342" class="calibre18" id="iddle1342"></a><a name="iddle1343" class="calibre18" id="iddle1343"></a><a name="iddle1438" class="calibre18" id="iddle1438"></a><a name="iddle1533" class="calibre18" id="iddle1533"></a><a name="iddle2048" class="calibre18" id="iddle2048"></a><a name="iddle2049" class="calibre18" id="iddle2049"></a><a name="iddle2153" class="calibre18" id="iddle2153"></a><a name="iddle2520" class="calibre18" id="iddle2520"></a><a name="iddle2747" class="calibre18" id="iddle2747"></a><a name="iddle2748" class="calibre18" id="iddle2748"></a><a name="iddle2956" class="calibre18" id="iddle2956"></a><a name="iddle2957" class="calibre18" id="iddle2957"></a><a name="iddle3059" class="calibre18" id="iddle3059"></a><a name="iddle4217" class="calibre18" id="iddle4217"></a><a name="iddle4745" class="calibre18" id="iddle4745"></a>Encapsulation simplifies making classes thread-safe by promoting <span class="docEmphasis">instance confinement</span>, often just called <span class="docEmphasis">confinement</span> [CPJ 2.3.3]. When an object is encapsulated within another object, all code paths that have access to the encapsulated object are known and can be therefore be analyzed more easily than if that object were accessible to the entire program. Combining confinement with an appropriate locking discipline can ensure that otherwise non-thread-safe objects are used in a thread-safe manner.</p>
<a name="ch04sb03" class="calibre18" id="ch04sb03"></a><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<p class="docText1">Encapsulating data within an object confines access to the data to the object's methods, making it easier to ensure that the data is always accessed with the appropriate lock held.</p>
</td></tr></table></p><p class="calibre1"> </p>
<p class="docText1">Confined objects must not escape their intended scope. An object may be confined to a class instance (such as a private class member), a lexical scope (such as a local variable), or a thread (such as an object that is passed from method to method within a thread, but not supposed to be shared across threads). Objects don't escape on their own, of coursethey need help from the developer, who assists by publishing the object beyond its intended scope.</p>
<p class="docText1"><tt class="calibre25">PersonSet</tt> in <a class="calibre2" href="#ch04list02">Listing 4.2</a> illustrates how confinement and locking can work together to make a class thread-safe even when its component state variables are not. The state of <tt class="calibre25">PersonSet</tt> is managed by a <tt class="calibre25">HashSet</tt>, which is not thread-safe. But because <tt class="calibre25">mySet</tt> is private and not allowed to escape, the <tt class="calibre25">HashSet</tt> is confined to the <tt class="calibre25">PersonSet</tt>. The only code paths that can access <tt class="calibre25">mySet</tt> are <tt class="calibre25">addPerson</tt> and <tt class="calibre25">containsPerson</tt>, and each of these acquires the lock on the <tt class="calibre25">PersonSet</tt>. All its state is guarded by its intrinsic lock, making <tt class="calibre25">PersonSet</tt> thread-safe.</p>
<a name="ch04list02" class="calibre18" id="ch04list02"></a><h5 id="title-IDARF3AH" class="docExampleTitle">Listing 4.2. Using Confinement to Ensure Thread Safety.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">@ThreadSafe
public class PersonSet {
    @GuardedBy("this")
    private final Set&lt;Person&gt; mySet = new HashSet&lt;Person&gt;();

    public synchronized void addPerson(Person p) {
        mySet.add(p);
    }

    public synchronized boolean containsPerson(Person p) {
        return mySet.contains(p);
    }
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1">This example makes no assumptions about the thread-safety of <tt class="calibre25">Person</tt>, but if it is mutable, additional synchronization will be needed when accessing a <tt class="calibre25">Person</tt> retrieved from a <tt class="calibre25">PersonSet</tt>. The most reliable way to do this would be to make <a name="iddle1842" class="calibre18" id="iddle1842"></a><a name="iddle1843" class="calibre18" id="iddle1843"></a><a name="iddle1946" class="calibre18" id="iddle1946"></a><a name="iddle1947" class="calibre18" id="iddle1947"></a><a name="iddle1948" class="calibre18" id="iddle1948"></a><a name="iddle1949" class="calibre18" id="iddle1949"></a><a name="iddle2051" class="calibre18" id="iddle2051"></a><a name="iddle2052" class="calibre18" id="iddle2052"></a><a name="iddle2374" class="calibre18" id="iddle2374"></a><a name="iddle2512" class="calibre18" id="iddle2512"></a><a name="iddle2638" class="calibre18" id="iddle2638"></a><a name="iddle2639" class="calibre18" id="iddle2639"></a><a name="iddle2897" class="calibre18" id="iddle2897"></a><a name="iddle2898" class="calibre18" id="iddle2898"></a><a name="iddle3056" class="calibre18" id="iddle3056"></a><a name="iddle3244" class="calibre18" id="iddle3244"></a><a name="iddle3708" class="calibre18" id="iddle3708"></a><a name="iddle3709" class="calibre18" id="iddle3709"></a><a name="iddle5166" class="calibre18" id="iddle5166"></a><a name="iddle5167" class="calibre18" id="iddle5167"></a><a name="iddle5168" class="calibre18" id="iddle5168"></a><tt class="calibre25">Person</tt> tHRead-safe; less reliable would be to guard the <tt class="calibre25">Person</tt> objects with a lock and ensure that all clients follow the protocol of acquiring the appropriate lock before accessing the <tt class="calibre25">Person</tt>.</p>
<p class="docText1">Instance confinement is one of the easiest ways to build thread-safe classes. It also allows flexibility in the choice of locking strategy; <tt class="calibre25">PersonSet</tt> happened to use its own intrinsic lock to guard its state, but any lock, consistently used, would do just as well. Instance confinement also allows different state variables to be guarded by different locks. (For an example of a class that uses multiple lock objects to guard its state, see <tt class="calibre25">ServerStatus</tt> on <a class="calibre2" href="ch11lev1sec4.html#ch11list06">236</a>.)</p>
<p class="docText1">There are many examples of confinement in the platform class libraries, including some classes that exist solely to turn non-thread-safe classes into threadsafe ones. The basic collection classes such as <tt class="calibre25">ArrayList</tt> and <tt class="calibre25">HashMap</tt> are not thread-safe, but the class library provides wrapper factory methods (<tt class="calibre25">Collections.synchronizedList</tt> and friends) so they can be used safely in multithreaded environments. These factories use the Decorator pattern (<a class="calibre2" href="bib01.html#biblio01_011">Gamma et al., 1995</a>) to wrap the collection with a synchronized wrapper object; the wrapper implements each method of the appropriate interface as a synchronized method that forwards the request to the underlying collection object. So long as the wrapper object holds the only reachable reference to the underlying collection (i.e., the underlying collection is confined to the wrapper), the wrapper object is then thread-safe. The Javadoc for these methods warns that all access to the underlying collection must be made through the wrapper.</p>
<p class="docText1">Of course, it is still possible to violate confinement by publishing a supposedly confined object; if an object is intended to be confined to a specific scope, then letting it escape from that scope is a bug. Confined objects can also escape by publishing other objects such as iterators or inner class instances that may indirectly publish the confined objects.</p>
<a name="ch04sb04" class="calibre18" id="ch04sb04"></a><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<p class="docText1">Confinement makes it easier to build thread-safe classes because a class that confines its state can be analyzed for thread safety without having to examine the whole program.</p>
</td></tr></table></p><p class="calibre1"> </p>
<a name="ch04lev2sec4" class="calibre18" id="ch04lev2sec4"></a>
<h4 id="title-IDA4P3AH" class="docSection2Title">4.2.1. The Java Monitor Pattern</h4>
<p class="docText1">Following the principle of instance confinement to its logical conclusion leads you to the <span class="docEmphasis">Java monitor pattern</span>.<sup class="docFootnote"><a class="calibre2" href="#ch04fn02">[2]</a></sup> An object following the Java monitor pattern encapsulates all its mutable state and guards it with the object's own intrinsic lock.</p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch04fn02" class="calibre18" id="ch04fn02">[2]</a></sup> The Java monitor pattern is inspired by Hoare's work on <span class="docEmphasis">monitors</span> (<a class="calibre2" href="bib01.html#biblio01_018">Hoare, 1974</a>), though there are significant differences between this pattern and a true monitor. The bytecode instructions for entering and exiting a synchronized block are even called <tt class="calibre35">monitorenter</tt> and <tt class="calibre35">monitorexit</tt>, and Java's built-in (intrinsic) locks are sometimes called <span class="docEmphasis">monitor locks</span> or <span class="docEmphasis">monitors</span>.</p></blockquote>
<p class="docText1"><tt class="calibre25">Counter</tt> in <a class="calibre2" href="ch04lev1sec1.html#ch04list01">Listing 4.1</a> shows a typical example of this pattern. It encapsulates one state variable, <tt class="calibre25">value</tt>, and all access to that state variable is through the methods of <tt class="calibre25">Counter</tt>, which are all synchronized.</p>
<p class="docText1"><a name="iddle1632" class="calibre18" id="iddle1632"></a><a name="iddle1638" class="calibre18" id="iddle1638"></a><a name="iddle2159" class="calibre18" id="iddle2159"></a><a name="iddle2491" class="calibre18" id="iddle2491"></a><a name="iddle2492" class="calibre18" id="iddle2492"></a><a name="iddle2900" class="calibre18" id="iddle2900"></a><a name="iddle3023" class="calibre18" id="iddle3023"></a><a name="iddle3051" class="calibre18" id="iddle3051"></a><a name="iddle3113" class="calibre18" id="iddle3113"></a><a name="iddle3128" class="calibre18" id="iddle3128"></a><a name="iddle3129" class="calibre18" id="iddle3129"></a><a name="iddle3227" class="calibre18" id="iddle3227"></a><a name="iddle3289" class="calibre18" id="iddle3289"></a><a name="iddle3668" class="calibre18" id="iddle3668"></a><a name="iddle3669" class="calibre18" id="iddle3669"></a><a name="iddle4283" class="calibre18" id="iddle4283"></a><a name="iddle4476" class="calibre18" id="iddle4476"></a><a name="iddle4477" class="calibre18" id="iddle4477"></a><a name="iddle5080" class="calibre18" id="iddle5080"></a><a name="iddle5082" class="calibre18" id="iddle5082"></a><a name="iddle5089" class="calibre18" id="iddle5089"></a>The Java monitor pattern is used by many library classes, such as <tt class="calibre25">Vector</tt> and <tt class="calibre25">Hashtable</tt>. Sometimes a more sophisticated synchronization policy is needed; <a class="calibre2" href="ch11.html#ch11">Chapter 11</a> shows how to improve scalability through finer-grained locking strategies. The primary advantage of the Java monitor pattern is its simplicity.</p>
<p class="docText1">The Java monitor pattern is merely a convention; any lock object could be used to guard an object's state so long as it is used consistently. <a class="calibre2" href="#ch04list03">Listing 4.3</a> illustrates a class that uses a private lock to guard its state.</p>
<a name="ch04list03" class="calibre18" id="ch04list03"></a><h5 id="title-IDAXZ3AH" class="docExampleTitle">Listing 4.3. Guarding State with a Private Lock.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">public class PrivateLock {
    private final Object myLock = new Object();
    @GuardedBy("myLock") Widget widget;

    void someMethod() {
        synchronized(myLock) {
            // Access or modify the state of widget
        }
    }
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<p class="docText1">There are advantages to using a private lock object instead of an object's intrinsic lock (or any other publicly accessible lock). Making the lock object private encapsulates the lock so that client code cannot acquire it, whereas a publicly accessible lock allows client code to participate in its synchronization policycorrectly or incorrectly. Clients that improperly acquire another object's lock could cause liveness problems, and verifying that a publicly accessible lock is properly used requires examining the entire program rather than a single class.</p>
<a name="ch04lev2sec5" class="calibre18" id="ch04lev2sec5"></a>
<h4 id="title-IDAJ03AH" class="docSection2Title">4.2.2. Example: Tracking Fleet Vehicles</h4>
<p class="docText1"><tt class="calibre25">Counter</tt> in <a class="calibre2" href="ch04lev1sec1.html#ch04list01">Listing 4.1</a> is a concise, but trivial, example of the Java monitor pattern. Let's build a slightly less trivial example: a "vehicle tracker" for dispatching fleet vehicles such as taxicabs, police cars, or delivery trucks. We'll build it first using the monitor pattern, and then see how to relax some of the encapsulation requirements while retaining thread safety.</p>
<p class="docText1">Each vehicle is identified by a <tt class="calibre25">String</tt> and has a location represented by (<span class="docEmphasis">x</span>, <span class="docEmphasis">y</span>) coordinates. The <tt class="calibre25">VehicleTracker</tt> classes encapsulate the identity and locations of the known vehicles, making them well-suited as a data model in a modelview-controller GUI application where it might be shared by a view thread and multiple updater threads. The view thread would fetch the names and locations of the vehicles and render them on a display:</p>
<div class="docText2"><pre class="calibre36">Map&lt;String, Point&gt; locations = vehicles.getLocations();
for (String key : locations.keySet())
    renderVehicle(key, locations.get(key));
</pre></div><p class="calibre1"> </p>
<p class="docText1"><a name="iddle1550" class="calibre18" id="iddle1550"></a><a name="iddle1551" class="calibre18" id="iddle1551"></a><a name="iddle1552" class="calibre18" id="iddle1552"></a><a name="iddle1662" class="calibre18" id="iddle1662"></a><a name="iddle1663" class="calibre18" id="iddle1663"></a><a name="iddle1863" class="calibre18" id="iddle1863"></a><a name="iddle1940" class="calibre18" id="iddle1940"></a><a name="iddle4734" class="calibre18" id="iddle4734"></a>Similarly, the updater threads would modify vehicle locations with data received from GPS devices or entered manually by a dispatcher through a GUI interface:</p>
<div class="docText2"><pre class="calibre36">void vehicleMoved(VehicleMovedEvent evt) {
    Point loc = evt.getNewLocation();
    vehicles.setLocation(evt.getVehicleId(), loc.x, loc.y);
}
</pre></div><p class="calibre1"> </p>
<p class="docText1">Since the view thread and the updater threads will access the data model concurrently, it must be thread-safe. <a class="calibre2" href="ch04lev1sec3.html#ch04list04">Listing 4.4</a> shows an implementation of the vehicle tracker using the Java monitor pattern that uses <tt class="calibre25">MutablePoint</tt> in <a class="calibre2" href="ch04lev1sec3.html#ch04list05">Listing 4.5</a> for representing the vehicle locations.</p>
<p class="docText1">Even though <tt class="calibre25">MutablePoint</tt> is not thread-safe, the tracker class is. Neither the map nor any of the mutable points it contains is ever published. When we need to a return vehicle locations to callers, the appropriate values are copied using either the <tt class="calibre25">MutablePoint</tt> copy constructor or <tt class="calibre25">deepCopy</tt>, which creates a new <tt class="calibre25">Map</tt> whose values are copies of the keys and values from the old <tt class="calibre25">Map</tt>.<sup class="docFootnote"><a class="calibre2" href="#ch04fn03">[3]</a></sup></p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch04fn03" class="calibre18" id="ch04fn03">[3]</a></sup> Note that <tt class="calibre35">deepCopy</tt> can't just wrap the <tt class="calibre35">Map</tt> with an <tt class="calibre35">unmodifiableMap</tt>, because that protects only the <span class="docEmphasis">collection</span> from modification; it does not prevent callers from modifying the mutable objects stored in it. For the same reason, populating the <tt class="calibre35">HashMap</tt> in <tt class="calibre35">deepCopy</tt> via a copy constructor wouldn't work either, because only the <span class="docEmphasis">references</span> to the points would be copied, not the point objects themselves.</p></blockquote>
<p class="docText1">This implementation maintains thread safety in part by copying mutable data before returning it to the client. This is usually not a performance issue, but could become one <span class="docEmphasis">if</span> the set of vehicles is very large.<sup class="docFootnote"><a class="calibre2" href="#ch04fn04">[4]</a></sup> Another consequence of copying the data on each call to <tt class="calibre25">getLocation</tt> is that the contents of the returned collection do not change even if the underlying locations change. Whether this is good or bad depends on your requirements. It could be a benefit if there are internal consistency requirements on the location set, in which case returning a consistent snapshot is critical, or a drawback if callers require up-to-date information for each vehicle and therefore need to refresh their snapshot more often.</p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch04fn04" class="calibre18" id="ch04fn04">[4]</a></sup> Because<tt class="calibre35">deepCopy</tt> is called from a <tt class="calibre35">synchronized</tt> method, the tracker's intrinsic lock is held for the duration of what might be a long-running copy operation, and this could degrade the responsiveness of the user interface when many vehicles are being tracked.</p></blockquote>

<p class="calibre1"> </p>

</div>

{% endraw %}

