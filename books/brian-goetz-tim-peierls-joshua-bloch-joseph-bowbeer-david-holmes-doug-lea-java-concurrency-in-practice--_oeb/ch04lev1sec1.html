---
layout: page
title: "Java Concurrency in Practice"
prev: ch04.html
next: ch04lev1sec2.html
book_path: books/brian-goetz-tim-peierls-joshua-bloch-joseph-bowbeer-david-holmes-doug-lea-java-concurrency-in-practice--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a href="21021536.html" class="calibre2"><img src="pixel.jpg" alt="" border="0" class="calibre26"/></a><a name="ch04lev1sec1" class="calibre18" id="ch04lev1sec1"></a>
<h3 id="title-IDAU2IYH" class="docSection1Title">4.1. Designing a Thread-safe Class</h3>
<p class="docText1">While it is possible to write a thread-safe program that stores all its state in public static fields, it is a lot harder to verify its thread safety or to modify it so that it remains thread-safe than one that uses encapsulation appropriately. Encapsulation makes it possible to determine that a class is thread-safe without having to examine the entire program.</p>
<a name="ch04sb01" class="calibre18" id="ch04sb01"></a><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<p class="docText1">The design process for a thread-safe class should include these three basic elements:</p>
<ul class="calibre15"><li class="calibre16"><p class="docText1">Identify the variables that form the object's state;</p></li><li class="calibre16"><p class="docText1">Identify the invariants that constrain the state variables;</p></li><li class="calibre16"><p class="docText1">Establish a policy for managing concurrent access to the object's state.</p></li></ul>
</td></tr></table></p><p class="calibre1"> </p>
<p class="docText1">An object's state starts with its fields. If they are all of primitive type, the fields comprise the entire state. <tt class="calibre25">Counter</tt> in <a class="calibre2" href="#ch04list01">Listing 4.1</a> has only one field, so the <tt class="calibre25">value</tt> field comprises its entire state. The state of an object with <span class="docEmphasis">n</span> primitive fields is just the <span class="docEmphasis">n</span>-tuple of its field values; the state of a 2D <tt class="calibre25">Point</tt> is its (<span class="docEmphasis">x</span>, <span class="docEmphasis">y</span>) value. If the object has fields that are references to other objects, its state will encompass fields from the referenced objects as well. For example, the state of a <tt class="calibre25">LinkedList</tt> includes the state of all the link node objects belonging to the list.</p>
<p class="docText1">The <span class="docEmphasis">synchronization policy</span> defines how an object coordinates access to its state without violating its invariants or postconditions. It specifies what combination of <a name="iddle1154" class="calibre18" id="iddle1154"></a><a name="iddle1542" class="calibre18" id="iddle1542"></a><a name="iddle1562" class="calibre18" id="iddle1562"></a><a name="iddle2104" class="calibre18" id="iddle2104"></a><a name="iddle2714" class="calibre18" id="iddle2714"></a><a name="iddle3142" class="calibre18" id="iddle3142"></a><a name="iddle3143" class="calibre18" id="iddle3143"></a><a name="iddle3890" class="calibre18" id="iddle3890"></a><a name="iddle3891" class="calibre18" id="iddle3891"></a><a name="iddle4335" class="calibre18" id="iddle4335"></a><a name="iddle4336" class="calibre18" id="iddle4336"></a><a name="iddle4421" class="calibre18" id="iddle4421"></a><a name="iddle4429" class="calibre18" id="iddle4429"></a><a name="iddle4571" class="calibre18" id="iddle4571"></a><a name="iddle4572" class="calibre18" id="iddle4572"></a><a name="iddle4755" class="calibre18" id="iddle4755"></a><a name="iddle4960" class="calibre18" id="iddle4960"></a>immutability, thread confinement, and locking is used to maintain thread safety, and which variables are guarded by which locks. To ensure that the class can be analyzed and maintained, document the synchronization policy.</p>
<a name="ch04list01" class="calibre18" id="ch04list01"></a><h5 id="title-IDAREJYH" class="docExampleTitle">Listing 4.1. Simple Thread-safe Counter Using the Java Monitor Pattern.</h5><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<pre class="calibre30">@ThreadSafe
public final class Counter {
    <span class="docEmphStrong">@GuardedBy("this")</span>  private long value = 0;

    public <span class="docEmphStrong">synchronized</span>  long getValue() {
        return value;
    }
    public  <span class="docEmphStrong">synchronized</span>  long increment() {
        if (value == Long.MAX_VALUE)
            throw new IllegalStateException("counter overflow");
        return ++value;
    }
}
</pre><br class="calibre11"/>
</td></tr></table></p>
<a name="ch04lev2sec1" class="calibre18" id="ch04lev2sec1"></a>
<h4 id="title-IDAMFJYH" class="docSection2Title">4.1.1. Gathering Synchronization Requirements</h4>
<p class="docText1">Making a class thread-safe means ensuring that its invariants hold under concurrent access; this requires reasoning about its state. Objects and variables have a <span class="docEmphasis">state space</span>: the range of possible states they can take on. The smaller this state space, the easier it is to reason about. By using final fields wherever practical, you make it simpler to analyze the possible states an object can be in. (In the extreme case, immutable objects can only be in a single state.)</p>
<p class="docText1">Many classes have invariants that identify certain states as <span class="docEmphasis">valid</span> or <span class="docEmphasis">invalid</span>. The <tt class="calibre25">value</tt> field in <tt class="calibre25">Counter</tt> is a <tt class="calibre25">long</tt>. The state space of a <tt class="calibre25">long</tt> ranges from <tt class="calibre25">Long.MIN_VALUE</tt> to <tt class="calibre25">Long.MAX_VALUE</tt>, but <tt class="calibre25">Counter</tt> places constraints on <tt class="calibre25">value</tt>; negative values are not allowed.</p>
<p class="docText1">Similarly, operations may have postconditions that identify certain <span class="docEmphasis">state transitions</span> as invalid. If the current state of a <tt class="calibre25">Counter</tt> is 17, the <span class="docEmphasis">only</span> valid next state is 18. When the next state is derived from the current state, the operation is necessarily a compound action. Not all operations impose state transition constraints; when updating a variable that holds the current temperature, its previous state does not affect the computation.</p>
<p class="docText1">Constraints placed on states or state transitions by invariants and postconditions create additional synchronization or encapsulation requirements. If certain states are invalid, then the underlying state variables must be encapsulated, otherwise client code could put the object into an invalid state. If an operation has invalid state transitions, it must be made atomic. On the other hand, if the class does not impose any such constraints, we may be able to relax encapsulation or serialization requirements to obtain greater flexibility or better performance.</p>
<p class="docText1"><a name="iddle1150" class="calibre18" id="iddle1150"></a><a name="iddle1237" class="calibre18" id="iddle1237"></a><a name="iddle1437" class="calibre18" id="iddle1437"></a><a name="iddle1727" class="calibre18" id="iddle1727"></a><a name="iddle1878" class="calibre18" id="iddle1878"></a><a name="iddle1896" class="calibre18" id="iddle1896"></a><a name="iddle1897" class="calibre18" id="iddle1897"></a><a name="iddle2546" class="calibre18" id="iddle2546"></a><a name="iddle2567" class="calibre18" id="iddle2567"></a><a name="iddle2855" class="calibre18" id="iddle2855"></a><a name="iddle3273" class="calibre18" id="iddle3273"></a><a name="iddle3376" class="calibre18" id="iddle3376"></a><a name="iddle3441" class="calibre18" id="iddle3441"></a><a name="iddle3442" class="calibre18" id="iddle3442"></a><a name="iddle3647" class="calibre18" id="iddle3647"></a><a name="iddle4144" class="calibre18" id="iddle4144"></a><a name="iddle4390" class="calibre18" id="iddle4390"></a><a name="iddle4415" class="calibre18" id="iddle4415"></a><a name="iddle4416" class="calibre18" id="iddle4416"></a><a name="iddle5054" class="calibre18" id="iddle5054"></a>A class can also have invariants that constrain multiple state variables. A number range class, like <tt class="calibre25">NumberRange</tt> in <a class="calibre2" href="ch04lev1sec3.html#ch04list10">Listing 4.10</a>, typically maintains state variables for the lower and upper bounds of the range. These variables must obey the constraint that the lower bound be less than or equal to the upper bound. Multivariable invariants like this one create atomicity requirements: related variables must be fetched or updated in a single atomic operation. You cannot update one, release and reacquire the lock, and then update the others, since this could involve leaving the object in an invalid state when the lock was released. When multiple variables participate in an invariant, the lock that guards them must be held for the duration of any operation that accesses the related variables.</p>
<a name="ch04sb02" class="calibre18" id="ch04sb02"></a><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<p class="docText1">You cannot ensure thread safety without understanding an object's invariants and postconditions. Constraints on the valid values or state transitions for state variables can create atomicity and encapsulation requirements.</p>
</td></tr></table></p><p class="calibre1"> </p>
<a name="ch04lev2sec2" class="calibre18" id="ch04lev2sec2"></a>
<h4 id="title-IDAMOJYH" class="docSection2Title">4.1.2. State-dependent Operations</h4>
<p class="docText1">Class invariants and method postconditions constrain the valid states and state transitions for an object. Some objects also have methods with state-based <span class="docEmphasis">preconditions</span>. For example, you cannot remove an item from an empty queue; a queue must be in the "nonempty" state before you can remove an element. Operations with state-based preconditions are called <span class="docEmphasis">state-dependent</span> [CPJ 3].</p>
<p class="docText1">In a single-threaded program, if a precondition does not hold, the operation has no choice but to fail. But in a concurrent program, the precondition may become true later due to the action of another thread. Concurrent programs add the possibility of waiting until the precondition becomes true, and then proceeding with the operation.</p>
<p class="docText1">The built-in mechanisms for efficiently waiting for a condition to become true<tt class="calibre25">wait</tt> and <tt class="calibre25">notify</tt>are tightly bound to intrinsic locking, and can be difficult to use correctly. To create operations that wait for a precondition to become true before proceeding, it is often easier to use existing library classes, such as blocking queues or semaphores, to provide the desired state-dependent behavior. Blocking library classes such as <tt class="calibre25">BlockingQueue</tt>, <tt class="calibre25">Semaphore</tt>, and other <span class="docEmphasis">synchronizers</span> are covered in <a class="calibre2" href="ch05.html#ch05">Chapter 5</a>; creating state-dependent classes using the low-level mechanisms provided by the platform and class library is covered in <a class="calibre2" href="ch14.html#ch14">Chapter 14</a>.</p>
<a name="ch04lev2sec3" class="calibre18" id="ch04lev2sec3"></a>
<h4 id="title-IDA0PJYH" class="docSection2Title">4.1.3. State Ownership</h4>
<p class="docText1">We implied in <a class="calibre2" href="#ch04lev1sec1">Section 4.1</a> that an object's state could be a subset of the fields in the object graph rooted at that object. Why might it be a subset? Under what conditions are fields reachable from a given object <span class="docEmphasis">not</span> part of that object's state?</p>
<p class="docText1">When defining which variables form an object's state, we want to consider only the data that object <span class="docEmphasis">owns</span>. Ownership is not embodied explicitly in the language, but is instead an element of class design. If you allocate and populate <a name="iddle1534" class="calibre18" id="iddle1534"></a><a name="iddle2012" class="calibre18" id="iddle2012"></a><a name="iddle2025" class="calibre18" id="iddle2025"></a><a name="iddle2669" class="calibre18" id="iddle2669"></a><a name="iddle2670" class="calibre18" id="iddle2670"></a><a name="iddle2749" class="calibre18" id="iddle2749"></a><a name="iddle3173" class="calibre18" id="iddle3173"></a><a name="iddle3438" class="calibre18" id="iddle3438"></a><a name="iddle3439" class="calibre18" id="iddle3439"></a><a name="iddle3440" class="calibre18" id="iddle3440"></a><a name="iddle3467" class="calibre18" id="iddle3467"></a><a name="iddle3468" class="calibre18" id="iddle3468"></a><a name="iddle4044" class="calibre18" id="iddle4044"></a><a name="iddle4179" class="calibre18" id="iddle4179"></a><a name="iddle4352" class="calibre18" id="iddle4352"></a><a name="iddle4403" class="calibre18" id="iddle4403"></a><a name="iddle4490" class="calibre18" id="iddle4490"></a>a <tt class="calibre25">HashMap</tt>, you are creating multiple objects: the <tt class="calibre25">HashMap</tt> object, a number of <tt class="calibre25">Map.Entry</tt> objects used by the implementation of <tt class="calibre25">HashMap</tt>, and perhaps other internal objects as well. The logical state of a <tt class="calibre25">HashMap</tt> includes the state of all its <tt class="calibre25">Map.Entry</tt> and internal objects, even though they are implemented as separate objects.</p>
<p class="docText1">For better or worse, garbage collection lets us avoid thinking carefully about ownership. When passing an object to a method in C++, you have to think fairly carefully about whether you are transferring ownership, engaging in a short-term loan, or envisioning long-term joint ownership. In Java, all these same ownership models are possible, but the garbage collector reduces the cost of many of the common errors in reference sharing, enabling less-than-precise thinking about ownership.</p>
<p class="docText1">In many cases, ownership and encapsulation go togetherthe object encapsulates the state it owns and owns the state it encapsulates. It is the owner of a given state variable that gets to decide on the locking protocol used to maintain the integrity of that variable's state. Ownership implies control, but once you publish a reference to a mutable object, you no longer have exclusive control; at best, you might have "shared ownership". A class usually does not own the objects passed to its methods or constructors, unless the method is designed to explicitly transfer ownership of objects passed in (such as the synchronized collection wrapper factory methods).</p>
<p class="docText1">Collection classes often exhibit a form of "split ownership", in which the collection owns the state of the collection infrastructure, but client code owns the objects stored in the collection. An example is <tt class="calibre25">ServletContext</tt> from the servlet framework. <tt class="calibre25">ServletContext</tt> provides a <tt class="calibre25">Map</tt>-like object container service to servlets where they can register and retrieve application objects by name with <tt class="calibre25">setAttribute</tt> and <tt class="calibre25">getAttribute</tt>. The <tt class="calibre25">ServletContext</tt> object implemented by the servlet container must be thread-safe, because it will necessarily be accessed by multiple threads. Servlets need not use synchronization when calling <tt class="calibre25">set-Attribute</tt> and <tt class="calibre25">getAttribute</tt>, but they may have to use synchronization when <span class="docEmphasis">using</span> the objects stored in the <tt class="calibre25">ServletContext</tt>. These objects are owned by the application; they are being stored for safekeeping by the servlet container on the application's behalf. Like all shared objects, they must be shared safely; in order to prevent interference from multiple threads accessing the same object concurrently, they should either be thread-safe, effectively immutable, or explicitly guarded by a lock.<sup class="docFootnote"><a class="calibre2" href="#ch04fn1">[1]</a></sup>
</p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch04fn1" class="calibre18" id="ch04fn1">[1]</a></sup> Interestingly, the <tt class="calibre35">HttpSession</tt> object, which performs a similar function in the servlet framework, may have stricter requirements. Because the servlet container may access the objects in the <tt class="calibre35">HttpSession</tt> so they can be serialized for replication or passivation, they must be thread-safe because the container will be accessing them as well as the web application. (We say "may have" since replication and passivation is outside of the servlet specification but is a common feature of servlet containers.)</p></blockquote>
<a href="21021536.html" class="calibre2"><img src="pixel.jpg" alt="" border="0" class="calibre26"/></a>
<p class="calibre3"> </p>

</div>

{% endraw %}

