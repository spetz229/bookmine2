---
layout: page
title: "Java Concurrency in Practice"
prev: ch01lev1sec3.html
next: part01.html
book_path: books/brian-goetz-tim-peierls-joshua-bloch-joseph-bowbeer-david-holmes-doug-lea-java-concurrency-in-practice--_oeb/
---
{% include JB/setup %}
{% raw %}
<div>


<a href="21021536.html" class="calibre2"><img src="pixel.jpg" alt="" border="0" class="calibre26"/></a><a name="ch01lev1sec4" class="calibre18" id="ch01lev1sec4"></a>
<h3 id="title-IDA2F1O0" class="docSection1Title">1.4. Threads are Everywhere</h3>
<p class="docText1"><a name="iddle1180" class="calibre18" id="iddle1180"></a><a name="iddle2411" class="calibre18" id="iddle2411"></a><a name="iddle2412" class="calibre18" id="iddle2412"></a><a name="iddle2928" class="calibre18" id="iddle2928"></a><a name="iddle4000" class="calibre18" id="iddle4000"></a><a name="iddle4001" class="calibre18" id="iddle4001"></a><a name="iddle4383" class="calibre18" id="iddle4383"></a><a name="iddle4384" class="calibre18" id="iddle4384"></a><a name="iddle4527" class="calibre18" id="iddle4527"></a><a name="iddle4822" class="calibre18" id="iddle4822"></a><a name="iddle4934" class="calibre18" id="iddle4934"></a>Even if your program never explicitly creates a thread, frameworks may create threads on your behalf, and code called from these threads must be thread-safe. This can place a significant design and implementation burden on developers, since developing thread-safe classes requires more care and analysis than developing non-thread-safe classes.</p>
<p class="docText1">Every Java application uses threads. When the JVM starts, it creates threads for JVM housekeeping tasks (garbage collection, finalization) and a main thread for running the <tt class="calibre25">main</tt> method. The AWT (Abstract Window Toolkit) and Swing user interface frameworks create threads for managing user interface events. <tt class="calibre25">Timer</tt> creates threads for executing deferred tasks. Component frameworks, such as servlets and RMI create pools of threads and invoke component methods in these threads.</p>
<p class="docText1">If you use these facilitiesas many developers doyou have to be familiar with concurrency and thread safety, because these frameworks create threads and call your components from them. It would be nice to believe that concurrency is an "optional" or "advanced" language feature, but the reality is that nearly all Java applications are multithreaded and these frameworks do not insulate you from the need to properly coordinate access to application state.</p>
<p class="docText1">When concurrency is introduced into an application by a framework, it is usually impossible to restrict the concurrency-awareness to the framework code, because frameworks by their nature make callbacks to application components that in turn access application state. Similarly, the need for thread safety does not end with the components called by the frameworkit extends to all code paths that access the program state accessed by those components. Thus, the need for thread safety is contagious.</p>
<a name="ch01sb02" class="calibre18" id="ch01sb02"></a><p class="calibre21"><table cellspacing="0" width="90%" border="1" cellpadding="5" class="calibre5"><tr class="calibre6"><td class="calibre28">
<p class="docText1">Frameworks introduce concurrency into applications by calling application components from framework threads. Components invariably access application state, thus requiring that <span class="docEmphasis">all</span> code paths accessing that state be thread-safe.</p>
</td></tr></table></p><p class="calibre1"> </p>
<p class="docText1">The facilities described below all cause application code to be called from threads not managed by the application. While the need for thread safety may start with these facilities, it rarely ends there; instead, it ripples through the application.</p>
<blockquote class="calibre19"><p class="calibre21"></p><p class="docText1"><span class="docEmphStrong">Timer.</span> <tt class="calibre25">Timer</tt> is a convenience mechanism for scheduling tasks to run at a later time, either once or periodically. The introduction of a <tt class="calibre25">Timer</tt> can complicate an otherwise sequential program, because <tt class="calibre25">TimerTask</tt>s are executed in a thread managed by the <tt class="calibre25">Timer</tt>, not the application. If a <tt class="calibre25">TimerTask</tt> accesses data that is also accessed by other application threads, then not only must the <tt class="calibre25">TimerTask</tt> do so in a thread-safe manner, but <span class="docEmphasis">so must any other classes that access that data</span>. Often <a name="iddle1107" class="calibre18" id="iddle1107"></a><a name="iddle1108" class="calibre18" id="iddle1108"></a><a name="iddle1111" class="calibre18" id="iddle1111"></a><a name="iddle1181" class="calibre18" id="iddle1181"></a><a name="iddle1583" class="calibre18" id="iddle1583"></a><a name="iddle1584" class="calibre18" id="iddle1584"></a><a name="iddle2487" class="calibre18" id="iddle2487"></a><a name="iddle2912" class="calibre18" id="iddle2912"></a><a name="iddle2913" class="calibre18" id="iddle2913"></a><a name="iddle3843" class="calibre18" id="iddle3843"></a><a name="iddle3844" class="calibre18" id="iddle3844"></a><a name="iddle4002" class="calibre18" id="iddle4002"></a><a name="iddle4003" class="calibre18" id="iddle4003"></a><a name="iddle4103" class="calibre18" id="iddle4103"></a><a name="iddle4104" class="calibre18" id="iddle4104"></a><a name="iddle4200" class="calibre18" id="iddle4200"></a><a name="iddle4201" class="calibre18" id="iddle4201"></a><a name="iddle4202" class="calibre18" id="iddle4202"></a><a name="iddle4210" class="calibre18" id="iddle4210"></a><a name="iddle4211" class="calibre18" id="iddle4211"></a><a name="iddle4414" class="calibre18" id="iddle4414"></a><a name="iddle4528" class="calibre18" id="iddle4528"></a> the easiest way to achieve this is to ensure that objects accessed by the <tt class="calibre25">TimerTask</tt> are themselves thread-safe, thus encapsulating the thread safety within the shared objects.</p><p class="calibre21"></p><p class="docText1"><span class="docEmphStrong">Servlets and JavaServer Pages (JSPs).</span> The servlets framework is designed to handle all the infrastructure of deploying a web application and dispatching requests from remote HTTP clients. A request arriving at the server is dispatched, perhaps through a chain of filters, to the appropriate servlet or JSP. Each servlet represents a component of application logic, and in high-volume web sites, multiple clients may require the services of the same servlet at once. The servlets specification requires that a servlet be prepared to be called simultaneously from multiple threads. In other words, servlets need to be thread-safe.</p></blockquote>
<p class="docText1">Even if you could guarantee that a servlet was only called from one thread at a time, you would still have to pay attention to thread safety when building a web application. Servlets often access state information shared with other servlets, such as application-scoped objects (those stored in the <tt class="calibre25">ServletContext</tt>) or session-scoped objects (those stored in the per-client <tt class="calibre25">HttpSession</tt>). When a servlet accesses objects shared across servlets or requests, it must coordinate access to these objects properly, since multiple requests could be accessing them simultaneously from separate threads. Servlets and JSPs, as well as servlet filters and objects stored in scoped containers like <tt class="calibre25">ServletContext</tt> and <tt class="calibre25">HttpSession</tt>, simply have to be thread-safe.</p>
<p class="docText1"><span class="docEmphStrong">Remote Method Invocation.</span> RMI lets you invoke methods on objects running in another JVM. When you call a remote method with RMI, the method arguments are packaged (marshaled) into a byte stream and shipped over the network to the remote JVM, where they are unpacked (unmarshaled) and passed to the remote method.</p>
<p class="docText1">When the RMI code calls your remote object, in what thread does that call happen? You don't know, but it's definitely not in a thread you createdyour object gets called in a thread managed by RMI. How many threads does RMI create? Could the same remote method on the same remote object be called simultaneously in multiple RMI threads?<sup class="docFootnote"><a class="calibre2" href="#ch01fn04">[4]</a></sup></p><blockquote class="calibre19"><p class="docFootnote1"><sup class="calibre27"><a name="ch01fn04" class="calibre18" id="ch01fn04">[4]</a></sup> Answer: yes, but it's not all that clear from the Javadocyou have to read the RMI spec.</p></blockquote>
<p class="docText1">A remote object must guard against two thread safety hazards: properly coordinating access to state that may be shared with other objects, and properly coordinating access to the state of the remote object itself (since the same object may be called in multiple threads simultaneously). Like servlets, RMI objects should be prepared for multiple simultaneous calls and must provide their own thread safety.</p>
<p class="docText1"><span class="docEmphStrong">Swing and AWT.</span> GUI applications are inherently asynchronous. Users may select a menu item or press a button at any time, and they expect that the application will respond promptly even if it is in the middle of doing something else. Swing and AWT address this problem by creating a separate thread for handling user-initiated events and updating the graphical view presented to the user.</p>
<p class="docText1">Swing components, such as <tt class="calibre25">JTable</tt>, are not thread-safe. Instead, Swing programs achieve their thread safety by confining all access to GUI components to the event thread. If an application wants to manipulate the GUI from outside the event thread, it must cause the code that will manipulate the GUI to run in the event thread instead.</p>
<p class="docText1">When the user performs a UI action, an event handler is called in the event thread to perform whatever operation the user requested. If the handler needs to access application state that is also accessed from other threads (such as a document being edited), then the event handler, along with any other code that accesses that state, must do so in a thread-safe manner.</p>
<a href="21021536.html" class="calibre2"><img src="pixel.jpg" alt="" border="0" class="calibre26"/></a>
<p class="calibre3"> </p>

</div>

{% endraw %}

